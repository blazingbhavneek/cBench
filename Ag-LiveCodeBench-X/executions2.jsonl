{"question_id": "1873_D", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n        char s[n+1];\n        scanf(\"%s\", s);\n\n        int operations = 0;\n        int i = 0;\n        while (i < n) {\n            if (s[i] == 'B') {\n                operations++;\n                i += k;\n            } else {\n                i++;\n            }\n        }\n\n        printf(\"%d\\n\", operations);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "1873_B", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n;\n        scanf(\"%d\", &n);\n        int *a = malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        int max_product = 0;\n        for (int i = 0; i < n; i++) {\n            int *copy = malloc(n * sizeof(int));\n            for (int j = 0; j < n; j++) {\n                copy[j] = a[j];\n            }\n            copy[i] += 1;\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                product *= copy[j];\n            }\n            if (product > max_product) {\n                max_product = product;\n            }\n            free(copy);\n        }\n        printf(\"%d\\n\", max_product);\n        free(a);\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "1873_A", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int i = 0; i < t; i++) {\n        char s[3];\n        scanf(\"%s\", s);\n        if (strcmp(s, \"abc\") == 0) {\n            printf(\"YES\\n\");\n        } else {\n            // Check if the string can be transformed into \"abc\" with one swap\n            // Check all possible swaps\n            if ((s[0] == 'a' && s[1] == 'c' && s[2] == 'b') || \n                (s[0] == 'c' && s[1] == 'a' && s[2] == 'b') || \n                (s[0] == 'a' && s[1] == 'b' && s[2] == 'c') || \n                (s[0] == 'b' && s[1] == 'a' && s[2] == 'c') || \n                (s[0] == 'b' && s[1] == 'c' && s[2] == 'a') || \n                (s[0] == 'c' && s[1] == 'b' && s[2] == 'a')) {\n                printf(\"YES\\n\");\n            } else {\n                printf(\"NO\\n\");\n            }\n        }\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": -11, \"stdout\": \"YES\\n\", \"stderr\": \"Test case 0 failed with exit code -11:\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": -11, "stdout": "YES\n", "stderr": "Test case 0 failed with exit code -11:\n"}
{"question_id": "1899_C", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n;\n        scanf(\"%d\", &n);\n        int a[n];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        long long max_sum = a[0];\n        long long current_even = a[0];\n        long long current_odd = a[0];\n        for (int i = 1; i < n; i++) {\n            if (a[i] % 2 == 0) {\n                long long temp_even = (a[i] > (current_odd + a[i])) ? a[i] : (current_odd + a[i]);\n                long long temp_odd = (current_odd == -1000000000LL) ? -1000000000LL : current_odd;\n                current_even = temp_even;\n                current_odd = temp_odd;\n            } else {\n                long long temp_odd = (a[i] > (current_even + a[i])) ? a[i] : (current_even + a[i]);\n                long long temp_even = (current_even == -1000000000LL) ? -1000000000LL : current_even;\n                current_even = temp_even;\n                current_odd = temp_odd;\n            }\n            if (current_even > max_sum) {\n                max_sum = current_even;\n            }\n            if (current_odd > max_sum) {\n                max_sum = current_odd;\n            }\n        }\n        printf(\"%lld\\n\", max_sum);\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"2099\\n3743\\n4083\\n2915\\n2781\\n2390\\n2161\\n2760\\n2780\\n2882\\n1924\\n2950\\n3207\\n2474\\n2993\\n1717\\n2233\\n4063\\n2580\\n2868\\n3067\\n1369\\n2024\\n2534\\n1659\\n2190\\n3996\\n2717\\n2676\\n2429\\n2300\\n2962\\n3065\\n3030\\n4135\\n2776\\n3217\\n2737\\n1551\\n2821\\n3175\\n3809\\n3033\\n3534\\n2562\\n3531\\n1996\\n2072\\n3850\\n3269\\n3947\\n2479\\n5140\\n3156\\n3247\\n2278\\n3641\\n3042\\n1643\\n2710\\n2524\\n2438\\n3963\\n3707\\n3881\\n3227\\n2960\\n3199\\n2282\\n2284\\n2980\\n2492\\n3139\\n2906\\n2498\\n3596\\n3470\\n2338\\n2624\\n2932\\n3869\\n4861\\n2636\\n2150\\n2021\\n2246\\n3209\\n3223\\n3371\\n2001\\n2575\\n2144\\n3558\\n2308\\n3212\\n2123\\n3344\\n2614\\n3010\\n3643\\n3863\\n2514\\n3262\\n2315\\n2964\\n3195\\n2368\\n3955\\n2480\\n3121\\n3339\\n2101\\n2658\\n1524\\n3422\\n2615\\n2789\\n2456\\n2514\\n2561\\n2164\\n2452\\n2961\\n3669\\n2527\\n4132\\n3163\\n2645\\n2617\\n2999\\n2236\\n3371\\n2952\\n2567\\n2805\\n2800\\n2311\\n3421\\n3779\\n2878\\n2923\\n3754\\n2734\\n3294\\n4743\\n2149\\n2846\\n2743\\n2909\\n2486\\n2629\\n2609\\n3368\\n2090\\n2996\\n2257\\n4265\\n2826\\n4417\\n3518\\n2284\\n3178\\n2769\\n3120\\n2678\\n2619\\n2400\\n3579\\n2779\\n3921\\n2717\\n2681\\n2568\\n2480\\n3721\\n2027\\n4175\\n2676\\n3120\\n2668\\n2212\\n3281\\n3724\\n2279\\n3329\\n3169\\n2955\\n2512\\n5572\\n2082\\n2248\\n3125\\n3094\\n2996\\n2965\\n2854\\n2428\\n2596\\n3069\\n3284\\n1888\\n2024\\n2568\\n2784\\n2325\\n2633\\n3356\\n2157\\n2620\\n2257\\n3326\\n2941\\n3000\\n2779\\n3142\\n2272\\n2996\\n2199\\n2654\\n3575\\n1963\\n3596\\n2454\\n2013\\n3561\\n3739\\n3488\\n3544\\n2592\\n2934\\n1755\\n2058\\n2458\\n2327\\n3674\\n4273\\n3577\\n2142\\n3860\\n2710\\n3236\\n2794\\n2566\\n2748\\n2416\\n2352\\n2491\\n2196\\n2784\\n2252\\n2615\\n3471\\n2573\\n3689\", \"got\": \"2938\\n21292\\n12773\\n21992\\n12210\\n13155\\n9722\\n10854\\n15497\\n3190\\n3556\\n18668\\n12246\\n9127\\n24980\\n5138\\n4399\\n23528\\n14655\\n14376\\n12788\\n3016\\n11631\\n4818\\n3140\\n7946\\n29733\\n10747\\n11013\\n15366\\n12805\\n7655\\n5372\\n15078\\n7096\\n9975\\n10068\\n5829\\n7935\\n7018\\n13089\\n9988\\n4605\\n10130\\n4183\\n12326\\n11439\\n5580\\n18226\\n12345\\n15271\\n12173\\n10388\\n4281\\n5152\\n6677\\n17536\\n11526\\n5594\\n8223\\n11854\\n6614\\n8524\\n17523\\n7026\\n11858\\n12982\\n10927\\n17200\\n6765\\n12948\\n1245", "raw_stderr": "", "result": "fail"}
{"question_id": "1883_C", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Function to compute the prime factors of a number\nvoid get_prime_factors(int num, int factors[5], int *count) {\n    *count = 0;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) {\n            factors[*count] = i;\n            (*count)++;\n            while (num % i == 0) {\n                num /= i;\n            }\n        }\n    }\n    if (num > 1) {\n        factors[*count] = num;\n        (*count)++;\n    }\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        int a[n];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n\n        // Factorize k into its prime factors\n        int k_factors[5];\n        int k_count = 0;\n        get_prime_factors(k, k_factors, &k_count);\n\n        // Calculate the current factors in the array\n        int current_factors[5] = {0};\n        for (int i = 0; i < n; i++) {\n            int num = a[i];\n            int factors[5];\n            int count = 0;\n            get_prime_factors(num, factors, &count);\n            for (int j = 0; j < count; j++) {\n                current_factors[factors[j]]++;\n            }\n        }\n\n        // Determine the required operations\n        int total_operations = 0;\n        for (int i = 0; i < k_count; i++) {\n            int required = k_factors[i];\n            int current = current_factors[required];\n            if (current < 1) {\n                total_operations += 1;\n            }\n        }\n\n        printf(\"%d\\n\", total_operations);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"2\", \"got\": \"1\", \"stderr\": \"Test case 0 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "2", "got": "1", "stderr": "Test case 0 produced wrong output\n"}
{"question_id": "1899_B", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n;\n        scanf(\"%d\", &n);\n        long long *a = (long long*)malloc(n * sizeof(long long));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lld\", &a[i]);\n        }\n        // Compute prefix sum\n        long long *prefix_sum = (long long*)malloc((n + 1) * sizeof(long long));\n        prefix_sum[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            prefix_sum[i] = prefix_sum[i-1] + a[i-1];\n        }\n        // Generate divisors of n\n        int *divisors = (int*)malloc(n * sizeof(int));\n        int div_count = 0;\n        for (int i = 1; i*i <= n; i++) {\n            if (n % i == 0) {\n                divisors[div_count++] = i;\n                if (i != n / i) {\n                    divisors[div_count++] = n / i;\n                }\n            }\n        }\n        // Remove duplicates and sort\n        int unique_divisors[div_count];\n        int unique_count = 0;\n        for (int i = 0; i < div_count; i++) {\n            bool is_unique = true;\n            for (int j = 0; j < unique_count; j++) {\n                if (divisors[i] == divisors[unique_divisors[j]]) {\n                    is_unique = false;\n                    break;\n                }\n            }\n            if (is_unique) {\n                unique_divisors[unique_count++] = divisors[i];\n            }\n        }\n        // Process each divisor\n        long long max_diff = 0;\n        for (int i = 0; i < unique_count; i++) {\n            int k = unique_divisors[i];\n            int m = n / k;\n            long long current_max = LLONG_MIN;\n            long long current_min = LLONG_MAX;\n            for (int group = 0; group < m; group++) {\n                int start = group * k;\n                int end = start + k;\n                long long sum = prefix_sum[end] - prefix_sum[start];\n                if (sum > current_max) {\n                    current_max = sum;\n                }\n                if (sum < current_min) {\n                    current_min = sum;\n                }\n            }\n            long long diff = current_max - current_min;\n            if (diff > max_diff) {\n                max_diff = diff;\n            }\n        }\n        printf(\"%lld\\n\", max_diff);\n        // Free memory\n        free(a);\n        free(prefix_sum);\n        free(divisors);\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2vd8cb_b/program.c: In function 'main':\\n/tmp/agnostics_c_2vd8cb_b/program.c:37:13: error: unknown type name 'bool'\\n   37 |             bool is_unique = true;\\n      |             ^~~~\\n/tmp/agnostics_c_2vd8cb_b/program.c:5:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n    4 | #include <limits.h>\\n  +++ |+#include <stdbool.h>\\n    5 | \\n/tmp/agnostics_c_2vd8cb_b/program.c:37:30: error: 'true' undeclared (first use in this function)\\n   37 |             bool is_unique = true;\\n      |                              ^~~~\\n/tmp/agnostics_c_2vd8cb_b/program.c:37:30: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_2vd8cb_b/program.c:37:30: note: each undeclared identifier is reported only once for each function it appears in\\n/tmp/agnostics_c_2vd8cb_b/program.c:40:33: error: 'false' undeclared (first use in this function)\\n   40 |                     is_unique = false;\\n      |                                 ^~~~~\\n/tmp/agnostics_c_2vd8cb_b/program.c:40:33: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2vd8cb_b/program.c: In function 'main':\n/tmp/agnostics_c_2vd8cb_b/program.c:37:13: error: unknown type name 'bool'\n   37 |             bool is_unique = true;\n      |             ^~~~\n/tmp/agnostics_c_2vd8cb_b/program.c:5:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n    4 | #include <limits.h>\n  +++ |+#include <stdbool.h>\n    5 | \n/tmp/agnostics_c_2vd8cb_b/program.c:37:30: error: 'true' undeclared (first use in this function)\n   37 |             bool is_unique = true;\n      |                              ^~~~\n/tmp/agnostics_c_2vd8cb_b/program.c:37:30: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n/tmp/agnostics_c_2vd8cb_b/program.c:37:30: note: each undeclared identifier is reported only once for each function it appears in\n/tmp/agnostics_c_2vd8cb_b/program.c:40:33: error: 'false' undeclared (first use in this function)\n   40 |                     is_unique = false;\n      |                                 ^~~~~\n/tmp/agnostics_c_2vd8cb_b/program.c:40:33: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n"}
{"question_id": "abc301_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char S[N + 1];\n    scanf(\"%s\", S);\n\n    int t_count = 0, a_count = 0;\n\n    // Count the number of wins for T and A\n    for (int i = 0; i < N; i++) {\n        if (S[i] == 'T') {\n            t_count++;\n        } else {\n            a_count++;\n        }\n    }\n\n    // Determine the winner\n    if (t_count > a_count) {\n        printf(\"T\\n\");\n    } else if (a_count > t_count) {\n        printf(\"A\\n\");\n    } else {\n        // Tie case: determine who reached the count first\n        int current_t = 0, current_a = 0;\n        for (int i = 0; i < N; i++) {\n            if (S[i] == 'T') {\n                current_t++;\n            } else {\n                current_a++;\n            }\n            if (current_t == t_count || current_a == a_count) {\n                if (current_t == t_count) {\n                    printf(\"T\\n\");\n                } else {\n                    printf(\"A\\n\");\n                }\n                break;\n            }\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "1899_D", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n;\n        scanf(\"%d\", &n);\n        int *a = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n\n        // Count frequency of each number\n        int *freq = (int *)calloc(1000000, sizeof(int)); // Assuming a_i <= 1e9, but we can use a hash table\n        for (int i = 0; i < n; i++) {\n            freq[a[i]]++;\n        }\n\n        long long total = 0;\n\n        // Count pairs with same value\n        for (int i = 1; i <= 1000000; i++) {\n            int count = freq[i];\n            total += (long long)count * (count - 1) / 2;\n        }\n\n        // Count pairs (1, 2) and (2, 1)\n        total += (long long)freq[1] * freq[2];\n\n        printf(\"%lld\\n\", total);\n\n        free(a);\n        free(freq);\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": -11, \"stdout\": \"\", \"stderr\": \"Test case 0 failed with exit code -11:\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": -11, "stdout": "", "stderr": "Test case 0 failed with exit code -11:\n"}
{"question_id": "abc301_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <ctype.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int *arr = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    while (true) {\n        bool found = false;\n        for (int i = 0; i < N - 1; i++) {\n            int a = arr[i];\n            int b = arr[i + 1];\n            if (abs(a - b) != 1) {\n                // Create a temporary array to hold the new elements\n                int *insert_list = (int *)malloc((abs(a - b) - 1) * sizeof(int));\n                int insert_list_len = 0;\n\n                if (a < b) {\n                    for (int j = a + 1; j < b; j++) {\n                        insert_list[insert_list_len++] = j;\n                    }\n                } else {\n                    for (int j = a - 1; j > b; j--) {\n                        insert_list[insert_list_len++] = j;\n                    }\n                }\n\n                // Insert the new elements into the array\n                int *new_arr = (int *)malloc((N + insert_list_len) * sizeof(int));\n                int new_idx = 0;\n\n                // Copy elements before the insertion point\n                for (int k = 0; k < i; k++) {\n                    new_arr[new_idx++] = arr[k];\n                }\n\n                // Copy the inserted elements\n                for (int k = 0; k < insert_list_len; k++) {\n                    new_arr[new_idx++] = insert_list[k];\n                }\n\n                // Copy the remaining elements\n                for (int k = i; k < N; k++) {\n                    new_arr[new_idx++] = arr[k];\n                }\n\n                // Free the old array and update the pointer\n                free(arr);\n                arr = new_arr;\n                N += insert_list_len;\n                free(insert_list);\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            break;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    free(arr);\n    return 0;\n}", "raw_exit_code": -1, "raw_stdout": "", "raw_stderr": "", "result": "fail"}
{"question_id": "abc301_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Function to convert binary string to decimal\nlong long str_to_decimal(const char *s) {\n    long long val = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        val = val * 2 + (s[i] - '0');\n    }\n    return val;\n}\n\n// Function to generate all possible values by replacing '?' with 0 or 1\nvoid generate(int pos, char *current, long long current_val, long long *max_val, int len, long long N) {\n    if (pos == len) {\n        if (current_val <= N && current_val > *max_val) {\n            *max_val = current_val;\n        }\n        return;\n    }\n\n    char c = current[pos];\n    if (c == '?') {\n        // Try replacing with 0\n        current[pos] = '0';\n        generate(pos + 1, current, current_val * 2, max_val, len, N);\n        \n        // Try replacing with 1\n        current[pos] = '1';\n        generate(pos + 1, current, current_val * 2 + 1, max_val, len, N);\n    } else {\n        // Directly use the character\n        generate(pos + 1, current, current_val * 2 + (c - '0'), max_val, len, N);\n    }\n}\n\nint main() {\n    char S[100];\n    long long N;\n    scanf(\"%s\", S);\n    scanf(\"%lld\", &N);\n\n    int len = strlen(S);\n    long long max_val = -1;\n\n    // Initialize the current string and start generating\n    char current[len + 1];\n    strcpy(current, S);\n    generate(0, current, 0, &max_val, len, N);\n\n    printf(\"%lld\\n\", max_val);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"5\", \"got\": \"3\", \"stderr\": \"Test case 4 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "5", "got": "3", "stderr": "Test case 4 produced wrong output\n"}
{"question_id": "abc302_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_H 100\n#define MAX_W 100\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    char grid[MAX_H][MAX_W];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int directions[8][2] = {\n        {-1, -1}, {-1, 0}, {-1, 1},\n        {0, -1},          {0, 1},\n        {1, -1},  {1, 0}, {1, 1}\n    };\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 's') {\n                for (int d = 0; d < 8; d++) {\n                    int dx = directions[d][0];\n                    int dy = directions[d][1];\n                    bool valid = true;\n                    for (int k = 0; k < 5; k++) {\n                        int row = i + k * dx;\n                        int col = j + k * dy;\n                        if (row < 0 || row >= H || col < 0 || col >= W) {\n                            valid = false;\n                            break;\n                        }\n                        char c = grid[row][col];\n                        if (k == 0) {\n                            if (c != 's') {\n                                valid = false;\n                                break;\n                            }\n                        } else if (k == 1) {\n                            if (c != 'n') {\n                                valid = false;\n                                break;\n                            }\n                        } else if (k == 2) {\n                            if (c != 'u') {\n                                valid = false;\n                                break;\n                            }\n                        } else if (k == 3) {\n                            if (c != 'k') {\n                                valid = false;\n                                break;\n                            }\n                        } else if (k == 4) {\n                            if (c != 'e') {\n                                valid = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (valid) {\n                        for (int k = 0; k < 5; k++) {\n                            int r = i + k * dx;\n                            int c = j + k * dy;\n                            printf(\"%d %d\\n\", r + 1, c + 1);\n                        }\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8jf0ligx/program.c: In function 'main':\\n/tmp/agnostics_c_8jf0ligx/program.c:28:21: error: unknown type name 'bool'\\n   28 |                     bool valid = true;\\n      |                     ^~~~\\n/tmp/agnostics_c_8jf0ligx/program.c:4:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n    3 | #include <string.h>\\n  +++ |+#include <stdbool.h>\\n    4 | \\n/tmp/agnostics_c_8jf0ligx/program.c:28:34: error: 'true' undeclared (first use in this function)\\n   28 |                     bool valid = true;\\n      |                                  ^~~~\\n/tmp/agnostics_c_8jf0ligx/program.c:28:34: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_8jf0ligx/program.c:28:34: note: each undeclared identifier is reported only once for each function it appears in\\n/tmp/agnostics_c_8jf0ligx/program.c:33:37: error: 'false' undeclared (first use in this function)\\n   33 |                             valid = false;\\n      |                                     ^~~~~\\n/tmp/agnostics_c_8jf0ligx/program.c:33:37: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_8jf0ligx/program.c: In function 'main':\n/tmp/agnostics_c_8jf0ligx/program.c:28:21: error: unknown type name 'bool'\n   28 |                     bool valid = true;\n      |                     ^~~~\n/tmp/agnostics_c_8jf0ligx/program.c:4:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n    3 | #include <string.h>\n  +++ |+#include <stdbool.h>\n    4 | \n/tmp/agnostics_c_8jf0ligx/program.c:28:34: error: 'true' undeclared (first use in this function)\n   28 |                     bool valid = true;\n      |                                  ^~~~\n/tmp/agnostics_c_8jf0ligx/program.c:28:34: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n/tmp/agnostics_c_8jf0ligx/program.c:28:34: note: each undeclared identifier is reported only once for each function it appears in\n/tmp/agnostics_c_8jf0ligx/program.c:33:37: error: 'false' undeclared (first use in this function)\n   33 |                             valid = false;\n      |                                     ^~~~~\n/tmp/agnostics_c_8jf0ligx/program.c:33:37: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n"}
{"question_id": "abc302_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N, M, D;\n    scanf(\"%d %d %d\", &N, &M, &D);\n\n    // Read Aoki's gift values\n    long long *A = (long long *)malloc(N * sizeof(long long));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lld\", &A[i]);\n    }\n\n    // Read Snuke's gift values\n    long long *B = (long long *)malloc(M * sizeof(long long));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%lld\", &B[i]);\n    }\n\n    // Sort Snuke's gift values\n    qsort(B, M, sizeof(long long), (int (*)(const void*, const void*))compare);\n\n    long long max_sum = -1;\n\n    // For each gift in Aoki's list, find the best matching gift in Snuke's list\n    for (int i = 0; i < N; i++) {\n        long long a = A[i];\n        long long low = 0, high = M - 1;\n        long long best_b = -1;\n\n        // Binary search for the best matching gift in B\n        while (low <= high) {\n            long long mid = low + (high - low) / 2;\n            long long b = B[mid];\n\n            if (abs(a - b) <= D) {\n                best_b = b;\n                low = mid + 1; // Try for a larger value\n            } else if (a > b) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        if (best_b != -1) {\n            max_sum = fmax(max_sum, a + best_b);\n        }\n    }\n\n    // Output the result\n    printf(\"%lld\\n\", max_sum);\n\n    // Free memory\n    free(A);\n    free(B);\n\n    return 0;\n}\n\n// Comparison function for qsort\nint compare(const void *a, const void *b) {\n    long long val1 = *(long long *)a;\n    long long val2 = *(long long *)b;\n    if (val1 < val2) return -1;\n    if (val1 > val2) return 1;\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_7jsrzp7c/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_7jsrzp7c/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc301_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <limits.h>\n\n#define MOD 998244353\n\nint main() {\n    char S[300001];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n\n    // dp[i][a][b][c] represents the number of valid strings up to position i with last three characters a, b, c\n    // We use a 3D array to track the state of the last three characters\n    // a, b, c can be 0 (uppercase), 1 (lowercase), or 2 (unknown)\n    // We use a 3D array of size [n+1][3][3][3] to store the DP states\n    int dp[n+1][3][3][3];\n    memset(dp, 0, sizeof(dp));\n\n    // Initialize the DP table\n    for (int a = 0; a < 3; a++) {\n        for (int b = 0; b < 3; b++) {\n            for (int c = 0; c < 3; c++) {\n                dp[0][a][b][c] = 1;\n            }\n        }\n    }\n\n    // Process each character in the string\n    for (int i = 1; i <= n; i++) {\n        char current = S[i-1];\n        for (int a = 0; a < 3; a++) {\n            for (int b = 0; b < 3; b++) {\n                for (int c = 0; c < 3; c++) {\n                    int count = dp[i-1][a][b][c];\n                    if (count == 0) continue;\n\n                    // Determine the possible values for the current character\n                    int possible_values[2];\n                    int num_possible = 0;\n                    if (current == '?') {\n                        possible_values[0] = 0; // uppercase\n                        possible_values[1] = 1; // lowercase\n                        num_possible = 2;\n                    } else if (current >= 'A' && current <= 'Z') {\n                        possible_values[0] = 0;\n                        num_possible = 1;\n                    } else if (current >= 'a' && current <= 'z') {\n                        possible_values[0] = 1;\n                        num_possible = 1;\n                    }\n\n                    // Update the DP table\n                    for (int new_val = 0; new_val < num_possible; new_val++) {\n                        int new_a = a;\n                        int new_b = b;\n                        int new_c = c;\n                        if (new_val == 0) {\n                            new_a = new_val;\n                            new_b = new_val;\n                            new_c = new_val;\n                        } else {\n                            new_a = new_val;\n                            new_b = new_val;\n                            new_c = new_val;\n                        }\n\n                        // Check if the new state forms a DDoS-type string\n                        if (new_a == 0 && new_b == 0 && new_c == 1 && new_val == 0) {\n                            // Skip this state as it forms a DDoS-type string\n                            continue;\n                        }\n\n                        dp[i][new_a][new_b][new_c] = (dp[i][new_a][new_b][new_c] + count) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    // Sum all valid states at the end\n    int result = 0;\n    for (int a = 0; a < 3; a++) {\n        for (int b = 0; b < 3; b++) {\n            for (int c = 0; c < 3; c++) {\n                result = (result + dp[n][a][b][c]) % MOD;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", result);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"7294040\", \"got\": \"432\", \"stderr\": \"Test case 0 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "7294040", "got": "432", "stderr": "Test case 0 produced wrong output\n"}
{"question_id": "abc302_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAXN 300005\n\n// Hash table to track the edges connected to each vertex\ntypedef struct EdgeNode {\n    int vertex;\n    struct EdgeNode *next;\n} EdgeNode;\n\nEdgeNode *edges[MAXN];\nint degree[MAXN];\nint isolated_count;\n\nvoid init(int N) {\n    for (int i = 1; i <= N; i++) {\n        degree[i] = 0;\n        edges[i] = NULL;\n    }\n    isolated_count = N;\n}\n\nvoid add_edge(int u, int v) {\n    // Add edge u -> v\n    EdgeNode *new_node = (EdgeNode *)malloc(sizeof(EdgeNode));\n    new_node->vertex = v;\n    new_node->next = edges[u];\n    edges[u] = new_node;\n\n    // Add edge v -> u\n    new_node = (EdgeNode *)malloc(sizeof(EdgeNode));\n    new_node->vertex = u;\n    new_node->next = edges[v];\n    edges[v] = new_node;\n\n    // Update degrees\n    degree[u]++;\n    degree[v]++;\n\n    // Check if u and v were isolated before adding the edge\n    if (degree[u] == 1) {\n        isolated_count--;\n    }\n    if (degree[v] == 1) {\n        isolated_count--;\n    }\n}\n\nvoid remove_edges(int v) {\n    // Get all edges connected to v\n    EdgeNode *current = edges[v];\n    EdgeNode *prev = NULL;\n\n    while (current != NULL) {\n        int u = current->vertex;\n        // Remove edge between u and v\n        // Decrement degrees of u and v\n        degree[u]--;\n        degree[v]--;\n\n        // Check if u or v were isolated before decrementing\n        if (degree[u] == 0) {\n            isolated_count++;\n        }\n        if (degree[v] == 0) {\n            isolated_count++;\n        }\n\n        // Remove the edge from u's list\n        EdgeNode *temp = current;\n        current = current->next;\n        if (prev == NULL) {\n            edges[v] = current;\n        } else {\n            prev->next = current;\n        }\n        free(temp);\n        prev = temp;\n    }\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    init(N);\n\n    for (int q = 0; q < Q; q++) {\n        char type;\n        scanf(\" %c\", &type);\n        if (type == '1') {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n            add_edge(u, v);\n        } else {\n            int v;\n            scanf(\"%d\", &v);\n            remove_edges(v);\n        }\n        printf(\"%d\\n\", isolated_count);\n    }\n\n    // Free memory\n    for (int i = 1; i <= N; i++) {\n        EdgeNode *current = edges[i];\n        while (current != NULL) {\n            EdgeNode *temp = current;\n            current = current->next;\n            free(temp);\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": -11, \"stdout\": \"299993\\n299991\\n299989\\n299987\\n299985\\n299983\\n299981\\n299980\\n299979\\n299977\\n299975\\n299973\\n299973\\n299971\\n299971\\n299970\\n299968\\n299968\\n299967\\n299966\\n299965\\n299963\\n299963\\n299962\\n299961\\n299961\\n299961\\n299961\\n299960\\n299960\\n299960\\n299960\\n299960\\n299960\\n299960\\n299959\\n299959\\n299957\\n299957\\n299957\\n299957\\n299956\\n299956\\n299956\\n299956\\n299956\\n299956\\n299956\\n299956\\n299956\\n299956\\n299956\\n299956\\n299956\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299956\\n299956\\n299956\\n299956\\n299956\\n299956\\n299956\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n299955\\n29", "raw_stderr": "", "result": "fail"}
