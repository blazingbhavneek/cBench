{"question_id": "1873_A", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int i = 0; i < t; i++) {\n        char s[3];\n        scanf(\"%s\", s);\n        if (strcmp(s, \"abc\") == 0) {\n            printf(\"YES\\n\");\n        } else {\n            if ((s[0] == 'b' && s[1] == 'a' && s[2] == 'c') || \n                (s[0] == 'c' && s[1] == 'b' && s[2] == 'a') || \n                (s[0] == 'a' && s[1] == 'c' && s[2] == 'b')) {\n                printf(\"YES\\n\");\n            } else {\n                printf(\"NO\\n\");\n            }\n        }\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0zjgpw_0/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0zjgpw_0/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1873_B", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <ctype.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n;\n        scanf(\"%d\", &n);\n        int *a = malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        GArray *array = g_array_new(FALSE, FALSE, sizeof(int));\n        for (int i = 0; i < n; i++) {\n            g_array_append_val(array, a[i]);\n        }\n        int max_product = 0;\n        for (int i = 0; i < n; i++) {\n            GArray *copy_array = g_array_copy(array);\n            int val = g_array_index(copy_array, int, i);\n            g_array_index(copy_array, int, i) = val + 1;\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                product *= g_array_index(copy_array, int, j);\n            }\n            if (product > max_product) {\n                max_product = product;\n            }\n            g_array_free(copy_array, TRUE);\n        }\n        printf(\"%d\\n\", max_product);\n        g_array_free(array, TRUE);\n        free(a);\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_a2hqsny6/program.c:8:10: fatal error: glib.h: No such file or directory\\n    8 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_a2hqsny6/program.c:8:10: fatal error: glib.h: No such file or directory\n    8 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1899_A", "solution": "#include <stdio.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int i = 0; i < t; i++) {\n        int n;\n        scanf(\"%d\", &n);\n        if (n % 3 == 0) {\n            printf(\"Second\\n\");\n        } else {\n            printf(\"First\\n\");\n        }\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "1873_D", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n        char s[n+1];\n        scanf(\"%s\", s);\n\n        int operations = 0;\n        int i = 0;\n        while (i < n) {\n            if (s[i] == 'B') {\n                operations++;\n                i += k;\n            } else {\n                i++;\n            }\n        }\n\n        printf(\"%d\\n\", operations);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_izrrt0ka/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_izrrt0ka/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1883_C", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n        int a[n];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n\n        // Factorize k into its prime factors\n        GHashTable *prime_factors = g_hash_table_new(g_direct_hash, g_direct_equal);\n        int temp_k = k;\n        for (int p = 2; p*p <= temp_k; p++) {\n            if (temp_k % p == 0) {\n                int count = 0;\n                while (temp_k % p == 0) {\n                    temp_k /= p;\n                    count++;\n                }\n                g_hash_table_insert(prime_factors, GINT_TO_POINTER(p), GINT_TO_POINTER(count));\n            }\n        }\n        if (temp_k > 1) {\n            g_hash_table_insert(prime_factors, GINT_TO_POINTER(temp_k), GINT_TO_POINTER(1));\n        }\n\n        // Calculate the required factors from the array\n        GHashTable *current_factors = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (int i = 0; i < n; i++) {\n            int num = a[i];\n            for (int p = 2; p*p <= num; p++) {\n                if (num % p == 0) {\n                    int count = 0;\n                    while (num % p == 0) {\n                        num /= p;\n                        count++;\n                    }\n                    g_hash_table_insert(current_factors, GINT_TO_POINTER(p), GINT_TO_POINTER(count));\n                }\n            }\n            if (num > 1) {\n                g_hash_table_insert(current_factors, GINT_TO_POINTER(num), GINT_TO_POINTER(1));\n            }\n        }\n\n        // Determine the required operations\n        int total_operations = 0;\n        GHashTableIter iter;\n        g_hash_table_iter_init(&iter, prime_factors);\n        while (g_hash_table_iter_next(&iter, &p, &required_count)) {\n            int current_count = 0;\n            gpointer current_val = g_hash_table_lookup(current_factors, p);\n            if (current_val) {\n                current_count = GPOINTER_TO_INT(current_val);\n            }\n            if (current_count < required_count) {\n                total_operations += (required_count - current_count);\n            }\n        }\n\n        printf(\"%d\\n\", total_operations);\n\n        // Free memory\n        g_hash_table_destroy(prime_factors);\n        g_hash_table_destroy(current_factors);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4797a46f/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_4797a46f/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1899_B", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <ctype.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n;\n        scanf(\"%d\", &n);\n        int *a = (int*)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        // Compute prefix sum\n        long long *prefix_sum = (long long*)malloc((n + 1) * sizeof(long long));\n        prefix_sum[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            prefix_sum[i] = prefix_sum[i-1] + a[i-1];\n        }\n        // Generate divisors of n\n        GHashTable *divisors = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (int i = 1; i*i <= n; i++) {\n            if (n % i == 0) {\n                g_hash_table_insert(divisors, GINT_TO_POINTER(i), NULL);\n                if (i != n / i) {\n                    g_hash_table_insert(divisors, GINT_TO_POINTER(n / i), NULL);\n                }\n            }\n        }\n        GArray *divisors_list = g_array_new(FALSE, FALSE, sizeof(int));\n        GHashTableIter iter;\n        g_hash_table_iter_init(&iter, divisors);\n        int *key;\n        while (g_hash_table_iter_next(&iter, (void**)&key, NULL)) {\n            g_array_append_val(divisors_list, *key);\n        }\n        // Process each divisor\n        long long max_diff = 0;\n        for (int i = 0; i < divisors_list->len; i++) {\n            int k = g_array_index(divisors_list, int, i);\n            int m = n / k;\n            long long current_max = LLONG_MIN;\n            long long current_min = LLONG_MAX;\n            for (int group = 0; group < m; group++) {\n                int start = group * k;\n                int end = start + k;\n                long long sum = prefix_sum[end] - prefix_sum[start];\n                if (sum > current_max) {\n                    current_max = sum;\n                }\n                if (sum < current_min) {\n                    current_min = sum;\n                }\n            }\n            long long diff = current_max - current_min;\n            if (diff > max_diff) {\n                max_diff = diff;\n            }\n        }\n        printf(\"%lld\\n\", max_diff);\n        // Free memory\n        g_array_free(divisors_list, TRUE);\n        g_hash_table_destroy(divisors);\n        free(a);\n        free(prefix_sum);\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_iftn1rc5/program.c:8:10: fatal error: glib.h: No such file or directory\\n    8 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_iftn1rc5/program.c:8:10: fatal error: glib.h: No such file or directory\n    8 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1899_C", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <ctype.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n;\n        scanf(\"%d\", &n);\n        int a[n];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        long long current_even = -1000000000LL;\n        long long current_odd = -1000000000LL;\n        long long max_sum = -1000000000LL;\n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n                if (a[i] % 2 == 0) {\n                    current_even = a[i];\n                    current_odd = -1000000000LL;\n                } else {\n                    current_odd = a[i];\n                    current_even = -1000000000LL;\n                }\n                max_sum = (current_even > current_odd) ? current_even : current_odd;\n            } else {\n                if (a[i] % 2 == 0) {\n                    long long temp_even = (a[i] > (current_odd + a[i])) ? a[i] : (current_odd + a[i]);\n                    long long temp_odd = -1000000000LL;\n                    current_even = temp_even;\n                    current_odd = temp_odd;\n                } else {\n                    long long temp_odd = (a[i] > (current_even + a[i])) ? a[i] : (current_even + a[i]);\n                    long long temp_even = -1000000000LL;\n                    current_even = temp_even;\n                    current_odd = temp_odd;\n                }\n                if (current_even > max_sum) {\n                    max_sum = current_even;\n                }\n                if (current_odd > max_sum) {\n                    max_sum = current_odd;\n                }\n            }\n        }\n        printf(\"%lld\\n\", max_sum);\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_qq238fnv/program.c:8:10: fatal error: glib.h: No such file or directory\\n    8 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_qq238fnv/program.c:8:10: fatal error: glib.h: No such file or directory\n    8 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc301_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char S[N + 1];\n    scanf(\"%s\", S);\n\n    // Use GHashTable to count wins for 'T' and 'A'\n    GHashTable *counts = g_hash_table_new(g_str_hash, g_str_equal);\n    g_hash_table_insert(counts, \"T\", GINT_TO_POINTER(0));\n    g_hash_table_insert(counts, \"A\", GINT_TO_POINTER(0));\n\n    for (int i = 0; i < N; i++) {\n        char c = S[i];\n        char *key = (c == 'T') ? \"T\" : \"A\";\n        int *count = g_hash_table_lookup(counts, key);\n        if (count) {\n            *count += 1;\n        }\n    }\n\n    int t_count = GPOINTER_TO_INT(g_hash_table_lookup(counts, \"T\"));\n    int a_count = GPOINTER_TO_INT(g_hash_table_lookup(counts, \"A\"));\n\n    if (t_count > a_count) {\n        printf(\"T\\n\");\n    } else if (a_count > t_count) {\n        printf(\"A\\n\");\n    } else {\n        // Tie case: determine who reached the count first\n        int current_t = 0, current_a = 0;\n        for (int i = 0; i < N; i++) {\n            char c = S[i];\n            if (c == 'T') {\n                current_t++;\n            } else {\n                current_a++;\n            }\n            if (current_t == t_count || current_a == a_count) {\n                if (current_t == t_count) {\n                    printf(\"T\\n\");\n                } else {\n                    printf(\"A\\n\");\n                }\n                break;\n            }\n        }\n    }\n\n    g_hash_table_destroy(counts);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_lzlyz36w/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_lzlyz36w/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc301_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <ctype.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        int val;\n        scanf(\"%d\", &val);\n        g_array_append_val(arr, val);\n    }\n\n    gboolean found;\n    do {\n        found = FALSE;\n        for (int i = 0; i < arr->len - 1; i++) {\n            int a = g_array_index(arr, int, i);\n            int b = g_array_index(arr, int, i + 1);\n            if (abs(a - b) != 1) {\n                GArray *insert_list = g_array_new(FALSE, FALSE, sizeof(int));\n                if (a < b) {\n                    for (int j = a + 1; j < b; j++) {\n                        g_array_append_val(insert_list, j);\n                    }\n                } else {\n                    for (int j = a - 1; j > b; j--) {\n                        g_array_append_val(insert_list, j);\n                    }\n                }\n\n                int insert_pos = i + 1;\n                for (int k = 0; k < insert_list->len; k++) {\n                    g_array_insert_val(arr, insert_pos, g_array_index(insert_list, int, k));\n                    insert_pos++;\n                }\n\n                g_array_free(insert_list, TRUE);\n                found = TRUE;\n                break;\n            }\n        }\n    } while (found);\n\n    for (int i = 0; i < arr->len; i++) {\n        printf(\"%d \", g_array_index(arr, int, i));\n    }\n    printf(\"\\n\");\n\n    g_array_free(arr, TRUE);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tzqteted/program.c:8:10: fatal error: glib.h: No such file or directory\\n    8 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_tzqteted/program.c:8:10: fatal error: glib.h: No such file or directory\n    8 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1899_D", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    for (int test_case = 0; test_case < t; test_case++) {\n        int n;\n        scanf(\"%d\", &n);\n        int *a = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n        GHashTable *freq = g_hash_table_new(g_int_hash, g_int_equal);\n        for (int i = 0; i < n; i++) {\n            int key = a[i];\n            gpointer value = g_hash_table_lookup(freq, &key);\n            int count = (value != NULL) ? GPOINTER_TO_INT(value) : 0;\n            count++;\n            g_hash_table_insert(freq, &key, GINT_TO_POINTER(count));\n        }\n        long long total = 0;\n        GHashTableIter iter;\n        gpointer key, value;\n        g_hash_table_iter_init(&iter, freq);\n        while (g_hash_table_iter_next(&iter, &key, &value)) {\n            int count = GPOINTER_TO_INT(value);\n            total += (count * (count - 1)) / 2;\n        }\n        int count_1 = GPOINTER_TO_INT(g_hash_table_lookup(freq, &1));\n        int count_2 = GPOINTER_TO_INT(g_hash_table_lookup(freq, &2));\n        total += (long long)count_1 * count_2;\n        printf(\"%lld\\n\", total);\n        g_hash_table_destroy(freq);\n        free(a);\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_hpkid7d9/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_hpkid7d9/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1883_B", "solution": null, "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:other\", \"stdout\": \"\", \"stderr\": \"No code provided\"}\n", "raw_stderr": "", "result": "fail:other", "stdout": "", "stderr": "No code provided"}
{"question_id": "abc302_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long long A, B;\n    scanf(\"%lld %lld\", &A, &B);\n    long long result = (A + B - 1) / B;\n    printf(\"%lld\\n\", result);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc301_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[100];\n    long long N;\n    scanf(\"%s\", S);\n    scanf(\"%lld\", &N);\n\n    int len = strlen(S);\n    int max_val = -1;\n\n    // Function to convert binary string to decimal\n    long long str_to_decimal(const char *s) {\n        long long val = 0;\n        for (int i = 0; s[i] != '\\0'; i++) {\n            val = val * 2 + (s[i] - '0');\n        }\n        return val;\n    }\n\n    // Function to generate all possible values by replacing '?' with 0 or 1\n    // Since generating all combinations is not feasible for large strings, we use a recursive approach\n    // to find the maximum value <= N\n    void generate(int pos, int count, char *current, long long current_val, gboolean *found) {\n        if (pos == len) {\n            if (current_val <= N) {\n                if (current_val > max_val) {\n                    max_val = current_val;\n                }\n            }\n            return;\n        }\n\n        if (found[0]) return;\n\n        char c = S[pos];\n        if (c == '?') {\n            // Try replacing with 0\n            current[pos] = '0';\n            generate(pos + 1, count, current, current_val * 2, found);\n            \n            // Try replacing with 1\n            current[pos] = '1';\n            generate(pos + 1, count, current, current_val * 2 + 1, found);\n        } else {\n            // Directly use the character\n            current[pos] = c;\n            generate(pos + 1, count, current, current_val * 2 + (c - '0'), found);\n        }\n    }\n\n    // Initialize the current string and start generating\n    char current[len + 1];\n    gboolean found = FALSE;\n    generate(0, 0, current, 0, &found);\n\n    printf(\"%d\\n\", max_val);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jatf4445/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jatf4445/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc302_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    char grid[H][W];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int directions[8][2] = {\n        {-1, -1}, {-1, 0}, {-1, 1},\n        {0, -1},          {0, 1},\n        {1, -1},  {1, 0}, {1, 1}\n    };\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 's') {\n                for (int d = 0; d < 8; d++) {\n                    int dx = directions[d][0];\n                    int dy = directions[d][1];\n                    bool valid = true;\n                    for (int k = 0; k < 5; k++) {\n                        int row = i + k * dx;\n                        int col = j + k * dy;\n                        if (row < 0 || row >= H || col < 0 || col >= W) {\n                            valid = false;\n                            break;\n                        }\n                        char c = grid[row][col];\n                        if (k == 0) {\n                            if (c != 's') {\n                                valid = false;\n                                break;\n                            }\n                        } else if (k == 1) {\n                            if (c != 'n') {\n                                valid = false;\n                                break;\n                            }\n                        } else if (k == 2) {\n                            if (c != 'u') {\n                                valid = false;\n                                break;\n                            }\n                        } else if (k == 3) {\n                            if (c != 'k') {\n                                valid = false;\n                                break;\n                            }\n                        } else if (k == 4) {\n                            if (c != 'e') {\n                                valid = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (valid) {\n                        for (int k = 0; k < 5; k++) {\n                            int r = i + k * dx;\n                            int c = j + k * dy;\n                            printf(\"%d %d\\n\", r + 1, c + 1);\n                        }\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_vr93t2t1/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_vr93t2t1/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc302_c", "solution": null, "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:other\", \"stdout\": \"\", \"stderr\": \"No code provided\"}\n", "raw_stderr": "", "result": "fail:other", "stdout": "", "stderr": "No code provided"}
{"question_id": "abc301_c", "solution": null, "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:other\", \"stdout\": \"\", \"stderr\": \"No code provided\"}\n", "raw_stderr": "", "result": "fail:other", "stdout": "", "stderr": "No code provided"}
{"question_id": "abc302_d", "solution": "The solution involves reading input values, sorting the array of Snuke's gift values, and using binary search to efficiently find valid pairs for each value in Aoki's array. The maximum sum of valid pairs is tracked and printed at the end. The approach ensures that the solution is efficient and handles large input sizes within constraints.", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jmk9b1bt/program.c:1:1: error: unknown type name 'The'\\n    1 | The solution involves reading input values, sorting the array of Snuke's gift values, and using binary search to efficiently find valid pairs for each value in Aoki's array. The maximum sum of valid pairs is tracked and printed at the end. The approach ensures that the solution is efficient and handles large input sizes within constraints.\\n      | ^~~\\n/tmp/agnostics_c_jmk9b1bt/program.c:1:14: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'involves'\\n    1 | The solution involves reading input values, sorting the array of Snuke's gift values, and using binary search to efficiently find valid pairs for each value in Aoki's array. The maximum sum of valid pairs is tracked and printed at the end. The approach ensures that the solution is efficient and handles large input sizes within constraints.\\n      |              ^~~~~~~~\\n/tmp/agnostics_c_jmk9b1bt/program.c:1:14: error: unknown type name 'involves'\\n/tmp/agnostics_c_jmk9b1bt/program.c:1:71: warning: character constant too long for its type\\n    1 | The solution involves reading input values, sorting the array of Snuke's gift values, and using binary search to efficiently find valid pairs for each value in Aoki's array. The maximum sum of valid pairs is tracked and printed at the end. The approach ensures that the solution is efficient and handles large input sizes within constraints.\\n      |                                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jmk9b1bt/program.c:1:1: error: unknown type name 'The'\n    1 | The solution involves reading input values, sorting the array of Snuke's gift values, and using binary search to efficiently find valid pairs for each value in Aoki's array. The maximum sum of valid pairs is tracked and printed at the end. The approach ensures that the solution is efficient and handles large input sizes within constraints.\n      | ^~~\n/tmp/agnostics_c_jmk9b1bt/program.c:1:14: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'involves'\n    1 | The solution involves reading input values, sorting the array of Snuke's gift values, and using binary search to efficiently find valid pairs for each value in Aoki's array. The maximum sum of valid pairs is tracked and printed at the end. The approach ensures that the solution is efficient and handles large input sizes within constraints.\n      |              ^~~~~~~~\n/tmp/agnostics_c_jmk9b1bt/program.c:1:14: error: unknown type name 'involves'\n/tmp/agnostics_c_jmk9b1bt/program.c:1:71: warning: character constant too long for its type\n    1 | The solution involves reading input values, sorting the array of Snuke's gift values, and using binary search to efficiently find valid pairs for each value in Aoki's array. The maximum sum of valid pairs is tracked and printed at the end. The approach ensures that the solution is efficient and handles large input sizes within constraints.\n      |                                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"}
{"question_id": "abc301_e", "solution": null, "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:other\", \"stdout\": \"\", \"stderr\": \"No code provided\"}\n", "raw_stderr": "", "result": "fail:other", "stdout": "", "stderr": "No code provided"}
{"question_id": "abc301_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    char S[300001];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n\n    // dp[i][a][b][c] represents the number of valid strings up to position i with last three characters a", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_fpa4rbzw/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_fpa4rbzw/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc302_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Hash table to track the degree of each vertex\n    GHashTable *degree = g_hash_table_new(g_int_hash, g_int_equal);\n    // Hash table to track the edges connected to each vertex\n    GHashTable *edges = g_hash_table_new(g_int_hash, g_int_equal);\n    // Counter for the number of isolated vertices\n    int isolated_count = N;\n\n    // Initialize degrees to 0\n    for (int i = 1; i <= N; i++) {\n        g_hash_table_insert(degree, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n    }\n\n    // Process each query\n    for (int q = 0; q < Q; q++) {\n        char type;\n        scanf(\" %c\", &type);\n        if (type == '1') {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n            // Check if u and v are already connected (though problem says they are not)\n            // For this problem, we can assume they are not connected\n            // Add the edge\n            g_hash_table_add(edges, GINT_TO_POINTER(u));\n            g_hash_table_add(edges, GINT_TO_POINTER(v));\n            // Update degrees\n            int *deg_u = g_hash_table_lookup(degree, GINT_TO_POINTER(u));\n            int *deg_v = g_hash_table_lookup(degree, GINT_TO_POINTER(v));\n            *deg_u += 1;\n            *deg_v += 1;\n            // Check if u and v were isolated before adding the edge\n            if (*deg_u == 1) {\n                isolated_count--;\n            }\n            if (*deg_v == 1) {\n                isolated_count--;\n            }\n        } else {\n            int v;\n            scanf(\"%d\", &v);\n            // Remove all edges connected to v\n            // Get all edges connected to v\n            GList *list = g_hash_table_lookup(edges, GINT_TO_POINTER(v));\n            if (list) {\n                GList *node = list;\n                while (node) {\n                    int u = GPOINTER_TO_INT(node->data);\n                    // Remove edge between u and v\n                    // Decrement degrees of u and v\n                    int *deg_u = g_hash_table_lookup(degree, GINT_TO_POINTER(u));\n                    int *deg_v = g_hash_table_lookup(degree, GINT_TO_POINTER(v));\n                    *deg_u -= 1;\n                    *deg_v -= 1;\n                    // Check if u or v were isolated before decrementing\n                    if (*deg_u == 0) {\n                        isolated_count++;\n                    }\n                    if (*deg_v == 0) {\n                        isolated_count++;\n                    }\n                    node = node->next;\n                }\n                // Remove v from edges\n                g_hash_table_remove(edges, GINT_TO_POINTER(v));\n            }\n        }\n        // Print the current number of isolated vertices\n        printf(\"%d\\n\", isolated_count);\n    }\n\n    // Clean up\n    g_hash_table_destroy(degree);\n    g_hash_table_destroy(edges);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_nq9okekh/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_nq9okekh/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
