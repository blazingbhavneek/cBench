{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        char str[4];\n        scanf(\"%s\", str);\n\n        // Find the positions of 'a', 'b', and 'c'\n        int pos_a = -1, pos_b = -1, pos_c = -1;\n        for (int i = 0; i < 3; i++) {\n            if (str[i] == 'a') pos_a = i;\n            else if (str[i] == 'b') pos_b = i;\n            else if (str[i] == 'c') pos_c = i;\n        }\n\n        // Check if the string is already 'abc'\n        if (pos_a == 0 && pos_b == 1 && pos_c == 2) {\n            printf(\"YES\n\");\n        } else {\n            // Check if a single swap can make it 'abc'\n            if ((pos_a == 1 && pos_b == 2) ||\n                (pos_a == 2 && pos_b == 1) ||\n                (pos_a == 0 && pos_c == 2) ||\n                (pos_a == 2 && pos_c == 0) ||\n                (pos_b == 0 && pos_c == 1) ||\n                (pos_b == 1 && pos_c == 0)) {\n                printf(\"YES\n\");\n            } else {\n                printf(\"NO\n\");\n            }\n        }\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can transform a given string of three characters ('a', 'b', 'c') into the string 'abc' with at most one swap. The approach involves checking the positions of the characters 'a', 'b', and 'c' in the given string and determining if a single swap can correct the order.", "question_id": "1873_A"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *a = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n\n        int max_product = 1;\n        for (int i = 0; i < n; i++) {\n            int original_digit = a[i];\n            a[i] += 1;\n\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                product *= a[j];\n            }\n\n            if (product > max_product) {\n                max_product = product;\n            }\n\n            a[i] = original_digit;\n        }\n\n        printf(\"%d\n\", max_product);\n\n        free(a);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maximize the product of digits in an array by adding 1 to exactly one of the digits. The approach involves iterating through each digit, adding 1 to it, calculating the product, and then subtracting 1 to revert the change. We track the maximum product obtained during this process.", "question_id": "1873_B"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n        char s[n + 1];\n        scanf(\"%s\", s);\n\n        int operations = 0;\n        int i = 0;\n\n        while (i < n) {\n            if (s[i] == 'B') {\n                operations++;\n                i += k;\n            } else {\n                i++;\n            }\n        }\n\n        printf(\"%d\n\", operations);\n    }\n\n    return 0;\n}", "reasoning": "The problem requires finding the minimum number of operations to remove all black cells from a strip of paper. Each operation allows changing any k consecutive cells to white. The approach involves iterating through the string and counting the number of operations needed to convert all black cells to white. For each black cell encountered, we need to perform an operation that covers it and possibly adjacent cells.", "question_id": "1873_D"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 100005\n\nbool canFormPalindrome(int count[], int k) {\n    int oddCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (count[i] % 2 != 0) {\n            oddCount++;\n        }\n    }\n    return oddCount <= 1 && (k >= oddCount);\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n        char s[MAXN];\n        scanf(\"%s\", s);\n\n        int count[26] = {0};\n        for (int i = 0; i < n; i++) {\n            count[s[i] - 'a']++;\n        }\n\n        if (canFormPalindrome(count, k)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can remove exactly k characters from the string s such that the remaining characters can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count, while all other characters have even counts. Here's a step-by-step approach to solve the problem:", "question_id": "1883_B"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        int operations = 0;\n\n        for (int i = 0; i < n; i++) {\n            int a;\n            scanf(\"%d\", &a);\n\n            if (k == 2 && a % 2 != 0) {\n                operations++;\n            } else if (k == 3 && a % 3 != 0) {\n                operations++;\n            } else if (k == 5 && a % 5 != 0) {\n                operations++;\n            }\n        }\n\n        printf(\"%d\\n\", operations);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of operations required to make the product of an array of integers divisible by a given number k (where 2 <= k <= 5). The operations allowed are incrementing any element of the array by 1. We can approach this problem by analyzing the prime factorization of k and ensuring that the array's product contains at least the required factors of k. For k = 2, we need at least one even number in the array. For k = 3, we need at least one multiple of 3. For k = 5, we need at least one multiple of 5. We can iterate through the array and count the number of elements that are not divisible by 2, 3, or 5, and the result will be the minimum number of operations needed.", "question_id": "1883_C"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        // If n is already divisible by 3, Vanya wins immediately\n        if (n % 3 == 0) {\n            printf(\"First\n\");\n        } else {\n            // Calculate the number of moves required to make n divisible by 3\n            int moves = 0;\n            if (n % 3 == 1) {\n                moves = 1;\n            } else if (n % 3 == 2) {\n                moves = 2;\n            }\n\n            // If the number of moves is even, Vova wins; otherwise, Vanya wins\n            if (moves % 2 == 0) {\n                printf(\"Second\n\");\n            } else {\n                printf(\"First\n\");\n            }\n        }\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the optimal moves for both players and predict the outcome based on the starting number n. The key observation is that if the number is already divisible by 3, Vanya wins immediately. Otherwise, we need to analyze the parity of the number of moves required to make the number divisible by 3. If the number of moves is even, Vova wins; if odd, Vanya wins.", "question_id": "1899_A"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        long long *boxes = (long long *)malloc(n * sizeof(long long));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lld\", &boxes[i]);\n        }\n\n        // Calculate prefix sums\n        for (int i = 1; i < n; i++) {\n            boxes[i] += boxes[i - 1];\n        }\n\n        long long max_diff = 0;\n\n        // Iterate through possible values of k\n        for (int k = 1; k <= n; k++) {\n            long long min_weight = 0;\n            long long max_weight = 0;\n\n            for (int i = k; i < n; i += k) {\n                if (i == k) {\n                    min_weight = boxes[i - 1];\n                    max_weight = boxes[i - 1];\n                } else {\n                    long long current_weight = boxes[i - 1] - (i - k > 0 ? boxes[i - k - 1] : 0);\n                    min_weight = current_weight < min_weight ? current_weight : min_weight;\n                    max_weight = current_weight > max_weight ? current_weight : max_weight;\n                }\n            }\n\n            long long diff = max_weight - min_weight;\n            if (diff > max_diff) {\n                max_diff = diff;\n            }\n        }\n\n        printf(\"%lld\\n\", max_diff);\n\n        free(boxes);\n    }\n\n    return 0;\n}", "reasoning": "The problem requires finding the maximum absolute difference between the total weights of two trucks when the boxes are divided into groups of k boxes each. To achieve this, we can use a prefix sum array to calculate the total weight of boxes up to any point and then iterate through possible values of k to find the maximum difference. The key insight is that for a given k, the maximum difference can be found by comparing the prefix sums at multiples of k.", "question_id": "1899_B"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *a = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n\n        int max_sum = INT_MIN;\n        int current_sum = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && (a[i] % 2 == a[i - 1] % 2)) {\n                current_sum = a[i];\n            } else {\n                current_sum += a[i];\n            }\n            max_sum = fmax(max_sum, current_sum);\n        }\n\n        printf(\"%d\\n\", max_sum);\n\n        free(a);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum sum of a subarray with alternating parities for adjacent elements. Here's a step-by-step approach to achieve this:", "question_id": "1899_C"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        long long pairs = (long long)n * (n - 1) / 2;\n        printf(\"%lld\\n\", pairs);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of pairs (i, j) such that b_i^b_j = b_j^b_i. Given that b_i = 2^a_i and b_j = 2^a_j, this condition simplifies to (2^a_i)^(2^a_j) = (2^a_j)^(2^a_i), which is always true. Therefore, we need to count all pairs (i, j) where i < j. This is equivalent to finding the number of ways to choose 2 elements from n elements, which is given by the combination formula nC2 = n*(n-1)/2. We will iterate through each test case, calculate nC2, and print the result.", "question_id": "1899_D"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    // Initialize variables\n    int takahashi_wins = 0;\n    int aoki_wins = 0;\n    int takahashi_last_win = -1;\n    int aoki_last_win = -1;\n\n    // Process the string to count wins and track last wins\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'T') {\n            takahashi_wins++;\n            takahashi_last_win = i;\n        } else {\n            aoki_wins++;\n            aoki_last_win = i;\n        }\n    }\n\n    // Determine the overall winner\n    if (takahashi_wins > aoki_wins) {\n        printf(\"T\\n\");\n    } else if (aoki_wins > takahashi_wins) {\n        printf(\"A\\n\");\n    } else {\n        if (takahashi_last_win < aoki_last_win) {\n            printf(\"T\\n\");\n        } else {\n            printf(\"A\\n\");\n        }\n    }\n\n    return 0;\n}", "reasoning": "To determine the overall winner between Takahashi and Aoki, we need to count the number of games each of them won and then compare these counts. If the counts are equal, we need to determine the first game in which the winner was decided. This requires iterating through the string and keeping track of the counts and the order of wins.", "question_id": "abc301_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nvoid insert_numbers(GArray *arr, int i, int j) {\n    int diff = abs(j - i);\n    for (int k = 1; k < diff; k++) {\n        if (i < j) {\n            g_array_insert_val(arr, i + k, i + k);\n        } else {\n            g_array_insert_val(arr, i + k, i - k);\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int num;\n        scanf(\"%d\", &num);\n        g_array_append_val(arr, num);\n    }\n\n    while (true) {\n        int max_diff = 0;\n        int max_i = -1;\n        int max_j = -1;\n\n        for (int i = 0; i < arr->len - 1; i++) {\n            int diff = abs(g_array_index(arr, int, i) - g_array_index(arr, int, i + 1));\n            if (diff > max_diff) {\n                max_diff = diff;\n                max_i = i;\n                max_j = i + 1;\n            }\n        }\n\n        if (max_diff == 1) {\n            break;\n        }\n\n        insert_numbers(arr, max_i, max_j);\n    }\n\n    for (int i = 0; i < arr->len; i++) {\n        printf(\"%d \", g_array_index(arr, int, i));\n    }\n    printf(\"\\n\");\n\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "reasoning": "The problem requires us to insert numbers between adjacent elements in a sequence until no more insertions can be made. The key is to identify the pair of adjacent elements with the largest absolute difference and insert the sequence of numbers between them. This process is repeated until no more insertions are possible. We can use a loop to repeatedly find and insert the numbers until no more insertions can be made. We can use a hash table to keep track of the positions of the numbers in the sequence, and a queue to keep track of the pairs of adjacent elements with the largest absolute difference. We can use a function to insert the numbers between two elements and update the hash table and queue accordingly.", "question_id": "abc301_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[200001], T[200001];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int len = strlen(S);\n    GHashTable *countS = g_hash_table_new(g_str_hash, g_str_equal);\n    GHashTable *countT = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Count characters in S and T\n    for (int i = 0; i < len; i++) {\n        if (S[i] != '@') {\n            g_hash_table_insert(countS, (gpointer)S[i], GINT_TO_POINTER(g_hash_table_lookup(countS, (gpointer)S[i]) ? GPOINTER_TO_INT(g_hash_table_lookup(countS, (gpointer)S[i])) + 1 : 1));\n        }\n        if (T[i] != '@') {\n            g_hash_table_insert(countT, (gpointer)T[i], GINT_TO_POINTER(g_hash_table_lookup(countT, (gpointer)T[i]) ? GPOINTER_TO_INT(g_hash_table_lookup(countT, (gpointer)T[i])) + 1 : 1));\n        }\n    }\n\n    // Check if we can match characters in S with T\n    bool canMatch = true;\n    for (int i = 0; i < len; i++) {\n        if (S[i] != '@' && T[i] != '@' && GPOINTER_TO_INT(g_hash_table_lookup(countS, (gpointer)S[i])) != GPOINTER_TO_INT(g_hash_table_lookup(countT, (gpointer)T[i]))) {\n            canMatch = false;\n            break;\n        }\n    }\n\n    // Check if we can match remaining '@'s\n    int atCountS = 0, atCountT = 0;\n    for (int i = 0; i < len; i++) {\n        if (S[i] == '@') atCountS++;\n        if (T[i] == '@') atCountT++;\n    }\n\n    if (atCountS == atCountT) {\n        canMatch = true;\n    } else {\n        canMatch = false;\n    }\n\n    // Output result\n    if (canMatch) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(countS);\n    g_hash_table_destroy(countT);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can rearrange the cards in two rows (S and T) such that they match, allowing for the replacement of '@' with any of the characters 'a', 't', 'c', 'o', 'd', 'e', or 'r'. The key insight is that we can treat each '@' in S as a wildcard that can match any character in T, and vice versa. We can use a frequency count approach to check if the characters in S can be matched with the characters in T, considering the wildcards.", "question_id": "abc301_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[61];\n    long long N;\n    scanf(\"%s %lld\", S, &N);\n\n    int len = strlen(S);\n    GArray *values = g_array_new(FALSE, FALSE, sizeof(long long));\n\n    // Helper function to generate binary values\n    void generate_values(char *str, int pos, long long value) {\n        if (pos == len) {\n            if (value <= N) {\n                g_array_append_val(values, value);\n            }\n            return;\n        }\n\n        if (str[pos] == '?') {\n            generate_values(str, pos + 1, value * 2);\n            generate_values(str, pos + 1, value * 2 + 1);\n        } else {\n            generate_values(str, pos + 1, value * 2 + (str[pos] - '0')));\n        }\n    }\n\n    // Generate all possible values\n    generate_values(S, 0, 0);\n\n    // Sort the values in descending order\n    qsort(values->data, values->len, sizeof(long long),\n          (int (*)(const void *, const void *))compare);\n\n    // Find the greatest value less than or equal to N\n    long long result = -1;\n    for (int i = 0; i < values->len; i++) {\n        if (g_array_index(values, long long, i) <= N) {\n            result = g_array_index(values, long long, i);\n        } else {\n            break;\n        }\n    }\n\n    // Print the result\n    printf(\"%lld\\n\", result);\n\n    // Clean up\n    g_array_free(values, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate all possible binary values from the given string S by replacing each '?' with '0' and '1'. Then, we need to find the greatest value among these that is less than or equal to N. Here's a step-by-step approach to achieve this:", "question_id": "abc301_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_H 300\n#define MAX_W 300\n#define MAX_T 2000000\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint main() {\n    int H, W, T;\n    scanf(\"%d %d %d\", &H, &W, &T);\n\n    char grid[MAX_H][MAX_W];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    Point start, goal;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                start.x = i;\n                start.y = j;\n            } else if (grid[i][j] == 'G') {\n                goal.x = i;\n                goal.y = j;\n            }\n        }\n    }\n\n    GQueue *queue = g_queue_new();\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    g_queue_push_tail(queue, GINT_TO_POINTER(start.x * W + start.y));\n    g_hash_table_insert(visited, GINT_TO_POINTER(start.x * W + start.y), GINT_TO_POINTER(0));\n\n    int max_candies = -1;\n\n    while (!g_queue_is_empty(queue) && T > 0) {\n        int size = g_queue_get_length(queue);\n        for (int i = 0; i < size; i++) {\n            int pos = GPOINTER_TO_INT(g_queue_pop_head(queue));\n            int x = pos / W;\n            int y = pos % W;\n\n            for (int d = 0; d < 4; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] != '#') {\n                    int new_pos = nx * W + ny;\n                    int candies = GPOINTER_TO_INT(g_hash_table_lookup(visited, GINT_TO_POINTER(pos))) + (grid[nx][ny] == 'o' ? 1 : 0);\n\n                    if (nx == goal.x && ny == goal.y) {\n                        max_candies = candies;\n                        break;\n                    }\n\n                    if (!g_hash_table_contains(visited, GINT_TO_POINTER(new_pos))) {\n                        g_queue_push_tail(queue, GINT_TO_POINTER(new_pos));\n                        g_hash_table_insert(visited, GINT_TO_POINTER(new_pos), GINT_TO_POINTER(candies));\n                    }\n                }\n            }\n\n            if (max_candies != -1) {\n                break;\n            }\n        }\n\n        T--;\n    }\n\n    printf(\"%d\\n\", max_candies);\n\n    g_queue_free(queue);\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if Takahashi can reach the goal square within T moves and, if so, find the maximum number of candy squares he can visit. Here's a step-by-step approach to solving the problem:\n\n1. **Input Parsing**: Read the grid dimensions and the grid itself from the input.\n2. **Breadth-First Search (BFS)**: Use BFS to explore all possible paths from the start square within T moves. This will help us determine if it's possible to reach the goal square and also track the maximum number of candy squares visited on the way.\n3. **Tracking Candy Squares**: As we perform the BFS, keep track of the number of candy squares visited on each path. We need to ensure that each candy square is counted only once even if it's visited multiple times on the same path.\n4. **Result Calculation**: If we can reach the goal square, return the maximum number of candy squares visited. If not, return -1.\n\nThis approach ensures that we efficiently explore all possible paths and find the optimal solution.", "question_id": "abc301_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    char s[300001];\n    scanf(\"%s\", s);\n    int n = strlen(s);\n\n    // Count the number of '?' characters\n    int q = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '?') {\n            q++;\n        }\n    }\n\n    // If there are no '?' characters, the result is 1 (the string itself)\n    if (q == 0) {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    // Calculate the total number of possible strings\n    long long total = 52LL * q;\n    total %= MOD;\n\n    // Calculate the number of strings containing a DDoS-type substring\n    long long ddos_count = 0;\n\n    // Iterate over all possible positions for the '?' characters\n    for (int i = 0; i < q; i++) {\n        for (int j = i + 1; j < q; j++) {\n            for (int k = j + 1; k < q; k++) {\n                // Check if the substring formed by the '?' characters at positions i, j, and k forms a DDoS-type string\n                if (s[i] == s[j] && s[j] != s[k] && s[k] == s[i] + 32) {\n                    ddos_count++;\n                }\n            }\n        }\n    }\n\n    // Calculate the number of valid strings\n    long long valid_count = (total - ddos_count + MOD) % MOD;\n\n    // Print the result\n    printf(\"%lld\\n\", valid_count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of valid strings that do not contain a DDoS-type string as a subsequence. A DDoS-type string is defined as a string of length 4 with specific character constraints. We can approach this problem using dynamic programming and combinatorial mathematics.", "question_id": "abc301_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long long A, B;\n    scanf(\"%lld %lld\", &A, &B);\n\n    // Calculate the minimum number of attacks required\n    long long attacks = (A + B - 1) / B;\n\n    // Output the result\n    printf(\"%lld\n\", attacks);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of attacks required to reduce the enemy's stamina to 0 or less. Given the constraints, direct iteration would be inefficient due to the large values of A and B. Instead, we can use a mathematical approach to find the solution more efficiently.", "question_id": "abc302_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define H 100\n#define W 100\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    char grid[H][W];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int result[H * W][5][2] = {0};\n    int result_count = 0;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 's') {\n                for (int di = -1; di <= 1; di++) {\n                    for (int dj = -1; dj <= 1; dj++) {\n                        if (di == 0 && dj == 0) continue;\n                        int ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < H && nj >= 0 && nj < W && grid[ni][nj] == 'n') {\n                            for (int dk = -1; dk <= 1; dk++) {\n                                if (dk == 0) continue;\n                                int nk = ni + di * dk, nkj = nj + dj * dk;\n                                if (nk >= 0 && nk < H && nkj >= 0 && nkj < W && grid[nk][nkj] == 'u') {\n                                    for (int dl = -1; dl <= 1; dl++) {\n                                        if (dl == 0) continue;\n                                        int nl = nk + di * dk * dl, nlj = nkj + dj * dk * dl;\n                                        if (nl >= 0 && nl < H && nlj >= 0 && nlj < W && grid[nl][nlj] == 'k') {\n                                            for (int dm = -1; dm <= 1; dm++) {\n                                                if (dm == 0) continue;\n                                                int nm = nl + di * dk * dl * dm, nmj = nlj + dj * dk * dl * dm;\n                                                if (nm >= 0 && nm < H && nmj >= 0 && nmj < W && grid[nm][nmj] == 'e') {\n                                                    result[result_count][0][0] = i;\n                                                    result[result_count][0][1] = j;\n                                                    result[result_count][1][0] = ni;\n                                                    result[result_count][1][1] = nj;\n                                                    result[result_count][2][0] = nk;\n                                                    result[result_count][2][1] = nkj;\n                                                    result[result_count][3][0] = nl;\n                                                    result[result_count][3][1] = nlj;\n                                                    result[result_count][4][0] = nm;\n                                                    result[result_count][4][1] = nmj;\n                                                    result_count++;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < result_count; i++) {\n        for (int j = 0; j < 5; j++) {\n            printf(\"%d %d\n\", result[i][j][0] + 1, result[i][j][1] + 1);\n        }\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find a sequence of five cells in a grid that form a line and contain the letters 's', 'n', 'u', 'k', and 'e' in that order. The cells must be contiguous and can be connected vertically, horizontally, or diagonally. Here's a step-by-step approach to solve the problem:", "question_id": "abc302_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 8\n#define MAXM 5\n\ntypedef struct {\n    int vertices;\n    int edges;\n    GArray *adj[MAXM * 26];\n} Graph;\n\nGraph* createGraph(int vertices) {\n    Graph *graph = (Graph*)malloc(sizeof(Graph));\n    graph->vertices = vertices;\n    graph->edges = 0;\n    for (int i = 0; i < MAXM * 26; i++) {\n        graph->adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n    return graph;\n}\n\nvoid addEdge(Graph *graph, int u, int v) {\n    g_array_append_val(graph->adj[u], v);\n    graph->edges++;\n}\n\nbool isEulerianPath(Graph *graph) {\n    int odd = 0;\n    for (int i = 0; i < graph->vertices; i++) {\n        if (g_array_get_length(graph->adj[i]) % 2 != 0) {\n            odd++;\n        }\n    }\n    return (odd == 0 || odd == 2);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    char strings[MAXN][MAXM + 1];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", strings[i]);\n    }\n\n    Graph *graph = createGraph(N);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int diff = 0;\n            for (int k = 0; k < M; k++) {\n                if (strings[i][k] != strings[j][k]) {\n                    diff++;\n                }\n                if (diff > 1) {\n                    break;\n                }\n            }\n            if (diff == 1) {\n                addEdge(graph, i, j);\n                addEdge(graph, j, i);\n            }\n        }\n    }\n\n    if (isEulerianPath(graph)) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    for (int i = 0; i < MAXM * 26; i++) {\n        g_array_free(graph->adj[i], TRUE);\n    }\n    free(graph);\n\n    return 0;\n}", "reasoning": "The problem requires determining if we can rearrange the given strings into a sequence where each string can be transformed into the next by changing exactly one character. This problem can be approached by checking if there exists a path between any two strings in a graph where each edge represents a valid transformation (changing exactly one character). The solution involves constructing a graph, checking for connectivity, and ensuring that the graph is Eulerian (each vertex has an even degree). If the graph is Eulerian, it means we can find an Eulerian path, which is a path that visits every edge exactly once, thus satisfying the problem's conditions.", "question_id": "abc302_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m, d;\n    scanf(\"%d %d %d\", &n, &m, &d);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int *b = (int *)malloc(m * sizeof(int));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    qsort(a, n, sizeof(int), compare);\n    qsort(b, m, sizeof(int), compare);\n\n    int i = 0, j = 0;\n    long long max_sum = -1;\n\n    while (i < n && j < m) {\n        if (b[j] - a[i] <= d) {\n            max_sum = a[i] + b[j];\n            i++;\n            j++;\n        } else if (b[j] - a[i] > d) {\n            i++;\n        }\n    }\n\n    printf(\"%lld\n\", max_sum);\n\n    free(a);\n    free(b);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find pairs of gifts from Aoki's and Snuke's lists such that their value difference is at most D, and we want to maximize the sum of the values of the chosen gifts. Here's a step-by-step approach to solve it using a two-pointer technique after sorting both lists:", "question_id": "abc302_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    // Initialize adjacency list and degree map\n    GHashTable *adj = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *degree = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initialize all vertices with degree 0\n    for (int i = 1; i <= n; i++) {\n        g_hash_table_insert(degree, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n    }\n\n    for (int i = 0; i < q; i++) {\n        int type, u, v;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            scanf(\"%d %d\", &u, &v);\n\n            // Add edge u-v\n            GArray *list = g_hash_table_lookup(adj, GINT_TO_POINTER(u));\n            if (!list) {\n                list = g_array_new(FALSE, FALSE, sizeof(int));\n                g_hash_table_insert(adj, GINT_TO_POINTER(u), list);\n            }\n            g_array_append_val(list, v);\n\n            list = g_hash_table_lookup(adj, GINT_TO_POINTER(v));\n            if (!list) {\n                list = g_array_new(FALSE, FALSE, sizeof(int));\n                g_hash_table_insert(adj, GINT_TO_POINTER(v), list);\n            }\n            g_array_append_val(list, u);\n\n            // Update degrees\n            int *deg_u = g_hash_table_lookup(degree, GINT_TO_POINTER(u));\n            int *deg_v = g_hash_table_lookup(degree, GINT_TO_POINTER(v));\n            (*deg_u)++;\n            (*deg_v)++;\n        } else if (type == 2) {\n            scanf(\"%d\", &u);\n\n            // Remove all edges connected to vertex u\n            GArray *list = g_hash_table_lookup(adj, GINT_TO_POINTER(u));\n            if (list) {\n                for (guint j = 0; j < list->len; j++) {\n                    int v = g_array_index(list, int, j);\n                    GArray *v_list = g_hash_table_lookup(adj, GINT_TO_POINTER(v));\n                    if (v_list) {\n                        g_array_remove_range(v_list, j, 1);\n                        j--;\n                    }\n                }\n                g_array_free(list, TRUE);\n                g_hash_table_remove(adj, GINT_TO_POINTER(u));\n            }\n\n            // Update degrees\n            int *deg_u = g_hash_table_lookup(degree, GINT_TO_POINTER(u));\n            (*deg_u) = 0;\n        }\n\n        // Count vertices with degree 0\n        int count = 0;\n        GHashTableIter iter;\n        gpointer key, value;\n        g_hash_table_iter_init(&iter, degree);\n        while (g_hash_table_iter_next(&iter, &key, &value)) {\n            if (GPOINTER_TO_INT(value) == 0) {\n                count++;\n            }\n        }\n\n        // Print the count\n        printf(\"%d\n\", count);\n    }\n\n    // Clean up\n    g_hash_table_destroy(adj);\n    g_hash_table_destroy(degree);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently handle graph operations and keep track of vertices that are not connected to any other vertices. We can use a hash table to maintain the adjacency list of the graph and another hash table to keep track of the degrees of each vertex. When processing a query, we update the graph and the degrees accordingly. For each query, we also need to determine the number of vertices with a degree of 0 and print it.", "question_id": "abc302_e"}
