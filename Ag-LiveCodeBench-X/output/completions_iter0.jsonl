{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        char str[4];\n        scanf(\"%s\", str);\n\n        // Check if the string is already 'abc'\n        if (strcmp(str, \"abc\") == 0) {\n            printf(\"YES\\n\");\n            continue;\n        }\n\n        // Find the positions of 'a', 'b', and 'c'\n        int pos_a, pos_b, pos_c;\n        for (int i = 0; i < 3; i++) {\n            if (str[i] == 'a') pos_a = i;\n            if (str[i] == 'b') pos_b = i;\n            if (str[i] == 'c') pos_c = i;\n        }\n\n        // Check if swapping 'a' and 'b' makes 'abc'\n        if (pos_a != 0 || pos_b != 1) {\n            char temp = str[0];\n            str[0] = str[1];\n            str[1] = temp;\n            if (strcmp(str, \"abc\") == 0) {\n                printf(\"YES\\n\");\n                continue;\n            }\n            // Swap back\n            temp = str[0];\n            str[0] = str[1];\n            str[1] = temp;\n        }\n\n        // Check if swapping 'a' and 'c' makes 'abc'\n        if (pos_a != 0 || pos_c != 2) {\n            char temp = str[0];\n            str[0] = str[2];\n            str[2] = temp;\n            if (strcmp(str, \"abc\") == 0) {\n                printf(\"YES\\n\");\n                continue;\n            }\n            // Swap back\n            temp = str[0];\n            str[0] = str[2];\n            str[2] = temp;\n        }\n\n        // Check if swapping 'b' and 'c' makes 'abc'\n        if (pos_b != 1 || pos_c != 2) {\n            char temp = str[1];\n            str[1] = str[2];\n            str[2] = temp;\n            if (strcmp(str, \"abc\") == 0) {\n                printf(\"YES\\n\");\n                continue;\n            }\n            // Swap back\n            temp = str[1];\n            str[1] = str[2];\n            str[2] = temp;\n        }\n\n        // If none of the above swaps work, it's not possible\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can make the string 'abc' by swapping at most one pair of characters in the given string. Here's a step-by-step approach to achieve this:", "question_id": "1873_A"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *digits = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &digits[i]);\n        }\n\n        int maxProduct = 1;\n        int maxIndex = -1;\n\n        for (int i = 0; i < n; i++) {\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    product *= (digits[j] + 1);\n                } else {\n                    product *= digits[j];\n                }\n            }\n            if (product > maxProduct) {\n                maxProduct = product;\n                maxIndex = i;\n            }\n        }\n\n        printf(\"%d\n\", maxProduct);\n\n        free(digits);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maximize the product of the digits in an array by adding 1 to exactly one of the digits. Here's a step-by-step approach to achieve this:", "question_id": "1873_B"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n        char s[n + 1];\n        scanf(\"%s\", s);\n\n        int operations = 0;\n        int i = 0;\n\n        while (i < n) {\n            if (s[i] == 'B') {\n                operations++;\n                while (i < n && s[i] == 'B' && (i - i % k) % k == 0) {\n                    i++;\n                }\n            } else {\n                i++;\n            }\n        }\n\n        printf(\"%d\\n\", operations);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum number of operations required to remove all black cells from a strip of paper. Each operation allows us to change any k consecutive cells to white. The key insight is to iterate through the string and count the number of segments of consecutive black cells. Each segment of black cells requires one operation to convert them all to white. Additionally, if the last segment of black cells is at the end of the string and its length is less than k, we need to handle this separately.", "question_id": "1873_D"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        char s[100001];\n        scanf(\"%s\", s);\n\n        // Count the frequency of each character\n        GHashTable *count = g_hash_table_new(g_str_hash, g_str_equal);\n        for (int i = 0; i < n; i++) {\n            char *ch = g_strdup(&s[i]);\n            int val = GPOINTER_TO_INT(g_hash_table_lookup(count, ch)) + 1;\n            g_hash_table_insert(count, ch, GINT_TO_POINTER(val));\n        }\n\n        int odd_count = 0;\n        GHashTableIter iter;\n        gpointer key, value;\n        g_hash_table_iter_init(&iter, count);\n        while (g_hash_table_iter_next(&iter, &key, &value)) {\n            if (GPOINTER_TO_INT(value) % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        // Check if it's possible to form a palindrome\n        if (odd_count <= 1 && n - k >= 0 && (n - k) % 2 == 0) {\n            printf(\"YES\n\");\n        } else {\n            printf(\"NO\n\");\n        }\n\n        // Clean up\n        g_hash_table_destroy(count);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if it's possible to remove exactly k characters from a given string s such that the remaining characters can form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count (for strings of odd length) and all characters have even counts (for strings of even length). Here's how we can approach the solution:", "question_id": "1883_B"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (int i = 0; i < n; i++) {\n            int num;\n            scanf(\"%d\", &num);\n            int remainder = num % k;\n            if (remainder != 0) {\n                g_hash_table_insert(count, GINT_TO_POINTER(remainder), GINT_TO_POINTER(1));\n            }\n        }\n\n        int operations = 0;\n        if (k == 2) {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(1))) {\n                operations = 1;\n            }\n        } else if (k == 3) {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(1))) {\n                operations = 1;\n            } else if (g_hash_table_lookup(count, GINT_TO_POINTER(2))) {\n                operations = 2;\n            }\n        } else if (k == 4) {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(2))) {\n                operations = 1;\n            }\n        } else if (k == 5) {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(1))) {\n                operations = 1;\n            } else if (g_hash_table_lookup(count, GINT_TO_POINTER(2))) {\n                operations = 2;\n            } else if (g_hash_table_lookup(count, GINT_TO_POINTER(3))) {\n                operations = 3;\n            } else if (g_hash_table_lookup(count, GINT_TO_POINTER(4))) {\n                operations = 4;\n            }\n        }\n\n        printf(\"%d\n\", operations);\n\n        g_hash_table_destroy(count);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of operations required to make the product of all elements in an array divisible by a given number k. The key observation is that we only need to consider the least significant bits of the numbers that are relevant to k. For k = 2, we need to ensure there is at least one even number. For k = 3, we need to ensure there is at least one number that is divisible by 3. For k = 4, we need to ensure there is at least one number that is divisible by 2. For k = 5, we need to ensure there is at least one number that is divisible by 5. The solution involves counting the numbers that are not divisible by k and determining the minimum operations needed to make the product divisible by k.", "question_id": "1883_C"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        if (n % 3 == 0) {\n            printf(\"First\\n\");\n        } else {\n            printf(\"Second\\n\");\n        }\n    }\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the winner of the game based on the integer n. The key observation here is that if the current number is divisible by 3, the player whose turn it is wins. Otherwise, the player can force the other player into a losing position by moving to a number that is divisible by 3 in their next turn. We can use this observation to determine the winner for each test case. If n is already divisible by 3, Vanya wins. Otherwise, Vanya can always force Vova into a losing position by moving to a number that is divisible by 3 in his first turn.", "question_id": "1899_A"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *weights = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &weights[i]);\n        }\n\n        qsort(weights, n, sizeof(int), compare);\n\n        long long sum1 = 0, sum2 = 0;\n        for (int i = 0; i < n / 2; i++) {\n            sum1 += weights[i];\n        }\n        for (int i = n / 2; i < n; i++) {\n            sum2 += weights[i];\n        }\n\n        printf(\"%lld\n\", llabs(sum1 - sum2));\n\n        free(weights);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum absolute difference between the total weights of any two trucks when the boxes are divided into groups of size k, where k is between 1 and n. The key insight is that the maximum difference will occur when the boxes are divided into two groups with the smallest and largest possible total weights. This can be achieved by sorting the weights and then summing the first half and the second half of the sorted array. The difference between these two sums will give us the maximum absolute difference.", "question_id": "1899_B"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *arr = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &arr[i]);\n        }\n\n        int max_sum = INT_MIN;\n        int current_sum = 0;\n        int last_parity = -1; // -1 for unknown, 0 for even, 1 for odd\n\n        for (int i = 0; i < n; i++) {\n            int current_parity = arr[i] % 2;\n\n            if (last_parity == -1 || last_parity != current_parity) {\n                current_sum += arr[i];\n                last_parity = current_parity;\n            } else {\n                current_sum = arr[i];\n                last_parity = current_parity;\n            }\n\n            max_sum = fmax(max_sum, current_sum);\n        }\n\n        printf(\"%d\n\", max_sum);\n\n        free(arr);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum sum of a subarray with alternating parities for adjacent elements. Here's a step-by-step approach to achieve this:", "question_id": "1899_C"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n        long long count = 0;\n\n        for (int i = 0; i < n; i++) {\n            int a;\n            scanf(\"%d\", &a);\n\n            long long key = (long long)a * (1LL << a);\n            gpointer value = g_hash_table_lookup(map, GINT_TO_POINTER(key));\n\n            if (value != NULL) {\n                count += GPOINTER_TO_LONG(value);\n            }\n\n            g_hash_table_insert(map, GINT_TO_POINTER(key), GINT_TO_LONG(value ? GPOINTER_TO_LONG(value) + 1 : 1));\n        }\n\n        printf(\"%lld\n\", count);\n\n        g_hash_table_destroy(map);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of pairs (i, j) such that b_i^b_j = b_j^b_i. Given that b_i = 2^a_i, we can rewrite the condition as (2^a_i)^(2^a_j) = (2^a_j)^(2^a_i), which simplifies to 2^(a_i * 2^a_j) = 2^(a_j * 2^a_i). This equation holds true if and only if a_i * 2^a_j = a_j * 2^a_i. Therefore, we need to count pairs (a_i, a_j) that satisfy this condition. To efficiently count such pairs, we can use a hash table to store the frequency of each value of a_i * 2^a_j and then count the number of pairs for each frequency.", "question_id": "1899_D"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char s[1000];\n    scanf(\"%s\", s);\n\n    int takahashi_wins = 0;\n    int aoki_wins = 0;\n    int takahashi_last_win = -1;\n    int aoki_last_win = -1;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'T') {\n            takahashi_wins++;\n            takahashi_last_win = i;\n        } else if (s[i] == 'A') {\n            aoki_wins++;\n            aoki_last_win = i;\n        }\n    }\n\n    if (takahashi_wins > aoki_wins) {\n        printf(\"T\\n\");\n    } else if (aoki_wins > takahashi_wins) {\n        printf(\"A\\n\");\n    } else {\n        if (takahashi_last_win < aoki_last_win) {\n            printf(\"T\\n\");\n        } else {\n            printf(\"A\\n\");\n        }\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of wins for both Takahashi and Aoki and determine the overall winner based on the given rules. Here's a step-by-step approach to achieve this:", "question_id": "abc301_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Read the input sequence\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    // Perform the insertion process\n    bool inserted;\n    do {\n        inserted = false;\n        for (int i = 0; i < arr->len - 1; i++) {\n            int diff = abs(g_array_index(arr, int, i) - g_array_index(arr, int, i + 1));\n            if (diff != 1) {\n                int start = (g_array_index(arr, int, i) < g_array_index(arr, int, i + 1)) ? g_array_index(arr, int, i) + 1 : g_array_index(arr, int, i + 1) - 1;\n                int end = (g_array_index(arr, int, i) < g_array_index(arr, int, i + 1)) ? g_array_index(arr, int, i + 1) - 1 : g_array_index(arr, int, i);\n                for (int j = start; j <= end; j++) {\n                    g_array_insert_val(arr, i + 1, j);\n                }\n                inserted = true;\n                break;\n            }\n        }\n    } while (inserted);\n\n    // Print the final sequence\n    for (int i = 0; i < arr->len; i++) {\n        printf(\"%d \", g_array_index(arr, int, i));\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the insertion process described. We will use a loop to repeatedly check the sequence and insert numbers between adjacent terms that do not have an absolute difference of 1. The process continues until no more insertions are needed. We will use a GArray to dynamically store the sequence and a loop to perform the insertions. After the loop, we will print the final sequence.", "question_id": "abc301_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[200001], T[200001];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int len = strlen(S);\n    GHashTable *countS = g_hash_table_new(g_str_hash, g_str_equal);\n    GHashTable *countT = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Count characters in S and T\n    for (int i = 0; i < len; i++) {\n        if (S[i] != '@') {\n            int *count = g_hash_table_lookup(countS, &S[i]);\n            if (count == NULL) {\n                g_hash_table_insert(countS, &S[i], GINT_TO_POINTER(1));\n            } else {\n                *count += 1;\n            }\n        }\n        if (T[i] != '@') {\n            int *count = g_hash_table_lookup(countT, &T[i]);\n            if (count == NULL) {\n                g_hash_table_insert(countT, &T[i], GINT_TO_POINTER(1));\n            } else {\n                *count += 1;\n            }\n        }\n    }\n\n    // Check if we can balance the counts\n    int wildcardCountS = 0;\n    int wildcardCountT = 0;\n    int mismatch = 0;\n\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, countS);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int count = GPOINTER_TO_INT(value);\n        if (count > 0) {\n            int *Tcount = g_hash_table_lookup(countT, key);\n            if (Tcount != NULL) {\n                if (*Tcount < count) {\n                    mismatch += count - *Tcount;\n                }\n            } else {\n                mismatch += count;\n            }\n        }\n    }\n\n    g_hash_table_iter_init(&iter, countT);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int count = GPOINTER_TO_INT(value);\n        if (count > 0) {\n            int *Scount = g_hash_table_lookup(countS, key);\n            if (Scount != NULL) {\n                if (*Scount < count) {\n                    mismatch += count - *Scount;\n                }\n            } else {\n                mismatch += count;\n            }\n        }\n    }\n\n    // Check if we have enough wildcards to balance the mismatch\n    for (int i = 0; i < len; i++) {\n        if (S[i] == '@') {\n            wildcardCountS++;\n        }\n        if (T[i] == '@') {\n            wildcardCountT++;\n        }\n    }\n\n    if (wildcardCountS >= mismatch && wildcardCountT >= mismatch) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(countS);\n    g_hash_table_destroy(countT);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can rearrange the cards in two rows (S and T) such that they coincide. The key observation is that we can replace '@' with any of the letters 'a', 't', 'c', 'o', 'd', 'e', or 'r'. This means we can treat '@' as a wildcard that can match any character. Therefore, we need to check if we can match the characters in S and T, considering '@' as a wildcard. We can do this by counting the occurrences of each character in both strings and ensuring that the counts are balanced in a way that allows us to replace '@' with the required characters.", "question_id": "abc301_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[61];\n    long long N;\n    scanf(\"%s %lld\", S, &N);\n\n    int len = strlen(S);\n    GArray *numbers = g_array_new(FALSE, FALSE, sizeof(long long));\n\n    void generate_numbers(char *str, int index, long long current) {\n        if (index == len) {\n            g_array_append_val(numbers, current);\n            return;\n        }\n        if (str[index] == '?') {\n            generate_numbers(str, index + 1, current * 2);\n            generate_numbers(str, index + 1, current * 2 + 1);\n        } else {\n            generate_numbers(str, index + 1, current * 2 + (str[index] - '0')));\n        }\n    }\n\n    generate_numbers(S, 0, 0);\n\n    long long result = -1;\n    for (int i = 0; i < numbers->len; i++) {\n        long long num = g_array_index(numbers, long long, i);\n        if (num <= N && num > result) {\n            result = num;\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n\n    g_array_free(numbers, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate all possible binary numbers from the given string S by replacing each '?' with either '0' or '1'. We then need to find the greatest value among these numbers that is less than or equal to N. If no such value exists, we return -1. Here's a step-by-step approach to achieve this:", "question_id": "abc301_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 301\n\n// Directions for moving up, down, left, and right\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\n// Function to check if a position is within the grid boundaries\nbool isValid(int x, int y, int H, int W) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nint main() {\n    int H, W, T;\n    scanf(\"%d %d %d\", &H, &W, &T);\n\n    char grid[MAX][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    // Find the start and goal positions\n    int startX, startY, goalX, goalY;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                startX = i;\n                startY = j;\n            } else if (grid[i][j] == 'G') {\n                goalX = i;\n                goalY = j;\n            }\n        }\n    }\n\n    // BFS to find the maximum number of candy squares that can be visited\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(startX * W + startY));\n    g_hash_table_insert(visited, GINT_TO_POINTER(startX * W + startY), GINT_TO_POINTER(0));\n\n    int maxCandies = 0;\n\n    while (!g_queue_is_empty(queue) && T > 0) {\n        int size = g_queue_get_length(queue);\n        for (int i = 0; i < size; i++) {\n            int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n            int x = current / W;\n            int y = current % W;\n\n            for (int d = 0; d < 4; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n\n                if (isValid(nx, ny, H, W) && grid[nx][ny] != '#') {\n                    int newCandies = g_hash_table_lookup(visited, GINT_TO_POINTER(nx * W + ny)) ? g_hash_table_lookup(visited, GINT_TO_POINTER(nx * W + ny)) : 0;\n\n                    if (grid[nx][ny] == 'o') {\n                        newCandies++;\n                    }\n\n                    if (newCandies > maxCandies) {\n                        maxCandies = newCandies;\n                    }\n\n                    int key = nx * W + ny;\n                    if (!g_hash_table_contains(visited, GINT_TO_POINTER(key)) || newCandies > g_hash_table_lookup(visited, GINT_TO_POINTER(key))) {\n                        g_hash_table_insert(visited, GINT_TO_POINTER(key), GINT_TO_POINTER(newCandies));\n                        g_queue_push_tail(queue, GINT_TO_POINTER(key));\n                    }\n                }\n            }\n        }\n        T--;\n    }\n\n    printf(\"%d\n\", maxCandies);\n\n    g_hash_table_destroy(visited);\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if Takahashi can reach the goal square within T moves and, if so, find the maximum number of candy squares he can visit. Here's a step-by-step approach to solve it using BFS and dynamic programming with a hash table to keep track of visited states.", "question_id": "abc301_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int first;\n    int second;\n    int third;\n    int fourth;\n} State;\n\ntypedef struct {\n    GHashTable *table;\n} Memo;\n\nint countValidStrings(const char *s, int index, int prev, Memo *memo) {\n    if (index == strlen(s)) {\n        return 1;\n    }\n\n    State key = {prev, prev, 0, 0};\n    gpointer value = g_hash_table_lookup(memo->table, &key);\n    if (value) {\n        return GPOINTER_TO_INT(value);\n    }\n\n    int count = 0;\n\n    if (s[index] == '?') {\n        for (char c = 'A'; c <= 'Z'; c++) {\n            count = (count + countValidStrings(s, index + 1, c, memo)) % MOD;\n        }\n    } else {\n        count = countValidStrings(s, index + 1, s[index], memo);\n    }\n\n    g_hash_table_insert(memo->table, &key, GINT_TO_POINTER(count));\n\n    return count;\n}\n\nint main() {\n    char s[300005];\n    scanf(\"%s\", s);\n\n    Memo memo = {g_hash_table_new(g_direct_hash, g_direct_equal)};\n\n    int result = countValidStrings(s, 0, 0, &memo);\n\n    printf(\"%d\n\", result);\n\n    g_hash_table_destroy(memo.table);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of strings that do not contain any DDoS-type string as a subsequence. A DDoS-type string is defined as a string of length 4 with the first, second, and fourth characters being uppercase English letters, and the third character being a lowercase English letter, with the first and second characters being equal. We will use dynamic programming with memoization to count the valid strings. The approach involves using a hash table to store the results of subproblems to avoid redundant calculations.", "question_id": "abc301_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint main() {\n    // Read input\n    long long A, B;\n    scanf(\"%lld %lld\", &A, &B);\n\n    // Calculate the minimum number of attacks needed\n    long long attacks = (A + B - 1) / B;\n\n    // Output the result\n    printf(\"%lld\n\", attacks);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of attacks required to reduce the enemy's stamina to 0 or less. Given that the stamina decreases by a fixed amount B with each attack, we can use integer division to calculate the number of attacks needed. However, since the stamina can become negative, we need to ensure that the result is rounded up to account for the final attack that reduces the stamina to 0 or less.", "question_id": "abc302_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define H 100\n#define W 100\n\nbool is_collinear(int x1, int y1, int x2, int y2, int x3, int y3) {\n    return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0;\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    char grid[H][W + 1];\n\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 's') {\n                for (int di = -1; di <= 1; di++) {\n                    for (int dj = -1; dj <= 1; dj++) {\n                        if (di == 0 && dj == 0) continue;\n                        int ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < H && nj >= 0 && nj < W && grid[ni][nj] == 'n') {\n                            int ni2 = ni + di, nj2 = nj + dj;\n                            if (ni2 >= 0 && ni2 < H && nj2 >= 0 && nj2 < W && grid[ni2][nj2] == 'u') {\n                                int ni3 = ni2 + di, nj3 = nj2 + dj;\n                                if (ni3 >= 0 && ni3 < H && nj3 >= 0 && nj3 < W && grid[ni3][nj3] == 'k') {\n                                    int ni4 = ni3 + di, nj4 = nj3 + dj;\n                                    if (ni4 >= 0 && ni4 < H && nj4 >= 0 && nj4 < W && grid[ni4][nj4] == 'e') {\n                                        if (is_collinear(i, j, ni, nj, ni2, nj2) &&\n                                            is_collinear(ni, nj, ni2, nj2, ni3, nj3) &&\n                                            is_collinear(ni2, nj2, ni3, nj3, ni4, nj4)) {\n                                            printf(\"%d %d\n\", i + 1, j + 1);\n                                            printf(\"%d %d\n\", ni + 1, nj + 1);\n                                            printf(\"%d %d\n\", ni2 + 1, nj2 + 1);\n                                            printf(\"%d %d\n\", ni3 + 1, nj3 + 1);\n                                            printf(\"%d %d\n\", ni4 + 1, nj4 + 1);\n                                            return 0;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"No solution found\n\");\n    return 0;\n}", "reasoning": "The problem requires finding a specific pattern of letters ('s', 'n', 'u', 'k', 'e') in a grid and printing their positions. The pattern must be contiguous either vertically, horizontally, or diagonally, and the centers of these cells must lie on a straight line. To solve this, we will iterate through the grid, checking for the presence of the pattern in all possible directions. Once found, we will verify that the centers of the cells are collinear.", "question_id": "abc302_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 8\n#define MAX_M 5\n\nbool canTransform(const char *s1, const char *s2) {\n    int diff = 0;\n    for (int i = 0; i < strlen(s1); i++) {\n        if (s1[i] != s2[i]) {\n            diff++;\n            if (diff > 1) {\n                return false;\n            }\n        }\n    }\n    return diff == 1;\n}\n\nbool dfs(const char *target, GHashTable *visited, GHashTable *graph, int *path, int pathLength) {\n    if (strcmp(target, path[pathLength - 1]) == 0) {\n        return true;\n    }\n\n    GList *neighbors = g_hash_table_lookup(graph, (gpointer)target);\n    if (neighbors) {\n        GList *node = neighbors;\n        while (node) {\n            const char *neighbor = (const char *)node->data;\n            if (!g_hash_table_contains(visited, (gpointer)neighbor)) {\n                g_hash_table_insert(visited, (gpointer)neighbor, (gpointer)true);\n                path[pathLength] = neighbor;\n                if (dfs(neighbor, visited, graph, path, pathLength + 1)) {\n                    return true;\n                }\n                g_hash_table_remove(visited, (gpointer)neighbor);\n            }\n            node = node->next;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashTable *graph = g_hash_table_new(g_str_hash, g_str_equal);\n    char **strings = (char **)malloc(N * sizeof(char *));\n\n    for (int i = 0; i < N; i++) {\n        strings[i] = (char *)malloc((M + 1) * sizeof(char));\n        scanf(\"%s\", strings[i]);\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i != j && canTransform(strings[i], strings[j])) {\n                g_hash_table_insert(graph, (gpointer)strings[i], (gpointer)strings[j]);\n                g_hash_table_insert(graph, (gpointer)strings[j], (gpointer)strings[i]);\n            }\n        }\n    }\n\n    char *path[N];\n    bool found = false;\n\n    for (int i = 0; i < N; i++) {\n        GHashTable *visited = g_hash_table_new(g_str_hash, g_str_equal);\n        path[0] = strings[i];\n        if (dfs(strings[i], visited, graph, path, 1)) {\n            found = true;\n            break;\n        }\n        g_hash_table_destroy(visited);\n    }\n\n    if (found) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    for (int i = 0; i < N; i++) {\n        free(strings[i]);\n    }\n    free(strings);\n    g_hash_table_destroy(graph);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can rearrange the given strings such that each string can be transformed into the next string by changing exactly one character. This involves checking if there exists a sequence of transformations that can connect all strings in the given list. We can approach this problem using a graph traversal technique, specifically Depth-First Search (DFS), to explore all possible rearrangements and check if a valid sequence exists.", "question_id": "abc302_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m, d;\n    scanf(\"%d %d %d\", &n, &m, &d);\n\n    GArray *aoki = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(aoki, value);\n    }\n\n    GArray *snuke = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < m; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(snuke, value);\n    }\n\n    g_array_sort(aoki, compare);\n    g_array_sort(snuke, compare);\n\n    int max_sum = -1;\n    int i = 0, j = 0;\n\n    while (i < n && j < m) {\n        if (g_array_index(aoki, int, i) + d >= g_array_index(snuke, int, j)) {\n            max_sum = g_array_index(aoki, int, i) + g_array_index(snuke, int, j);\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    printf(\"%d\n\", max_sum);\n\n    g_array_free(aoki, TRUE);\n    g_array_free(snuke, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum sum of values of two gifts, one for Aoki and one for Snuke, such that the difference in their values is at most D. Here's a step-by-step approach to achieve this:", "question_id": "abc302_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MAX_N 300005\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize data structures\n    GHashTable *graph = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GQueue *queue = g_queue_new();\n    int *degree = (int *)calloc(N + 1, sizeof(int));\n\n    // Initialize the queue with all vertices\n    for (int i = 1; i <= N; i++) {\n        g_queue_push_tail(queue, GINT_TO_POINTER(i));\n    }\n\n    for (int i = 0; i < Q; i++) {\n        int type, u, v;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            scanf(\"%d %d\", &u, &v);\n            // Add edge between u and v\n            if (!g_hash_table_contains(graph, GINT_TO_POINTER(u))) {\n                g_hash_table_insert(graph, GINT_TO_POINTER(u), g_array_new(FALSE, FALSE, sizeof(int)));\n            }\n            if (!g_hash_table_contains(graph, GINT_TO_POINTER(v))) {\n                g_hash_table_insert(graph, GINT_TO_POINTER(v), g_array_new(FALSE, FALSE, sizeof(int)));\n            }\n            g_array_append_val(g_hash_table_lookup(graph, GINT_TO_POINTER(u)), v);\n            g_array_append_val(g_hash_table_lookup(graph, GINT_TO_POINTER(v)), u);\n\n            // Update degrees\n            degree[u]++;\n            degree[v]++;\n\n            // If either vertex was previously disconnected, remove it from the queue\n            if (degree[u] == 1) {\n                g_queue_remove(queue, GINT_TO_POINTER(u));\n            }\n            if (degree[v] == 1) {\n                g_queue_remove(queue, GINT_TO_POINTER(v));\n            }\n        } else if (type == 2) {\n            scanf(\"%d\", &v);\n            // Remove all edges connected to v\n            if (g_hash_table_contains(graph, GINT_TO_POINTER(v))) {\n                GArray *neighbors = g_hash_table_lookup(graph, GINT_TO_POINTER(v));\n                for (int j = 0; j < neighbors->len; j++) {\n                    int neighbor = g_array_index(neighbors, int, j);\n                    g_array_remove_range(g_hash_table_lookup(graph, GINT_TO_POINTER(neighbor)), j, 1);\n                    degree[neighbor]--;\n                    if (degree[neighbor] == 1) {\n                        g_queue_push_tail(queue, GINT_TO_POINTER(neighbor));\n                    }\n                    j--;\n                }\n                g_hash_table_remove(graph, GINT_TO_POINTER(v));\n                degree[v] = 0;\n            }\n        }\n\n        // Print the number of disconnected vertices\n        printf(\"%d\\n\", g_queue_get_length(queue));\n    }\n\n    // Clean up\n    g_hash_table_destroy(graph);\n    g_queue_free(queue);\n    free(degree);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently handle two types of queries on an undirected graph: adding an edge and removing all edges connected to a vertex. We will use a combination of a hash table to keep track of the connections and a queue to efficiently manage the vertices that are not connected to any other vertices. Here's the step-by-step approach:", "question_id": "abc302_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Create a hash table to keep track of sets containing 1 and M\n    GHashTable *sets_with_1 = g_hash_table_new(g_int_hash, g_int_equal);\n    GHashTable *sets_with_m = g_hash_table_new(g_int_hash, g_int_equal);\n\n    // Read the sets and update the hash tables\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        int *set = (int *)malloc(a * sizeof(int));\n        for (int j = 0; j < a; j++) {\n            scanf(\"%d\", &set[j]);\n            if (set[j] == 1) {\n                g_hash_table_insert(sets_with_1, set, set);\n            }\n            if (set[j] == m) {\n                g_hash_table_insert(sets_with_m, set, set);\n            }\n        }\n        // Free the allocated memory for the set\n        free(set);\n    }\n\n    // Check if both 1 and M are already in the same set\n    if (g_hash_table_lookup(sets_with_1, g_hash_table_lookup(sets_with_m, NULL)) != NULL) {\n        printf(\"0\n\");\n        g_hash_table_destroy(sets_with_1);\n        g_hash_table_destroy(sets_with_m);\n        return 0;\n    }\n\n    // Initialize the minimum operations counter\n    int min_operations = -1;\n\n    // Try merging sets with 1 and sets with M\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, sets_with_1);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        g_hash_table_iter_init(&iter, sets_with_m);\n        while (g_hash_table_iter_next(&iter, &key, &value)) {\n            int *set1 = (int *)key;\n            int *set2 = (int *)value;\n\n            // Check if there is a common element between set1 and set2\n            for (int i = 0; i < a; i++) {\n                for (int j = 0; j < a; j++) {\n                    if (set1[i] == set2[j]) {\n                        // Merge set1 and set2\n                        int *merged_set = (int *)malloc((a + a) * sizeof(int));\n                        int merged_size = 0;\n                        for (int k = 0; k < a; k++) {\n                            merged_set[merged_size++] = set1[k];\n                        }\n                        for (int k = 0; k < a; k++) {\n                            merged_set[merged_size++] = set2[k];\n                        }\n\n                        // Check if the merged set contains both 1 and M\n                        bool contains_1 = false;\n                        bool contains_m = false;\n                        for (int k = 0; k < merged_size; k++) {\n                            if (merged_set[k] == 1) {\n                                contains_1 = true;\n                            }\n                            if (merged_set[k] == m) {\n                                contains_m = true;\n                            }\n                        }\n\n                        if (contains_1 && contains_m) {\n                            // Update the minimum operations counter\n                            if (min_operations == -1 || min_operations > 1) {\n                                min_operations = 1;\n                            }\n                        }\n\n                        // Free the allocated memory for the merged set\n                        free(merged_set);\n                    }\n                }\n            }\n        }\n    }\n\n    // Print the result\n    printf(\"%d\n\", min_operations);\n\n    // Clean up\n    g_hash_table_destroy(sets_with_1);\n    g_hash_table_destroy(sets_with_m);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if it's possible to obtain a set containing both 1 and M by repeatedly merging sets that have at least one common element. If it is possible, we need to find the minimum number of operations required to achieve this. Here's a step-by-step approach to solve the problem:", "question_id": "abc302_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[101], t[101];\n    scanf(\"%s\", s);\n    scanf(\"%s\", t);\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] != t[i] && !(s[i] == '1' && t[i] == 'l') && !(s[i] == 'l' && t[i] == '1') && !(s[i] == '0' && t[i] == 'o') && !(s[i] == 'o' && t[i] == '0')) {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\\n\");\n\n    return 0;\n}", "reasoning": "To determine if two strings S and T are similar, we need to iterate through each character of the strings and check if the corresponding characters are similar according to the given rules. The rules state that two characters are similar if they are the same, or if one is '1' and the other is 'l', or if one is '0' and the other is 'o'. We will use a loop to compare each pair of characters and return 'No' if any pair does not satisfy the similarity condition. If all pairs are similar, we return 'Yes'.", "question_id": "abc303_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Create a 2D array to store the positions of each person in each photo\n    int **positions = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        positions[i] = (int *)malloc(M * sizeof(int));\n    }\n\n    // Populate the positions array\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &positions[j][i]);\n        }\n    }\n\n    // Initialize a hash table to keep track of pairs of people who have been next to each other\n    GHashTable *next_to_each_other = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Check each photo for pairs of people who have been next to each other\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N - 1; j++) {\n            int person1 = positions[j][i];\n            int person2 = positions[j + 1][i];\n            GList *key = g_list_prepend(NULL, GINT_TO_POINTER(person1));\n            key = g_list_prepend(key, GINT_TO_POINTER(person2));\n            g_hash_table_insert(next_to_each_other, key, GINT_TO_POINTER(1));\n        }\n    }\n\n    // Count the number of pairs of people who did not stand next to each other\n    int count = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            GList *key = g_list_prepend(NULL, GINT_TO_POINTER(i));\n            key = g_list_prepend(key, GINT_TO_POINTER(j));\n            if (!g_hash_table_lookup_extended(next_to_each_other, key, NULL, NULL)) {\n                count++;\n            }\n            g_list_free(key);\n        }\n    }\n\n    // Print the result\n    printf(\"%d\n\", count);\n\n    // Free memory\n    for (int i = 0; i < N; i++) {\n        free(positions[i]);\n    }\n    free(positions);\n    g_hash_table_destroy(next_to_each_other);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine how many pairs of people did not stand next to each other in any of the photos. Here's a step-by-step approach to achieve this:", "question_id": "abc303_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M, H, K;\n    scanf(\"%d %d %d %d\", &N, &M, &H, &K);\n\n    char S[N + 1];\n    scanf(\"%s\", S);\n\n    GHashTable *items = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < M; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        g_hash_table_insert(items, GINT_TO_POINTER(x * 200001 + y), GINT_TO_POINTER(K));\n    }\n\n    int x = 0, y = 0;\n    for (int i = 0; i < N; i++) {\n        H--;\n        if (H < 0) {\n            printf(\"No\\n\");\n            g_hash_table_destroy(items);\n            return 0;\n        }\n\n        if (S[i] == 'R') x++;\n        else if (S[i] == 'L') x--;\n        else if (S[i] == 'U') y++;\n        else if (S[i] == 'D') y--;\n\n        int key = x * 200001 + y;\n        if (g_hash_table_contains(items, GINT_TO_POINTER(key))) {\n            H = K;\n            g_hash_table_remove(items, GINT_TO_POINTER(key));\n        }\n    }\n\n    printf(\"Yes\\n\");\n\n    g_hash_table_destroy(items);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate Takahashi's movements on the plane and keep track of his health. We will use a hash table to store the health recovery items and their positions. We will iterate through each move, update Takahashi's position and health, and check if he consumes a health recovery item. If at any point his health becomes negative, we will stop and print 'No'. If he completes all moves without collapsing, we will print 'Yes'.", "question_id": "abc303_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int X, Y, Z;\n    scanf(\"%d %d %d\", &X, &Y, &Z);\n\n    char S[300001];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n    int time = 0;\n    bool caps_lock = false;\n\n    for (int i = 0; i < n; i++) {\n        if (S[i] == 'A') {\n            if (caps_lock) {\n                time += X;\n            } else {\n                time += Y;\n            }\n        } else {\n            if (caps_lock) {\n                time += Y;\n            } else {\n                time += X;\n            }\n        }\n\n        if (S[i] == 'A' || S[i] == 'a') {\n            if (i + 1 < n && (S[i + 1] == 'A' || S[i + 1] == 'a')) {\n                time += Z;\n                caps_lock = !caps_lock;\n                i++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", time);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum time required to type a given string using the three available keys: 'a', Shift key, and Caps Lock key. The key observation is that pressing the Caps Lock key changes the case of the subsequent 'a' key presses. Therefore, we can use a greedy approach to minimize the total time by keeping track of the current case and the time taken to type the string.", "question_id": "abc303_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Create adjacency list for the graph\n    GHashTable *adj = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        g_hash_table_insert(adj, GINT_TO_POINTER(i), g_array_new(FALSE, FALSE, sizeof(int)));\n    }\n\n    // Read edges and build the adjacency list\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        GArray *list_u = (GArray *)g_hash_table_lookup(adj, GINT_TO_POINTER(u));\n        g_array_append_val(list_u, v);\n        GArray *list_v = (GArray *)g_hash_table_lookup(adj, GINT_TO_POINTER(v));\n        g_array_append_val(list_v, u);\n    }\n\n    // Function to check if a node is a leaf\n    bool is_leaf(GHashTable *adj, int node) {\n        GArray *list = (GArray *)g_hash_table_lookup(adj, GINT_TO_POINTER(node));\n        return g_array_get_length(list) == 1;\n    }\n\n    // Function to find the level of a star\n    int find_star_level(GHashTable *adj, int root) {\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(root));\n        int level = 0;\n        while (!g_queue_is_empty(queue)) {\n            int size = g_queue_get_length(queue);\n            for (int i = 0; i < size; i++) {\n                int node = GPOINTER_TO_INT(g_queue_pop_head(queue));\n                GArray *list = (GArray *)g_hash_table_lookup(adj, GINT_TO_POINTER(node));\n                for (int j = 0; j < g_array_get_length(list); j++) {\n                    int neighbor = g_array_index(list, int, j);\n                    if (is_leaf(adj, neighbor)) {\n                        g_queue_push_tail(queue, GINT_TO_POINTER(neighbor));\n                    }\n                }\n            }\n            level++;\n        }\n        return level;\n    }\n\n    // Find all leaves and determine the stars\n    GArray *leaves = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        if (is_leaf(adj, i)) {\n            g_array_append_val(leaves, i);\n        }\n    }\n\n    // Determine the number of stars and their levels\n    GHashTable *stars = g_hash_table_new(g_direct_hash, g_direct_equal);\n    while (g_array_get_length(leaves) > 0) {\n        int root = g_array_index(leaves, int, 0);\n        g_array_remove_index(leaves, 0);\n        int level = find_star_level(adj, root);\n        g_hash_table_insert(stars, GINT_TO_POINTER(level), GINT_TO_POINTER(1));\n    }\n\n    // Print the levels of the stars sorted in ascending order\n    GList *keys = g_hash_table_get_keys(stars);\n    keys = g_list_sort(keys, (GCompareFunc)g_int_compare);\n    for (GList *key = keys; key != NULL; key = key->next) {\n        int level = GPOINTER_TO_INT(key->data);\n        int count = GPOINTER_TO_INT(g_hash_table_lookup(stars, key->data));\n        for (int i = 0; i < count; i++) {\n            printf(\"%d \", level);\n        }\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_hash_table_destroy(adj);\n    g_hash_table_destroy(stars);\n    g_list_free(keys);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to understand the structure of the graph and how it evolves from a collection of stars to a tree. The key observation is that each edge added in the procedure connects two vertices that are leaves (degree 1), and this process continues until all vertices are connected. The goal is to determine the initial number and levels of stars that form the tree T.", "question_id": "abc303_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_NAME_LENGTH 11\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int age;\n} Person;\n\n// Comparison function for qsort to sort by age\nint compare_by_age(const void *a, const void *b) {\n    Person *personA = (Person *)a;\n    Person *personB = (Person *)b;\n    return personA->age - personB->age;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create an array of Person structures\n    Person people[n];\n\n    // Read input and store in the array\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s %d\", people[i].name, &people[i].age);\n    }\n\n    // Sort the array by age using qsort\n    qsort(people, n, sizeof(Person), compare_by_age);\n\n    // Find the index of the youngest person\n    int youngest_index = 0;\n    for (int i = 1; i < n; i++) {\n        if (people[i].age < people[youngest_index].age) {\n            youngest_index = i;\n        }\n    }\n\n    // Print the names in clockwise order starting from the youngest person\n    for (int i = 0; i < n; i++) {\n        int index = (youngest_index + i) % n;\n        printf(\"%s\n\", people[index].name);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the seating order of N people around a round table based on their ages. The youngest person should be identified first, and then we need to print the names of all people in the clockwise order starting from the youngest person. Here's a step-by-step approach to achieve this:", "question_id": "abc304_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    if (n <= 999) {\n        printf(\"%d\n\", n);\n    } else if (n <= 9999) {\n        printf(\"%d\n\", n / 10 * 10);\n    } else if (n <= 99999) {\n        printf(\"%d\n\", n / 100 * 100);\n    } else if (n <= 999999) {\n        printf(\"%d\n\", n / 1000 * 1000);\n    } else if (n <= 9999999) {\n        printf(\"%d\n\", n / 10000 * 10000);\n    } else if (n <= 99999999) {\n        printf(\"%d\n\", n / 100000 * 100000);\n    } else {\n        printf(\"%d\n\", n / 1000000 * 1000000);\n    }\n\n    return 0;\n}", "reasoning": "The problem requires approximating an integer N based on its magnitude. The approximation is achieved by truncating certain digits based on the number of digits in N. We need to determine the number of digits in N and then truncate the appropriate number of digits from the right end of N. This can be done using integer division and modulo operations.", "question_id": "abc304_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_N 2000\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n\n    double X[MAX_N], Y[MAX_N];\n\n    // Read coordinates of each person\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf\", &X[i], &Y[i]);\n    }\n\n    // Check if person 1 is infected\n    bool person1_infected = false;\n    for (int i = 0; i < N; i++) {\n        double distance = sqrt(pow(X[i] - X[0], 2) + pow(Y[i] - Y[0], 2));\n        if (distance <= D) {\n            person1_infected = true;\n            break;\n        }\n    }\n\n    // Check if each person is infected\n    for (int i = 0; i < N; i++) {\n        if (person1_infected) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if each person is infected with the virus after it has spread to people within a distance of D from person 1. Here's a step-by-step approach to achieve this:", "question_id": "abc304_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n\nint main() {\n    int W, H;\n    scanf(\"%d %d\", &W, &H);\n\n    int N;\n    scanf(\"%d\", &N);\n    int strawberries[N][2];\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &strawberries[i][0], &strawberries[i][1]);\n    }\n\n    int A;\n    scanf(\"%d\", &A);\n    int a[A];\n\n    for (int i = 0; i < A; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int B;\n    scanf(\"%d\", &B);\n    int b[B];\n\n    for (int i = 0; i < B; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    // Sort the strawberry coordinates\n    qsort(strawberries, N, sizeof(strawberries[0]), (int (*)(const void *, const void *))compare);\n\n    // Sort the cutting lines\n    qsort(a, A, sizeof(a[0]), (int (*)(const void *, const void *))compare);\n    qsort(b, B, sizeof(b[0]), (int (*)(const void *, const void *))compare);\n\n    // Initialize the minimum and maximum number of strawberries\n    int min_strawberries = INT_MAX;\n    int max_strawberries = 0;\n\n    // Iterate through all possible pieces\n    for (int i = 0; i <= A; i++) {\n        for (int j = 0; j <= B; j++) {\n            int x1 = (i == 0) ? 0 : a[i - 1];\n            int y1 = (j == 0) ? 0 : b[j - 1];\n            int x2 = (i == A) ? W : a[i];\n            int y2 = (j == B) ? H : b[j];\n\n            int count = 0;\n\n            // Count the strawberries in the current piece\n            for (int k = 0; k < N; k++) {\n                if (strawberries[k][0] > x1 && strawberries[k][0] < x2 && strawberries[k][1] > y1 && strawberries[k][1] < y2) {\n                    count++;\n                }\n            }\n\n            // Update the minimum and maximum number of strawberries\n            min_strawberries = (count < min_strawberries) ? count : min_strawberries;\n            max_strawberries = (count > max_strawberries) ? count : max_strawberries;\n        }\n    }\n\n    // Print the result\n    printf(\"%d %d\n\", min_strawberries, max_strawberries);\n\n    return 0;\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}", "reasoning": "To solve this problem, we need to determine the minimum and maximum number of strawberries that can be found in any of the resulting rectangular pieces after cutting the cake with the given lines. Here's a step-by-step approach to solve it:", "question_id": "abc304_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n#define MAXM 200005\n#define MAXQ 200005\n\nGArray *adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int u, int target) {\n    if (u == target) return;\n    visited[u] = true;\n    for (int i = 0; i < g_array_get_length(adj[u]); i++) {\n        int v = g_array_index(adj[u], int, i);\n        if (!visited[v]) {\n            dfs(v, target);\n        }\n    }\n}\n\nbool isGoodAfterAddingEdge(int u, int v, int pairs[][2], int K) {\n    visited[u] = true;\n    for (int i = 0; i < K; i++) {\n        if (pairs[i][0] == u || pairs[i][1] == u || pairs[i][0] == v || pairs[i][1] == v) {\n            dfs(pairs[i][0], pairs[i][1]);\n            if (visited[pairs[i][0]] || visited[pairs[i][1]]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M, K, Q, u, v, p, q;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 0; i < N; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        g_array_append_val(adj[u], v);\n        g_array_append_val(adj[v], u);\n    }\n\n    scanf(\"%d\", &K);\n    int pairs[K][2];\n    for (int i = 0; i < K; i++) {\n        scanf(\"%d %d\", &pairs[i][0], &pairs[i][1]);\n        pairs[i][0]--; pairs[i][1]--;\n    }\n\n    scanf(\"%d\", &Q);\n\n    for (int i = 0; i < Q; i++) {\n        scanf(\"%d %d\", &p, &q);\n        p--; q--;\n        if (isGoodAfterAddingEdge(p, q, pairs, K)) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if adding an edge between two vertices in a given graph makes the graph good. A graph is considered good if there is no path connecting any of the pairs of vertices given in the input. Here's how we can approach the problem:\n\n1. **Graph Representation**: We will use an adjacency list to represent the graph. This allows efficient addition of edges and checking for paths between vertices.\n\n2. **Path Checking**: For each question, we need to check if adding an edge between the two vertices makes the graph good. To do this, we can use Depth-First Search (DFS) to check if there is a path between the vertices in the pairs given in the input.\n\n3. **Edge Addition and Removal**: For each question, we will add the edge, check if the graph remains good, and then remove the edge to restore the original graph.\n\n4. **Efficiency**: To handle the large input size, we need to optimize our path checking and edge addition/removal operations. Using DFS for path checking is efficient, and maintaining the graph's state allows us to reuse the graph for multiple questions.", "question_id": "abc304_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Calculate the nearest water station\n    int nearest_station = ((N + 2) / 5) * 5;\n\n    // Output the result\n    printf(\"%d\n\", nearest_station);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the nearest water station to Takahashi's current position on the ultramarathon course. The water stations are located every 5 km along the course, starting from 0 km to 100 km. Given Takahashi's position N, we need to determine the nearest water station, which could be either the next or previous water station. We can achieve this by calculating the distances to the nearest water stations and comparing them.", "question_id": "abc305_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char p, q;\n    scanf(\"%c %c\", &p, &q);\n\n    // Initialize cumulative distances\n    int distances[8] = {0};  // Array to store distances from A to each point\n    distances[1] = 3;  // Distance from A to B\n    distances[2] = distances[1] + 1;  // Distance from A to C\n    distances[3] = distances[2] + 4;  // Distance from A to D\n    distances[4] = distances[3] + 1;  // Distance from A to E\n    distances[5] = distances[4] + 5;  // Distance from A to F\n    distances[6] = distances[5] + 9;  // Distance from A to G\n\n    // Calculate the distance between p and q\n    int dist_p = distances[p - 'A' + 1];\n    int dist_q = distances[q - 'A' + 1];\n    int distance = abs(dist_p - dist_q);\n\n    // Output the result\n    printf(\"%d\n\", distance);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the distance between two points on a straight line given their positions. The positions are represented by uppercase English letters A through G, and the distances between adjacent points are provided. We can use a hash table to store the cumulative distances from point A to each subsequent point. This allows us to quickly calculate the distance between any two points by subtracting the cumulative distances at those points. Here's the step-by-step approach:", "question_id": "abc305_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    char grid[H][W + 1];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '#') {\n                bool has_adjacent = false;\n                if (i > 0 && grid[i - 1][j] == '#') has_adjacent = true;\n                if (i < H - 1 && grid[i + 1][j] == '#') has_adjacent = true;\n                if (j > 0 && grid[i][j - 1] == '#') has_adjacent = true;\n                if (j < W - 1 && grid[i][j + 1] == '#') has_adjacent = true;\n\n                if (!has_adjacent) {\n                    printf(\"%d %d\n\", i + 1, j + 1);\n                    return 0;\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "reasoning": "The problem requires identifying the unique cookie that was eaten from a grid. The grid is represented by a 2D character array, where '#' indicates a cookie and '.' indicates an empty square. The key insight is that the cookie eaten must be the only one that does not have a cookie immediately above, below, to the left, or to the right of it. This is because if a cookie had a cookie adjacent to it, it would not be the only one in the rectangle defined by the initial configuration. We can iterate through the grid, checking each square to see if it is a cookie and if it has no adjacent cookies. If such a cookie is found, it is the one that was eaten.", "question_id": "abc305_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *sleep_log = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int time;\n        scanf(\"%d\", &time);\n        g_array_append_val(sleep_log, time);\n    }\n\n    qsort(sleep_log->data, sleep_log->len, sizeof(int), compare);\n\n    int q;\n    scanf(\"%d\", &q);\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n\n        int total_sleep_time = 0;\n        for (int j = 1; j < sleep_log->len; j += 2) {\n            if (l <= sleep_log->data[j] && sleep_log->data[j] <= r) {\n                total_sleep_time += sleep_log->data[j + 1] - sleep_log->data[j];\n            }\n        }\n\n        printf(\"%d\n\", total_sleep_time);\n    }\n\n    g_array_free(sleep_log, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the total sleep time for each query within the given range. The key steps are as follows:\n1. Parse the input to get the sleep log and the list of queries.\n2. Sort the sleep log to facilitate the calculation of sleep intervals.\n3. For each query, determine the sleep intervals within the specified range and calculate the total sleep time.\n4. Output the results for each query.", "question_id": "abc305_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    // Adjacency list for the graph\n    GArray *adj[MAXN];\n    for (int i = 0; i < N; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read edges\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        g_array_append_val(adj[a], b);\n        g_array_append_val(adj[b], a);\n    }\n\n    // Read guards\n    GHashTable *guards = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < K; i++) {\n        int p, h;\n        scanf(\"%d %d\", &p, &h);\n        p--;\n        g_hash_table_insert(guards, GINT_TO_POINTER(p), GINT_TO_POINTER(h));\n    }\n\n    // BFS to find guarded vertices\n    bool guarded[MAXN];\n    memset(guarded, false, sizeof(guarded));\n\n    for (int i = 0; i < K; i++) {\n        int p = GPOINTER_TO_INT(g_hash_table_lookup(guards, GINT_TO_POINTER(i)));\n        int h = GPOINTER_TO_INT(g_hash_table_lookup(guards, GINT_TO_POINTER(i)));\n\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(p));\n\n        bool visited[MAXN];\n        memset(visited, false, sizeof(visited));\n        visited[p] = true;\n\n        while (!g_queue_is_empty(queue)) {\n            int u = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n            for (int j = 0; j < g_array_get_length(adj[u]); j++) {\n                int v = g_array_index(adj[u], int, j);\n\n                if (!visited[v] && g_array_get_length(adj[u]) <= h) {\n                    visited[v] = true;\n                    guarded[v] = true;\n                    g_queue_push_tail(queue, GINT_TO_POINTER(v));\n                }\n            }\n        }\n\n        g_queue_free(queue);\n    }\n\n    // Count and print guarded vertices\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        if (guarded[i]) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    for (int i = 0; i < N; i++) {\n        if (guarded[i]) {\n            printf(\"%d \", i + 1);\n        }\n    }\n\n    printf(\"\\n\");\n\n    // Clean up\n    for (int i = 0; i < N; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n    g_hash_table_destroy(guards);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine which vertices are guarded by the security guards based on their positions and staminas. We can use a breadth-first search (BFS) approach to check the reachability of each vertex from the guards' positions within their staminas. Here's a step-by-step breakdown of the solution:", "question_id": "abc305_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[51];\n    scanf(\"%s\", s);\n\n    char result[101];\n    result[0] = '\\0';\n\n    for (int i = 0; i < n; i++) {\n        strncat(result, &s[i], 1);\n        strncat(result, &s[i], 1);\n    }\n\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to read a string S of length N from the input and then create a new string that is twice the length of S. This new string should be formed by repeating each character of S in the order they appear, but twice. For example, if S is 'beginner', the output should be 'bbeeggiinnnneerr'. This can be achieved by iterating through the string S and appending each character twice to a new string. Finally, we print the new string.", "question_id": "abc306_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char binary[65];\n    scanf(\"%64s\", binary);\n\n    long long decimal = 0;\n    for (int i = 0; i < 64; i++) {\n        if (binary[i] == '1') {\n            decimal += (1LL << (63 - i));\n        }\n    }\n\n    printf(\"%lld\\n\", decimal);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to convert a binary sequence of length 64 into its decimal equivalent. Given the constraints and the size of the input, we need an efficient approach to handle the conversion. The binary sequence can be interpreted as a sum of powers of 2, where each bit represents whether a particular power of 2 is included in the sum or not. Since the sequence is given as a string of 0s and 1s, we can iterate through the string, multiply the current power of 2 by the corresponding bit, and add the result to the total sum. This approach ensures that we correctly convert the binary sequence to its decimal equivalent without running into performance issues with large numbers.", "question_id": "abc306_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int *A = (int *)malloc(3 * N * sizeof(int));\n    for (int i = 0; i < 3 * N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GHashTable *index_map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < 3 * N; i++) {\n        int num = A[i];\n        if (g_hash_table_contains(index_map, GINT_TO_POINTER(num))) {\n            GArray *indices = g_hash_table_lookup(index_map, GINT_TO_POINTER(num));\n            g_array_append_val(indices, i);\n        } else {\n            GArray *indices = g_array_new(FALSE, FALSE, sizeof(int));\n            g_array_append_val(indices, i);\n            g_hash_table_insert(index_map, GINT_TO_POINTER(num), indices);\n        }\n    }\n\n    int *middle_indices = (int *)malloc(N * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        GArray *indices = g_hash_table_lookup(index_map, GINT_TO_POINTER(i));\n        middle_indices[i - 1] = g_array_index(indices, int, 1);\n    }\n\n    qsort(middle_indices, N, sizeof(int), compare);\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", middle_indices[i]);\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    for (int i = 1; i <= N; i++) {\n        GArray *indices = g_hash_table_lookup(index_map, GINT_TO_POINTER(i));\n        g_array_free(indices, TRUE);\n    }\n    g_hash_table_destroy(index_map);\n    free(A);\n    free(middle_indices);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to follow these steps:\n1. Read the input values for N and the sequence A.\n2. Create a hash table to store the indices of each number in the sequence A.\n3. For each number from 1 to N, find the index of its middle occurrence using the hash table.\n4. Store these indices in an array and sort the array based on the indices.\n5. Print the sorted sequence of numbers.\n6. Free all dynamically allocated memory.", "question_id": "abc306_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 300000\n\ntypedef struct {\n    int healthy;\n    int unhealthy;\n} State;\n\ntypedef struct {\n    int tastiness;\n    int type;\n} Course;\n\nGHashTable *dp;\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint solve(int index, State state, Course *courses, int N) {\n    if (index == N) {\n        return 0;\n    }\n\n    State next_state;\n    if (state.healthy) {\n        next_state.healthy = 1;\n        next_state.unhealthy = 0;\n    } else {\n        next_state.healthy = 0;\n        next_state.unhealthy = 1;\n    }\n\n    gpointer result = g_hash_table_lookup(dp, &(State){state.healthy, state.unhealthy});\n    if (result != NULL) {\n        return GPOINTER_TO_INT(result);\n    }\n\n    int eat = 0;\n    if (state.healthy && courses[index].type == 0) {\n        eat = courses[index].tastiness + solve(index + 1, next_state, courses, N);\n    } else if (state.unhealthy && courses[index].type == 1) {\n        eat = courses[index].tastiness + solve(index + 1, next_state, courses, N);\n    }\n\n    int skip = solve(index + 1, state, courses, N);\n\n    int max_tastiness = max(eat, skip);\n    g_hash_table_insert(dp, &(State){state.healthy, state.unhealthy}, GINT_TO_POINTER(max_tastiness));\n\n    return max_tastiness;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    Course courses[MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &courses[i].type, &courses[i].tastiness);\n    }\n\n    dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int result = solve(0, (State){1, 0}, courses, N);\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum possible sum of tastiness of the courses that Takahashi eats while ensuring he does not die. The key observation is that Takahashi's state (healthy or upset) determines whether he can eat a course or not. We can use dynamic programming with memoization to keep track of the maximum tastiness Takahashi can achieve at each step, considering both eating and skipping each course.", "question_id": "abc306_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int N, K, Q;\n    scanf(\"%d %d %d\", &N, &K, &Q);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    memset(A, 0, N * sizeof(int));\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(arr, A[i]);\n    }\n\n    for (int i = 0; i < Q; i++) {\n        int X, Y;\n        scanf(\"%d %d\", &X, &Y);\n\n        // Update the sequence\n        A[X - 1] = Y;\n        g_array_set_val(arr, X - 1, Y);\n\n        // Sort the array in descending order\n        qsort(arr->data, arr->len, sizeof(int), compare);\n\n        // Calculate the sum of the largest K elements\n        long long sum = 0;\n        for (int j = 0; j < K; j++) {\n            sum += g_array_index(arr, int, j);\n        }\n\n        // Print the result\n        printf(\"%lld\n\", sum);\n    }\n\n    // Clean up\n    free(A);\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maintain a sequence A and apply updates to it while keeping track of the sum of the largest K elements after each update. Here's a step-by-step approach to achieve this:", "question_id": "abc306_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int *steps = (int *)malloc(7 * N * sizeof(int));\n    for (int i = 0; i < 7 * N; i++) {\n        scanf(\"%d\", &steps[i]);\n    }\n\n    for (int week = 0; week < N; week++) {\n        int weekly_steps = 0;\n        for (int day = 0; day < 7; day++) {\n            weekly_steps += steps[week * 7 + day];\n        }\n        printf(\"%d \", weekly_steps);\n    }\n\n    free(steps);\n\n    return 0;\n}", "reasoning": "The problem requires calculating the total number of steps Takahashi walked each week from a given list of daily steps. Since there are 7 days in a week, we can iterate through the list of steps in chunks of 7 to calculate the weekly totals. We'll use a loop to handle each week and a running total to accumulate the steps for each week. Finally, we'll print the weekly totals separated by spaces.", "question_id": "abc307_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nbool is_palindrome(const char *str, int len) {\n    for (int i = 0, j = len - 1; i < j; i++, j--) {\n        if (str[i] != str[j]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(char *));\n\n    for (int i = 0; i < n; i++) {\n        char str[1000];\n        scanf(\"%s\", str);\n        arr = g_array_append_val(arr, strdup(str));\n    }\n\n    bool found = false;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i != j) {\n                char concatenated[2000];\n                snprintf(concatenated, sizeof(concatenated), \"%s%s\", arr->pdata[i], arr->pdata[j]);\n                if (is_palindrome(concatenated, strlen(concatenated))) {\n                    found = true;\n                    goto end;\n                }\n            }\n        }\n    }\n\nend:\n    if (found) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    for (gsize i = 0; i < arr->len; i++) {\n        free(g_array_index(arr, char *, i));\n    }\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exist two distinct strings S_i and S_j such that their concatenation forms a palindrome. We can achieve this by iterating through all possible pairs of strings and checking if their concatenation is a palindrome. To check if a string is a palindrome, we can compare characters from the start and end moving towards the center. If we find any mismatch, the string is not a palindrome. We need to ensure that the pairs (i, j) are distinct, meaning i != j.", "question_id": "abc307_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int HA, WA, HB, WB, HX, WX;\n    scanf(\"%d %d\", &HA, &WA);\n    char A[HA][WA + 1];\n    for (int i = 0; i < HA; i++) {\n        scanf(\"%s\", A[i]);\n    }\n    scanf(\"%d %d\", &HB, &WB);\n    char B[HB][WB + 1];\n    for (int i = 0; i < HB; i++) {\n        scanf(\"%s\", B[i]);\n    }\n    scanf(\"%d %d\", &HX, &WX);\n    char X[HX][WX + 1];\n    for (int i = 0; i < HX; i++) {\n        scanf(\"%s\", X[i]);\n    }\n\n    // Combine A and B\n    char combined[HA + HB][WA + WB + 1];\n    for (int i = 0; i < HA; i++) {\n        strcpy(combined[i], A[i]);\n    }\n    for (int i = 0; i < HB; i++) {\n        strcpy(combined[HA + i], B[i]);\n    }\n\n    // Check if combined contains all black squares of X\n    bool contains_all = true;\n    for (int i = 0; i < HX; i++) {\n        for (int j = 0; j < WX; j++) {\n            if (X[i][j] == '#' && combined[i][j] != '#') {\n                contains_all = false;\n                break;\n            }\n        }\n        if (!contains_all) break;\n    }\n    if (!contains_all) {\n        printf(\"No\");\n        return 0;\n    }\n\n    // Check if any HX x WX area matches X\n    for (int i = 0; i <= HA + HB - HX; i++) {\n        for (int j = 0; j <= WA + WB - WX; j++) {\n            bool matches = true;\n            for (int k = 0; k < HX; k++) {\n                for (int l = 0; l < WX; l++) {\n                    if (X[k][l] == '#' && combined[i + k][j + l] != '#') {\n                        matches = false;\n                        break;\n                    }\n                }\n                if (!matches) break;\n            }\n            if (matches) {\n                printf(\"Yes\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"No\");\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if Takahashi can create sheet X using all black squares from sheets A and B by pasting them onto an infinitely large sheet C and then cutting out an H_X x W_X area that matches sheet X. The key steps are to check if the combined area of A and B contains all black squares of X and if the cut-out area matches X. We will use a sliding window approach to check all possible positions for cutting out the area from the combined sheet A and B.", "question_id": "abc307_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    char str[n + 1];\n    scanf(\"%s\", str);\n\n    // Initialize stack\n    GQueue *stack = g_queue_new();\n\n    // Process each character in the string\n    for (int i = 0; i < n; i++) {\n        if (str[i] == '(') {\n            // Push '(' onto the stack\n            g_queue_push_tail(stack, GINT_TO_POINTER(str[i]));\n        } else if (str[i] == ')') {\n            if (!g_queue_is_empty(stack) && GPOINTER_TO_INT(g_queue_peek_tail(stack)) == '(') {\n                // Pop the matching '(' from the stack\n                g_queue_pop_tail(stack);\n            } else {\n                // If no matching '(', push ')' onto the stack\n                g_queue_push_tail(stack, GINT_TO_POINTER(str[i]));\n            }\n        } else {\n            // Push other characters onto the stack\n            g_queue_push_tail(stack, GINT_TO_POINTER(str[i]));\n        }\n    }\n\n    // Build the result string from the stack\n    char result[n + 1];\n    int index = 0;\n    while (!g_queue_is_empty(stack)) {\n        result[index++] = GPOINTER_TO_INT(g_queue_pop_tail(stack));\n    }\n    result[index] = '\\0';\n\n    // Reverse the result string to get the correct order\n    for (int i = 0; i < index / 2; i++) {\n        char temp = result[i];\n        result[i] = result[index - i - 1];\n        result[index - i - 1] = temp;\n    }\n\n    // Print the result\n    printf(\"%s\\n\", result);\n\n    // Clean up\n    g_queue_free(stack);\n\n    return 0;\n}", "reasoning": "The problem requires us to repeatedly remove contiguous substrings that start with '(' and end with ')', without any '(' or ')' in between. This process can be efficiently handled using a stack data structure. The stack will help us keep track of the characters and ensure that we only remove valid substrings. Here's a step-by-step breakdown of the solution:", "question_id": "abc307_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint dp[1000001][1000001];\n\nint countWays(int n, int m) {\n    if (dp[n][m] != -1) return dp[n][m];\n    if (n == 1) return m;\n    if (n == 2) return m * (m - 1) % MOD;\n\n    int result = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (i != j) {\n                result = (result + countWays(n - 1, m)) % MOD;\n            }\n        }\n    }\n    dp[n][m] = result;\n    return result;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    memset(dp, -1, sizeof(dp));\n\n    int result = countWays(n, m);\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of ways to distribute integers to N people standing in a circle such that no two adjacent people have the same integer. This can be approached using dynamic programming with memoization, leveraging the properties of the circle and the constraints given. Here's the step-by-step approach:\n\n1. **Define the State**: We need to keep track of the current person and the last assigned number. Since the circle is involved, we can use modulo operations to handle the circular nature.\n2. **Dynamic Programming Table**: Use a 2D DP table where `dp[i][j]` represents the number of ways to assign numbers to the first `i` people such that the `i-th` person is assigned number `j` and no two adjacent people have the same number.\n3. **Base Case**: Initialize the base case for the first person. There are `M` ways to assign the first person any number from 0 to M-1.\n4. **Transition**: For each subsequent person, calculate the number of ways to assign them a number different from the previous person's number. Sum up the results for all valid assignments.\n5. **Modulo Operation**: Since the result can be large, take modulo 998244353 at each step to prevent overflow.\n6. **Circular Adjustment**: Since the people are standing in a circle, we need to ensure that the first and last person do not have the same number. Adjust the final result accordingly.", "question_id": "abc307_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int numbers[8];\n\n    // Read input\n    for (int i = 0; i < 8; i++) {\n        scanf(\"%d\", &numbers[i]);\n    }\n\n    // Check the conditions\n    bool isMonotonic = true;\n    bool inRange = true;\n    bool isMultipleOf25 = true;\n\n    for (int i = 1; i < 8; i++) {\n        if (numbers[i] < numbers[i - 1]) {\n            isMonotonic = false;\n        }\n        if (numbers[i] < 100 || numbers[i] > 675) {\n            inRange = false;\n        }\n        if (numbers[i] % 25 != 0) {\n            isMultipleOf25 = false;\n        }\n    }\n\n    // Print the result\n    if (isMonotonic && inRange && isMultipleOf25) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to check three conditions for a given sequence of eight integers. We will read the integers from standard input, then check each of the three conditions sequentially. If all conditions are satisfied, we print 'Yes'; otherwise, we print 'No'. The conditions are:\n1. The sequence is monotonically non-decreasing.\n2. Each integer is between 100 and 675, inclusive.\n3. Each integer is a multiple of 25.", "question_id": "abc308_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Read the colors of the plates Takahashi ate\n    char *C[N];\n    for (int i = 0; i < N; i++) {\n        C[i] = (char *)malloc(21 * sizeof(char));\n        scanf(\" %s\", C[i]);\n    }\n\n    // Read the distinct colors and their corresponding prices\n    char *D[M];\n    int *P = (int *)malloc((M + 1) * sizeof(int));\n    for (int i = 0; i < M; i++) {\n        D[i] = (char *)malloc(21 * sizeof(char));\n        scanf(\" %s\", D[i]);\n        scanf(\" %d\", &P[i]);\n    }\n\n    // Initialize the price for unknown colors\n    P[0] = 0;\n\n    // Create a hash table to store the prices of each color\n    GHashTable *price_map = g_hash_table_new(g_str_hash, g_str_equal);\n    for (int i = 0; i <= M; i++) {\n        g_hash_table_insert(price_map, D[i], GINT_TO_POINTER(P[i]));\n    }\n\n    // Calculate the total price\n    int total_price = 0;\n    for (int i = 0; i < N; i++) {\n        char *color = C[i];\n        gpointer price_ptr = g_hash_table_lookup(price_map, color);\n        if (price_ptr != NULL) {\n            int price = GPOINTER_TO_INT(price_ptr);\n            total_price += price;\n        }\n    }\n\n    // Output the total price\n    printf(\"%d\n\", total_price);\n\n    // Free allocated memory\n    for (int i = 0; i < N; i++) {\n        free(C[i]);\n    }\n    for (int i = 0; i < M; i++) {\n        free(D[i]);\n    }\n    free(P);\n    g_hash_table_destroy(price_map);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the total price of the sushi plates Takahashi ate based on their colors and the given prices. Here's a step-by-step approach to achieve this:", "question_id": "abc308_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\ntypedef struct {\n    int person;\n    double success_rate;\n} Person;\n\nint compare(const void *a, const void *b) {\n    Person *p1 = (Person *)a;\n    Person *p2 = (Person *)b;\n    if (p1->success_rate != p2->success_rate) {\n        return p2->success_rate > p1->success_rate ? 1 : -1;\n    } else {\n        return p1->person - p2->person;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Person people[n];\n    for (int i = 0; i < n; i++) {\n        people[i].person = i + 1;\n        scanf(\"%d %d\", &people[i].success_rate, &people[i].success_rate);\n        people[i].success_rate = (double)people[i].success_rate / (people[i].success_rate + people[i].success_rate);\n    }\n\n    qsort(people, n, sizeof(Person), compare);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", people[i].person);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the success rate for each person and then sort them based on the success rate in descending order. If two people have the same success rate, we should sort them based on their assigned numbers in ascending order. We can use a custom comparison function for sorting and store the person's number along with their success rate in a structure. This way, we can sort the structure based on the success rate and person's number.", "question_id": "abc308_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define H_MAX 500\n#define W_MAX 500\n\ntypedef struct {\n    int x, y;\n} Point;\n\nbool is_valid(int x, int y, int H, int W) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nbool dfs(int H, int W, char grid[H_MAX][W_MAX], Point current, int sequence_index, GHashTable *visited) {\n    if (sequence_index >= 5) {\n        sequence_index %= 5;\n    }\n\n    char expected_char = \"sneku\"[sequence_index];\n    if (grid[current.x][current.y] != expected_char) {\n        return false;\n    }\n\n    if (current.x == H - 1 && current.y == W - 1) {\n        return true;\n    }\n\n    Point directions[4] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for (int i = 0; i < 4; i++) {\n        Point next = {current.x + directions[i].x, current.y + directions[i].y};\n        if (is_valid(next.x, next.y, H, W) && !g_hash_table_contains(visited, &next)) {\n            g_hash_table_insert(visited, &next, GINT_TO_POINTER(1));\n            if (dfs(H, W, grid, next, sequence_index + 1, visited)) {\n                return true;\n            }\n            g_hash_table_remove(visited, &next);\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    char grid[H_MAX][W_MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    Point start = {0, 0};\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n    g_hash_table_insert(visited, &start, GINT_TO_POINTER(1));\n\n    if (dfs(H, W, grid, start, 0, visited)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exists a path from the top-left corner (1,1) to the bottom-right corner (H,W) in a grid such that the sequence of characters visited matches the sequence 's -> n -> u -> k -> e -> s -> n -> ...'. This involves checking if we can traverse the grid in such a way that each cell's character matches the expected character in the sequence, and we can only move to adjacent cells (sharing a side). We can use Depth-First Search (DFS) to explore all possible paths and check if any of them satisfy the conditions.", "question_id": "abc308_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int A[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    char S[MAXN];\n    scanf(\"%s\", S);\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int result = 0;\n\n    for (int i = 0; i < N - 2; i++) {\n        if (S[i] == 'M' && S[i + 1] == 'E' && S[i + 2] == 'X') {\n            int mex = 0;\n            bool found[3] = {false, false, false};\n\n            for (int j = i; j <= i + 2; j++) {\n                if (A[j] == 0) {\n                    found[0] = true;\n                } else if (A[j] == 1) {\n                    found[1] = true;\n                } else if (A[j] == 2) {\n                    found[2] = true;\n                }\n            }\n\n            for (int j = 0; j < 3; j++) {\n                if (!found[j]) {\n                    mex = j;\n                    break;\n                }\n            }\n\n            result += mex;\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the sum of the minimum excluded values (mex) for all valid triplets (i, j, k) such that the corresponding substring in string S is 'MEX'. The mex of three numbers is the smallest non-negative integer not present among them. We will use a combination of hash tables and dynamic programming to efficiently compute the required values.", "question_id": "abc308_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare_int(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *prices = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &prices[i]);\n    }\n\n    int *min_prices = (int *)malloc(m * sizeof(int));\n    int *discounts = (int *)malloc(m * sizeof(int));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &min_prices[i], &discounts[i]);\n    }\n\n    qsort(prices, n, sizeof(int), compare_int);\n    qsort(min_prices, m, sizeof(int), compare_int);\n    qsort(discounts, m, sizeof(int), compare_int);\n\n    int total_cost = 0;\n    int coupon_index = m - 1;\n\n    for (int i = 0; i < n; i++) {\n        while (coupon_index >= 0 && min_prices[coupon_index] > prices[i]) {\n            coupon_index--;\n        }\n\n        if (coupon_index >= 0 && prices[i] >= min_prices[coupon_index]) {\n            total_cost += prices[i] - discounts[coupon_index];\n            coupon_index--;\n        } else {\n            total_cost += prices[i];\n        }\n    }\n\n    printf(\"%d\\n\", total_cost);\n\n    free(prices);\n    free(min_prices);\n    free(discounts);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to minimize the total cost of buying N items using M coupons. The key is to use the coupons optimally. Here's a step-by-step approach to solve the problem:\n\n1. **Input Reading**: Read the number of items (N) and coupons (M). Then, read the regular prices of the items and the details of the coupons (minimum price and discount).\n\n2. **Sorting**: Sort the items based on their regular prices in ascending order. This helps in considering the cheapest items first.\n\n3. **Sorting Coupons**: Sort the coupons based on the discount in descending order. This helps in using the most effective coupons first.\n\n4. **Greedy Approach**: Use a greedy algorithm to assign coupons to items. Iterate through the sorted items and try to use the most effective coupon that can be used for the current item. If no suitable coupon is found, buy the item at its regular price.\n\n5. **Result Calculation**: Calculate the total cost by summing up the prices after applying the coupons (if used).\n\n6. **Output**: Print the total cost.", "question_id": "abc308_f"}
{"solution": "#include <stdio.h>\n\nint main() {\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n\n    // Determine the row of A and B\n    int rowA = (A - 1) / 3;\n    int rowB = (B - 1) / 3;\n\n    // Check if A and B are in the same row and adjacent horizontally\n    if (rowA == rowB && abs(A - B) == 1) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine if two squares with integers A and B are adjacent horizontally on a 3x3 board, we need to consider the positions of A and B on the board. The board can be visualized as follows, where each number represents its position on the board:\n\n1 2 3\n4 5 6\n7 8 9\n\nFor A and B to be adjacent horizontally, they must be in the same row and their positions must differ by exactly 1. We can achieve this by checking the following conditions:\n1. Both A and B must be in the same row.\n2. The absolute difference between A and B must be 1.\n\nWe can use the modulo operation to determine the row of each number and then check the conditions.", "question_id": "abc309_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Read the grid into a 2D array\n    char grid[n][n + 1];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    // Initialize variables to store the outer squares\n    GQueue *top = g_queue_new();\n    GQueue *bottom = g_queue_new();\n    GQueue *left = g_queue_new();\n    GQueue *right = g_queue_new();\n\n    // Extract the outer squares\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || i == n - 1) {\n            for (int j = 0; j < n; j++) {\n                g_queue_push_tail(top, GINT_TO_POINTER(grid[i][j] - '0'));\n                g_queue_push_tail(bottom, GINT_TO_POINTER(grid[n - 1 - i][j] - '0'));\n            }\n        } else {\n            g_queue_push_tail(left, GINT_TO_POINTER(grid[i][0] - '0'));\n            g_queue_push_tail(right, GINT_TO_POINTER(grid[i][n - 1] - '0'));\n        }\n    }\n\n    // Shift the outer squares clockwise by one position\n    GQueue *temp = g_queue_new();\n    g_queue_push_tail(temp, g_queue_pop_head(top));\n    g_queue_free(top);\n    top = temp;\n\n    temp = g_queue_new();\n    g_queue_push_tail(temp, g_queue_pop_head(right));\n    g_queue_free(right);\n    right = temp;\n\n    temp = g_queue_new();\n    g_queue_push_tail(temp, g_queue_pop_head(bottom));\n    g_queue_free(bottom);\n    bottom = temp;\n\n    temp = g_queue_new();\n    g_queue_push_tail(temp, g_queue_pop_head(left));\n    g_queue_free(left);\n    left = temp;\n\n    // Update the grid with the shifted outer squares\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || i == n - 1) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = '0' + g_queue_pop_head(top);\n                grid[n - 1 - i][j] = '0' + g_queue_pop_head(bottom);\n            }\n        } else {\n            grid[i][0] = '0' + g_queue_pop_head(left);\n            grid[i][n - 1] = '0' + g_queue_pop_head(right);\n        }\n    }\n\n    // Print the resulting grid\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\n\", grid[i]);\n    }\n\n    // Free the queues\n    g_queue_free(top);\n    g_queue_free(bottom);\n    g_queue_free(left);\n    g_queue_free(right);\n    g_queue_free(temp);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to shift the outer squares of a given N x N grid clockwise by one position. Here's a step-by-step approach to achieve this:", "question_id": "abc309_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    int days[N], pills[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &days[i], &pills[i]);\n    }\n\n    int current_day = 0;\n    int total_pills = 0;\n\n    while (total_pills <= K) {\n        current_day++;\n        for (int i = 0; i < N; i++) {\n            if (current_day % days[i] == 1) {\n                total_pills += pills[i];\n            }\n        }\n    }\n\n    printf(\"%d\n\", current_day);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the first day on which the total number of pills Takahashi has to take is less than or equal to K. We can achieve this by iterating through each day and calculating the total number of pills taken until the condition is met. Here's a step-by-step breakdown of the approach:\n\n1. Parse the input values to get the number of medicines (N), the threshold (K), and the list of medicines with their respective days and pill counts.\n2. Initialize a variable to keep track of the current day and the total number of pills taken.\n3. Iterate through each medicine and add its pill count to the total for the corresponding day.\n4. Check if the total number of pills taken is less than or equal to K. If it is, return the current day.\n5. If the end of the list is reached without finding a day that meets the condition, return -1 (though the problem guarantees a solution, this step is included for completeness).", "question_id": "abc309_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N1, N2, M;\n    scanf(\"%d %d %d\", &N1, &N2, &M);\n\n    GHashTable *graph[N1 + N2 + 1];\n    for (int i = 0; i <= N1 + N2; i++) {\n        graph[i] = g_hash_table_new(g_direct_hash, g_direct_equal);\n    }\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        g_hash_table_insert(graph[a], GINT_TO_POINTER(b), NULL);\n        g_hash_table_insert(graph[b], GINT_TO_POINTER(a), NULL);\n    }\n\n    int max_dist = 0;\n    for (int i = 1; i <= N1; i++) {\n        for (int j = N1 + 1; j <= N1 + N2; j++) {\n            if (g_hash_table_lookup(graph[i], GINT_TO_POINTER(j)) == NULL) {\n                int dist = 0;\n                GQueue *queue = g_queue_new();\n                GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n                g_queue_push_tail(queue, GINT_TO_POINTER(i));\n                g_hash_table_insert(visited, GINT_TO_POINTER(i), NULL);\n\n                while (!g_queue_is_empty(queue)) {\n                    int node = GPOINTER_TO_INT(g_queue_pop_head(queue));\n                    if (node == j) {\n                        dist = 1;\n                        break;\n                    }\n                    GHashTable *neighbors = graph[node];\n                    GHashTableIter iter;\n                    gpointer key;\n                    g_hash_table_iter_init(&iter, neighbors);\n                    while (g_hash_table_iter_next(&iter, &key, NULL)) {\n                        int neighbor = GPOINTER_TO_INT(key);\n                        if (g_hash_table_lookup(visited, GINT_TO_POINTER(neighbor)) == NULL) {\n                            g_queue_push_tail(queue, GINT_TO_POINTER(neighbor));\n                            g_hash_table_insert(visited, GINT_TO_POINTER(neighbor), NULL);\n                        }\n                    }\n                }\n\n                g_queue_free(queue);\n                g_hash_table_destroy(visited);\n                max_dist = (dist > max_dist) ? dist : max_dist;\n            }\n        }\n    }\n\n    printf(\"%d\n\", max_dist);\n\n    for (int i = 0; i <= N1 + N2; i++) {\n        g_hash_table_destroy(graph[i]);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum possible path length between vertex 1 and vertex (N_1+N_2) after adding a single edge between a vertex in the first set (1 to N_1) and a vertex in the second set (N_1+1 to N_1+N_2). The key insight is that the maximum path length will be achieved by adding an edge between a vertex in the first set that is farthest from vertex 1 and a vertex in the second set that is farthest from vertex (N_1+N_2). This is because the path length is determined by the longest path from vertex 1 to the added edge and from the added edge to vertex (N_1+N_2). By choosing the farthest vertices, we ensure the longest possible path.", "question_id": "abc309_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Read parent information\n    int *parents = (int *)malloc(n * sizeof(int));\n    for (int i = 1; i < n; i++) {\n        scanf(\"%d\", &parents[i]);\n    }\n\n    // Read insurance policies\n    GArray *insurance = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        g_array_append_val(insurance, x);\n        g_array_append_val(insurance, y);\n    }\n\n    // Initialize coverage array\n    bool *covered = (bool *)calloc(n + 1, sizeof(bool));\n\n    // Process each insurance policy\n    for (int i = 0; i < m * 2; i += 2) {\n        int x = g_array_index(insurance, int, i);\n        int y = g_array_index(insurance, int, i + 1);\n\n        // Traverse the family tree to mark descendants as covered\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(x));\n\n        while (!g_queue_is_empty(queue)) {\n            int person = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n            if (!covered[person]) {\n                covered[person] = true;\n\n                // Add descendants to the queue\n                for (int i = 0; i < n; i++) {\n                    if (parents[i] == person) {\n                        g_queue_push_tail(queue, GINT_TO_POINTER(i + 1));\n                    }\n                }\n\n                // Add current person's descendants up to y generations\n                for (int j = 1; j <= y; j++) {\n                    GQueue *temp_queue = g_queue_new();\n                    while (!g_queue_is_empty(queue)) {\n                        int descendant = GPOINTER_TO_INT(g_queue_pop_head(queue));\n                        for (int k = 0; k < n; k++) {\n                            if (parents[k] == descendant) {\n                                g_queue_push_tail(temp_queue, GINT_TO_POINTER(k + 1));\n                            }\n                        }\n                    }\n                    g_queue_free(queue);\n                    queue = temp_queue;\n                }\n            }\n        }\n\n        g_queue_free(queue);\n    }\n\n    // Count the number of people covered by at least one insurance policy\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (covered[i]) {\n            count++;\n        }\n    }\n\n    // Print the result\n    printf(\"%d\\n\", count);\n\n    // Clean up\n    free(parents);\n    free(covered);\n    g_array_free(insurance, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine which people are covered by at least one insurance policy. Each insurance policy covers a person and their descendants up to a certain number of generations. We can use a depth-first search (DFS) approach to traverse the family tree and mark all descendants covered by each insurance policy. To avoid counting the same person multiple times, we will use a boolean array to keep track of which people have been covered. Finally, we will count the number of people who have been covered by at least one insurance policy.", "question_id": "abc309_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, p, q;\n    scanf(\"%d %d %d\", &n, &p, &q);\n\n    GArray *dishes = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int dish_price;\n        scanf(\"%d\", &dish_price);\n        g_array_append_val(dishes, dish_price);\n    }\n\n    qsort(dishes->data, dishes->len, sizeof(int), compare);\n\n    int min_cost = p;\n    for (int i = 0; i < n; i++) {\n        int total_cost = q + g_array_index(dishes, int, i);\n        if (total_cost < min_cost) {\n            min_cost = total_cost;\n        }\n    }\n\n    printf(\"%d\\n\", min_cost);\n\n    g_array_free(dishes, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum total amount of money Takahashi must pay to get the AtCoder Drink. He has two options: either pay the regular price P yen or use the discount coupon Q yen, but he must also order one of the N dishes to use the coupon. We need to find the minimum cost by comparing the total cost of using the coupon with the regular price.", "question_id": "abc310_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 100\n#define MAX_M 100\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashTable *products = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < N; i++) {\n        int P, C;\n        scanf(\"%d %d\", &P, &C);\n        int *functions = (int *)malloc(C * sizeof(int));\n        for (int j = 0; j < C; j++) {\n            scanf(\"%d\", &functions[j]);\n        }\n\n        qsort(functions, C, sizeof(int), compare);\n\n        g_hash_table_insert(products, GINT_TO_POINTER(P), functions);\n    }\n\n    bool found = false;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i != j) {\n                int *functions_i = (int *)g_hash_table_lookup(products, GINT_TO_POINTER(i + 1));\n                int *functions_j = (int *)g_hash_table_lookup(products, GINT_TO_POINTER(j + 1));\n\n                int C_i = 0, C_j = 0;\n                for (int k = 0; k < MAX_M; k++) {\n                    if (functions_i[k] != 0) C_i++;\n                    if (functions_j[k] != 0) C_j++;\n                }\n\n                if (C_i >= C_j) {\n                    int k = 0;\n                    while (k < C_i && functions_i[k] <= functions_j[k]) k++;\n                    if (k == C_i && (C_i > C_j || functions_i[k - 1] < functions_j[k - 1])) {\n                        found = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (found) break;\n    }\n\n    if (found) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    g_hash_table_destroy(products);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exists a product that is strictly superior to another based on the given conditions. The conditions are that for products i and j, the i-th product should have all the functions of the j-th product, and either its price should be greater or it should have additional functions that the j-th product lacks. We can use a hash table to store the products and their functions, and then compare each pair of products to check if the conditions are met. If we find such a pair, we print 'Yes'; otherwise, we print 'No'.", "question_id": "abc310_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Use a hash table to store the canonical form of each stick\n    GHashTable *map = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < n; i++) {\n        char str[1000];\n        scanf(\"%s\", str);\n\n        // Create a reversed copy of the string\n        char reversed[1000];\n        strcpy(reversed, str);\n        strrev(reversed);\n\n        // Use the lexicographically smaller version as the key\n        char *key = (strcmp(str, reversed) < 0) ? str : reversed;\n\n        // Insert the key into the hash table\n        g_hash_table_insert(map, key, GINT_TO_POINTER(1));\n    }\n\n    // The number of distinct sticks is the size of the hash table\n    int result = g_hash_table_size(map);\n\n    // Output the result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of distinct sticks among N sticks, where each stick is represented by a string of lowercase English letters. Two sticks are considered the same if one string is the reverse of the other. Here's a step-by-step approach to solve the problem:", "question_id": "abc310_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MAX_N 10\n#define MAX_T 10\n#define MAX_M 50\n\nint N, T, M;\nint A[MAX_M], B[MAX_M];\nGArray *team[MAX_N];\n\nvoid dfs(int player, int team_id) {\n    if (player > N) {\n        for (int i = 1; i <= N; i++) {\n            if (g_array_length(team[i]) > 0) {\n                printf(\"Team %d: \", i);\n                for (int j = 0; j < g_array_length(team[i]); j++) {\n                    printf(\"%d \", g_array_index(team[i], int, j));\n                }\n                printf(\"\\n\");\n            }\n        }\n        return;\n    }\n    if (g_array_length(team[player]) > 0) {\n        dfs(player + 1, team_id);\n        return;\n    }\n    for (int i = 1; i <= T; i++) {\n        bool valid = true;\n        for (int j = 0; j < g_array_length(team[i]); j++) {\n            int other = g_array_index(team[i], int, j);\n            if (other == A[player] || other == B[player]) {\n                valid = false;\n                break;\n            }\n        }\n        if (valid) {\n            g_array_append_val(team[i], player);\n            dfs(player + 1, team_id);\n            g_array_remove_range(team[i], g_array_length(team[i]) - 1, 1);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &T, &M);\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n    }\n    for (int i = 1; i <= N; i++) {\n        team[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n    dfs(1, 0);\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of ways to divide N players into T teams such that no two incompatible pairs are in the same team. Here's a step-by-step approach to achieve this:", "question_id": "abc310_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    // Initialize a GArray to store the intermediate results\n    GArray *results = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Iterate over all possible starting points i\n    for (int i = 0; i < n; i++) {\n        int result = 0;\n        // Iterate over all possible ending points j starting from i\n        for (int j = i; j < n; j++) {\n            // Compute f(i, j) using the NAND operator\n            result = !(s[j] == '1' && (i == j || result == 0));\n            // Add the result to the total sum\n            g_array_append_val(results, result);\n        }\n    }\n\n    // Calculate the sum of all results\n    int sum = 0;\n    for (int i = 0; i < results->len; i++) {\n        sum += g_array_index(results, int, i);\n    }\n\n    // Print the result\n    printf(\"%d\\n\", sum);\n\n    // Free the GArray\n    g_array_free(results, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to compute the sum of the function f(i, j) for all 1 <= i <= j <= N, where f(i, j) is defined using the NAND operator. The key insight is to recognize that the NAND operator can be expressed in terms of the OR and NOT operators, which allows us to simplify the computation. Specifically, we can use the fact that a NAND(b, c) is equivalent to NOT(a AND b AND c). This observation helps us to efficiently compute the function values and their sum without having to explicitly compute the NAND operator for each pair (i, j). We can use dynamic programming to store intermediate results and avoid redundant calculations, leading to an efficient solution that can handle large input sizes.", "question_id": "abc310_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        g_array_append_val(A, a);\n    }\n\n    int max_val = 10;\n    for (int i = 0; i < N; i++) {\n        max_val += g_array_index(A, int, i);\n    }\n\n    int *dp = (int *)malloc((max_val + 1) * sizeof(int));\n    memset(dp, 0, (max_val + 1) * sizeof(int));\n    dp[0] = 1;\n\n    for (int i = 0; i < N; i++) {\n        int a = g_array_index(A, int, i);\n        for (int j = max_val; j >= 0; j--) {\n            for (int k = 1; k <= a; k++) {\n                if (j - k >= 0) {\n                    dp[j] = (dp[j] + dp[j - k]) % MOD;\n                }\n            }\n        }\n    }\n\n    int total_ways = dp[10];\n    int total_outcomes = 1;\n\n    for (int i = 0; i < N; i++) {\n        total_outcomes = (total_outcomes * g_array_index(A, int, i)) % MOD;\n    }\n\n    int result = 0;\n    for (int i = 1; i < MOD; i++) {\n        if ((i * total_outcomes) % MOD == 1) {\n            result = (result * total_ways) % MOD;\n            break;\n        }\n    }\n\n    printf(\"%d\n\", result);\n\n    free(dp);\n    g_array_free(A, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the probability that we can choose some of the N dice such that their sum is 10. We can approach this problem using dynamic programming. We'll use a 2D DP array where dp[i][j] represents the number of ways to achieve a sum of j using the first i dice. We'll then calculate the probability by dividing the number of successful outcomes by the total number of possible outcomes, both modulo 998244353.", "question_id": "abc310_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char str[1000];\n    scanf(\"%s\", str);\n\n    int lastA = -1, lastB = -1, lastC = -1;\n\n    for (int i = 0; i < n; i++) {\n        if (str[i] == 'A') {\n            lastA = i;\n        } else if (str[i] == 'B') {\n            lastB = i;\n        } else if (str[i] == 'C') {\n            lastC = i;\n        }\n        if (lastA != -1 && lastB != -1 && lastC != -1) {\n            break;\n        }\n    }\n\n    int result = 1 + fmax(fmax(lastA, lastB), lastC);\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the first position in the string where all three characters (A, B, and C) have appeared at least once. We can achieve this by iterating through the string and keeping track of the last positions of A, B, and C. Once we have the last positions, we can find the maximum of these positions, which will give us the first position where all three characters have appeared at least once.", "question_id": "abc311_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n\n    // Read the schedules into a GArray of strings\n    GArray *schedules = g_array_new(FALSE, FALSE, sizeof(char*));\n    for (int i = 0; i < N; i++) {\n        char *schedule = malloc(D + 1);\n        scanf(\"%s\", schedule);\n        g_array_append_val(schedules, schedule);\n    }\n\n    int max_consecutive_days = 0;\n\n    // Check each day for the maximum consecutive free days\n    for (int day = 0; day < D; day++) {\n        int consecutive_free = 0;\n        bool all_free = true;\n\n        for (int person = 0; person < N; person++) {\n            if (g_array_index(schedules, char*, person)[day] == 'x') {\n                all_free = false;\n                break;\n            }\n        }\n\n        if (all_free) {\n            consecutive_free++;\n        }\n\n        for (int i = day + 1; i < D; i++) {\n            bool all_free_in_range = true;\n\n            for (int person = 0; person < N; person++) {\n                if (g_array_index(schedules, char*, person)[i] == 'x') {\n                    all_free_in_range = false;\n                    break;\n                }\n            }\n\n            if (all_free_in_range) {\n                consecutive_free++;\n            } else {\n                break;\n            }\n        }\n\n        max_consecutive_days = fmax(max_consecutive_days, consecutive_free);\n    }\n\n    // Free the allocated memory for schedules\n    for (int i = 0; i < N; i++) {\n        free(g_array_index(schedules, char*, i));\n    }\n    g_array_free(schedules, TRUE);\n\n    // Output the result\n    printf(\"%d\n\", max_consecutive_days);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum number of consecutive days when all N people are free. Here's a step-by-step approach to achieve this:", "question_id": "abc311_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GQueue *queue = g_queue_new();\n\n    for (int i = 0; i < n; i++) {\n        if (!g_hash_table_contains(visited, GINT_TO_POINTER(i))) {\n            GQueue *path = g_queue_new();\n            g_queue_push_tail(path, GINT_TO_POINTER(i));\n            g_hash_table_insert(visited, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n\n            while (!g_queue_is_empty(path)) {\n                int current = GPOINTER_TO_INT(g_queue_peek_head(path));\n                int next = A[current - 1] - 1;\n\n                if (next == current) {\n                    int cycle_length = g_queue_get_length(path);\n                    printf(\"%d\\n\", cycle_length);\n                    GList *node = g_queue_peek_head_link(path);\n                    for (int j = 0; j < cycle_length; j++) {\n                        printf(\"%d \", GPOINTER_TO_INT(node->data) + 1);\n                        node = node->next;\n                    }\n                    printf(\"\\n\");\n                    goto end;\n                }\n\n                if (!g_hash_table_contains(visited, GINT_TO_POINTER(next))) {\n                    g_queue_push_tail(path, GINT_TO_POINTER(next));\n                    g_hash_table_insert(visited, GINT_TO_POINTER(next), GINT_TO_POINTER(1));\n                } else {\n                    g_queue_push_tail(path, GINT_TO_POINTER(next));\n                    break;\n                }\n            }\n\n            g_queue_free(path);\n        }\n    }\n\nend:\n    g_hash_table_destroy(visited);\n    g_queue_free(queue);\n    free(A);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find a directed cycle in a graph where each vertex appears only once. We can use a hash table to keep track of visited vertices and detect cycles. Here's a step-by-step approach to solve the problem:", "question_id": "abc311_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200\n#define MAX_M 200\n\ntypedef struct {\n    int x, y;\n} Position;\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    char grid[MAX_N][MAX_M];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    GQueue *queue = g_queue_new();\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    Position start = {2, 2};\n    g_queue_push_tail(queue, GINT_TO_POINTER(start.x * MAX_M + start.y));\n    g_hash_table_insert(visited, GINT_TO_POINTER(start.x * MAX_M + start.y), GINT_TO_POINTER(1));\n\n    int count = 0;\n\n    while (!g_queue_is_empty(queue)) {\n        Position current = *(Position*)g_queue_pop_head(queue);\n        int x = current.x;\n        int y = current.y;\n\n        count++;\n\n        // Up\n        if (x > 1 && grid[x-1][y] == \".\" && !g_hash_table_contains(visited, GINT_TO_POINTER((x-1) * MAX_M + y))) {\n            Position next = {x-1, y};\n            g_queue_push_tail(queue, GINT_TO_POINTER(next.x * MAX_M + next.y));\n            g_hash_table_insert(visited, GINT_TO_POINTER(next.x * MAX_M + next.y), GINT_TO_POINTER(1));\n        }\n\n        // Down\n        if (x < N-1 && grid[x+1][y] == \".\" && !g_hash_table_contains(visited, GINT_TO_POINTER((x+1) * MAX_M + y))) {\n            Position next = {x+1, y};\n            g_queue_push_tail(queue, GINT_TO_POINTER(next.x * MAX_M + next.y));\n            g_hash_table_insert(visited, GINT_TO_POINTER(next.x * MAX_M + next.y), GINT_TO_POINTER(1));\n        }\n\n        // Left\n        if (y > 1 && grid[x][y-1] == \".\" && !g_hash_table_contains(visited, GINT_TO_POINTER(x * MAX_M + (y-1)))) {\n            Position next = {x, y-1};\n            g_queue_push_tail(queue, GINT_TO_POINTER(next.x * MAX_M + next.y));\n            g_hash_table_insert(visited, GINT_TO_POINTER(next.x * MAX_M + next.y), GINT_TO_POINTER(1));\n        }\n\n        // Right\n        if (y < M-1 && grid[x][y+1] == \".\" && !g_hash_table_contains(visited, GINT_TO_POINTER(x * MAX_M + (y+1)))) {\n            Position next = {x, y+1};\n            g_queue_push_tail(queue, GINT_TO_POINTER(next.x * MAX_M + next.y));\n            g_hash_table_insert(visited, GINT_TO_POINTER(next.x * MAX_M + next.y), GINT_TO_POINTER(1));\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    g_queue_free(queue);\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the player's movement on the grid and count the number of ice squares the player can touch. The player starts at position (2,2) and can move in four directions: up, down, left, and right. The movement continues until the player bumps into a rock. We can use a breadth-first search (BFS) approach to explore all possible moves and count the ice squares the player can reach.", "question_id": "abc311_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    GHashTable *holed_squares = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < N; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        g_hash_table_insert(holed_squares, GINT_TO_POINTER(a), GINT_TO_POINTER(b));\n    }\n\n    long long holeless_count = 0;\n\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            int can_be_holeless = 1;\n            for (int n = 1; n <= H - i + 1 && n <= W - j + 1; n++) {\n                if (g_hash_table_lookup(holed_squares, GINT_TO_POINTER(i + n - 1)) == GINT_TO_POINTER(j + n - 1)) {\n                    can_be_holeless = 0;\n                    break;\n                }\n            }\n            if (can_be_holeless) {\n                holeless_count++;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", holeless_count);\n\n    g_hash_table_destroy(holed_squares);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of holeless squares in a grid given the positions of holed squares. A holeless square is defined as a square region whose top-left corner is (i, j) and whose bottom-right corner is (i + n - 1, j + n - 1) such that no part of this square is holed. The approach involves iterating over each possible top-left corner of a square and checking if the corresponding bottom-right corner is within bounds and if the entire square is holeless.", "question_id": "abc311_e"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[4];  // Array to store the input string\n    scanf(\"%s\", S);  // Read the input string\n\n    // Define the target strings\n    char targets[8][4] = {\"ACE\", \"BDF\", \"CEG\", \"DFA\", \"EGB\", \"FAC\", \"GBD\"};\n\n    // Check each target string\n    for (int i = 0; i < 8; i++) {\n        if (strcmp(S, targets[i]) == 0) {\n            printf(\"Yes\n\");\n            return 0;\n        }\n    }\n\n    // If no match is found, print 'No'\n    printf(\"No\n\");\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to check if the given string S matches any of the specified strings. The strings to check against are ACE, BDF, CEG, DFA, EGB, FAC, and GBD. We can do this by comparing each character of the input string S with the corresponding characters in the target strings. If any of the characters do not match, we can immediately return 'No'. If all characters match for any of the target strings, we return 'Yes'.", "question_id": "abc312_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define N 9\n\nbool isTakCode(const char *grid[N], int startRow, int startCol) {\n    // Check top-left 3x3 region\n    if (grid[startRow][startCol] != '#' || grid[startRow][startCol + 1] != '#' || grid[startRow][startCol + 2] != '#') return false;\n    if (grid[startRow + 1][startCol] != '#' || grid[startRow + 1][startCol + 1] != '.' || grid[startRow + 1][startCol + 2] != '#') return false;\n    if (grid[startRow + 2][startCol] != '#' || grid[startRow + 2][startCol + 1] != '#' || grid[startRow + 2][startCol + 2] != '#') return false;\n\n    // Check bottom-right 3x3 region\n    if (grid[startRow + 6][startCol + 6] != '#' || grid[startRow + 6][startCol + 7] != '#' || grid[startRow + 6][startCol + 8] != '#') return false;\n    if (grid[startRow + 7][startCol + 6] != '#' || grid[startRow + 7][startCol + 7] != '.' || grid[startRow + 7][startCol + 8] != '#') return false;\n    if (grid[startRow + 8][startCol + 6] != '#' || grid[startRow + 8][startCol + 7] != '#' || grid[startRow + 8][startCol + 8] != '#') return false;\n\n    // Check adjacent cells\n    for (int i = startRow; i < startRow + 9; i++) {\n        for (int j = startCol; j < startCol + 9; j++) {\n            if (i == startRow || i == startRow + 8 || j == startCol || j == startCol + 8) {\n                if (grid[i][j] != '.') return false;\n            } else {\n                if (grid[i][j] != '#') return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    char grid[N][M + 1];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i <= N - 9; i++) {\n        for (int j = 0; j <= M - 9; j++) {\n            if (isTakCode(grid, i, j)) {\n                printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to identify all possible 9x9 regions in the given grid that meet the criteria for a TaK Code. The TaK Code has specific patterns that must be present in its top-left and bottom-right 3x3 regions. We will iterate through all possible 9x9 regions in the grid, check if they match the TaK Code pattern, and if they do, print their coordinates.", "question_id": "abc312_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *sellers = (int *)malloc(n * sizeof(int));\n    int *buyers = (int *)malloc(m * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &sellers[i]);\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &buyers[i]);\n    }\n\n    qsort(sellers, n, sizeof(int), compare);\n    qsort(buyers, m, sizeof(int), compare);\n\n    int i = 0, j = 0;\n    int result = -1;\n\n    while (i < n && j < m) {\n        if (sellers[i] >= buyers[j]) {\n            result = buyers[j];\n            break;\n        }\n        i++;\n    }\n\n    if (result == -1) {\n        result = buyers[m - 1];\n    }\n\n    printf(\"%d\n\", result);\n\n    free(sellers);\n    free(buyers);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum integer X such that the number of sellers who can sell an apple for X yen is greater than or equal to the number of buyers who can buy an apple for X yen. Here's a step-by-step approach to achieve this:", "question_id": "abc312_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    char S[3001];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n    GHashTable *dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initialize dp for empty string\n    g_hash_table_insert(dp, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n\n    for (int i = 0; i < n; i++) {\n        GHashTable *new_dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n        if (S[i] == '(' || S[i] == ')') {\n            GHashTableIter iter;\n            gpointer key, value;\n            g_hash_table_iter_init(&iter, dp);\n            while (g_hash_table_iter_next(&iter, &key, &value)) {\n                int count = GPOINTER_TO_INT(value);\n                int left = S[i] == '(' ? count : 0;\n                int right = S[i] == ')' ? count : 0;\n                g_hash_table_insert(new_dp, GINT_TO_POINTER(left), GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(new_dp, GINT_TO_POINTER(left))) + count) % MOD));\n                g_hash_table_insert(new_dp, GINT_TO_POINTER(right), GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(new_dp, GINT_TO_POINTER(right))) + count) % MOD));\n            }\n        } else {\n            GHashTableIter iter;\n            gpointer key, value;\n            g_hash_table_iter_init(&iter, dp);\n            while (g_hash_table_iter_next(&iter, &key, &value)) {\n                int count = GPOINTER_TO_INT(value);\n                int left = count;\n                int right = count;\n                g_hash_table_insert(new_dp, GINT_TO_POINTER(left), GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(new_dp, GINT_TO_POINTER(left))) + count) % MOD));\n                g_hash_table_insert(new_dp, GINT_TO_POINTER(right), GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(new_dp, GINT_TO_POINTER(right))) + count) % MOD));\n            }\n        }\n        g_hash_table_destroy(dp);\n        dp = new_dp;\n    }\n\n    int result = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, dp);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        result = (result + GPOINTER_TO_INT(value)) % MOD;\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of ways to replace each '?' in the given string S with '(' or ')' such that the resulting string is a valid parenthesis string. A valid parenthesis string can be empty, or it can be formed by concatenating valid strings in a specific way. We can use dynamic programming to solve this problem efficiently.", "question_id": "abc312_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Array to store cuboids\n    int cuboids[n][6];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 6; j++) {\n            scanf(\"%d\", &cuboids[i][j]);\n        }\n    }\n\n    // Array to store the result\n    int result[n];\n\n    // Process each cuboid\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n\n        // Check for shared faces with other cuboids\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n\n            // Check XY plane\n            if (cuboids[i][0] == cuboids[j][0] && cuboids[i][1] == cuboids[j][1] &&\n                (cuboids[i][2] == cuboids[j][2] || cuboids[i][2] == cuboids[j][5] ||\n                 cuboids[i][5] == cuboids[j][2])) {\n                count++;\n            }\n\n            // Check XZ plane\n            if (cuboids[i][0] == cuboids[j][0] && cuboids[i][2] == cuboids[j][2] &&\n                (cuboids[i][1] == cuboids[j][1] || cuboids[i][1] == cuboids[j][4] ||\n                 cuboids[i][4] == cuboids[j][1])) {\n                count++;\n            }\n\n            // Check YZ plane\n            if (cuboids[i][1] == cuboids[j][1] && cuboids[i][2] == cuboids[j][2] &&\n                (cuboids[i][0] == cuboids[j][0] || cuboids[i][0] == cuboids[j][3] ||\n                 cuboids[i][3] == cuboids[j][0])) {\n                count++;\n            }\n        }\n\n        result[i] = count;\n    }\n\n    // Output the results\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\\n\", result[i]);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine how many other cuboids share a face with each given cuboid. Given the constraints, a brute-force approach would be too slow, so we need an efficient solution. The key insight is to use the properties of the cuboids' coordinates to quickly determine if two cuboids share a face. Specifically, two cuboids share a face if their projections onto one of the coordinate planes (XY, XZ, or YZ) overlap, and their third dimension is adjacent.", "question_id": "abc312_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n#define MAXM 200000\n\ntypedef struct {\n    int type;\n    int value;\n} Item;\n\nint compare(const void *a, const void *b) {\n    return ((Item *)b)->value - ((Item *)a)->value;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Item items[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &items[i].type, &items[i].value);\n    }\n\n    qsort(items, N, sizeof(Item), compare);\n\n    int total_happiness = 0;\n    int can_openers = 0;\n\n    for (int i = 0; i < M; i++) {\n        if (items[i].type == 2) {\n            can_openers += items[i].value;\n        } else if (items[i].type == 1) {\n            if (can_openers > 0) {\n                can_openers--;\n                total_happiness += items[i].value;\n            }\n        } else if (items[i].type == 0) {\n            total_happiness += items[i].value;\n        }\n    }\n\n    printf(\"%d\\n\", total_happiness);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maximize the total happiness by selecting M items out of N, considering the constraints on the types of items and their interactions. Here's a step-by-step approach to solve the problem:", "question_id": "abc312_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *abilities = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &abilities[i]);\n    }\n\n    int max_ability = 0;\n    for (int i = 1; i < n; i++) {\n        if (abilities[i] > max_ability) {\n            max_ability = abilities[i];\n        }\n    }\n\n    int x = 0;\n    if (max_ability > abilities[0]) {\n        x = max_ability - abilities[0] + 1;\n    }\n\n    printf(\"%d\n\", x);\n\n    free(abilities);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum non-negative integer x such that person 1's programming ability becomes greater than that of any other person. Here's a step-by-step approach to achieve this:", "question_id": "abc313_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 50\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Initialize adjacency list\n    GArray *adj[N + 1];\n    for (int i = 1; i <= N; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read input and build adjacency list\n    for (int i = 0; i < M; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n        g_array_append_val(adj[A], B);\n    }\n\n    // Initialize in-degree and out-degree arrays\n    int in_degree[N + 1] = {0};\n    int out_degree[N + 1] = {0};\n\n    // Calculate in-degree and out-degree\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j < g_array_index(adj[i], int, j); j++) {\n            int neighbor = g_array_index(adj[i], int, j);\n            in_degree[neighbor]++;\n            out_degree[i]++;\n        }\n    }\n\n    // Find nodes with in-degree 0 and out-degree N-1\n    int strongest = -1;\n    for (int i = 1; i <= N; i++) {\n        if (in_degree[i] == 0 && out_degree[i] == N - 1) {\n            if (strongest != -1) {\n                strongest = -1;\n                break;\n            }\n            strongest = i;\n        }\n    }\n\n    // Output the result\n    printf(\"%d\n\", strongest);\n\n    // Clean up\n    for (int i = 1; i <= N; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "reasoning": "To determine the strongest programmer, we need to analyze the given superiority relations and check if there is a single person who is stronger than all others. This problem can be approached using graph theory, where each person is a node and the superiority relation is a directed edge. The strongest programmer would be the source node in a topological sort of the graph, if such a node exists. If there are multiple nodes with the same in-degree and out-degree, or if the graph is not a single strongly connected component, then there is no unique strongest programmer.", "question_id": "abc313_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    qsort(arr, n, sizeof(int), compare);\n\n    int min = arr[0];\n    int max = arr[n-1];\n    int operations = 0;\n\n    while (max - min > 1) {\n        if (max - min == 2) {\n            if (arr[1] - min > max - arr[n-2]) {\n                operations += arr[1] - min;\n                arr[1] -= arr[1] - min;\n                max = arr[n-1];\n            } else {\n                operations += max - arr[n-2];\n                arr[n-2] += max - arr[n-2];\n                min = arr[0];\n            }\n        } else {\n            operations += (max - min - 1) / 2;\n            max -= (max - min - 1) / 2;\n            min += (max - min - 1) / 2;\n        }\n    }\n\n    printf(\"%d\n\", operations);\n\n    free(arr);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of operations required to make the difference between the minimum and maximum values of the array A at most one. The operation allows us to decrease one element by one and increase another element by one. This means we need to balance the array elements to achieve the desired condition.", "question_id": "abc313_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <gmp.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    mpz_t pi;\n    mpz_init(pi);\n\n    // Calculate pi to the n-th decimal place\n    mpz_set_ui(pi, 0);\n    mpz_ui_pow_ui(pi, 10, n);\n    mpz_mul_ui(pi, pi, 4);\n\n    // Print pi with n decimal places\n    gmp_printf(\"%.%Ff\\n\", n, pi);\n\n    mpz_clear(pi);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to print the value of pi to the N-th decimal place without removing any trailing zeros. Given the constraints and the precision required, we can use the gmpy2 library in Python to handle arbitrary-precision arithmetic. However, since the problem requires a C solution, we will use the GMP library, which is a C library for arbitrary-precision arithmetic. We will use the GMP library to calculate pi to the required precision and then print it with the correct number of decimal places.", "question_id": "abc314_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, X;\n    scanf(\"%d\", &N);\n\n    GHashTable *bets = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 1; i <= N; i++) {\n        int C;\n        scanf(\"%d\", &C);\n\n        for (int j = 0; j < C; j++) {\n            int A;\n            scanf(\"%d\", &A);\n\n            if (A == X) {\n                if (g_hash_table_contains(bets, GINT_TO_POINTER(i))) {\n                    int *current_bets = g_hash_table_lookup(bets, GINT_TO_POINTER(i));\n                    (*current_bets)++;\n                } else {\n                    int *new_bets = malloc(sizeof(int));\n                    *new_bets = 1;\n                    g_hash_table_insert(bets, GINT_TO_POINTER(i), new_bets);\n                }\n            }\n        }\n    }\n\n    int min_bets = INT_MAX;\n    GList *keys = g_hash_table_get_keys(bets);\n    for (GList *key = keys; key != NULL; key = key->next) {\n        int *bets_count = g_hash_table_lookup(bets, key);\n        if (*bets_count < min_bets) {\n            min_bets = *bets_count;\n        }\n    }\n\n    int count = 0;\n    for (GList *key = keys; key != NULL; key = key->next) {\n        int *bets_count = g_hash_table_lookup(bets, key);\n        if (*bets_count == min_bets) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    for (GList *key = keys; key != NULL; key = key->next) {\n        int *bets_count = g_hash_table_lookup(bets, key);\n        if (*bets_count == min_bets) {\n            printf(\"%d \", GPOINTER_TO_INT(key));\n        }\n    }\n\n    printf(\"\\n\");\n\n    g_hash_table_destroy(bets);\n    g_list_free(keys);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine which people have bet on the outcome X with the fewest bets. Here's a step-by-step approach to achieve this:", "question_id": "abc314_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    int *color_indices = (int *)malloc(m * sizeof(int));\n    memset(color_indices, 0, m * sizeof(int));\n\n    // Store the starting indices of each color group\n    for (int i = 0; i < n; i++) {\n        color_indices[s[i] - 'a'] = i;\n    }\n\n    // Perform the right circular shifts for each color\n    for (int i = 0; i < m; i++) {\n        int start = color_indices[i];\n        int end = n - 1;\n        char temp = s[end];\n\n        // Perform the shift\n        while (end > start) {\n            s[end] = s[end - 1];\n            end--;\n        }\n        s[start] = temp;\n    }\n\n    // Print the final string\n    printf(\"%s\n\", s);\n\n    // Free allocated memory\n    free(color_indices);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the right circular shifts for each color group in the string. Here's a step-by-step approach to achieve this:", "question_id": "abc314_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n    int q;\n    scanf(\"%d\", &q);\n\n    // Initialize flags\n    bool to_upper = false;\n    bool to_lower = false;\n\n    // Process operations\n    for (int i = 0; i < q; i++) {\n        int t, x;\n        char c;\n        scanf(\"%d %d %c\", &t, &x, &c);\n\n        if (t == 1) {\n            // Change character at position x-1 to c\n            s[x - 1] = c;\n        } else if (t == 2) {\n            // Convert all characters to lowercase\n            to_upper = false;\n            to_lower = true;\n        } else if (t == 3) {\n            // Convert all characters to uppercase\n            to_upper = true;\n            to_lower = false;\n        }\n    }\n\n    // Apply flags to the string\n    if (to_upper) {\n        for (int i = 0; i < n; i++) {\n            if (isalpha(s[i])) {\n                s[i] = toupper(s[i]);\n            }\n        }\n    } else if (to_lower) {\n        for (int i = 0; i < n; i++) {\n            if (isalpha(s[i])) {\n                s[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    // Print the result\n    printf(\"%s\\n\", s);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to handle three types of operations on a string: changing a character, converting all characters to lowercase, and converting all characters to uppercase. Given the constraints, using a direct approach to modify the string in place for each operation would be inefficient. Instead, we can use a combination of flags and conditional logic to handle the operations more efficiently. Here's a step-by-step breakdown of the solution approach:", "question_id": "abc314_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 100\n#define MAX_M 100\n#define MAX_C 10000\n#define MAX_P 100\n#define EPS 1e-5\n\ntypedef struct {\n    int C;\n    int P;\n    int S[MAX_P];\n} Wheel;\n\nWheel wheels[MAX_N];\nint N, M;\n\nGHashTable *dp[MAX_N][MAX_M];\n\ndouble expected_cost(int points, int wheel_index) {\n    if (points >= M) {\n        return 0.0;\n    }\n    if (wheel_index == N) {\n        return INT_MAX;\n    }\n\n    GHashTable *hash = dp[wheel_index][points];\n    if (hash == NULL) {\n        hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n        dp[wheel_index][points] = hash;\n    }\n\n    gpointer value = g_hash_table_lookup(hash, GINT_TO_POINTER(wheel_index));\n    if (value != NULL) {\n        return GPOINTER_TO_DOUBLE(value);\n    }\n\n    double min_cost = INT_MAX;\n    for (int i = 0; i < wheels[wheel_index].P; i++) {\n        double cost = wheels[wheel_index].C + expected_cost(points + wheels[wheel_index].S[i], wheel_index + 1);\n        min_cost = fmin(min_cost, cost);\n    }\n\n    g_hash_table_insert(hash, GINT_TO_POINTER(wheel_index), GINT_TO_DOUBLE(min_cost));\n\n    return min_cost;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &wheels[i].C, &wheels[i].P);\n        for (int j = 0; j < wheels[i].P; j++) {\n            scanf(\"%d\", &wheels[i].S[j]);\n        }\n    }\n\n    double total_cost = 0.0;\n    for (int i = 0; i < N; i++) {\n        total_cost += expected_cost(0, i);\n    }\n\n    printf(\"%.10f\n\", total_cost);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            g_hash_table_destroy(dp[i][j]);\n        }\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the expected amount of money Takahashi will pay before he earns at least M points. We can use dynamic programming with memoization to achieve this. The key idea is to maintain a DP table where dp[i][j] represents the expected cost to achieve at least i points starting from j wheels. We will use a recursive function with memoization to calculate the expected cost for each state and then choose the optimal wheel to minimize the expected cost.", "question_id": "abc314_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int wins;\n    int total;\n} PlayerStats;\n\nvoid dfs(int player, GHashTable *graph, GHashTable *stats, int *visited) {\n    if (visited[player]) return;\n    visited[player] = 1;\n\n    GList *edges = g_hash_table_lookup(graph, GINT_TO_POINTER(player));\n    if (edges) {\n        PlayerStats sum = {0, 0};\n        GList *edge;\n        for (edge = edges; edge != NULL; edge = edge->next) {\n            int neighbor = GPOINTER_TO_INT(edge->data);\n            dfs(neighbor, graph, stats, visited);\n            sum.wins += ((PlayerStats *)g_hash_table_lookup(stats, GINT_TO_POINTER(neighbor)))->wins;\n            sum.total += ((PlayerStats *)g_hash_table_lookup(stats, GINT_TO_POINTER(neighbor)))->total;\n        }\n        PlayerStats *current = g_hash_table_lookup(stats, GINT_TO_POINTER(player));\n        current->wins = (sum.wins + 1) % MOD;\n        current->total = sum.total + 1;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *graph = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *stats = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 1; i <= n; i++) {\n        PlayerStats *new_stats = g_new(PlayerStats, 1);\n        new_stats->wins = 0;\n        new_stats->total = 0;\n        g_hash_table_insert(stats, GINT_TO_POINTER(i), new_stats);\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        int p, q;\n        scanf(\"%d %d\", &p, &q);\n\n        GList *edges_p = g_hash_table_lookup(graph, GINT_TO_POINTER(p));\n        if (!edges_p) {\n            edges_p = g_list_append(NULL, GINT_TO_POINTER(q));\n            g_hash_table_insert(graph, GINT_TO_POINTER(p), edges_p);\n        } else {\n            edges_p = g_list_append(edges_p, GINT_TO_POINTER(q));\n            g_hash_table_insert(graph, GINT_TO_POINTER(p), edges_p);\n        }\n\n        GList *edges_q = g_hash_table_lookup(graph, GINT_TO_POINTER(q));\n        if (!edges_q) {\n            edges_q = g_list_append(NULL, GINT_TO_POINTER(p));\n            g_hash_table_insert(graph, GINT_TO_POINTER(q), edges_q);\n        } else {\n            edges_q = g_list_append(edges_q, GINT_TO_POINTER(p));\n            g_hash_table_insert(graph, GINT_TO_POINTER(q), edges_q);\n        }\n    }\n\n    int *visited = g_new(int, n + 1);\n    memset(visited, 0, sizeof(int) * (n + 1));\n\n    for (int i = 1; i <= n; i++) {\n        dfs(i, graph, stats, visited);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        PlayerStats *player_stats = g_hash_table_lookup(stats, GINT_TO_POINTER(i));\n        printf(\"%d \", player_stats->wins);\n    }\n\n    printf(\"\\n\");\n\n    g_hash_table_destroy(graph);\n    g_hash_table_destroy(stats);\n    g_free(visited);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the expected number of wins for each player in the tournament. The key insight is that each player's expected number of wins can be determined recursively based on the matches they are involved in. Here's a step-by-step breakdown of the approach:\n\n1. **Graph Representation**: Represent the players and matches as a graph where each player is a node and each match is an edge. This helps in understanding the dependencies between players.\n\n2. **Expected Wins Calculation**: For each player, calculate the expected number of wins by considering all matches they are involved in. The expected wins for a player can be derived from the expected wins of the players in the matches they are part of.\n\n3. **Modulo Operation**: Since the expected values can be large, we need to take the result modulo 998244353. This ensures that the results fit within standard integer limits and are manageable.\n\n4. **Recursive Calculation**: Use a recursive approach to calculate the expected wins for each player, ensuring that we handle the base cases and dependencies correctly.\n\n5. **Dynamic Programming**: Use dynamic programming to store intermediate results and avoid redundant calculations, which is crucial given the constraints.", "question_id": "abc314_f"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[101];\n    scanf(\"%s\", S);\n\n    char result[101];\n    int j = 0;\n\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (S[i] != 'a' && S[i] != 'e' && S[i] != 'i' && S[i] != 'o' && S[i] != 'u') {\n            result[j++] = S[i];\n        }\n    }\n    result[j] = '\\0';\n\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "reasoning": "The problem requires removing all occurrences of the vowels 'a', 'e', 'i', 'o', 'u' from a given string S. We can achieve this by iterating through the string and copying only the characters that are not vowels to a new string. Since the output string should be printed without any vowels, we can use a simple loop to check each character and append it to a new string if it is not a vowel.", "question_id": "abc315_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int M;\n    scanf(\"%d\", &M);\n\n    int *days = (int *)malloc(M * sizeof(int));\n    int total_days = 0;\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &days[i]);\n        total_days += days[i];\n    }\n\n    int middle_day = (total_days + 1) / 2;\n    int current_day = 0;\n\n    for (int i = 0; i < M; i++) {\n        current_day += days[i];\n        if (current_day >= middle_day) {\n            printf(\"%d %d\\n\", i + 1, middle_day - (current_day - days[i]) + 1);\n            break;\n        }\n    }\n\n    free(days);\n    return 0;\n}", "reasoning": "To find the middle day of the year in AtCoderLand, we need to determine which day and month it falls on. Given that the total number of days in the year is odd, the middle day will be the ((D_1+D_2+...+D_M+1)/2)-th day. We can iterate through the months, keeping a running total of the days, and check when the running total exceeds the middle day. The month and day at that point will be our answer.", "question_id": "abc315_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create a hash table to store the maximum deliciousness for each flavor\n    GHashTable *flavor_max = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        int flavor, deliciousness;\n        scanf(\"%d %d\", &flavor, &deliciousness);\n\n        // Update the maximum deliciousness for the current flavor\n        gpointer existing_max = g_hash_table_lookup(flavor_max, GINT_TO_POINTER(flavor));\n        if (existing_max == NULL || GPOINTER_TO_INT(existing_max) < deliciousness) {\n            g_hash_table_insert(flavor_max, GINT_TO_POINTER(flavor), GINT_TO_POINTER(deliciousness));\n        }\n    }\n\n    // Initialize variables to store the maximum satisfaction\n    int max_satisfaction = 0;\n\n    // Iterate through all pairs of cups\n    for (int i = 0; i < n; i++) {\n        int flavor1, deliciousness1;\n        scanf(\"%d %d\", &flavor1, &deliciousness1);\n\n        for (int j = i + 1; j < n; j++) {\n            int flavor2, deliciousness2;\n            scanf(\"%d %d\", &flavor2, &deliciousness2);\n\n            // Calculate satisfaction for different flavors\n            if (flavor1 != flavor2) {\n                int satisfaction = deliciousness1 + deliciousness2;\n                if (satisfaction > max_satisfaction) {\n                    max_satisfaction = satisfaction;\n                }\n            } else {\n                // Calculate satisfaction for same flavor\n                int satisfaction = deliciousness2 + deliciousness1 / 2;\n                if (satisfaction > max_satisfaction) {\n                    max_satisfaction = satisfaction;\n                }\n            }\n        }\n    }\n\n    // Output the maximum satisfaction\n    printf(\"%d\\n\", max_satisfaction);\n\n    // Clean up\n    g_hash_table_destroy(flavor_max);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maximize the satisfaction based on the given rules. The key observation is that the maximum satisfaction can be achieved by either selecting two cups with different flavors or two cups with the same flavor. Here's a step-by-step approach to solve the problem:", "question_id": "abc315_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 2001\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    char grid[MAX][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    bool marked[MAX][MAX];\n    memset(marked, false, sizeof(marked));\n\n    bool changed;\n    do {\n        changed = false;\n\n        // Mark cookies in rows\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W - 1; j++) {\n                if (grid[i][j] == grid[i][j + 1] && grid[i][j] != '.') {\n                    marked[i][j] = true;\n                    marked[i][j + 1] = true;\n                    changed = true;\n                }\n            }\n        }\n\n        // Mark cookies in columns\n        for (int j = 0; j < W; j++) {\n            for (int i = 0; i < H - 1; i++) {\n                if (grid[i][j] == grid[i + 1][j] && grid[i][j] != '.') {\n                    marked[i][j] = true;\n                    marked[i + 1][j] = true;\n                    changed = true;\n                }\n            }\n        }\n\n        // Remove marked cookies\n        if (changed) {\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (marked[i][j]) {\n                        grid[i][j] = '.';\n                    }\n                }\n            }\n        }\n\n        // Reset marked array for the next iteration\n        memset(marked, false, sizeof(marked));\n    } while (changed);\n\n    // Count remaining cookies\n    int count = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] != '.') {\n                count++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of marking and removing cookies based on their colors in rows and columns. Here's a step-by-step breakdown of the approach:\n\n1. **Read Input**: We first read the dimensions of the grid and the grid itself.\n2. **Mark Cookies**: We iterate through each row and column to mark cookies that have the same color consecutively.\n3. **Remove Marked Cookies**: We remove all marked cookies and update the grid.\n4. **Repeat**: We repeat steps 2 and 3 until no more cookies are marked.\n5. **Count Remaining Cookies**: Finally, we count the number of remaining cookies and print the result.\n\nThe key is to efficiently mark and remove cookies, and to handle the grid operations correctly.", "question_id": "abc315_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_BOOKS 200000\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GArray *in_degree = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_set_size(in_degree, N + 1);\n\n    GArray *adj_list[N + 1];\n    for (int i = 1; i <= N; i++) {\n        adj_list[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    for (int i = 1; i <= N; i++) {\n        int C;\n        scanf(\"%d\", &C);\n        for (int j = 0; j < C; j++) {\n            int P;\n            scanf(\"%d\", &P);\n            g_array_append_val(adj_list[P], i);\n            g_array_index(in_degree, int, i)++;\n        }\n    }\n\n    GQueue *queue = g_queue_new();\n    for (int i = 1; i <= N; i++) {\n        if (g_array_index(in_degree, int, i) == 0) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(i));\n        }\n    }\n\n    GArray *result = g_array_new(FALSE, FALSE, sizeof(int));\n\n    while (!g_queue_is_empty(queue)) {\n        int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        g_array_append_val(result, current);\n\n        for (guint j = 0; j < adj_list[current]->len; j++) {\n            int neighbor = g_array_index(adj_list[current], int, j);\n            g_array_index(in_degree, int, neighbor)--;\n            if (g_array_index(in_degree, int, neighbor) == 0) {\n                g_queue_push_tail(queue, GINT_TO_POINTER(neighbor));\n            }\n        }\n    }\n\n    for (int i = 2; i <= N; i++) {\n        printf(\"%d \", g_array_index(result, int, i));\n    }\n    printf(\"\\n\");\n\n    g_array_free(in_degree, TRUE);\n    for (int i = 1; i <= N; i++) {\n        g_array_free(adj_list[i], TRUE);\n    }\n    g_queue_free(queue);\n    g_array_free(result, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of books required to read book 1 and the order in which these books should be read. This problem can be approached using topological sorting on a directed graph where each book points to the books it depends on. Here's a step-by-step breakdown of the solution:", "question_id": "abc315_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 10000\n#define EPS 1e-5\n\n// Function to calculate Euclidean distance between two points\ndouble distance(int x1, int y1, int x2, int y2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\n// Function to calculate minimum distance with penalty\ndouble min_distance(int n, int *x, int *y, int pos, int skip) {\n    // Base case: if at the last checkpoint\n    if (pos == n - 1) {\n        return distance(x[pos], y[pos], x[0], y[0]) + (skip > 0 ? pow(2, skip - 1) : 0);\n    }\n\n    // Check if result is already computed\n    if (dp[pos][skip] != -1) {\n        return dp[pos][skip];\n    }\n\n    double min_dist = INT_MAX;\n\n    // Try skipping the current checkpoint\n    min_dist = fmin(min_dist, min_distance(n, x, y, pos + 1, skip + 1));\n\n    // Try not skipping the current checkpoint\n    for (int i = pos + 1; i < n; i++) {\n        min_dist = fmin(min_dist, min_distance(n, x, y, i, 0) + distance(x[pos], y[pos], x[i], y[i]));\n    }\n\n    // Store the result in dp array\n    dp[pos][skip] = min_dist;\n    return min_dist;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int x[MAX_N], y[MAX_N];\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &x[i], &y[i]);\n    }\n\n    // Initialize dp array with -1\n    double dp[MAX_N][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = -1;\n        }\n    }\n\n    // Calculate minimum distance\n    double result = min_distance(n, x, y, 0, 0);\n\n    // Print the result\n    printf(\"%.15f\\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum total distance traveled from checkpoint 1 to checkpoint N, considering the penalty for skipping checkpoints. The approach involves dynamic programming with memoization to explore all possible paths and calculate the minimum cost. Here's a step-by-step breakdown of the solution:", "question_id": "abc315_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, M, P;\n    scanf(\"%d %d %d\", &N, &M, &P);\n\n    // Calculate the number of full moon days\n    int full_moon_count = 0;\n    if (M <= N) {\n        full_moon_count = (N - M + 1) / P;\n    }\n\n    // Output the result\n    printf(\"%d\n\", full_moon_count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of days between day 1 and day N (inclusive) on which Takahashi can see a full moon. The full moons occur on day M and every P days after that. We can use a mathematical approach to find the number of full moon days within the given range.", "question_id": "abc318_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 101\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    bool grid[MAX][MAX] = {false};\n\n    for (int i = 0; i < N; i++) {\n        int A, B, C, D;\n        scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n\n        for (int x = A; x < B; x++) {\n            for (int y = C; y < D; y++) {\n                grid[x][y] = true;\n            }\n        }\n    }\n\n    int area = 0;\n    for (int x = 0; x < MAX; x++) {\n        for (int y = 0; y < MAX; y++) {\n            if (grid[x][y]) {\n                area++;\n            }\n        }\n    }\n\n    printf(\"%d\n\", area);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the area covered by one or more rectangular sheets on a coordinate plane. The key steps are:\n1. Parse the input to get the number of rectangles and their coordinates.\n2. Use a 2D array to represent the coordinate plane and mark the covered cells.\n3. Count the number of marked cells to get the total area covered by one or more sheets.\n4. Print the result.", "question_id": "abc318_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, D, P;\n    scanf(\"%d %d %d\", &N, &D, &P);\n\n    GArray *F = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        int fare;\n        scanf(\"%d\", &fare);\n        g_array_append_val(F, fare);\n    }\n\n    // Sort the fares in descending order\n    qsort(F->data, F->len, sizeof(int), (int (*)(const void *, const void *))strcmp);\n\n    int total_cost = 0;\n    int i = 0;\n\n    while (i < N) {\n        int pass_cost = 0;\n        int pass_days = 0;\n\n        // Calculate the cost and number of days for the current batch of passes\n        while (i < N && pass_cost + F->data[i] <= P) {\n            pass_cost += F->data[i];\n            pass_days++;\n            i++;\n        }\n\n        // If we can buy a full batch of passes, add the cost to total_cost\n        if (pass_days == D) {\n            total_cost += P;\n        } else {\n            // Otherwise, add the cost of the remaining days\n            total_cost += pass_cost;\n        }\n    }\n\n    printf(\"%d\\n\", total_cost);\n\n    g_array_free(F, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum cost for Takahashi's N-day train trip using either the regular fare or one-day passes. The key is to determine the optimal number of one-day passes to buy to minimize the total cost. Here's a step-by-step approach to solve it:", "question_id": "abc318_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 16\n#define MAX_VALUE 1000000000\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int graph[MAX_N][MAX_N];\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            scanf(\"%d\", &graph[i][j]);\n        }\n    }\n\n    int max_weight = 0;\n\n    for (int mask = 0; mask < (1 << (n * (n - 1) / 2)); mask++) {\n        int weight = 0;\n        int edge_count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (mask & (1 << edge_count)) {\n                    weight += graph[i][j];\n                }\n                edge_count++;\n            }\n        }\n        if (weight > max_weight) {\n            max_weight = weight;\n        }\n    }\n\n    printf(\"%d\n\", max_weight);\n\n    return 0;\n}", "reasoning": "The problem requires finding the maximum possible total weight of chosen edges in a weighted undirected complete graph such that the endpoints of the chosen edges are pairwise distinct. Given the constraints (2 \u2264 N \u2264 16), a brute-force approach to check all possible combinations of edges is feasible. Since N is small, we can use a bitmask to represent the set of chosen edges and iterate over all possible subsets of edges. For each subset, we calculate the total weight and keep track of the maximum weight encountered. This approach ensures that we explore all valid combinations and find the optimal solution.", "question_id": "abc318_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Use a hash table to store the count of each element and its last occurrence index\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *last_index = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    long long result = 0;\n\n    for (int i = 0; i < n; i++) {\n        // Get the count of the current element and its last occurrence index\n        int *c = (int *)g_hash_table_lookup(count, GINT_TO_POINTER(A[i]));\n        int *l = (int *)g_hash_table_lookup(last_index, GINT_TO_POINTER(A[i]));\n\n        if (c == NULL) {\n            c = (int *)malloc(sizeof(int));\n            *c = 0;\n            l = (int *)malloc(sizeof(int));\n            *l = -1;\n        }\n\n        // If the element has been seen before, add the number of valid triples to the result\n        if (*l != -1) {\n            result += *l;\n        }\n\n        // Update the count and last occurrence index of the current element\n        (*c)++;\n        *l = i;\n\n        // Insert the updated count and last occurrence index back into the hash tables\n        g_hash_table_insert(count, GINT_TO_POINTER(A[i]), c);\n        g_hash_table_insert(last_index, GINT_TO_POINTER(A[i]), l);\n    }\n\n    // Output the result\n    printf(\"%lld\n\", result);\n\n    // Clean up\n    for (int i = 0; i < n; i++) {\n        free((int *)g_hash_table_lookup(count, GINT_TO_POINTER(A[i])));\n        free((int *)g_hash_table_lookup(last_index, GINT_TO_POINTER(A[i])));\n    }\n    g_hash_table_destroy(count);\n    g_hash_table_destroy(last_index);\n    free(A);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the number of triples (i, j, k) such that A_i = A_k, A_i != A_j, and 1 <= i < j < k <= N. Here's a step-by-step approach to achieve this:", "question_id": "abc318_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char result[n + 1];\n    memset(result, '-', sizeof(result));\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 1; j <= 9; j++) {\n            if (n % j == 0 && i % (n / j) == 0) {\n                result[i] = '0' + j;\n                break;\n            }\n        }\n    }\n\n    result[n] = '\\0';\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "reasoning": "The problem requires generating a string of length (N+1) based on the divisors of N between 1 and 9. For each position i in the string, if i is a multiple of N/j for any j in the range [1, 9], we need to find the smallest such j and use it as the digit at position i. If no such j exists, we use '-'. The solution involves iterating through each position and checking for the appropriate divisor.", "question_id": "abc319_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define N 3\n\nint is_valid_sequence(int *grid, int *sequence, int length) {\n    for (int i = 0; i < N; i++) {\n        if (sequence[i * 3] == sequence[i * 3 + 1] && sequence[i * 3 + 1] != sequence[i * 3 + 2]) return 0;\n        if (sequence[i] == sequence[i + N] && sequence[i + N] != sequence[i + 2 * N]) return 0;\n    }\n    if (sequence[0] == sequence[4] && sequence[4] != sequence[8]) return 0;\n    if (sequence[2] == sequence[4] && sequence[4] != sequence[6]) return 0;\n    return 1;\n}\n\nint main() {\n    int grid[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    int count = 0;\n    int total = 0;\n\n    int *sequence = (int *)malloc(N * N * sizeof(int));\n    for (int i = 0; i < N * N; i++) {\n        sequence[i] = i;\n    }\n\n    do {\n        int valid = 1;\n        for (int i = 0; i < N * N; i++) {\n            int row = sequence[i] / N;\n            int col = sequence[i] % N;\n            int value = grid[row][col];\n            if (i > 0 && value == grid[sequence[i - 1] / N][sequence[i - 1] % N]) {\n                valid = 0;\n                break;\n            }\n        }\n        if (valid) {\n            total++;\n            if (is_valid_sequence(grid, sequence, N * N)) {\n                count++;\n            }\n        }\n    } while (next_permutation(sequence, sequence + N * N));\n\n    double probability = (double)count / total;\n    printf(\"%.15f\n\", probability);\n\n    free(sequence);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the probability that Takahashi sees all the numbers in the 3x3 grid without getting disappointed. This involves checking all possible permutations of the numbers in the grid and counting the valid sequences that do not contain any lines (horizontal, vertical, or diagonal) where the first two squares contain the same number, but the last square contains a different number.", "question_id": "abc319_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint canFit(int *words, int n, int m, int width) {\n    int lines = 1;\n    int currentWidth = 0;\n    for (int i = 0; i < n; i++) {\n        if (words[i] > width) return 0; // Word is too long to fit in any line\n        if (currentWidth + words[i] + (i > 0 ? 1 : 0) > width) {\n            lines++;\n            currentWidth = words[i];\n        } else {\n            currentWidth += words[i] + (i > 0 ? 1 : 0);\n        }\n    }\n    return lines <= m;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int *words = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &words[i]);\n    }\n\n    int left = 0, right = 1000000000000000000, result = 0;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (canFit(words, n, m, mid)) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    printf(\"%d\n\", result);\n\n    free(words);\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum window width that can fit the given sentence into M or fewer lines. This involves checking different possible window widths and determining if the sentence can fit within those widths. The key is to use a binary search approach to efficiently find the minimum width. We will use a helper function to check if a given width can fit the sentence into M or fewer lines. This function will simulate the line wrapping process and count the number of lines required.", "question_id": "abc319_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Define a structure to represent the state of Takahashi\ntypedef struct {\n    int stop;\n    long long time;\n} State;\n\n// Define a comparison function for the priority queue\nstatic gint compare_states(gconstpointer a, gconstpointer b) {\n    State *state1 = (State *)a;\n    State *state2 = (State *)b;\n    return state1->time - state2->time;\n}\n\nint main() {\n    int n, x, y;\n    scanf(\"%d %d %d\", &n, &x, &y);\n\n    // Read bus stop times and intervals\n    GArray *bus_times = g_array_new(FALSE, FALSE, sizeof(State));\n    for (int i = 0; i < n - 1; i++) {\n        int p, t;\n        scanf(\"%d %d\", &p, &t);\n        g_array_append_val(bus_times, (State){i + 1, t});\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n\n    // Process each query\n    for (int i = 0; i < q; i++) {\n        long long q_i;\n        scanf(\"%lld\", &q_i);\n\n        // Initialize the priority queue with the starting time at bus stop 1\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(q_i + x));\n\n        // Process the priority queue until we reach bus stop N\n        while (g_queue_get_length(queue) > 0) {\n            State current = *(State *)g_queue_pop_head(queue);\n            if (current.stop == n) {\n                printf(\"%lld\\n\", current.time);\n                break;\n            }\n\n            // Check the next bus departure time\n            State next = bus_times->data[current.stop - 1];\n            if (current.time % next.time == 0) {\n                g_queue_push_tail(queue, GINT_TO_POINTER(current.time + next.time));\n            } else {\n                g_queue_push_tail(queue, GINT_TO_POINTER((current.time / next.time + 1) * next.time));\n            }\n        }\n\n        // Clean up the priority queue\n        g_queue_free(queue);\n    }\n\n    // Clean up the bus times array\n    g_array_free(bus_times, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate Takahashi's movements and calculate the earliest arrival time at Aoki's house for each query. We can use a priority queue (min-heap) to keep track of the next possible times Takahashi can arrive at each bus stop. Here's a step-by-step breakdown of the solution:", "question_id": "abc319_e"}
{"solution": "#include <stdio.h>\n\nint main() {\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n\n    long long result = (long long)pow(A, B) + (long long)pow(B, A);\n\n    printf(\"%lld\\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate two values: A^B and B^A, and then sum them up. Given the constraints, we can directly compute these values using the power operator in C. Since the constraints are relatively small (A and B are between 2 and 9), we don't need to worry about overflow issues for the given range of inputs. We will read the values of A and B from standard input, compute the required values, and print the result.", "question_id": "abc320_a"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\n// Function to check if a substring is a palindrome\nbool is_palindrome(char *str, int start, int end) {\n    while (start < end) {\n        if (str[start] != str[end]) {\n            return false;\n        }\n        start++;\n        end--;\n    }\n    return true;\n}\n\nint main() {\n    char S[101];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n    int max_length = 1;\n\n    // Iterate through all possible substrings\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            if (is_palindrome(S, i, j)) {\n                int length = j - i + 1;\n                if (length > max_length) {\n                    max_length = length;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\n\", max_length);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum length of a contiguous substring that is a palindrome in a given string S. We can achieve this by iterating through all possible substrings of S and checking if each substring is a palindrome. If it is, we update the maximum length accordingly. To efficiently check if a substring is a palindrome, we can use a helper function that compares characters from the start and end of the substring, moving towards the center.", "question_id": "abc320_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int M;\n    scanf(\"%d\", &M);\n\n    char S1[M+1], S2[M+1], S3[M+1];\n    scanf(\"%s\", S1);\n    scanf(\"%s\", S2);\n    scanf(\"%s\", S3);\n\n    int result = -1;\n\n    // Iterate through all possible characters\n    for (int i = 0; i < M; i++) {\n        int t1 = (i + 1) % M;\n        int t2 = (i + 1) % M;\n        int t3 = (i + 1) % M;\n\n        // Check if all three characters match at the same time\n        if (S1[t1] == S2[t2] && S2[t2] == S3[t3]) {\n            if (result == -1 || t1 > result) {\n                result = t1;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum time required to stop all three reels so that they display the same character. Here's a step-by-step approach to achieve this:", "question_id": "abc320_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n#define MAXM 200005\n\ntypedef struct {\n    int x, y;\n    bool determined;\n} Person;\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Person people[MAXN];\n    for (int i = 0; i < N; i++) {\n        people[i].x = 0;\n        people[i].y = 0;\n        people[i].determined = false;\n    }\n\n    GHashTable *constraints = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < M; i++) {\n        int A, B, X, Y;\n        scanf(\"%d %d %d %d\", &A, &B, &X, &Y);\n\n        GArray *constraint = g_array_new(FALSE, FALSE, sizeof(int));\n        g_array_append_val(constraint, A);\n        g_array_append_val(constraint, B);\n        g_array_append_val(constraint, X);\n        g_array_append_val(constraint, Y);\n\n        g_hash_table_insert(constraints, GINT_TO_POINTER(A), constraint);\n        g_hash_table_insert(constraints, GINT_TO_POINTER(B), constraint);\n    }\n\n    for (int i = 1; i <= N; i++) {\n        if (!people[i - 1].determined) {\n            GArray *constraint = g_hash_table_lookup(constraints, GINT_TO_POINTER(i));\n            if (constraint != NULL) {\n                int A = g_array_index(constraint, int, 0);\n                int B = g_array_index(constraint, int, 1);\n                int X = g_array_index(constraint, int, 2);\n                int Y = g_array_index(constraint, int, 3);\n\n                if (!people[A - 1].determined) {\n                    people[A - 1].x = people[B - 1].x + X;\n                    people[A - 1].y = people[B - 1].y + Y;\n                    people[A - 1].determined = true;\n                } else {\n                    people[B - 1].x = people[A - 1].x - X;\n                    people[B - 1].y = people[A - 1].y - Y;\n                    people[B - 1].determined = true;\n                }\n            } else {\n                printf(\"undecidable\n\");\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (people[i].determined) {\n            printf(\"%d %d\n\", people[i].x, people[i].y);\n        } else {\n            printf(\"undecidable\n\");\n        }\n    }\n\n    g_hash_table_destroy(constraints);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the coordinates of each person on a coordinate plane based on the given relative positions. Here's a step-by-step approach to solve it using C and GLib data structures:", "question_id": "abc320_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MAX_N 200000\n#define MAX_M 200000\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashTable *people = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GQueue *events = g_queue_new();\n\n    for (int i = 0; i < M; i++) {\n        int T, W, S;\n        scanf(\"%d %d %d\", &T, &W, &S);\n\n        g_queue_push_tail(events, GINT_TO_POINTER(T));\n        g_queue_push_tail(events, GINT_TO_POINTER(T + S));\n        g_queue_push_tail(events, GINT_TO_POINTER(W));\n    }\n\n    int *noodles = (int *)calloc(N + 1, sizeof(int));\n\n    int time = 0;\n    while (!g_queue_is_empty(events)) {\n        int current_time = GPOINTER_TO_INT(g_queue_pop_head(events));\n\n        while (time < current_time) {\n            int *person = g_hash_table_lookup(people, GINT_TO_POINTER(time % N + 1));\n            if (person != NULL) {\n                noodles[*person] += 1;\n            }\n            time++;\n        }\n\n        int W = GPOINTER_TO_INT(g_queue_pop_head(events));\n        int person = GPOINTER_TO_INT(g_queue_pop_head(events));\n\n        if (person != 0) {\n            g_hash_table_insert(people, GINT_TO_POINTER(person), GINT_TO_POINTER(person));\n        }\n    }\n\n    for (int i = 1; i <= N; i++) {\n        printf(\"%d\n\", noodles[i]);\n    }\n\n    g_hash_table_destroy(people);\n    g_queue_free(events);\n    free(noodles);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of noodles being flown down and people stepping out and back into the row. We will use a combination of data structures to efficiently manage the state of the people in the row and the noodles being flown down. Here's a step-by-step breakdown of the approach:", "question_id": "abc320_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    char num[6];  // To store the number as a string, ensuring space for up to 5 digits and a null terminator\n    sprintf(num, \"%d\", N);\n\n    int length = strlen(num);\n\n    // Check if the number is a 321-like Number\n    bool is321Like = true;\n    for (int i = 0; i < length - 1; i++) {\n        if (num[i] <= num[i + 1]) {\n            is321Like = false;\n            break;\n        }\n    }\n\n    // Output the result\n    if (is321Like) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine if a given number is a 321-like Number, we need to check if its digits are strictly decreasing from left to right. This involves converting the number to a string, iterating through the digits, and comparing each digit with the next one to ensure the condition is met.", "question_id": "abc321_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, X;\n    scanf(\"%d %d\", &N, &X);\n\n    int scores[N-1];\n    for (int i = 0; i < N-1; i++) {\n        scanf(\"%d\", &scores[i]);\n    }\n\n    g_array_sort(G_ARRAY_FROM_POINTER(scores, int, N-1), (GCompareFunc)g_int_compare);\n\n    int sum = 0;\n    for (int i = 1; i < N-1; i++) {\n        sum += scores[i];\n    }\n\n    int min_score_needed = X - sum;\n    if (min_score_needed < 0) {\n        printf(\"-1\n\");\n    } else if (min_score_needed > 100) {\n        printf(\"-1\n\");\n    } else {\n        printf(\"%d\n\", min_score_needed);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum score required in the last round to achieve a final grade of at least X. Here's a step-by-step approach to solve it:", "question_id": "abc321_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 1000000\n\nGQueue *queue;\n\nvoid generate(int n, int last_digit) {\n    if (n == 0) {\n        char str[MAX];\n        sprintf(str, \"%d\", last_digit);\n        g_queue_push_tail(queue, g_strdup(str));\n        return;\n    }\n    for (int i = last_digit - 1; i >= 0; i--) {\n        char str[MAX];\n        sprintf(str, \"%d%d\", last_digit, i);\n        g_queue_push_tail(queue, g_strdup(str));\n        generate(n - 1, i);\n    }\n}\n\nint main() {\n    int K;\n    scanf(\"%d\", &K);\n\n    queue = g_queue_new();\n\n    for (int i = 9; i >= 1; i--) {\n        generate(1, i);\n    }\n\n    GList *node = g_list_nth(g_queue_get_elements(queue), K - 1);\n    printf(\"%s\n\", (char *)node->data);\n\n    g_queue_free_full(queue, g_free);\n\n    return 0;\n}", "reasoning": "To find the K-th smallest 321-like number, we need to generate 321-like numbers in ascending order and keep track of the K-th number. A 321-like number is a number where the digits are strictly decreasing. This problem can be approached by generating numbers with decreasing digits and checking if they are valid 321-like numbers. We can use a recursive approach to generate these numbers and a queue to store them in ascending order. The queue will help us efficiently find the K-th smallest number.", "question_id": "abc321_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m, p;\n    scanf(\"%d %d %d\", &n, &m, &p);\n\n    int *main_dishes = (int *)malloc(n * sizeof(int));\n    int *side_dishes = (int *)malloc(m * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &main_dishes[i]);\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &side_dishes[i]);\n    }\n\n    qsort(main_dishes, n, sizeof(int), compare);\n    qsort(side_dishes, m, sizeof(int), compare);\n\n    int total_price = 0;\n    int i = 0, j = 0;\n\n    while (i < n && j < m) {\n        int sum = main_dishes[i] + side_dishes[j];\n        total_price += (sum <= p) ? sum : p;\n\n        if (sum <= p) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    printf(\"%d\n\", total_price);\n\n    free(main_dishes);\n    free(side_dishes);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the total price of all possible set meals where each set meal consists of one main dish and one side dish. The price of a set meal is defined as the minimum of the sum of the prices of the main dish and side dish, and a constant P. We can achieve this by iterating through all combinations of main dishes and side dishes, calculating the price for each combination, and summing them up. Given the constraints, a direct approach would be too slow, so we need an efficient solution. One efficient way is to sort the main dishes and side dishes, and then use a two-pointer technique to find the minimum price for each combination.", "question_id": "abc321_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int N, X, K;\n        scanf(\"%d %d %d\", &N, &X, &K);\n\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(X));\n\n        int level = 0;\n        int count = 0;\n        bool found = false;\n\n        while (!g_queue_is_empty(queue)) {\n            int size = g_queue_get_length(queue);\n\n            if (level == K) {\n                count = size;\n                found = true;\n                break;\n            }\n\n            for (int i = 0; i < size; i++) {\n                int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n                int left = 2 * current;\n                int right = 2 * current + 1;\n\n                if (left <= N) {\n                    g_queue_push_tail(queue, GINT_TO_POINTER(left));\n                }\n\n                if (right <= N) {\n                    g_queue_push_tail(queue, GINT_TO_POINTER(right));\n                }\n            }\n\n            level++;\n        }\n\n        if (!found) {\n            count = 0;\n        }\n\n        printf(\"%d\\n\", count);\n\n        g_queue_free(queue);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of vertices in a tree whose distance from a given vertex X is K. The tree is defined such that for each vertex i (2 <= i <= N), there is an edge connecting vertex i and vertex floor(i/2). This structure forms a binary tree. To find the number of vertices at distance K from vertex X, we can use a level-order traversal (BFS) approach. We will maintain a queue to traverse the tree level by level and count the vertices at each level. When we reach level K, we will have the desired count.", "question_id": "abc321_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    // Iterate through the string to find the first occurrence of 'ABC'\n    for (int i = 0; i <= n - 3; i++) {\n        if (s[i] == 'A' && s[i + 1] == 'B' && s[i + 2] == 'C') {\n            printf(\"%d\n\", i + 1);  // +1 because positions are 1-based\n            return 0;\n        }\n    }\n\n    // If 'ABC' is not found, print -1\n    printf(\"-1\n\");\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the first occurrence of the substring 'ABC' in the given string S. We can do this by iterating through the string and checking each triplet of characters to see if they form 'ABC'. If we find a match, we return the starting index of that triplet. If we finish iterating through the string without finding 'ABC', we return -1.", "question_id": "abc322_a"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    char S[N+1], T[M+1];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int is_prefix = 1, is_suffix = 1;\n\n    // Check if S is a prefix of T\n    for (int i = 0; i < N; i++) {\n        if (T[i] != S[i]) {\n            is_prefix = 0;\n            break;\n        }\n    }\n\n    // Check if S is a suffix of T\n    for (int i = 0; i < N; i++) {\n        if (T[M - N + i] != S[i]) {\n            is_suffix = 0;\n            break;\n        }\n    }\n\n    // Determine the result based on the conditions\n    int result = 0;\n    if (is_prefix && is_suffix) {\n        result = 0;\n    } else if (is_prefix) {\n        result = 1;\n    } else if (is_suffix) {\n        result = 2;\n    } else {\n        result = 3;\n    }\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to check if string S is a prefix, suffix, or neither of string T. Here's a step-by-step approach to achieve this:", "question_id": "abc322_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Read the days on which fireworks are launched\n    GArray *fireworks_days = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < m; i++) {\n        int day;\n        scanf(\"%d\", &day);\n        g_array_append_val(fireworks_days, day);\n    }\n\n    // Create a hash table to store the days on which fireworks are launched\n    GHashTable *fireworks_map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < m; i++) {\n        int day = g_array_index(fireworks_days, int, i);\n        g_hash_table_insert(fireworks_map, GINT_TO_POINTER(day), GINT_TO_POINTER(1));\n    }\n\n    // For each day of the festival, find the next day on which fireworks are launched\n    for (int i = 1; i <= n; i++) {\n        if (g_hash_table_lookup(fireworks_map, GINT_TO_POINTER(i))) {\n            printf(\"0\\n\");\n        } else {\n            int next_day = i + 1;\n            while (g_hash_table_lookup(fireworks_map, GINT_TO_POINTER(next_day)) == NULL) {\n                next_day++;\n            }\n            printf(\"%d\\n\", next_day - i);\n        }\n    }\n\n    // Clean up\n    g_array_free(fireworks_days, TRUE);\n    g_hash_table_destroy(fireworks_map);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine how many days later fireworks will be launched for the first time on or after each day of the festival. The fireworks are launched on specific days given in the input. For each day, we need to find the next day on which fireworks are launched. If fireworks are launched on the current day, the answer is 0. We can use a hash table to store the days on which fireworks are launched and then use it to quickly find the next launch day for each day of the festival.", "question_id": "abc322_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define GRID_SIZE 4\n\n// Function to check if a polyomino can be placed at a given position\nbool can_place_polyomino(char grid[GRID_SIZE][GRID_SIZE], char polyomino[GRID_SIZE][GRID_SIZE], int x, int y, int rotation) {\n    // Placeholder for polyomino rotation logic\n    // For simplicity, assume rotation is handled elsewhere\n    // Check if the polyomino fits within the grid boundaries\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            if (polyomino[i][j] == '#' && (x + i >= GRID_SIZE || y + j >= GRID_SIZE || grid[x + i][y + j] != '.')) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n// Function to place a polyomino on the grid\nvoid place_polyomino(char grid[GRID_SIZE][GRID_SIZE], char polyomino[GRID_SIZE][GRID_SIZE], int x, int y) {\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            if (polyomino[i][j] == '#') {\n                grid[x + i][y + j] = '#';\n            }\n        }\n    }\n}\n\n// Function to remove a polyomino from the grid\nvoid remove_polyomino(char grid[GRID_SIZE][GRID_SIZE], char polyomino[GRID_SIZE][GRID_SIZE], int x, int y) {\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            if (polyomino[i][j] == '#') {\n                grid[x + i][y + j] = '.';\n            }\n        }\n    }\n}\n\n// Function to solve the puzzle\nbool solve_puzzle(char grid[GRID_SIZE][GRID_SIZE], char polyominoes[3][GRID_SIZE][GRID_SIZE], int index) {\n    if (index == 3) {\n        return true; // All polyominoes placed successfully\n    }\n\n    for (int x = 0; x <= GRID_SIZE - 1; x++) {\n        for (int y = 0; y <= GRID_SIZE - 1; y++) {\n            if (can_place_polyomino(grid, polyominoes[index], x, y, 0)) {\n                place_polyomino(grid, polyominoes[index], x, y);\n                if (solve_puzzle(grid, polyominoes, index + 1)) {\n                    return true;\n                }\n                remove_polyomino(grid, polyominoes[index], x, y);\n            }\n        }\n    }\n\n    return false; // No valid placement found\n}\n\nint main() {\n    char grid[GRID_SIZE][GRID_SIZE];\n    char polyominoes[3][GRID_SIZE][GRID_SIZE];\n\n    // Read the grid\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            scanf(\"%c\", &grid[i][j]);\n        }\n    }\n\n    // Read the polyominoes\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            for (int k = 0; k < GRID_SIZE; k++) {\n                scanf(\"%c\", &polyominoes[i][j][k]);\n            }\n        }\n    }\n\n    // Solve the puzzle\n    if (solve_puzzle(grid, polyominoes, 0)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can place three given polyominoes on a 4x4 grid such that all conditions are met. The conditions are: all squares of the grid are covered, the polyominoes do not overlap, do not stick out of the grid, and can be freely translated and rotated but not flipped over. Here's a step-by-step approach to solve the problem:", "question_id": "abc322_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 100\n#define MAX_K 5\n#define MAX_C 1000000000\n\ntypedef struct {\n    int cost;\n    int effects[MAX_K];\n} Plan;\n\nint compare(const void *a, const void *b) {\n    Plan *p1 = (Plan *)a;\n    Plan *p2 = (Plan *)b;\n    int diff = 0;\n    for (int i = 0; i < MAX_K; i++) {\n        diff += p1->effects[i] - p2->effects[i];\n    }\n    return (diff * MAX_C + p2->cost) - (diff * MAX_C + p1->cost);\n}\n\nint main() {\n    int N, K, P;\n    scanf(\"%d %d %d\", &N, &K, &P);\n\n    Plan plans[MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &plans[i].cost);\n        for (int j = 0; j < K; j++) {\n            scanf(\"%d\", &plans[i].effects[j]);\n        }\n    }\n\n    int current_values[MAX_K] = {0};\n    int total_cost = 0;\n\n    GArray *queue = g_array_new(FALSE, FALSE, sizeof(Plan));\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(queue, plans[i]);\n    }\n\n    g_array_sort(queue, compare);\n\n    while (g_array_get_length(queue) > 0) {\n        Plan plan = g_array_index(queue, Plan, 0);\n        g_array_remove_range(queue, 0, 1);\n\n        bool can_apply = true;\n        for (int j = 0; j < K; j++) {\n            if (current_values[j] + plan.effects[j] < P) {\n                can_apply = false;\n                break;\n            }\n        }\n\n        if (can_apply) {\n            for (int j = 0; j < K; j++) {\n                current_values[j] += plan.effects[j];\n            }\n            total_cost += plan.cost;\n        }\n\n        if (current_values[0] >= P && current_values[1] >= P && current_values[2] >= P) {\n            break;\n        }\n    }\n\n    if (current_values[0] >= P && current_values[1] >= P && current_values[2] >= P) {\n        printf(\"%d\\n\", total_cost);\n    } else {\n        printf(\"-1\\n\");\n    }\n\n    g_array_free(queue, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if it's possible to raise all K parameters to at least P using the given development plans, and if so, find the minimum total cost required. The problem can be approached using a greedy algorithm with a priority queue (min-heap) to always select the development plan that provides the highest value increase per unit cost. Here's a step-by-step breakdown of the approach:\n\n1. **Input Reading**: Read the number of development plans (N), the number of parameters (K), and the target value (P). Then, read the cost and effect of each development plan.\n\n2. **Initialization**: Initialize a priority queue to store the development plans based on their value increase per unit cost. Also, initialize an array to keep track of the current values of the parameters and a variable to store the total cost.\n\n3. **Processing**: While there are development plans in the queue and the parameters are not all at least P:\n   - Extract the development plan with the highest value increase per unit cost from the queue.\n   - Apply the development plan to the parameters and update their values.\n   - Add the cost of the development plan to the total cost.\n   - If the parameters are now all at least P, break out of the loop.\n\n4. **Output**: If the parameters are all at least P, print the total cost. Otherwise, print -1.\n\nThis approach ensures that we always use the most cost-effective development plans first, leading to the minimum total cost if a solution exists.", "question_id": "abc322_e"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[17];  // String of length 16 + 1 for the null terminator\n    scanf(\"%s\", S);\n\n    bool all_zeros = true;\n\n    // Check characters at even positions (indices 1, 3, 5, ..., 15)\n    for (int i = 1; i < 16; i += 2) {\n        if (S[i] != '0') {\n            all_zeros = false;\n            break;\n        }\n    }\n\n    // Print the result\n    if (all_zeros) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "The problem requires checking if the i-th character of a given string S is 0 for every even number i from 2 through 16. To solve this, we need to iterate through the string and check the characters at even positions (indices 1, 3, 5, ..., 15). If all these characters are 0, we print 'Yes'; otherwise, we print 'No'. The input is a string of length 16, and the output is a single character ('Yes' or 'No').", "question_id": "abc323_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    int player1 = GPOINTER_TO_INT(*(int *)a);\n    int player2 = GPOINTER_TO_INT(*(int *)b);\n    int wins1 = GPOINTER_TO_INT(g_hash_table_lookup(wins, GINT_TO_POINTER(player1)));\n    int wins2 = GPOINTER_TO_INT(g_hash_table_lookup(wins, GINT_TO_POINTER(player2)));\n    if (wins1 != wins2) {\n        return wins2 - wins1;\n    } else {\n        return player1 - player2;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *wins = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 1; i <= n; i++) {\n        g_hash_table_insert(wins, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n    }\n\n    char **results = (char **)malloc(n * sizeof(char *));\n    for (int i = 0; i < n; i++) {\n        results[i] = (char *)malloc(n + 1);\n        scanf(\"%s\", results[i]);\n        for (int j = 0; j < n; j++) {\n            if (results[i][j] == 'o') {\n                int *w = (int *)g_hash_table_lookup(wins, GINT_TO_POINTER(j + 1));\n                (*w)++;\n            }\n        }\n    }\n\n    int *players = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        players[i] = i + 1;\n    }\n\n    qsort(players, n, sizeof(int), compare);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", players[i]);\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < n; i++) {\n        free(results[i]);\n    }\n    free(results);\n    free(players);\n    g_hash_table_destroy(wins);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of wins for each player based on the given match results. We can use a GHashTable to keep track of the number of wins for each player. Then, we can sort the players based on their number of wins and player number in descending order. Finally, we print the player numbers in the sorted order.", "question_id": "abc323_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Read problem scores\n    int *scores = (int *)malloc(m * sizeof(int));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &scores[i]);\n    }\n\n    // Read player solved problems status\n    char **status = (char **)malloc(n * sizeof(char *));\n    for (int i = 0; i < n; i++) {\n        status[i] = (char *)malloc(m * sizeof(char));\n        scanf(\" %s\", status[i]);\n    }\n\n    // Calculate current total scores for each player\n    int *current_scores = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        current_scores[i] = 0;\n        for (int j = 0; j < m; j++) {\n            if (status[i][j] == 'o') {\n                current_scores[i] += scores[j] + (i + 1);\n            }\n        }\n    }\n\n    // Calculate the minimum number of problems each player needs to solve to exceed all others\n    for (int i = 0; i < n; i++) {\n        int max_needed = 0;\n        for (int j = 0; j < n; j++) {\n            if (current_scores[j] > current_scores[i]) {\n                int needed = (current_scores[j] - current_scores[i] + 99) / 100; // Round up\n                if (needed > max_needed) {\n                    max_needed = needed;\n                }\n            }\n        }\n        printf(\"%d\\n\", max_needed);\n    }\n\n    // Free allocated memory\n    free(scores);\n    for (int i = 0; i < n; i++) {\n        free(status[i]);\n    }\n    free(status);\n    free(current_scores);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of problems each player must solve to exceed the total scores of all other players. Here's a step-by-step approach to achieve this:", "question_id": "abc323_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *sizes = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *counts = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int size, count;\n        scanf(\"%d %d\", &size, &count);\n        g_array_append_val(sizes, size);\n        g_array_append_val(counts, count);\n    }\n\n    qsort(sizes->data, sizes->len, sizeof(int), compare);\n\n    int result = 0;\n\n    for (int i = 0; i < sizes->len; i++) {\n        int size = g_array_index(sizes, int, i);\n        int count = g_array_index(counts, int, i);\n\n        while (count > 1) {\n            count -= 2;\n            result++;\n        }\n\n        if (count == 1) {\n            result++;\n        }\n    }\n\n    printf(\"%d\n\", result);\n\n    g_array_free(sizes, TRUE);\n    g_array_free(counts, TRUE);\n\n    return 0;\n}", "reasoning": "The problem involves minimizing the number of slimes by repeatedly synthesizing them. The key insight is that the number of slimes can be reduced by repeatedly pairing and synthesizing slimes of the same size. To minimize the number of slimes, we should prioritize pairing and synthesizing slimes of the smallest sizes first. This approach ensures that we reduce the number of slimes as efficiently as possible.", "question_id": "abc323_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, X;\n    scanf(\"%d %d\", &N, &X);\n\n    GArray *times = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        int T;\n        scanf(\"%d\", &T);\n        g_array_append_val(times, T);\n    }\n\n    int total_time = 0;\n    for (int i = 0; i < N; i++) {\n        total_time += g_array_index(times, int, i);\n    }\n\n    int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    int x = total_time;\n    int y = N;\n    int g = gcd(x, y);\n    x /= g;\n    y /= g;\n\n    int result = 0;\n    for (int i = 0; i < N; i++) {\n        int T = g_array_index(times, int, i);\n        if ((X + 0.5) % T == 0) {\n            result = (result + y * (x * T / 2)) % MOD;\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_array_free(times, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the probability that song 1 is being played at time (X + 0.5) seconds after time 0. This involves understanding the random nature of song selection and the periodicity of the playlist. Here's a step-by-step approach to solving the problem:", "question_id": "abc323_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    bool allEqual = true;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] != arr[0]) {\n            allEqual = false;\n            break;\n        }\n    }\n\n    if (allEqual) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    free(arr);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if all given integers are equal. The approach is straightforward: read the integers into an array and then check if all elements are the same. We can use a loop to compare each element with the first element. If any element is different, we print 'No' and exit. If all elements are the same, we print 'Yes'. This approach ensures we handle all constraints and edge cases effectively.", "question_id": "abc324_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long long N;\n    scanf(\"%lld\", &N);\n\n    while (N % 2 == 0) {\n        N /= 2;\n    }\n\n    while (N % 3 == 0) {\n        N /= 3;\n    }\n\n    if (N == 1) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine if a given integer N can be expressed as 2^x * 3^y, we need to repeatedly divide N by 2 and 3 as long as it is divisible by these numbers. If after these divisions, the resulting number is 1, then N can be expressed as 2^x * 3^y. Otherwise, it cannot.", "question_id": "abc324_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to check if two strings are equal\nbool are_equal(const char *s1, const char *s2) {\n    return strcmp(s1, s2) == 0;\n}\n\n// Function to check if s2 is obtained by inserting one character into s1\nbool is_insertion(const char *s1, const char *s2) {\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    if (len2 != len1 + 1) return false;\n    for (int i = 0; i < len2; i++) {\n        if (i == len1) return true;\n        if (s1[i] != s2[i]) return false;\n    }\n    return true;\n}\n\n// Function to check if s2 is obtained by deleting one character from s1\nbool is_deletion(const char *s1, const char *s2) {\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    if (len1 != len2 + 1) return false;\n    for (int i = 0, j = 0; i < len1; i++, j++) {\n        if (s1[i] != s2[j]) {\n            i++;\n        }\n        if (i == len1 && j == len2) return true;\n    }\n    return false;\n}\n\n// Function to check if s2 is obtained by substituting one character in s1\nbool is_substitution(const char *s1, const char *s2) {\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    if (len1 != len2) return false;\n    int diff = 0;\n    for (int i = 0; i < len1; i++) {\n        if (s1[i] != s2[i]) {\n            diff++;\n            if (diff > 1) return false;\n        }\n    }\n    return diff == 1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char T_prime[500001];\n    scanf(\"%s\", T_prime);\n\n    GArray *indices = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        char S[500001];\n        scanf(\"%s\", S);\n\n        if (are_equal(S, T_prime) || is_insertion(S, T_prime) || is_deletion(S, T_prime) || is_substitution(S, T_prime)) {\n            g_array_append_val(indices, i + 1);\n        }\n    }\n\n    printf(\"%d\n\", indices->len);\n    for (int i = 0; i < indices->len; i++) {\n        printf(\"%d\", g_array_index(indices, int, i));\n        if (i < indices->len - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    g_array_free(indices, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine which strings from the given list could be transformed into the string T' through one of the four allowed operations: equality, insertion, deletion, or substitution of a single character. We will use a combination of string comparison and hash tables to efficiently check each condition for each string in the list.", "question_id": "abc324_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nbool is_perfect_square(long long num) {\n    long long root = (long long)sqrt(num);\n    return root * root == num;\n}\n\nvoid permute(char *str, int l, int r, GHashTable *set) {\n    if (l == r) {\n        long long num = atoll(str);\n        if (is_perfect_square(num)) {\n            g_hash_table_add(set, GINT_TO_POINTER(num), GINT_TO_POINTER(1));\n        }\n    } else {\n        for (int i = l; i <= r; i++) {\n            char temp = str[l];\n            str[l] = str[i];\n            str[i] = temp;\n\n            permute(str, l + 1, r, set);\n\n            temp = str[l];\n            str[l] = str[i];\n            str[i] = temp;\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char str[13];\n    scanf(\"%s\", str);\n\n    GHashTable *set = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    permute(str, 0, n - 1, set);\n\n    int result = g_hash_table_size(set);\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(set);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find all permutations of the given string S and check if the resulting numbers are perfect squares. Here's a step-by-step approach to achieve this:", "question_id": "abc324_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_LEN 500000\n\nint main() {\n    int n;\n    char t[MAX_LEN + 1];\n    scanf(\"%d %s\", &n, t);\n\n    GArray *strings = g_array_new(FALSE, FALSE, sizeof(char *));\n    for (int i = 0; i < n; i++) {\n        char s[MAX_LEN + 1];\n        scanf(\"%s\", s);\n        g_array_append_val(strings, s);\n    }\n\n    long long count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            char *s1 = g_array_index(strings, char *, i);\n            char *s2 = g_array_index(strings, char *, j);\n            char *concat = malloc((strlen(s1) + strlen(s2) + 1) * sizeof(char));\n            strcpy(concat, s1);\n            strcat(concat, s2);\n\n            char *pos = concat;\n            for (int k = 0; t[k] != '\\0'; k++) {\n                pos = strchr(pos, t[k]);\n                if (pos == NULL) {\n                    break;\n                }\n                pos++;\n            }\n\n            if (t[strlen(t)] == '\\0') {\n                count++;\n            }\n\n            free(concat);\n        }\n    }\n\n    printf(\"%lld\\n\", count);\n\n    g_array_free(strings, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine how many pairs (i, j) of strings from the given list, when concatenated, contain the target string T as a subsequence. Here's a step-by-step approach to achieve this:", "question_id": "abc324_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    int to, beauty, cost;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    Edge *e1 = (Edge *)a, *e2 = (Edge *)b;\n    return (e2->beauty * e1->cost - e1->beauty * e2->cost);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    Edge edges[m];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &edges[i].to, &edges[i].beauty, &edges[i].cost);\n    }\n\n    qsort(edges, m, sizeof(Edge), compare);\n\n    double max_ratio = 0.0;\n    for (int i = 0; i < m; i++) {\n        if (edges[i].to == n) {\n            max_ratio = (double)edges[i].beauty / edges[i].cost;\n            break;\n        }\n    }\n\n    printf(\"%.15f\\n\", max_ratio);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum value of the ratio of total beauty to total cost for a path from vertex 1 to vertex N in a directed graph. The key observation is that we can traverse the graph and keep track of the maximum ratio encountered. Since the graph is directed and we are looking for the maximum ratio, we can use a greedy approach to always choose the edge with the highest beauty-to-cost ratio that leads us closer to vertex N.", "question_id": "abc324_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    // Read input\n    char S[11], T[11];  // 10 characters for the name + 1 for the null terminator\n    scanf(\"%s %s\", S, T);\n\n    // Print the formatted string\n    printf(\"%s san\n\", S);\n\n    return 0;\n}", "reasoning": "The problem requires us to take a person's surname and first name as input and print the surname followed by a space and the honorific 'san'. The input is straightforward, and we can solve it by reading the input strings, formatting them as required, and printing the result. We don't need any complex data structures or algorithms for this task.", "question_id": "abc325_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GArray *employees = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        int W, X;\n        scanf(\"%d %d\", &W, &X);\n\n        for (int j = 0; j < W; j++) {\n            int meeting_time = (X + 9) % 24;\n            if (meeting_time < 9 || meeting_time > 18) {\n                meeting_time += 24;\n            }\n            g_array_append_val(employees, meeting_time);\n        }\n    }\n\n    qsort(employees->data, employees->len, sizeof(int), compare);\n\n    int max_employees = 0;\n    int current_count = 0;\n    int i = 0;\n\n    while (i < employees->len) {\n        int current_time = g_array_index(employees, int, i);\n        int end_time = current_time + 1;\n\n        while (i < employees->len && g_array_index(employees, int, i) < end_time) {\n            current_count++;\n            i++;\n        }\n\n        if (current_count > max_employees) {\n            max_employees = current_count;\n        }\n    }\n\n    printf(\"%d\n\", max_employees);\n\n    g_array_free(employees, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the optimal meeting time that allows the maximum number of employees to participate. The key insight is that the meeting time should be chosen such that it is within the 9:00-18:00 time slot at each base. We can achieve this by iterating through all possible meeting times in the 24-hour format and counting the number of employees who can participate at each time. The optimal meeting time will be the one that maximizes this count.", "question_id": "abc325_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 1000\n\nvoid flood_fill(char grid[MAX][MAX], int visited[MAX][MAX], int x, int y, int H, int W) {\n    if (x < 0 || x >= H || y < 0 || y >= W || visited[x][y] || grid[x][y] == '.')\n        return;\n    visited[x][y] = 1;\n    flood_fill(grid, visited, x + 1, y, H, W);\n    flood_fill(grid, visited, x - 1, y, H, W);\n    flood_fill(grid, visited, x, y + 1, H, W);\n    flood_fill(grid, visited, x, y - 1, H, W);\n    flood_fill(grid, visited, x + 1, y + 1, H, W);\n    flood_fill(grid, visited, x - 1, y - 1, H, W);\n    flood_fill(grid, visited, x + 1, y - 1, H, W);\n    flood_fill(grid, visited, x - 1, y + 1, H, W);\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    char grid[MAX][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int visited[MAX][MAX] = {0};\n    int sensor_count = 0;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '#' && !visited[i][j]) {\n                sensor_count++;\n                flood_fill(grid, visited, i, j, H, W);\n            }\n        }\n    }\n\n    printf(\"%d\\n\", sensor_count);\n\n    return 0;\n}", "reasoning": "The problem requires identifying interacting sensors on a grid and counting them as a single sensor. To solve this, we can use a flood fill algorithm to mark connected sensors as visited. We will iterate through each cell in the grid, and if we encounter an unvisited sensor, we will perform a flood fill to mark all connected sensors as visited. Each time we start a new flood fill, it indicates a new sensor. We will use a queue to implement the flood fill algorithm.", "question_id": "abc325_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *products = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int t, d;\n        scanf(\"%d %d\", &t, &d);\n        g_array_append_val(products, t);\n        g_array_append_val(products, d);\n    }\n\n    g_array_sort(products, compare);\n\n    int count = 0;\n    int last_print_time = 0;\n\n    for (int i = 0; i < products->len; i += 2) {\n        int start_time = g_array_index(products, int, i);\n        int end_time = g_array_index(products, int, i + 1);\n\n        if (start_time >= last_print_time) {\n            count++;\n            last_print_time = end_time + 1;\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    g_array_free(products, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum number of products that can be printed on by the Keyence printer given the constraints. The printer can print on one product per unit of time and requires a charge time of 1 unit before it can print again. The products are labeled from 1 to N and enter and leave the printer's range at specific times T_i and D_i, respectively. We need to find an optimal strategy to maximize the number of products printed on.", "question_id": "abc325_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_CITIES 1000\n#define INF 1000000000\n\nint main() {\n    int n, a, b, c;\n    scanf(\"%d %d %d %d\", &n, &a, &b, &c);\n\n    int D[MAX_CITIES][MAX_CITIES];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &D[i][j]);\n        }\n    }\n\n    GHashTable *dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        g_hash_table_insert(dp, GINT_TO_POINTER(i), GINT_TO_POINTER(INF));\n    }\n\n    g_hash_table_insert(dp, GINT_TO_POINTER(0), GINT_TO_POINTER(0));\n\n    for (int i = 0; i < n; i++) {\n        int *current = g_hash_table_lookup(dp, GINT_TO_POINTER(i));\n        int current_time = GPOINTER_TO_INT(current);\n\n        for (int j = 0; j < n; j++) {\n            int car_time = current_time + D[i][j] * a;\n            int train_time = current_time + D[i][j] * b + c;\n\n            int *min_time = g_hash_table_lookup(dp, GINT_TO_POINTER(j));\n            int current_min_time = GPOINTER_TO_INT(min_time);\n\n            if (car_time < current_min_time) {\n                g_hash_table_insert(dp, GINT_TO_POINTER(j), GINT_TO_POINTER(car_time));\n            }\n\n            if (train_time < current_min_time) {\n                g_hash_table_insert(dp, GINT_TO_POINTER(j), GINT_TO_POINTER(train_time));\n            }\n        }\n    }\n\n    int *result = g_hash_table_lookup(dp, GINT_TO_POINTER(n - 1));\n    int min_time = GPOINTER_TO_INT(result);\n\n    printf(\"%d\n\", min_time);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum time to travel from city 1 to city N using either the company car or the train, and possibly switching between them. The key insight is to recognize that switching between transportation modes can be beneficial in certain cities. We can model this problem using dynamic programming with a state that includes the current city and the mode of transportation used to reach that city. We will use a hash table to store the minimum time required to reach each city with each mode of transportation. By iterating through all possible states, we can compute the minimum time to reach city N.", "question_id": "abc325_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Read section lengths\n    int *D = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &D[i]);\n    }\n\n    // Read sensor details\n    int L[2], C[2], K[2];\n    for (int i = 0; i < 2; i++) {\n        scanf(\"%d %d %d\", &L[i], &C[i], &K[i]);\n    }\n\n    // Initialize DP array\n    long long *dp = (long long *)calloc(100001, sizeof(long long));\n\n    // Fill DP array\n    for (int i = 1; i <= 100000; i++) {\n        dp[i] = LLONG_MAX;\n        for (int j = 0; j < 2; j++) {\n            if (i >= L[j] && K[j] > 0) {\n                dp[i] = MIN(dp[i], dp[i - L[j]] + C[j]);\n            }\n        }\n    }\n\n    // Calculate minimum cost to monitor all sections\n    long long total_cost = 0;\n    for (int i = 0; i < n; i++) {\n        if (dp[D[i]] == LLONG_MAX) {\n            printf(\"-1\n\");\n            free(D);\n            free(dp);\n            return 0;\n        }\n        total_cost += dp[D[i]];\n    }\n\n    // Output result\n    printf(\"%lld\n\", total_cost);\n\n    // Clean up\n    free(D);\n    free(dp);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if it's possible to monitor all sections of the conveyor belt using the given sensors and, if possible, find the minimum total cost of the necessary sensors. The approach involves using dynamic programming to keep track of the minimum cost to monitor sections up to a certain length. Here's a step-by-step breakdown of the solution:", "question_id": "abc325_f"}
{"solution": "#include <stdio.h>\n\nint main() {\n    int X, Y;\n    scanf(\"%d %d\", &X, &Y);\n\n    int diff = abs(X - Y);\n\n    if (diff <= 2) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine whether Takahashi uses the stairs or the elevator to move from floor X to floor Y, we need to check the absolute difference between X and Y. If the difference is 2 or less, he uses the stairs. Otherwise, he uses the elevator. The constraints ensure that X and Y are within the range of 1 to 100 and are not equal.", "question_id": "abc326_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nbool is_326_like(int num) {\n    int hundreds = num / 100;\n    int tens = (num / 10) % 10;\n    int ones = num % 10;\n    return (hundreds * tens == ones);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    while (!is_326_like(N)) {\n        N++;\n    }\n\n    printf(\"%d\n\", N);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the smallest 326-like number greater than or equal to the given integer N. A 326-like number is defined as a three-digit number where the product of the hundreds and tens digits equals the ones digit. Here's a step-by-step approach to solve the problem:", "question_id": "abc326_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    qsort(a, n, sizeof(int), compare);\n\n    int max_gifts = 0;\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n        for (int j = i; j < n; j++) {\n            if (a[j] - a[i] < m) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        max_gifts = (max_gifts > count) ? max_gifts : count;\n    }\n\n    printf(\"%d\n\", max_gifts);\n\n    free(a);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum number of gifts that can be acquired by choosing a half-open interval [x, x+M) on the number line. The key observation is that we can sort the gifts based on their coordinates and then use a sliding window approach to find the maximum number of gifts that can be acquired within any interval of length M.", "question_id": "abc326_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define N 5\n\ntypedef struct {\n    char grid[N][N];\n    int n;\n    char *R;\n    char *C;\n} Grid;\n\nbool is_valid(Grid *grid, int row, int col, char ch) {\n    for (int i = 0; i < grid->n; i++) {\n        if (grid->grid[row][i] == ch || grid->grid[i][col] == ch) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool solve(Grid *grid, int row, int col) {\n    if (row == grid->n) {\n        return true;\n    }\n\n    if (col == grid->n) {\n        return solve(grid, row + 1, 0);\n    }\n\n    if (grid->grid[row][col] != '.') {\n        return solve(grid, row, col + 1);\n    }\n\n    for (char ch = 'A'; ch <= 'C'; ch++) {\n        if (is_valid(grid, row, col, ch)) {\n            grid->grid[row][col] = ch;\n            if (solve(grid, row, col + 1)) {\n                return true;\n            }\n            grid->grid[row][col] = '.';\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Grid grid = {0};\n    grid.n = n;\n    scanf(\"%s\", grid.R);\n    scanf(\"%s\", grid.C);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            grid.grid[i][j] = '.';\n        }\n    }\n\n    if (!solve(&grid, 0, 0)) {\n        printf(\"No\n\");\n        return 0;\n    }\n\n    printf(\"Yes\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%c\", grid.grid[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}", "reasoning": "The problem requires filling an N x N grid with characters A, B, and C such that each row and column contains exactly one A, one B, and one C. Additionally, the first character of each row should match the corresponding character in string R, and the first character of each column should match the corresponding character in string C. To solve this, we can use a backtracking approach to try placing characters in the grid while ensuring the constraints are met. If we reach a point where we cannot place a character without violating the constraints, we backtrack and try a different placement.", "question_id": "abc326_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Initialize the DP array\n    int *dp = (int *)calloc(n, sizeof(int));\n    dp[0] = A[0];\n\n    // Fill the DP array\n    for (int i = 1; i < n; i++) {\n        dp[i] = (dp[i - 1] * 2 + A[i]) % MOD;\n    }\n\n    // Calculate the expected value\n    int expected_value = 0;\n    for (int i = 0; i < n; i++) {\n        expected_value = (expected_value + dp[i]) % MOD;\n    }\n\n    // Print the result\n    printf(\"%d\\n\", expected_value);\n\n    // Free the allocated memory\n    free(A);\n    free(dp);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the expected value of Aoki's salary modulo 998244353. The process involves iterating through the sequence A and calculating the expected value based on the rules provided. We can use dynamic programming to solve this problem efficiently.", "question_id": "abc326_e"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[100];\n    scanf(\"%s\", s);\n\n    for (int i = 0; i < n - 1; i++) {\n        if ((s[i] == 'a' && s[i + 1] == 'b') || (s[i] == 'b' && s[i + 1] == 'a')) {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"No\\n\");\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to check if there are any adjacent occurrences of the letters 'a' and 'b' in the given string S. Here's a step-by-step approach to achieve this:", "question_id": "abc327_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    long long B;\n    scanf(\"%lld\", &B);\n\n    // Initialize binary search bounds\n    long long low = 1;\n    long long high = B;\n\n    // Perform binary search\n    while (low <= high) {\n        long long mid = low + (high - low) / 2;\n        long long mid_pow_mid = mid * mid;\n\n        if (mid_pow_mid == B) {\n            // Found the solution\n            printf(\"%lld\n\", mid);\n            return 0;\n        } else if (mid_pow_mid < B) {\n            // Search in the right half\n            low = mid + 1;\n        } else {\n            // Search in the left half\n            high = mid - 1;\n        }\n    }\n\n    // If no solution is found\n    printf(\"-1\n\");\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exists a positive integer A such that A^A equals the given integer B. The constraints are quite large (1 <= B <= 10^18), so a brute-force approach is not feasible. Instead, we can use a binary search approach to efficiently find the solution if it exists.", "question_id": "abc327_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Initialize a 9x9 grid\n    int grid[9][9];\n\n    // Read the grid from input\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    // Function to check if a set of 9 numbers contains each number from 1 to 9 exactly once\n    bool isValidSet(int *set) {\n        GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (int i = 0; i < 9; i++) {\n            int num = set[i];\n            if (num < 1 || num > 9) return false;\n            int *existing = g_hash_table_lookup(count, GINT_TO_POINTER(num));\n            if (existing) return false;\n            g_hash_table_insert(count, GINT_TO_POINTER(num), GINT_TO_POINTER(1));\n        }\n        g_hash_table_destroy(count);\n        return true;\n    }\n\n    // Check rows\n    for (int i = 0; i < 9; i++) {\n        if (!isValidSet(grid[i])) {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    // Check columns\n    for (int j = 0; j < 9; j++) {\n        int column[9];\n        for (int i = 0; i < 9; i++) {\n            column[i] = grid[i][j];\n        }\n        if (!isValidSet(column)) {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    // Check 3x3 subgrids\n    for (int block = 0; block < 9; block++) {\n        int subgrid[9];\n        int k = 0;\n        for (int i = block / 3 * 3; i < block / 3 * 3 + 3; i++) {\n            for (int j = block % 3 * 3; j < block % 3 * 3 + 3; j++) {\n                subgrid[k++] = grid[i][j];\n            }\n        }\n        if (!isValidSet(subgrid)) {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\n\");\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to validate a 9x9 grid against three conditions. We will use GLib's data structures to efficiently manage and check these conditions. Here's a step-by-step breakdown of the solution:", "question_id": "abc327_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Initialize a hash table to track the parity of positions in sequence A\n    GHashTable *parity = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Process each pair (A_i, B_i)\n    for (int i = 0; i < M; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n\n        // Check if both A_i and B_i have the same parity\n        if (g_hash_table_contains(parity, GINT_TO_POINTER(A)) &&\n            g_hash_table_contains(parity, GINT_TO_POINTER(B)) &&\n            GPOINTER_TO_INT(g_hash_table_lookup(parity, GINT_TO_POINTER(A))) == GPOINTER_TO_INT(g_hash_table_lookup(parity, GINT_TO_POINTER(B)))) {\n            printf(\"No\n\");\n            g_hash_table_destroy(parity);\n            return 0;\n        }\n\n        // Update the parity of A_i in the hash table\n        if (g_hash_table_contains(parity, GINT_TO_POINTER(A))) {\n            int current_parity = GPOINTER_TO_INT(g_hash_table_lookup(parity, GINT_TO_POINTER(A)));\n            g_hash_table_insert(parity, GINT_TO_POINTER(A), GINT_TO_POINTER(1 - current_parity));\n        } else {\n            g_hash_table_insert(parity, GINT_TO_POINTER(A), GINT_TO_POINTER(0));\n        }\n    }\n\n    // If we reach here, (A, B) is a good pair of sequences\n    printf(\"Yes\n\");\n\n    // Clean up\n    g_hash_table_destroy(parity);\n\n    return 0;\n}", "reasoning": "To determine if a pair of sequences (A, B) is a good pair, we need to check if there exists a sequence X of length N consisting of 0 and 1 such that X_{A_i} != X_{B_i} for each i = 1, 2, ..., M. This can be achieved by using a hash table to track the parity (even or odd) of the positions in sequence A. If for any position i, both A_i and B_i have the same parity, then it's impossible to find such a sequence X, and we should return 'No'. Otherwise, if we can find a valid sequence X, we return 'Yes'.", "question_id": "abc327_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    int *P = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n\n    // Initialize DP table\n    double **dp = (double **)malloc((n + 1) * sizeof(double *));\n    for (int i = 0; i <= n; i++) {\n        dp[i] = (double *)malloc((n + 1) * sizeof(double));\n        memset(dp[i], 0, (n + 1) * sizeof(double));\n    }\n\n    // Fill DP table\n    for (int i = 1; i <= n; i++) {\n        for (int k = 1; k <= i; k++) {\n            double sum = 0.0;\n            double denominator = 0.0;\n            for (int j = 0; j < k; j++) {\n                sum += pow(0.9, k - j - 1) * P[i - j - 1];\n                denominator += pow(0.9, k - j - 1);\n            }\n            double rating = (sum / denominator) - (1200 / sqrt(k));\n            dp[i][k] = rating;\n        }\n    }\n\n    // Find maximum rating\n    double max_rating = -1.0;\n    for (int k = 1; k <= n; k++) {\n        if (dp[n][k] > max_rating) {\n            max_rating = dp[n][k];\n        }\n    }\n\n    // Output result\n    printf(\"%.15f\n\", max_rating);\n\n    // Free memory\n    for (int i = 0; i <= n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    free(P);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maximize Takahashi's rating by optimally choosing some (at least one) contests from the given N contests. The rating is calculated based on the performances of the chosen contests in a specific order. We can use dynamic programming to explore all possible combinations of contests and compute their ratings, keeping track of the maximum rating found.", "question_id": "abc327_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, x;\n    scanf(\"%d %d\", &n, &x);\n\n    int total_score = 0;\n    for (int i = 0; i < n; i++) {\n        int score;\n        scanf(\"%d\", &score);\n        if (score <= x) {\n            total_score += score;\n        }\n    }\n\n    printf(\"%d\\n\", total_score);\n\n    return 0;\n}", "reasoning": "The problem requires calculating the total score of problems with a score of X or less. Given the constraints, a straightforward approach is to read the input, iterate through the scores, and sum up the scores that are less than or equal to X. The constraints are small enough to allow for a linear scan of the scores.", "question_id": "abc328_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *days = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int di;\n        scanf(\"%d\", &di);\n        for (int j = 1; j <= di; j++) {\n            int month = i + 1;\n            int day = j;\n            int month_digit = month % 10;\n            int day_digit = day % 10;\n            if (month_digit == day_digit) {\n                g_array_append_val(days, j);\n            }\n        }\n    }\n\n    int result = days->len;\n\n    printf(\"%d\\n\", result);\n\n    g_array_free(days, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine how many days in a year of AtCoder have repdigit dates. A repdigit date is defined as a date where both the month and day are represented by the same digit. We will iterate through each month and day, check if the month and day digits match, and count such dates.", "question_id": "abc328_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        int count = 0;\n        for (int j = l - 1; j < r - 1; j++) {\n            if (s[j] == s[j + 1]) {\n                count++;\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to process each query efficiently. The key observation is that we only need to check adjacent characters in the substring for duplicates. Given the constraints, a naive approach would be inefficient, so we need an optimized solution. Here's the step-by-step approach:\n\n1. Read the input values for N, Q, and the string S.\n2. For each query, extract the substring S[l_i-1:r_i] (since array indices are 0-based).\n3. Iterate through the characters in the substring and count the number of consecutive duplicate characters.\n4. Store the result for each query.\n5. Print the results for all queries.\n\nThe main challenge is to handle the large input size efficiently. By processing each query independently, we ensure that the solution is scalable.", "question_id": "abc328_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char s[200001];\n    scanf(\"%s\", s);\n\n    int len = strlen(s);\n    int i = 0;\n\n    while (i < len - 2) {\n        if (s[i] == 'A' && s[i + 1] == 'B' && s[i + 2] == 'C') {\n            // Remove the 'ABC' substring\n            for (int j = i; j < len - 2; j++) {\n                s[j] = s[j + 3];\n            }\n            len -= 3;\n            i = 0; // Reset index to check from the beginning again\n        } else {\n            i++;\n        }\n    }\n\n    printf(\"%s\\n\", s);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to repeatedly remove the leftmost occurrence of the substring 'ABC' from the given string S until no more 'ABC' substrings are found. Here's a step-by-step approach to achieve this:", "question_id": "abc328_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 8\n#define MAX_M (MAX_N * (MAX_N - 1) / 2)\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    return ((Edge *)a)->w - ((Edge *)b)->w;\n}\n\nint find(int *parent, int i) {\n    if (parent[i] != i)\n        parent[i] = find(parent, parent[i]);\n    return parent[i];\n}\n\nvoid unionSet(int *parent, int x, int y) {\n    int rootX = find(parent, x);\n    int rootY = find(parent, y);\n    if (rootX != rootY)\n        parent[rootX] = rootY;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %lld\", &N, &M, &K);\n\n    Edge edges[MAX_M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n    }\n\n    qsort(edges, M, sizeof(Edge), compare);\n\n    int parent[N + 1];\n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n    }\n\n    long long cost = 0;\n    for (int i = 0; i < M; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int w = edges[i].w;\n\n        if (find(parent, u) != find(parent, v)) {\n            unionSet(parent, u, v);\n            cost = (cost + w) % K;\n        }\n    }\n\n    printf(\"%lld\\n\", cost);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum cost of a spanning tree in a weighted graph, where the cost is defined as the sum of the edge weights modulo K. This problem can be approached using a modified version of Kruskal's algorithm, which is an efficient algorithm for finding the Minimum Spanning Tree (MST) of a graph. However, since the cost is defined modulo K, we need to ensure that our algorithm handles large numbers and modulo operations correctly.", "question_id": "abc328_e"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    // Read input string\n    char S[101];  // Maximum length of S is 100\n    scanf(\"%s\", S);\n\n    // Get the length of the string\n    int len = strlen(S);\n\n    // Iterate through each character of the string\n    for (int i = 0; i < len; i++) {\n        // Print the character\n        printf(\"%c \", S[i]);\n    }\n\n    // Remove the extra space at the end\n    printf(\"\\n\");\n\n    return 0;\n}", "reasoning": "The problem requires us to take a string input and print each character of the string separated by a space. Here's a step-by-step approach to solve the problem:", "question_id": "abc329_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize a GArray to store the integers\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Read the integers into the array\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    // Sort the array in ascending order\n    qsort(arr->data, arr->len, sizeof(int), compare);\n\n    // Find the second largest element\n    int second_largest = arr->data[0];\n    for (int i = 1; i < arr->len; i++) {\n        if (arr->data[i] > second_largest) {\n            second_largest = arr->data[i];\n            break;\n        }\n    }\n\n    // Output the second largest element\n    printf(\"%d\n\", second_largest);\n\n    // Clean up\n    g_array_free(arr, TRUE);\n\n    return 0;\n}\n\n// Comparison function for qsort\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}", "reasoning": "To solve this problem, we need to find the largest integer among the given N integers that is not the largest itself. Here's a step-by-step approach to achieve this:", "question_id": "abc329_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    int count = 0;\n    int length = 1;\n\n    for (int i = 1; i <= n; i++) {\n        if (s[i] == s[i - 1]) {\n            length++;\n        } else {\n            count += (length * (length + 1)) / 2;\n            length = 1;\n        }\n    }\n\n    count += (length * (length + 1)) / 2;\n\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of non-empty substrings of a given string S that consist of the same repeated character. We can achieve this by iterating through the string and counting consecutive characters. For each sequence of consecutive characters, we can determine the number of non-empty substrings that can be formed by using the formula (length * (length + 1)) / 2. This formula calculates the sum of the first 'length' natural numbers, which represents all possible non-empty substrings within that sequence.", "question_id": "abc329_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GHashTable *votes = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int max_votes = 0;\n    int current_winner = 0;\n\n    for (int i = 0; i < m; i++) {\n        int candidate;\n        scanf(\"%d\", &candidate);\n\n        // Update vote count for the candidate\n        int *count = (int *)g_hash_table_lookup(votes, GINT_TO_POINTER(candidate));\n        if (count == NULL) {\n            count = (int *)malloc(sizeof(int));\n            *count = 1;\n            g_hash_table_insert(votes, GINT_TO_POINTER(candidate), count);\n        } else {\n            (*count)++;\n        }\n\n        // Check if the current candidate has more votes than the current winner\n        if (*count > max_votes || (*count == max_votes && candidate < current_winner)) {\n            max_votes = *count;\n            current_winner = candidate;\n        }\n\n        // Print the current winner\n        printf(\"%d\n\", current_winner);\n    }\n\n    // Clean up\n    g_hash_table_destroy(votes);\n    for (GHashTableIter iter = {0}; g_hash_table_iter_init(&iter, votes);) {\n        int *count;\n        g_hash_table_iter_next(&iter, NULL, (gpointer *)&count);\n        free(count);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to keep track of the vote counts for each candidate as we process each vote. We will use a hash table to store the vote counts and another variable to keep track of the current maximum votes and the corresponding candidate. As we process each vote, we update the vote count for the corresponding candidate and check if this candidate now has the most votes. If so, we update the current winner. We will print the current winner after each vote.", "question_id": "abc329_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    char s[n + 1], t[m + 1];\n    scanf(\"%s\", s);\n    scanf(\"%s\", t);\n\n    GHashTable *count = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Count characters in T\n    for (int i = 0; i < m; i++) {\n        char ch = t[i];\n        int *val = (int *)g_hash_table_lookup(count, &ch);\n        if (val) {\n            *val += 1;\n        } else {\n            g_hash_table_insert(count, &ch, GINT_TO_POINTER(1));\n        }\n    }\n\n    // Count characters in S that are not part of the replacement\n    int unmatched = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] != '#') {\n            char ch = s[i];\n            int *val = (int *)g_hash_table_lookup(count, &ch);\n            if (val) {\n                *val -= 1;\n                if (*val == 0) {\n                    g_hash_table_remove(count, &ch);\n                }\n            } else {\n                unmatched++;\n            }\n        }\n    }\n\n    // If there are unmatched characters, it is not possible to transform X into S\n    if (unmatched > 0) {\n        printf(\"No\n\");\n    } else {\n        printf(\"Yes\n\");\n    }\n\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "The problem involves determining if a string X of length N, initially filled with '#', can be transformed into a given string S by replacing any M consecutive characters in X with another string T. The key insight is that we need to check if the characters in S that are not covered by the replacement operations can be matched with the characters in T. This can be done by iterating through S and checking if the characters that are not part of the replacement can be matched with T. If we can match all such characters, then it is possible to transform X into S. Otherwise, it is not possible.", "question_id": "abc329_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize a GArray to store the colors of balls in each box\n    GArray *boxes[N + 1];\n    for (int i = 1; i <= N; i++) {\n        boxes[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read initial colors of balls in each box\n    int colors[N + 1];\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &colors[i]);\n        g_array_append_val(boxes[i], colors[i]);\n    }\n\n    // Process each query\n    for (int i = 0; i < Q; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n\n        // Move all balls from box a to box b\n        for (int j = 0; j < boxes[a]->len; j++) {\n            int color = g_array_index(boxes[a], int, j);\n            g_array_append_val(boxes[b], color);\n        }\n        g_array_free(boxes[a], TRUE);\n        boxes[a] = g_array_new(FALSE, FALSE, sizeof(int));\n\n        // Print the number of different colors in box b\n        GHashTable *color_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (int j = 0; j < boxes[b]->len; j++) {\n            int color = g_array_index(boxes[b], int, j);\n            g_hash_table_insert(color_count, GINT_TO_POINTER(color), GINT_TO_POINTER(1));\n        }\n        int unique_colors = g_hash_table_size(color_count);\n        printf(\"%d\n\", unique_colors);\n\n        // Clean up\n        g_hash_table_destroy(color_count);\n    }\n\n    // Clean up for boxes\n    for (int i = 1; i <= N; i++) {\n        g_array_free(boxes[i], TRUE);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently handle multiple queries where we move balls between boxes and need to determine the number of unique colors in a box after each move. Here's a step-by-step approach to achieve this using GLib data structures for efficient operations:", "question_id": "abc329_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n, l;\n    scanf(\"%d %d\", &n, &l);\n\n    // Read scores into a GArray\n    GArray *scores = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int score;\n        scanf(\"%d\", &score);\n        g_array_append_val(scores, score);\n    }\n\n    // Initialize a counter for passed students\n    int passed = 0;\n\n    // Iterate through scores and count those that pass\n    for (int i = 0; i < scores->len; i++) {\n        int score = g_array_index(scores, int, i);\n        if (score >= l) {\n            passed++;\n        }\n    }\n\n    // Output the number of passed students\n    printf(\"%d\n\", passed);\n\n    // Clean up\n    g_array_free(scores, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine how many people have passed an exam based on their scores and a passing threshold. Here's a step-by-step approach to solve it using C programming with GLib data structures:", "question_id": "abc330_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, l, r;\n    scanf(\"%d %d %d\", &n, &l, &r);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int *range = (int *)malloc((r - l + 1) * sizeof(int));\n    for (int i = 0; i < r - l + 1; i++) {\n        range[i] = l + i;\n    }\n\n    qsort(range, r - l + 1, sizeof(int), compare);\n\n    for (int i = 0; i < n; i++) {\n        int *pos = (int *)bsearch(&a[i], range, r - l + 1, sizeof(int), compare);\n        if (pos == NULL) {\n            printf(\"Error: bsearch failed\n\");\n            return 1;\n        }\n        int index = pos - range;\n        int median = range[index];\n        printf(\"%d \", median);\n    }\n\n    free(a);\n    free(range);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the closest value within the range [L, R] for each element in the array A. The closest value to A[i] within the range [L, R] is the median of the values in the range [L, R] that are closest to A[i]. This is because the median minimizes the sum of absolute deviations from a set of values. Here's how we can approach the problem step-by-step:", "question_id": "abc330_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    long long D;\n    scanf(\"%lld\", &D);\n\n    // Initialize variables\n    long long min_diff = D;\n    long long x = 0;\n\n    // Iterate through possible values of x\n    while (x * x <= D) {\n        long long target = D - x * x;\n        long long y = (long long)sqrt(target);\n\n        // Calculate the difference\n        long long diff = abs(x * x + y * y - D);\n        if (diff < min_diff) {\n            min_diff = diff;\n        }\n\n        // Move to the next x\n        x++;\n    }\n\n    // Output the result\n    printf(\"%lld\\n\", min_diff);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum value of |x^2 + y^2 - D| for non-negative integers x and y. The key insight is to iterate through possible values of x and calculate the corresponding y that minimizes the expression. We can use a binary search approach to find the closest square root of D, which will help us determine the minimum difference.", "question_id": "abc330_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    char **grid = (char **)malloc(N * sizeof(char *));\n    for (int i = 0; i < N; i++) {\n        grid[i] = (char *)malloc(N * sizeof(char));\n        scanf(\" %s\", grid[i]);\n    }\n\n    int count = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 'o') {\n                for (int k = 0; k < N; k++) {\n                    if (k != i && grid[k][j] == 'o') {\n                        for (int l = 0; l < N; l++) {\n                            if (l != i && l != k && grid[i][l] == 'o' && grid[k][l] == 'o') {\n                                count++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    for (int i = 0; i < N; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to identify all possible triples of cells that satisfy the given conditions. The conditions are:\n1. The three cells in the triple are distinct.\n2. All three cells have an 'o' written in them.\n3. Exactly two of the cells are in the same row.\n4. Exactly two of the cells are in the same column.\n\nWe can approach this problem by iterating through the grid and checking for valid triples. Here's a step-by-step plan:\n1. Parse the input to get the grid dimensions and the grid itself.\n2. Iterate through each cell in the grid.\n3. For each cell, check if it contains an 'o'.\n4. If it does, check all other cells in the same row and column to see if they also contain an 'o'.\n5. If we find two cells in the same row and two cells in the same column that all contain 'o', we have found a valid triple.\n6. Count all such valid triples.\n7. Output the count.", "question_id": "abc330_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize the array and hash table\n    int *A = (int *)malloc(N * sizeof(int));\n    GHashTable *hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the initial sequence\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n        g_hash_table_insert(hash, GINT_TO_POINTER(A[i]), GINT_TO_POINTER(1));\n    }\n\n    // Process each query\n    for (int q = 0; q < Q; q++) {\n        int i, x;\n        scanf(\"%d %d\", &i, &x);\n\n        // Update the sequence\n        if (g_hash_table_contains(hash, GINT_TO_POINTER(A[i - 1]))) {\n            g_hash_table_remove(hash, GINT_TO_POINTER(A[i - 1]));\n        }\n        A[i - 1] = x;\n        g_hash_table_insert(hash, GINT_TO_POINTER(A[i - 1]), GINT_TO_POINTER(1));\n\n        // Find and print the mex\n        int mex = 0;\n        while (g_hash_table_contains(hash, GINT_TO_POINTER(mex))) {\n            mex++;\n        }\n        printf(\"%d\\n\", mex);\n    }\n\n    // Clean up\n    free(A);\n    g_hash_table_destroy(hash);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently handle two main operations: updating an element in the sequence and finding the smallest non-negative integer (mex) that is not present in the sequence. Given the constraints, using a hash table to keep track of the elements in the sequence will allow us to quickly update the sequence and determine the mex.", "question_id": "abc330_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int M, D, y, m, d;\n    scanf(\"%d %d\", &M, &D);\n    scanf(\"%d %d %d\", &y, &m, &d);\n\n    // Determine the next day\n    if (d == D) {\n        m++;\n        d = 1;\n        if (m > M) {\n            y++;\n            m = 1;\n        }\n    } else {\n        d++;\n    }\n\n    // Output the result\n    printf(\"%d %d %d\n\", y, m, d);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the day that follows a given date in a calendar system where each year consists of M months and each month consists of D days. The steps are as follows:\n1. Read the input values for M, D, y, m, and d.\n2. Check if the given day is the last day of the month. If it is, increment the month and reset the day to 1. If the month is the last month of the year, increment the year and reset the month to 1.\n3. If the given day is not the last day of the month, simply increment the day by 1.\n4. Output the resulting year, month, and day.", "question_id": "abc331_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, S, M, L;\n    scanf(\"%d %d %d %d\", &N, &S, &M, &L);\n\n    int min_cost = INT_MAX;\n\n    // Iterate through possible numbers of 12-egg packs\n    for (int x = 0; x * 12 <= N; x++) {\n        // Iterate through possible numbers of 8-egg packs\n        for (int y = 0; x * 12 + y * 8 <= N; y++) {\n            // Calculate the remaining eggs needed after buying x 12-egg and y 8-egg packs\n            int remaining = N - (x * 12 + y * 8);\n            // Calculate the number of 6-egg packs needed for the remaining eggs\n            int z = remaining / 6;\n            // Calculate the total cost for this combination\n            int cost = x * L + y * M + z * S;\n            // Update the minimum cost if the current cost is lower\n            if (cost < min_cost) {\n                min_cost = cost;\n            }\n        }\n    }\n\n    // Print the minimum cost\n    printf(\"%d\\n\", min_cost);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum cost to purchase at least N eggs using the given egg packs. We can approach this by iterating through possible combinations of the three types of egg packs (6-egg, 8-egg, and 12-egg) and calculating the total cost for each combination. We keep track of the minimum cost encountered. The constraints are small enough that a brute-force approach is feasible.", "question_id": "abc331_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Read the array elements\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    // Initialize result array\n    GArray *result = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Process each element in the array\n    for (int i = 0; i < n; i++) {\n        int current = g_array_index(arr, int, i);\n        int sum = 0;\n\n        // Calculate the sum of elements greater than current element\n        for (int j = 0; j < n; j++) {\n            if (j != i && g_array_index(arr, int, j) > current) {\n                sum += g_array_index(arr, int, j);\n            }\n        }\n\n        // Append the result to the result array\n        g_array_append_val(result, sum);\n    }\n\n    // Print the result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", g_array_index(result, int, i));\n        if (i < n - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_array_free(arr, TRUE);\n    g_array_free(result, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the sum of all elements in the array that are greater than the current element for each position in the array. Here's a step-by-step approach to achieve this using GLib data structures and functions:", "question_id": "abc331_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 1000\n#define MAXQ 200000\n\ntypedef struct {\n    int blackCount;\n} GridCell;\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Read the grid pattern\n    char pattern[N][N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", pattern[i]);\n    }\n\n    // Initialize prefix sum grid\n    GridCell prefixSum[MAXN][MAXN] = {0};\n\n    // Fill the prefix sum grid\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            int color = (pattern[i][j] == 'B') ? 1 : 0;\n            prefixSum[i][j].blackCount = color;\n            if (i > 0) prefixSum[i][j].blackCount += prefixSum[i - 1][j].blackCount;\n            if (j > 0) prefixSum[i][j].blackCount += prefixSum[i][j - 1].blackCount;\n            if (i > 0 && j > 0) prefixSum[i][j].blackCount -= prefixSum[i - 1][j - 1].blackCount;\n        }\n    }\n\n    // Process each query\n    for (int q = 0; q < Q; q++) {\n        int A, B, C, D;\n        scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n\n        // Adjust coordinates to be 0-based\n        A--; B--; C--; D--;\n\n        // Calculate the number of black squares in the query area\n        int blackCount = prefixSum[C][D].blackCount;\n        if (B > 0) blackCount -= prefixSum[C][B - 1].blackCount;\n        if (A > 0) blackCount -= prefixSum[A - 1][D].blackCount;\n        if (A > 0 && B > 0) blackCount += prefixSum[A - 1][B - 1].blackCount;\n\n        printf(\"%d\\n\", blackCount);\n    }\n\n    return 0;\n}", "reasoning": "The problem involves a large grid where each square's color is determined by a repeating pattern. We need to efficiently answer multiple queries about the number of black squares in specified rectangular areas. Given the constraints, a direct approach of checking each square in the query area would be too slow. Instead, we can use a prefix sum approach to preprocess the grid and answer each query in constant time.", "question_id": "abc331_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m, l;\n    scanf(\"%d %d %d\", &n, &m, &l);\n\n    GArray *main_dishes = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *side_dishes = g_array_new(FALSE, FALSE, sizeof(int));\n    GHashTable *unavailable_pairs = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        g_array_append_val(main_dishes, a);\n    }\n\n    for (int i = 0; i < m; i++) {\n        int b;\n        scanf(\"%d\", &b);\n        g_array_append_val(side_dishes, b);\n    }\n\n    for (int i = 0; i < l; i++) {\n        int c, d;\n        scanf(\"%d %d\", &c, &d);\n        g_hash_table_insert(unavailable_pairs, GINT_TO_POINTER(c), GINT_TO_POINTER(d));\n    }\n\n    int max_price = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int price = g_array_index(main_dishes, int, i) + g_array_index(side_dishes, int, j);\n            if (!g_hash_table_lookup(unavailable_pairs, GINT_TO_POINTER(i + 1)) || !g_hash_table_lookup(unavailable_pairs, GINT_TO_POINTER(j + 1))) {\n                max_price = (price > max_price) ? price : max_price;\n            }\n        }\n    }\n\n    printf(\"%d\n\", max_price);\n\n    g_array_free(main_dishes, TRUE);\n    g_array_free(side_dishes, TRUE);\n    g_hash_table_destroy(unavailable_pairs);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the most expensive set meal offered by AtCoder cafeteria. Here's a step-by-step approach to achieve this:", "question_id": "abc331_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, S, K;\n    scanf(\"%d %d %d\", &N, &S, &K);\n\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < N; i++) {\n        int P, Q;\n        scanf(\"%d %d\", &P, &Q);\n\n        int total_cost = P * Q;\n        g_hash_table_insert(map, GINT_TO_POINTER(P), GINT_TO_POINTER(total_cost));\n    }\n\n    int total_price = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, map);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        total_price += GPOINTER_TO_INT(value);\n    }\n\n    int shipping_fee = (total_price >= S) ? 0 : K;\n    int total_amount = total_price + shipping_fee;\n\n    printf(\"%d\n\", total_amount);\n\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the total cost of the products and then add the shipping fee based on the total cost. Here's a step-by-step breakdown of the solution:", "question_id": "abc332_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int K, G, M;\n    scanf(\"%d %d %d\", &K, &G, &M);\n\n    // Initialize the glass and mug\n    int glass = 0;\n    int mug = 0;\n\n    // Perform the operations K times\n    for (int i = 0; i < K; i++) {\n        if (glass == G) {\n            // Discard all the water from the glass\n            glass = 0;\n        } else if (mug == 0) {\n            // Fill the mug with water\n            mug = M;\n        } else {\n            // Transfer water from the mug to the glass until the mug is empty or the glass is filled with water\n            while (mug > 0 && glass < G) {\n                glass++;\n                mug--;\n            }\n        }\n    }\n\n    // Output the amounts of water in the glass and the mug\n    printf(\"%d %d\n\", glass, mug);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of filling and transferring water between the glass and the mug K times. We will use a loop to perform these operations and keep track of the amount of water in each container. The operations are as follows:\n\n1. If the glass is filled (contains exactly G milliliters of water), discard all the water from the glass.\n2. If the mug is empty, fill the mug with water.\n3. Otherwise, transfer water from the mug to the glass until the mug is empty or the glass is filled with water.\n\nWe will use a loop to perform these operations K times and keep track of the amount of water in the glass and the mug. After the loop, we will print the amounts of water in the glass and the mug.", "question_id": "abc332_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    char schedule[n + 1];\n    scanf(\"%s\", schedule);\n\n    GHashTable *plain_tshirts = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *logo_tshirts = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int plain_count = 0;\n    int logo_count = 0;\n    int min_logo_needed = 0;\n\n    for (int i = 0; i < n; i++) {\n        char day = schedule[i];\n\n        if (day == '0') {\n            if (plain_count > 0) {\n                plain_count--;\n            } else {\n                logo_count--;\n            }\n        } else if (day == '1') {\n            if (plain_count > 0) {\n                plain_count--;\n            } else {\n                logo_count--;\n            }\n            logo_count++;\n        } else if (day == '2') {\n            logo_count++;\n        }\n\n        if (logo_count < 0) {\n            logo_count = 0;\n        }\n\n        if (day == '1' || day == '2') {\n            min_logo_needed = (logo_count > min_logo_needed) ? logo_count : min_logo_needed;\n        }\n    }\n\n    printf(\"%d\n\", min_logo_needed);\n\n    g_hash_table_destroy(plain_tshirts);\n    g_hash_table_destroy(logo_tshirts);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of logo T-shirts Takahashi needs to buy to meet the given conditions. We will use a greedy approach to track the number of plain and logo T-shirts available and calculate the minimum number of logo T-shirts required based on his schedule.", "question_id": "abc332_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    // Read grid A\n    int **A = (int **)malloc(H * sizeof(int *));\n    for (int i = 0; i < H; i++) {\n        A[i] = (int *)malloc(W * sizeof(int));\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n\n    // Read grid B\n    int **B = (int **)malloc(H * sizeof(int *));\n    for (int i = 0; i < H; i++) {\n        B[i] = (int *)malloc(W * sizeof(int));\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &B[i][j]);\n        }\n    }\n\n    // Check if it is possible to make A identical to B\n    int operations = 0;\n    for (int i = 0; i < H; i++) {\n        int *rowA = A[i];\n        int *rowB = B[i];\n        for (int j = 0; j < W; j++) {\n            if (rowA[j] != rowB[j]) {\n                operations++;\n            }\n        }\n    }\n\n    for (int j = 0; j < W; j++) {\n        int *colA = (int *)malloc(H * sizeof(int));\n        int *colB = (int *)malloc(H * sizeof(int));\n        for (int i = 0; i < H; i++) {\n            colA[i] = A[i][j];\n            colB[i] = B[i][j];\n        }\n        for (int i = 0; i < H; i++) {\n            if (colA[i] != colB[i]) {\n                operations++;\n            }\n        }\n        free(colA);\n        free(colB);\n    }\n\n    // Output the result\n    if (operations == 0) {\n        printf(\"0\n\");\n    } else {\n        printf(\"%d\n\", operations);\n    }\n\n    // Free allocated memory\n    for (int i = 0; i < H; i++) {\n        free(A[i]);\n        free(B[i]);\n    }\n    free(A);\n    free(B);\n\n    return 0;\n}", "reasoning": "To determine whether it is possible to make grid A identical to grid B by swapping rows and columns, we need to analyze the problem step-by-step. The key observation is that swapping rows and columns does not change the relative order of elements within each row or column. Therefore, we can focus on sorting the elements in each row and column to see if they can be made identical to the corresponding elements in grid B. If we can sort both grids to match, then it is possible to achieve the goal with the minimum number of operations. The number of operations required will be the sum of the number of swaps needed to sort each row and column.", "question_id": "abc332_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize a buffer to store the result string\n    char result[10];\n    result[0] = '\n';\n\n    // Loop to concatenate N copies of the digit N\n    for (int i = 0; i < n; i++) {\n        char digit = '0' + n;\n        strcat(result, &digit);\n    }\n\n    // Print the result\n    printf(\"%s\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to read an integer N from the input, and then create a string that consists of N copies of the digit N. We can achieve this by using a loop to repeat the digit N times and concatenating it to a result string. Finally, we print the resulting string.", "question_id": "abc333_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S1, S2, T1, T2;\n    scanf(\"%c%c%c%c\", &S1, &S2, &T1, &T2);\n\n    // Define a mapping for the lengths of segments in a regular pentagon\n    GHashTable *lengths = g_hash_table_new(g_str_hash, g_str_equal);\n    g_hash_table_insert(lengths, \"AB\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"BC\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"CD\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"DE\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"EA\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"AC\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"BD\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"CE\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"AD\", GINT_TO_POINTER(1));\n\n    // Check if the lengths of the segments are equal\n    int len1 = GPOINTER_TO_INT(g_hash_table_lookup(lengths, g_strconcat(S1, S2, NULL)));\n    int len2 = GPOINTER_TO_INT(g_hash_table_lookup(lengths, g_strconcat(T1, T2, NULL)));\n\n    // Output the result\n    if (len1 == len2) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(lengths);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the lengths of the line segments connecting points S_1 and S_2, and T_1 and T_2 in a regular pentagon. In a regular pentagon, all sides are equal, and the diagonals connecting non-adjacent vertices are also equal. We can use a simple mapping to determine the lengths of these segments based on the vertices provided.", "question_id": "abc333_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to generate repunits\nGArray* generate_repunits(int max_length) {\n    GArray *repunits = g_array_new(FALSE, FALSE, sizeof(char*));\n    char *repunit = (char*)malloc(1000 * sizeof(char));\n    repunit[0] = '1';\n    repunit[1] = '\\0';\n    g_array_append_val(repunits, repunit);\n\n    for (int i = 1; i < max_length; i++) {\n        int len = strlen(repunit);\n        for (int j = 0; j < len; j++) {\n            repunit[j] = repunit[j] == '9' ? '0' : repunit[j] + 1;\n        }\n        if (repunit[len - 1] == '0') {\n            repunit[len - 1] = '1';\n            repunit[len] = '1';\n            repunit[len + 1] = '\\0';\n        }\n        g_array_append_val(repunits, repunit);\n    }\n\n    return repunits;\n}\n\n// Function to find the N-th smallest integer that can be expressed as the sum of exactly three repunits\nint find_nth_repunit_sum(int n) {\n    int max_length = 1000; // Maximum length of repunit to consider\n    GArray *repunits = generate_repunits(max_length);\n    GHashTable *sum_counts = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < repunits->len; i++) {\n        for (int j = 0; j < repunits->len; j++) {\n            for (int k = 0; k < repunits->len; k++) {\n                char *repunit1 = g_array_index(repunits, char*, i);\n                char *repunit2 = g_array_index(repunits, char*, j);\n                char *repunit3 = g_array_index(repunits, char*, k);\n\n                int sum = atoi(repunit1) + atoi(repunit2) + atoi(repunit3);\n                int count = GPOINTER_TO_INT(g_hash_table_lookup(sum_counts, GINT_TO_POINTER(sum))) + 1;\n                g_hash_table_insert(sum_counts, GINT_TO_POINTER(sum), GINT_TO_POINTER(count));\n            }\n        }\n    }\n\n    int result = 0;\n    int count = 0;\n\n    for (int sum = 3; sum < INT_MAX; sum++) {\n        int sum_count = GPOINTER_TO_INT(g_hash_table_lookup(sum_counts, GINT_TO_POINTER(sum)));\n        if (sum_count > 0) {\n            count += sum_count;\n            if (count >= n) {\n                result = sum;\n                break;\n            }\n        }\n    }\n\n    g_array_free(repunits, TRUE);\n    g_hash_table_destroy(sum_counts);\n\n    return result;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int result = find_nth_repunit_sum(n);\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate repunits and then find the N-th smallest integer that can be expressed as the sum of exactly three repunits. Here's a step-by-step approach to achieve this:", "question_id": "abc333_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create an adjacency list to represent the tree\n    GArray **adj = g_new(GArray *, n + 1);\n    for (int i = 0; i <= n; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read the edges and build the adjacency list\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        g_array_append_val(adj[u], v);\n        g_array_append_val(adj[v], u);\n    }\n\n    // Initialize a queue for BFS\n    GQueue *queue = g_queue_new();\n\n    // Initialize a visited array to keep track of visited nodes\n    bool *visited = g_new(bool, n + 1);\n    for (int i = 0; i <= n; i++) {\n        visited[i] = false;\n    }\n\n    // Initialize the degree array to store the degree of each node\n    int *degree = g_new(int, n + 1);\n    for (int i = 0; i <= n; i++) {\n        degree[i] = 0;\n    }\n\n    // Calculate the degree of each node\n    for (int i = 1; i <= n; i++) {\n        degree[i] = g_array_get_length(adj[i]);\n    }\n\n    // Add all leaf nodes (nodes with degree 1) to the queue\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] == 1) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(i));\n            visited[i] = true;\n        }\n    }\n\n    int operations = 0;\n\n    // Perform BFS to delete leaf nodes\n    while (!g_queue_is_empty(queue)) {\n        operations++;\n        int size = g_queue_get_length(queue);\n\n        for (int i = 0; i < size; i++) {\n            int u = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n            for (int j = 0; j < g_array_get_length(adj[u]); j++) {\n                int v = g_array_index(adj[u], int, j);\n\n                // Decrease the degree of the neighbor\n                degree[v]--;\n\n                // If the neighbor becomes a leaf, add it to the queue\n                if (degree[v] == 1) {\n                    g_queue_push_tail(queue, GINT_TO_POINTER(v));\n                    visited[v] = true;\n                }\n            }\n\n            // Remove the node from the adjacency list\n            g_array_remove_index(adj[u], 0);\n        }\n    }\n\n    // Clean up\n    for (int i = 0; i <= n; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n    g_free(adj);\n    g_queue_free(queue);\n    g_free(visited);\n    g_free(degree);\n\n    // Print the result\n    printf(\"%d\n\", operations);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of operations required to delete vertex 1 from a given tree. The key insight is that we should always delete the leaf vertices first, as this minimizes the number of operations needed. Here's a step-by-step approach to solve the problem:", "question_id": "abc333_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GHashTable *potions = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int K_min = 0;\n    int *actions = (int *)malloc(N * sizeof(int));\n    int action_index = 0;\n\n    for (int i = 0; i < N; i++) {\n        int t, x;\n        scanf(\"%d %d\", &t, &x);\n\n        if (t == 1) {\n            // Pick up the potion\n            actions[action_index++] = 1;\n            int *count = (int *)g_hash_table_lookup(potions, GINT_TO_POINTER(x));\n            if (count == NULL) {\n                count = (int *)malloc(sizeof(int));\n                *count = 1;\n                g_hash_table_insert(potions, GINT_TO_POINTER(x), count);\n            } else {\n                (*count)++;\n            }\n            K_min = g_max(K_min, *count);\n        } else {\n            // Encounter a monster\n            int *count = (int *)g_hash_table_lookup(potions, GINT_TO_POINTER(x));\n            if (count == NULL || *count == 0) {\n                printf(\"-1\n\");\n                for (int j = 0; j < action_index; j++) {\n                    free(actions);\n                }\n                g_hash_table_destroy(potions);\n                return 0;\n            } else {\n                actions[action_index++] = 0;\n                (*count)--;\n            }\n        }\n    }\n\n    printf(\"%d\n\", K_min);\n    for (int i = 0; i < action_index; i++) {\n        printf(\"%d \", actions[i]);\n    }\n    printf(\"\\n\");\n\n    for (int j = 0; j < action_index; j++) {\n        free(actions);\n    }\n    g_hash_table_destroy(potions);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate Takahashi's journey through the events and keep track of the potions he has. We need to determine the minimum number of potions he can have at any point to defeat all monsters without being defeated. Here's a step-by-step approach to solve it:\n\n1. Initialize a GHashTable to keep track of the number of potions of each type.\n2. Initialize a variable to keep track of the maximum number of potions he has at any point (K_min).\n3. Iterate through the events in order:\n   - If the event is a potion (t_i = 1), add it to the hash table and update K_min if necessary.\n   - If the event is a monster (t_i = 2), check if he has a potion of that type. If not, return -1 as he cannot defeat the monster.\n   - If he has the potion, use it and decrement the count in the hash table.\n4. After processing all events, print K_min and the sequence of actions that achieve it.\n5. Ensure to free all allocated memory before returning from the main function.", "question_id": "abc333_e"}
{"solution": "#include <stdio.h>\n\nint main() {\n    int B, G;\n    scanf(\"%d %d\", &B, &G);\n\n    if (B > G) {\n        printf(\"Bat\n\");\n    } else {\n        printf(\"Glove\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine which item Santa will give to Takahashi, we need to compare the costs of the bat and the glove. The bat is more expensive if its cost is greater than the cost of the glove. If the glove is more expensive, Santa will give Takahashi the glove. We can use simple conditional statements to compare the two costs and print the appropriate output.", "question_id": "abc334_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int A, M, L, R;\n    scanf(\"%d %d %d %d\", &A, &M, &L, &R);\n\n    // Calculate the number of Christmas trees\n    int count = 0;\n    for (int x = A; x <= R; x += M) {\n        if (x >= L) {\n            count++;\n        }\n    }\n\n    // Output result\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of Christmas trees set up by Snuke between two points, Takahashi and Aoki. The Christmas trees are placed at intervals of M meters starting from point A. We need to count the trees within the range [L, R], inclusive.", "question_id": "abc334_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    int *socks = (int *)malloc((2 * N - K) * sizeof(int));\n    int *colors = (int *)malloc(K * sizeof(int));\n\n    for (int i = 0; i < K; i++) {\n        scanf(\"%d\", &colors[i]);\n    }\n\n    int index = 0;\n    for (int i = 1; i <= N; i++) {\n        if (i != colors[index]) {\n            socks[index] = i;\n            index++;\n        }\n    }\n\n    qsort(socks, 2 * N - K, sizeof(int), compare);\n\n    int total_weirdness = 0;\n    for (int i = 0; i < 2 * N - K; i += 2) {\n        total_weirdness += abs(socks[i] - socks[i + 1]);\n    }\n\n    printf(\"%d\\n\", total_weirdness);\n\n    free(socks);\n    free(colors);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to minimize the total weirdness of pairs of socks. The weirdness of a pair (i, j) is defined as |i - j|. Given that we have N pairs of socks and lose one sock of each of K colors, we need to form new pairs from the remaining 2N-K socks to minimize the total weirdness. The optimal strategy involves pairing the socks in such a way that the difference between the colors of the socks in each pair is minimized. This can be achieved by pairing the smallest available sock with the next smallest available sock, and so on.", "question_id": "abc334_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    int *R = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &R[i]);\n    }\n\n    g_array_sort(G_ARRAY_FROM_POINTER(R, int, N), compare);\n\n    for (int q = 0; q < Q; q++) {\n        int X;\n        scanf(\"%d\", &X);\n\n        int count = 0;\n        for (int i = 0; i < N; i++) {\n            if (X >= R[i]) {\n                X -= R[i];\n                count++;\n            } else {\n                break;\n            }\n        }\n\n        printf(\"%d\\n\", count);\n    }\n\n    free(R);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum number of sleighs that can be pulled with a given number of reindeer. The key observation is that we should always try to pull the sleighs that require the fewest reindeer first. This way, we can maximize the number of sleighs pulled with the available reindeer. We can use a priority queue (min-heap) to always process the sleigh with the smallest reindeer requirement first. For each query, we will use a greedy approach to count how many sleighs can be pulled with the available reindeer.", "question_id": "abc334_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint H, W;\nchar grid[1001][1001];\nGHashTable *dp[1001][1001];\n\nint dfs(int x, int y) {\n    if (x < 0 || x >= H || y < 0 || y >= W || grid[x][y] == '.')\n        return 0;\n    grid[x][y] = 'X';\n    return 1 + dfs(x-1, y) + dfs(x+1, y) + dfs(x, y-1) + dfs(x, y+1);\n}\n\nint count_components() {\n    int components = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '#') {\n                components++;\n                dfs(i, j);\n            }\n        }\n    }\n    return components;\n}\n\nint expected_components() {\n    int total_red = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.') {\n                total_red++;\n                grid[i][j] = '#';\n                int components = count_components();\n                grid[i][j] = '.';\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        if (grid[k][l] == '#') {\n                            int new_components = components + dfs(k, l);\n                            int *count = (int *)g_hash_table_lookup(dp[k][l], GINT_TO_POINTER(components));\n                            if (count == NULL) {\n                                count = (int *)malloc(sizeof(int));\n                                *count = 0;\n                                g_hash_table_insert(dp[k][l], GINT_TO_POINTER(components), count);\n                            }\n                            (*count)++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int total_components = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '#') {\n                int *count = (int *)g_hash_table_lookup(dp[i][j], GINT_TO_POINTER(count_components()));\n                if (count != NULL) {\n                    total_components += (*count);\n                }\n            }\n        }\n    }\n    return (total_components + total_red - 1) / total_red;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            dp[i][j] = g_hash_table_new(g_direct_hash, g_direct_equal);\n        }\n    }\n    int result = expected_components();\n    printf(\"%d\\n\", result);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            g_hash_table_destroy(dp[i][j]);\n        }\n    }\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the expected number of green connected components after repainting one red cell green. The expected value is given by the sum of the number of components for each possible repaint, divided by the total number of red cells. Since the expected value is rational, we need to find its integer representation modulo 998244353. We will use dynamic programming and graph traversal to count the connected components for each possible repaint. We will use a hash table to store the results of subproblems to avoid redundant calculations.", "question_id": "abc334_e"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[101];\n    scanf(\"%s\", S);\n    int len = strlen(S);\n    if (len >= 4 && S[len - 1] == '3') {\n        S[len - 1] = '4';\n    }\n    printf(\"%s\n\", S);\n    return 0;\n}", "reasoning": "The problem requires modifying a given string S to change its last character from '3' to '4'. Since the string is guaranteed to end with '2023', we can directly access and modify the last character. The solution involves reading the string, modifying the last character, and then printing the modified string.", "question_id": "abc335_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Use a hash table to keep track of printed triples\n    GHashTable *printed = g_hash_table_new(g_int_hash, g_int_equal);\n\n    // Iterate through all possible values of x, y, and z\n    for (int x = 0; x <= n; x++) {\n        for (int y = 0; y <= n - x; y++) {\n            int z = n - x - y;\n\n            // Create a key for the hash table\n            int key = (x << 16) | (y << 8) | z;\n\n            // Check if the triple has already been printed\n            if (!g_hash_table_contains(printed, GINT_TO_POINTER(key))) {\n                // Print the triple\n                printf(\"%d %d %d\n\", x, y, z);\n\n                // Insert the key into the hash table\n                g_hash_table_insert(printed, GINT_TO_POINTER(key), GINT_TO_POINTER(1));\n            }\n        }\n    }\n\n    // Free the hash table\n    g_hash_table_destroy(printed);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate all possible triples of non-negative integers (x, y, z) such that their sum is less than or equal to N. The requirement for lexicographical order means that we need to generate these triples in a specific order, starting from the smallest possible values and moving towards larger ones. We can achieve this by using three nested loops to iterate through all possible values of x, y, and z. For each combination, we check if the sum of x, y, and z is less than or equal to N. If it is, we print the triple. To ensure that we only print unique triples, we can use a hash table to keep track of the triples we have already printed.", "question_id": "abc335_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 1000000\n#define MAX_Q 200000\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize the dragon's parts\n    GArray *parts = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(parts, i);\n    }\n\n    // Initialize the head's position\n    int head_x = 0, head_y = 0;\n\n    // Process each query\n    for (int i = 0; i < Q; i++) {\n        char query[2];\n        scanf(\"%s\", query);\n\n        if (query[0] == '1') {\n            char direction;\n            scanf(\" %c\", &direction);\n\n            // Move the head\n            switch (direction) {\n                case 'R':\n                    head_x++;\n                    break;\n                case 'L':\n                    head_x--;\n                    break;\n                case 'U':\n                    head_y++;\n                    break;\n                case 'D':\n                    head_y--;\n                    break;\n            }\n\n            // Move the parts\n            for (int j = 1; j < N; j++) {\n                int prev_x = head_x, prev_y = head_y;\n                scanf(\" %c\", &direction);\n\n                switch (direction) {\n                    case 'R':\n                        prev_x++;\n                        break;\n                    case 'L':\n                        prev_x--;\n                        break;\n                    case 'U':\n                        prev_y++;\n                        break;\n                    case 'D':\n                        prev_y--;\n                        break;\n                }\n\n                // Update the part's position\n                g_array_index(parts, int, j) = prev_x * 1000 + prev_y;\n            }\n        } else if (query[0] == '2') {\n            int p;\n            scanf(\" %d\", &p);\n\n            // Find the coordinates of part p\n            int x = g_array_index(parts, int, p - 1) / 1000;\n            int y = g_array_index(parts, int, p - 1) % 1000;\n\n            // Print the coordinates\n            printf(\"%d %d\n\", x, y);\n        }\n    }\n\n    // Free the allocated memory\n    g_array_free(parts, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the movement of a dragon with N parts on a 2D plane. The dragon's head moves in one of four directions (R, L, U, D), and each subsequent part follows the part in front of it. We need to handle two types of queries: moving the head and finding the coordinates of a specific part. Given the constraints, we need an efficient solution that can handle large inputs. The use of dynamic arrays and queues from GLib can help manage the dragon's parts efficiently.", "question_id": "abc335_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char grid[N][N];\n    memset(grid, '0', sizeof(grid));\n\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n\n    int x = n / 2, y = n / 2;\n    int dir = 0;\n    int count = 1;\n\n    while (count <= n * n - 1) {\n        grid[x][y] = '0' + count;\n        count++;\n\n        int nx = x + dx[dir % 4];\n        int ny = y + dy[dir % 4];\n\n        if (nx < 0 || nx >= n || ny < 0 || ny >= n || grid[nx][ny] != '0') {\n            dir++;\n            nx = x + dx[dir % 4];\n            ny = y + dy[dir % 4];\n        }\n\n        x = nx;\n        y = ny;\n    }\n\n    grid[n / 2][n / 2] = 'T';\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%c \", grid[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to place Takahashi and the dragon parts in a grid such that the dragon parts are placed in adjacent cells and Takahashi is at the center. The approach involves placing the dragon parts in a spiral pattern starting from the center and moving outward in a clockwise direction. This ensures that each part is adjacent to the previous part. We will use a 2D array to represent the grid and fill it according to the spiral pattern.", "question_id": "abc335_d"}
{"solution": "#include <stdio.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Buffer to store the Dragon String\n    char dragonString[2028];\n    int index = 0;\n\n    // Append 'L' to the string\n    dragonString[index++] = 'L';\n\n    // Append N 'o's to the string\n    for (int i = 0; i < N; i++) {\n        dragonString[index++] = 'o';\n    }\n\n    // Append 'n' to the string\n    dragonString[index++] = 'n';\n\n    // Append 'g' to the string\n    dragonString[index++] = 'g';\n\n    // Null-terminate the string\n    dragonString[index] = '\\0';\n\n    // Print the Dragon String\n    printf(\"%s\n\", dragonString);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate a specific string pattern based on the given level N. The pattern is always in the form of 'L' followed by N 'o's, then 'n', and finally 'g'. The length of the string will always be N+3. We can achieve this by using a loop to append the required characters to a string buffer. Since the constraints are small (1 <= N <= 2024), we can safely use a statically allocated buffer to store the result.", "question_id": "abc336_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N;\n    scanf(\"%d\", &N);\n\n    // Initialize a counter for trailing zeros\n    int ctz = 0;\n\n    // Loop until N becomes 0 or has no trailing zeros\n    while (N > 0 && (N & 1) == 0) {\n        N >>= 1;\n        ctz++;\n    }\n\n    // Output the result\n    printf(\"%d\n\", ctz);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of trailing zeros in the binary representation of a given positive integer N. The function ctz(N) is defined as the maximal number of consecutive zeros at the end of the binary notation of N. If the binary notation of N ends with a 1, then ctz(N) = 0. Here's a step-by-step approach to solve the problem:", "question_id": "abc336_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nvoid generateGoodIntegers(char *result, int N, int index) {\n    if (index == 0) {\n        result[index] = '0';\n        generateGoodIntegers(result, N, index + 1);\n        return;\n    }\n\n    if (N == 1) {\n        result[index] = '0';\n        return;\n    }\n\n    int count = 0;\n    for (int i = 0; i < 5; i++) {\n        if (N - count > 0) {\n            result[index] = '0' + 2 * i;\n            generateGoodIntegers(result, N - count, index + 1);\n            count++;\n        }\n    }\n}\n\nint main() {\n    long long N;\n    scanf(\"%lld\", &N);\n\n    char result[20];\n    result[0] = '\\0';\n\n    generateGoodIntegers(result, N, 0);\n\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "reasoning": "To find the N-th smallest good integer, we need to generate good integers in ascending order. A good integer is defined as a number where all its digits are even. We can generate these numbers by considering the structure of numbers composed of the digits 0, 2, 4, 6, and 8. By using a recursive approach, we can build these numbers step by step, ensuring they remain good integers. The key is to handle large numbers efficiently, which is why we use string manipulation to represent these numbers. We also need to ensure that we do not generate numbers that start with 0, as they would be considered smaller than they should be.", "question_id": "abc336_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int left = 0, right = n - 1;\n    int max_size = 0;\n\n    while (left <= right) {\n        if (A[left] == A[right]) {\n            max_size += 2;\n            left++;\n            right--;\n        } else if (A[left] < A[right]) {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(A[left] + 1))) {\n                max_size += 2;\n                left++;\n                right--;\n            } else {\n                right--;\n            }\n        } else {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(A[right] + 1))) {\n                max_size += 2;\n                left++;\n                right--;\n            } else {\n                left++;\n            }\n        }\n    }\n\n    max_size = (max_size + 1) / 2;\n    printf(\"%d\n\", max_size);\n\n    free(A);\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum size of a Pyramid Sequence that can be obtained from a given sequence A by performing the allowed operations. The key insight is to recognize that the Pyramid Sequence is symmetric around its center. Therefore, we can focus on finding the longest symmetric subsequence that can be formed by removing elements from the ends of the sequence and decreasing their values if necessary.", "question_id": "abc336_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int takahashi_total = 0, aoki_total = 0;\n\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        takahashi_total += x;\n        aoki_total += y;\n    }\n\n    if (takahashi_total > aoki_total) {\n        printf(\"Takahashi\\n\");\n    } else if (aoki_total > takahashi_total) {\n        printf(\"Aoki\\n\");\n    } else {\n        printf(\"Draw\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to read the input values, calculate the total scores for both teams, and then determine the winner based on these scores. Here's a step-by-step approach to achieve this:", "question_id": "abc337_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool isExtendedABC(char *S) {\n    int len = strlen(S);\n    int i = 0;\n\n    // Check for Extended A string at the beginning\n    while (i < len && S[i] == 'A') {\n        i++;\n    }\n\n    // Check for Extended B string next\n    while (i < len && S[i] == 'B') {\n        i++;\n    }\n\n    // Check for Extended C string at the end\n    while (i < len && S[i] == 'C') {\n        i++;\n    }\n\n    // If we have processed the entire string, it is an Extended ABC string\n    return i == len;\n}\n\nint main() {\n    char S[101];\n    scanf(\"%s\", S);\n\n    if (isExtendedABC(S)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine if a given string S is an Extended ABC string, we need to check if it can be divided into three parts: an Extended A string, an Extended B string, and an Extended C string. The approach involves iterating through the string and checking if it can be split into these three parts in the correct order.", "question_id": "abc337_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *stack = g_array_new(FALSE, FALSE, sizeof(int));\n    int *result = (int *)malloc(n * sizeof(int));\n\n    for (int i = n - 1; i >= 0; i--) {\n        int person;\n        scanf(\"%d\", &person);\n\n        if (person == -1) {\n            g_array_append_val(stack, i + 1);\n        } else {\n            while (g_array_index(stack, int, 0) != person) {\n                g_array_remove_index(stack, 0);\n            }\n            g_array_append_val(stack, i + 1);\n        }\n    }\n\n    int index = 0;\n    while (g_array_get_length(stack) > 0) {\n        result[index++] = g_array_pop_index(stack, int);\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", result[i]);\n    }\n    printf(\"\\n\");\n\n    free(result);\n    g_array_free(stack, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to reconstruct the line of people based on the given sequence A. The key observation is that if a person i is at the front of the line (A[i] = -1), they must be the first person in the line. For other people, their position in the line is determined by the person they are standing behind (A[i] != -1). We can use a stack to help reconstruct the line. Here's the step-by-step approach:\n1. Initialize an empty stack and a result array to store the final order of people.\n2. Iterate through the sequence A from the end to the beginning.\n3. For each person, if they are at the front (A[i] = -1), push them onto the stack.\n4. If they are not at the front, pop the stack until we find the person they are standing behind. Then, push the current person onto the stack.\n5. After processing all people, the stack will contain the people in the correct order. Pop the stack and store the result in the result array.\n6. Finally, print the result array.", "question_id": "abc337_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W, K;\n    scanf(\"%d %d %d\", &H, &W, &K);\n\n    char **grid = (char **)g_malloc(H * sizeof(char *));\n    for (int i = 0; i < H; i++) {\n        grid[i] = (char *)g_malloc(W * sizeof(char));\n        scanf(\"%s\", grid[i]);\n    }\n\n    int result = INT_MAX;\n\n    // Check horizontal sequences\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j <= W - K; j++) {\n            int changes = 0;\n            for (int k = 0; k < K; k++) {\n                if (grid[i][j + k] == \".\") {\n                    changes++;\n                }\n            }\n            if (changes < result) {\n                result = changes;\n            }\n        }\n    }\n\n    // Check vertical sequences\n    for (int j = 0; j < W; j++) {\n        for (int i = 0; i <= H - K; i++) {\n            int changes = 0;\n            for (int k = 0; k < K; k++) {\n                if (grid[i + k][j] == \".\") {\n                    changes++;\n                }\n            }\n            if (changes < result) {\n                result = changes;\n            }\n        }\n    }\n\n    if (result == INT_MAX) {\n        printf(\"-1\n\");\n    } else {\n        printf(\"%d\n\", result);\n    }\n\n    for (int i = 0; i < H; i++) {\n        g_free(grid[i]);\n    }\n    g_free(grid);\n\n    return 0;\n}", "reasoning": "The problem requires determining if we can make a sequence of K consecutive cells all 'o' by changing '.' to 'o'. We need to check both horizontal and vertical sequences. The solution involves iterating through all possible sequences of length K in both directions and counting the number of '.' characters to change to 'o'. We keep track of the minimum number of changes required for each sequence and return the minimum across all sequences.", "question_id": "abc337_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Binary search approach\n    int left = 1, right = N;\n    int M = 0;\n\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        M++;\n\n        // Serve the first half of the bottles to the current friend\n        printf(\"1 %d\n\", mid);\n\n        char S[100];\n        scanf(\"%s\", S);\n\n        if (S[0] == '1') {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    // The last served bottle is the spoiled one\n    printf(\"1 %d\n\", left);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to identify the spoiled juice bottle among N bottles using the minimum number of friends. The key insight is that we can use a binary search approach to identify the spoiled bottle. We will divide the bottles into two halves and ask each friend to drink from one half. Based on the response, we can narrow down the range of possible spoiled bottles until we identify the exact one.", "question_id": "abc337_e"}
{"solution": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char S[100];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n\n    // Check if the first character is uppercase\n    if (isupper(S[0])) {\n        // Check if all other characters are lowercase\n        for (int i = 1; i < n; i++) {\n            if (!islower(S[i])) {\n                printf(\"No\");\n                return 0;\n            }\n        }\n        printf(\"Yes\");\n    } else {\n        printf(\"No\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to check if the first character of the given string is uppercase and if all other characters are lowercase. Here's a step-by-step approach to achieve this:", "question_id": "abc338_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input string\n    char str[1001];\n    scanf(\"%s\", str);\n\n    // Initialize a hash table to store character frequencies\n    GHashTable *freq = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Count the frequency of each character in the string\n    for (int i = 0; str[i] != '\\0'; i++) {\n        char *key = &str[i];\n        int *count = (int *)g_hash_table_lookup(freq, key);\n        if (count) {\n            (*count)++;\n        } else {\n            g_hash_table_insert(freq, key, GINT_TO_POINTER(1));\n        }\n    }\n\n    // Find the character with the highest frequency\n    char most_freq_char = '\\0';\n    int max_count = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, freq);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int count = GPOINTER_TO_INT(value);\n        if (count > max_count || (count == max_count && strcmp(key, &most_freq_char) < 0)) {\n            max_count = count;\n            most_freq_char = *(char *)key;\n        }\n    }\n\n    // Print the character with the highest frequency\n    printf(\"%c\\n\", most_freq_char);\n\n    // Clean up\n    g_hash_table_destroy(freq);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the frequency of each character in the given string and then find the character with the highest frequency. If there are multiple characters with the same highest frequency, we should return the one that appears first in alphabetical order. Here's a step-by-step approach to achieve this:", "question_id": "abc338_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Read ingredient quantities\n    GArray *quantities = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int q;\n        scanf(\"%d\", &q);\n        g_array_append_val(quantities, q);\n    }\n\n    // Read dish A requirements\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        g_array_append_val(A, a);\n    }\n\n    // Read dish B requirements\n    GArray *B = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int b;\n        scanf(\"%d\", &b);\n        g_array_append_val(B, b);\n    }\n\n    // Calculate maximum servings for dish A\n    int max_servings_A = 0;\n    for (int i = 0; i < n; i++) {\n        int q = g_array_index(quantities, int, i);\n        int a = g_array_index(A, int, i);\n        if (a > 0) {\n            max_servings_A += q / a;\n        }\n    }\n\n    // Calculate maximum servings for dish B\n    int max_servings_B = 0;\n    for (int i = 0; i < n; i++) {\n        int q = g_array_index(quantities, int, i);\n        int b = g_array_index(B, int, i);\n        if (b > 0) {\n            max_servings_B += q / b;\n        }\n    }\n\n    // The result is the minimum of the two maximum servings\n    int result = (max_servings_A < max_servings_B) ? max_servings_A : max_servings_B;\n\n    // Output the result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_array_free(quantities, TRUE);\n    g_array_free(A, TRUE);\n    g_array_free(B, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum number of servings of two types of dishes (A and B) that can be made using the available ingredients. The key is to find the maximum possible number of servings of each dish independently and then take the minimum of these two values, as we can only make a total number of servings that is limited by the lesser of the two dishes.", "question_id": "abc338_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *x = (int *)malloc(m * sizeof(int));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &x[i]);\n    }\n\n    GHashTable *bridge_to_cost = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < m - 1; i++) {\n        int cost = abs(x[i] - x[i + 1]);\n        g_hash_table_insert(bridge_to_cost, GINT_TO_POINTER(i), GINT_TO_POINTER(cost));\n    }\n\n    int total_cost = 0;\n    for (int i = 0; i < m - 1; i++) {\n        total_cost += abs(x[i] - x[i + 1]);\n    }\n\n    int min_cost = total_cost;\n\n    for (int i = 0; i < m - 1; i++) {\n        int cost = abs(x[i] - x[i + 1]);\n        int new_cost = total_cost - cost;\n        if (i > 0) {\n            new_cost += abs(x[i - 1] - x[i]);\n        }\n        if (i < m - 2) {\n            new_cost += abs(x[i + 1] - x[i + 2]);\n        }\n        if (new_cost < min_cost) {\n            min_cost = new_cost;\n        }\n    }\n\n    printf(\"%d\n\", min_cost);\n\n    free(x);\n    g_hash_table_destroy(bridge_to_cost);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum possible length of the tour when one of the bridges is closed. The key insight is that closing a bridge will split the tour into two segments, and we need to find the optimal bridge to close such that the sum of the lengths of these two segments is minimized.", "question_id": "abc338_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *points = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < 2 * n; i++) {\n        int point;\n        scanf(\"%d\", &point);\n        g_array_append_val(points, point);\n    }\n\n    qsort(points->data, points->len, sizeof(int), compare);\n\n    for (int i = 0; i < n; i++) {\n        int a1 = g_array_index(points, int, 2 * i);\n        int b1 = g_array_index(points, int, 2 * i + 1);\n        int a2 = g_array_index(points, int, 2 * i + 2);\n        int b2 = g_array_index(points, int, 2 * i + 3);\n\n        if ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) {\n            printf(\"Yes\\n\");\n            g_array_free(points, TRUE);\n            return 0;\n        }\n    }\n\n    printf(\"No\\n\");\n\n    g_array_free(points, TRUE);\n    return 0;\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}", "reasoning": "To determine if there is an intersection between the chords, we can use a mathematical property. Two chords intersect if and only if the points of one chord are in an alternating order with respect to the points of the other chord. Specifically, for chords (A1, B1) and (A2, B2), they intersect if (A1 < A2 < B1 < B2) or (A2 < A1 < B2 < B1). This can be checked by sorting the points and then checking the order of the chords.", "question_id": "abc338_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 20\n#define MAX_M (MAX_N * (MAX_N - 1))\n#define INF 1e9\n\ntypedef struct {\n    int to, weight;\n} Edge;\n\nGArray *graph[MAX_N];\nint dp[MAX_N][1 << MAX_N];\nint n, m;\n\nint dfs(int node, int visited) {\n    if (visited == (1 << n) - 1) {\n        return 0;\n    }\n    if (dp[node][visited] != -1) {\n        return dp[node][visited];\n    }\n    int min_cost = INF;\n    for (int i = 0; i < graph[node]->len; i++) {\n        Edge *edge = &g_array_index(graph[node], Edge, i);\n        if (!(visited & (1 << (edge->to - 1)))) {\n            int new_cost = dfs(edge->to, visited | (1 << (edge->to - 1))) + edge->weight;\n            if (new_cost < min_cost) {\n                min_cost = new_cost;\n            }\n        }\n    }\n    dp[node][visited] = min_cost;\n    return min_cost;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        graph[i] = g_array_new(FALSE, FALSE, sizeof(Edge));\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        u--; v--;\n        Edge edge = {v, w};\n        g_array_append_val(graph[u], edge);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (1 << n); j++) {\n            dp[i][j] = -1;\n        }\n    }\n\n    int min_cost = INF;\n    for (int i = 0; i < n; i++) {\n        int cost = dfs(i, 1 << i);\n        if (cost != INF) {\n            min_cost = cost;\n        }\n    }\n\n    if (min_cost == INF) {\n        printf(\"No\n\");\n    } else {\n        printf(\"%d\n\", min_cost);\n    }\n\n    for (int i = 0; i < n; i++) {\n        g_array_free(graph[i], TRUE);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exists a walk that visits each vertex at least once in a weighted directed graph. If such a walk exists, we need to find the minimum total weight of the edges traversed. The problem can be approached using a combination of depth-first search (DFS) and dynamic programming (DP). Here's a step-by-step breakdown of the approach:\n\n1. **Graph Representation**: Represent the graph using an adjacency list to store the edges and their weights.\n2. **DFS with Memoization**: Use DFS to explore all possible walks starting from each vertex. Use memoization to store the results of subproblems to avoid redundant calculations.\n3. **State Representation**: The state of the DP can be represented by the current vertex and the set of visited vertices. Use a bitmask to represent the set of visited vertices efficiently.\n4. **Base Case**: If all vertices are visited, check if the walk is valid (i.e., it visits each vertex at least once) and return the total weight of the edges traversed.\n5. **Transition**: For each vertex, explore all its neighbors and recursively call the DFS function for each neighbor. Update the state by marking the current vertex as visited and adding the weight of the edge to the total weight.\n6. **Result**: The result will be the minimum total weight of the edges traversed for all possible walks that visit each vertex at least once.", "question_id": "abc338_f"}
{"solution": "#include <stdio.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S[101];\n    scanf(\"%s\", S);\n\n    // Initialize variables\n    int len = strlen(S);\n    int start = len;\n\n    // Find the last occurrence of '..'\n    for (int i = len - 1; i >= 0; i--) {\n        if (S[i] == '.' && i > 0 && S[i - 1] == '.') {\n            start = i + 1;\n            break;\n        }\n    }\n\n    // Print the last substring\n    printf(\"%s\n\", S + start);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the last substring of the given string S that does not contain the substring '..'. Here's a step-by-step approach to achieve this:", "question_id": "abc339_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    char grid[H][W];\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            grid[i][j] = '.';\n        }\n    }\n\n    int x = 0, y = 0, dx = -1, dy = 0;\n    bool isWhite = true;\n\n    for (int i = 0; i < N; i++) {\n        if (grid[x][y] == '.') {\n            grid[x][y] = '#';\n            dx = 0;\n            dy = 1;\n        } else {\n            grid[x][y] = '.';\n            dx = 0;\n            dy = -1;\n        }\n\n        int nx = (x + dx + H) % H;\n        int ny = (y + dy + W) % W;\n        x = nx;\n        y = ny;\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            printf(\"%c\", grid[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate Takahashi's movements on a toroidal grid and keep track of the color of each cell. The key steps are:", "question_id": "abc339_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize the minimum number of passengers to a large positive value\n    long long min_passengers = LLONG_MAX;\n    long long current_passengers = 0;\n\n    // Process each stop\n    for (int i = 0; i < n; i++) {\n        int change;\n        scanf(\"%d\", &change);\n\n        // Update the current number of passengers\n        current_passengers += change;\n\n        // Update the minimum number of passengers encountered\n        if (current_passengers < min_passengers) {\n            min_passengers = current_passengers;\n        }\n    }\n\n    // The minimum possible current number of passengers is the absolute value of the minimum encountered\n    printf(\"%lld\n\", abs(min_passengers));\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum possible current number of passengers on the bus that is consistent with the given information. The key insight is to track the minimum number of passengers the bus could have had at any point in time, given the sequence of passenger changes. We can achieve this by maintaining a running total of the passenger changes and keeping track of the minimum value encountered.", "question_id": "abc339_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 60\n\nint minMovesToSameCell(char grid[MAX_N][MAX_N], int N) {\n    int player1[2], player2[2];\n    bool foundPlayer1 = false, foundPlayer2 = false;\n\n    // Find the positions of the two players\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 'P') {\n                if (!foundPlayer1) {\n                    player1[0] = i;\n                    player1[1] = j;\n                    foundPlayer1 = true;\n                } else {\n                    player2[0] = i;\n                    player2[1] = j;\n                    foundPlayer2 = true;\n                }\n            }\n        }\n        if (foundPlayer1 && foundPlayer2) {\n            break;\n        }\n    }\n\n    if (!foundPlayer1 || !foundPlayer2) {\n        return -1; // Players not found\n    }\n\n    // Calculate the Manhattan distance between the two players\n    int distance = abs(player1[0] - player2[0]) + abs(player1[1] - player2[1]);\n\n    // If the distance is even, they can meet in an even number of moves\n    // If the distance is odd, they can meet in an odd number of moves\n    return distance;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    char grid[MAX_N][MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int result = minMovesToSameCell(grid, N);\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum number of moves required to bring two players to the same cell in an N x N grid. The players can move in four directions: up, down, left, or right. Each player moves independently if the destination cell is empty and does not contain an obstacle. If it's impossible to bring the two players to the same cell, we should return -1. Here's a step-by-step approach to solve the problem:", "question_id": "abc339_d"}
{"solution": "#include <stdio.h>\n\nint main() {\n    // Read input\n    int A, B, D;\n    scanf(\"%d %d %d\", &A, &B, &D);\n\n    // Generate and print the arithmetic sequence\n    for (int i = A; i <= B; i += D) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate an arithmetic sequence given the first term (A), the last term (B), and the common difference (D). The arithmetic sequence is defined by the formula: A, A+D, A+2D, ..., B. We can generate the sequence by iterating from A to B with a step of D and printing each term. The constraints ensure that the sequence will always exist for the given inputs.", "question_id": "abc340_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int Q;\n    scanf(\"%d\", &Q);\n\n    // Initialize a GQueue to store the sequence\n    GQueue *queue = g_queue_new();\n\n    // Process each query\n    for (int i = 0; i < Q; i++) {\n        int query_type, value, k;\n        scanf(\"%d\", &query_type);\n\n        if (query_type == 1) {\n            // Append x to the end of A\n            scanf(\"%d\", &value);\n            g_queue_push_tail(queue, GINT_TO_POINTER(value));\n        } else if (query_type == 2) {\n            // Find the k-th value from the end of A\n            scanf(\"%d\", &k);\n            // Since g_queue_get_nth_from_end is not available, we reverse the queue, get the k-th element, and then reverse it back\n            GQueue *temp_queue = g_queue_new();\n            while (!g_queue_is_empty(queue)) {\n                g_queue_push_tail(temp_queue, g_queue_pop_head(queue));\n            }\n            gpointer kth_value = g_queue_peek_nth(temp_queue, k - 1);\n            printf(\"%d\\n\", GPOINTER_TO_INT(kth_value));\n\n            // Reverse the queue back to its original order\n            while (!g_queue_is_empty(temp_queue)) {\n                g_queue_push_tail(queue, g_queue_pop_head(temp_queue));\n            }\n            g_queue_free(temp_queue);\n        }\n    }\n\n    // Clean up\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to handle two types of queries efficiently. The first type is appending an integer to the sequence, and the second type is retrieving the k-th element from the end of the sequence. Given the constraints, using a simple array or linked list for the sequence would not be efficient for frequent appends and access operations. Instead, using a GQueue from GLib can be more suitable because it provides efficient append and access operations. The GQueue allows us to append elements to the end and access elements from the head, which is suitable for our needs.", "question_id": "abc340_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long long N;\n    scanf(\"%lld\", &N);\n\n    // Calculate the total amount paid\n    long long total = (N * (N + 1)) / 2;\n\n    // Subtract the initial number N from the total\n    total -= N;\n\n    // Print the result\n    printf(\"%lld\n\", total);\n\n    return 0;\n}", "reasoning": "The problem requires us to simulate the process of repeatedly dividing numbers by 2 and paying the corresponding amount until all numbers less than 2 are removed. The key observation is that each number x will eventually be split into 1s, and the total amount paid will be the sum of all numbers that are split. This can be efficiently calculated without simulating each step by recognizing that the total amount paid is simply the sum of all numbers from 2 to N, inclusive.", "question_id": "abc340_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint min_time_to_reach_stage(GHashTable *dp, int stage, int *A, int *B, int *X, int N) {\n    if (stage == N) {\n        return 0;\n    }\n    if (g_hash_table_contains(dp, GINT_TO_POINTER(stage))) {\n        return GPOINTER_TO_INT(g_hash_table_lookup(dp, GINT_TO_POINTER(stage)));\n    }\n    int next_stage_time = min_time_to_reach_stage(dp, stage + 1, A, B, X, N) + A[stage];\n    int jump_stage_time = INT_MAX;\n    if (stage + 1 <= N) {\n        jump_stage_time = min_time_to_reach_stage(dp, X[stage], A, B, X, N) + B[stage];\n    }\n    int min_time = min(next_stage_time, jump_stage_time);\n    g_hash_table_insert(dp, GINT_TO_POINTER(stage), GINT_TO_POINTER(min_time));\n    return min_time;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int *A = (int *)malloc(N * sizeof(int));\n    int *B = (int *)malloc(N * sizeof(int));\n    int *X = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N - 1; i++) {\n        scanf(\"%d %d %d\", &A[i], &B[i], &X[i]);\n    }\n    GHashTable *dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int result = min_time_to_reach_stage(dp, 1, A, B, X, N);\n    printf(\"%d\n\", result);\n    g_hash_table_destroy(dp);\n    free(A);\n    free(B);\n    free(X);\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum time required to reach stage N. The key observation is that we can either move to the next stage directly or jump to a different stage using a second action. This problem can be approached using dynamic programming with memoization. We'll use a hash table to store the minimum time required to reach each stage. For each stage, we'll calculate the minimum time by considering both actions (moving to the next stage and jumping to another stage). We'll iterate through all stages and update the minimum time for each stage based on the minimum time of the previous stages.", "question_id": "abc340_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Initialize the number of balls in each box\n    GHashTable *boxes = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        int balls;\n        scanf(\"%d\", &balls);\n        g_hash_table_insert(boxes, GINT_TO_POINTER(i), GINT_TO_POINTER(balls));\n    }\n\n    // Process each operation\n    for (int i = 0; i < M; i++) {\n        int B;\n        scanf(\"%d\", &B);\n\n        // Take out all balls from box B\n        int balls = GPOINTER_TO_INT(g_hash_table_lookup(boxes, GINT_TO_POINTER(B)));\n        g_hash_table_insert(boxes, GINT_TO_POINTER(B), GINT_TO_POINTER(0));\n\n        // Simulate the process of putting balls back into the boxes\n        int C = 0;\n        while (balls > 0) {\n            C++;\n            int new_box = (B + C) % N;\n            int new_balls = GPOINTER_TO_INT(g_hash_table_lookup(boxes, GINT_TO_POINTER(new_box))) + 1;\n            g_hash_table_insert(boxes, GINT_TO_POINTER(new_box), GINT_TO_POINTER(new_balls));\n            balls--;\n        }\n    }\n\n    // Print the number of balls in each box\n    for (int i = 0; i < N; i++) {\n        printf(\"%d\", GPOINTER_TO_INT(g_hash_table_lookup(boxes, GINT_TO_POINTER(i))));\n        if (i < N - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_hash_table_destroy(boxes);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the operations described. The key steps are:\n1. Initialize the number of balls in each box.\n2. For each operation, take out all balls from the specified box and simulate the process of putting them back into the boxes according to the given rules.\n3. Use a hash table to keep track of the number of balls in each box to efficiently update the counts.\n4. After all operations, print the number of balls in each box.", "question_id": "abc340_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Allocate memory for the result string\n    char *result = (char *)malloc((2 * n + 1) * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\n\");\n        return 1;\n    }\n\n    // Initialize the result string with alternating 1s and 0s\n    for (int i = 0; i < 2 * n + 1; i++) {\n        result[i] = (i % 2 == 0) ? '1' : '0';\n    }\n\n    // Print the result string\n    printf(\"%s\n\", result);\n\n    // Free the allocated memory\n    free(result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate a string of N zeros and N+1 ones where the digits alternate. Here's a step-by-step approach to achieve this:", "question_id": "abc341_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MAXN 200000\n\nint compare(const void *a, const void *b) {\n    double r1 = ((double *)a)[1] / ((double *)a)[2];\n    double r2 = ((double *)b)[1] / ((double *)b)[2];\n    if (r1 > r2) return -1;\n    if (r1 < r2) return 1;\n    return 0;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    long long A[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lld\", &A[i]);\n    }\n\n    double ratios[N-1][3];\n    for (int i = 0; i < N-1; i++) {\n        scanf(\"%lf %lf\", &ratios[i][1], &ratios[i][2]);\n        ratios[i][0] = i;\n    }\n\n    qsort(ratios, N-1, sizeof(ratios[0]), compare);\n\n    long long result = A[N-1];\n\n    for (int i = 0; i < N-1; i++) {\n        int idx = (int)ratios[i][0];\n        if (A[idx] >= ratios[i][1]) {\n            A[idx+1] += A[idx] / ratios[i][1] * ratios[i][2];\n            A[idx] = 0;\n        } else {\n            A[idx+1] += A[idx];\n            A[idx] = 0;\n        }\n    }\n\n    printf(\"%lld\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maximize the number of units of currency Takahashi has in country N. The key observation is that the operation can only be performed if Takahashi has at least S_i units of currency in country i. We can simulate this process by iterating through each country and performing the operation if possible. To ensure we maximize the result, we should prioritize operations that allow us to gain the most currency in the next country. This can be achieved by sorting the operations by the ratio T_i / S_i in descending order. By processing the operations in this order, we can maximize the number of units we gain in each step.", "question_id": "abc341_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 501\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    char T[MAX];\n    scanf(\"%s\", T);\n\n    char grid[H][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    // Find the initial position (crash-landed position)\n    int initial_x, initial_y;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '#') {\n                initial_x = i;\n                initial_y = j;\n                break;\n            }\n        }\n    }\n\n    // Directions for L, R, U, D\n    int dx[] = {0, 0, -1, 1};\n    int dy[] = {-1, 1, 0, 0};\n\n    // Use a hash set to keep track of visited positions\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Start from the initial position\n    g_hash_table_insert(visited, GINT_TO_POINTER(initial_x * W + initial_y), NULL);\n\n    // Simulate the movements\n    for (int i = 0; i < N; i++) {\n        GHashTable *new_visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (gpointer key = g_hash_table_get_first_key(visited); key != NULL; key = g_hash_table_get_next_key(visited, key)) {\n            int pos = GPOINTER_TO_INT(key);\n            int x = pos / W;\n            int y = pos % W;\n\n            for (int k = 0; k < 4; k++) {\n                int new_x = x + dx[k];\n                int new_y = y + dy[k];\n\n                if (new_x >= 0 && new_x < H && new_y >= 0 && new_y < W && grid[new_x][new_y] == '.') {\n                    int new_pos = new_x * W + new_y;\n                    if (!g_hash_table_contains(visited, GINT_TO_POINTER(new_pos))) {\n                        g_hash_table_insert(new_visited, GINT_TO_POINTER(new_pos), NULL);\n                    }\n                }\n            }\n        }\n        g_hash_table_destroy(visited);\n        visited = new_visited;\n    }\n\n    // Output the number of possible positions\n    printf(\"%d\n\", g_hash_table_size(visited));\n\n    // Clean up\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to track Takahashi's possible positions after he moves according to the given instructions. The key steps are:\n1. Parse the input to get the grid dimensions, the movement instructions, and the grid itself.\n2. Identify the initial position where Takahashi crash-landed. This is the only sea cell on the perimeter of the grid.\n3. Simulate Takahashi's movements from the initial position, ensuring he stays on land cells and does not go out of bounds.\n4. Count the number of unique positions Takahashi could be in after all movements.", "question_id": "abc341_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    // Initialize variables\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(long long));\n\n    // Find numbers divisible by N but not by M\n    for (long long i = N; arr->len < K; i += N) {\n        if (i % M != 0) {\n            g_array_append_val(arr, i);\n        }\n    }\n\n    // Find numbers divisible by M but not by N\n    for (long long i = M; arr->len < K; i += M) {\n        if (i % N != 0) {\n            g_array_append_val(arr, i);\n        }\n    }\n\n    // Sort the array to get the K-th smallest element\n    qsort(arr->data, arr->len, sizeof(long long), compare);\n\n    // Print the K-th smallest element\n    printf(\"%lld\\n\", g_array_index(arr, long long, K - 1));\n\n    // Clean up\n    g_array_free(arr, TRUE);\n\n    return 0;\n}\n\n// Comparison function for qsort\nint compare(const void *a, const void *b) {\n    return (*(long long*)a - *(long long*)b);\n}", "reasoning": "To solve this problem, we need to find the K-th smallest positive integer that is divisible by exactly one of the given integers N or M. Here's a step-by-step approach to achieve this:", "question_id": "abc341_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 500005\n\n// Segment tree node structure\ntypedef struct {\n    int start, end;\n    bool value;\n    bool lazy;\n} Node;\n\n// Segment tree structure\ntypedef struct {\n    Node *nodes;\n    int size;\n} SegmentTree;\n\n// Initialize the segment tree\nvoid initSegmentTree(SegmentTree *tree, int n) {\n    tree->size = 1;\n    while (tree->size < n) {\n        tree->size *= 2;\n    }\n    tree->nodes = (Node *)g_malloc(tree->size * sizeof(Node));\n    for (int i = 0; i < tree->size; i++) {\n        tree->nodes[i].start = -1;\n        tree->nodes[i].end = -1;\n        tree->nodes[i].value = false;\n        tree->nodes[i].lazy = false;\n    }\n}\n\n// Build the segment tree\nvoid buildSegmentTree(SegmentTree *tree, char *s, int index, int start, int end) {\n    if (start == end) {\n        tree->nodes[index].start = start;\n        tree->nodes[index].end = end;\n        tree->nodes[index].value = (s[start] == '1');\n        return;\n    }\n    int mid = (start + end) / 2;\n    buildSegmentTree(tree, s, 2 * index + 1, start, mid);\n    buildSegmentTree(tree, s, 2 * index + 2, mid + 1, end);\n    tree->nodes[index].start = start;\n    tree->nodes[index].end = end;\n    tree->nodes[index].value = tree->nodes[2 * index + 1].value != tree->nodes[2 * index + 2].value;\n}\n\n// Push lazy updates to children\nvoid pushLazy(SegmentTree *tree, int index) {\n    if (tree->nodes[index].lazy) {\n        tree->nodes[2 * index + 1].value = !tree->nodes[2 * index + 1].value;\n        tree->nodes[2 * index + 2].value = !tree->nodes[2 * index + 2].value;\n        tree->nodes[2 * index + 1].lazy = !tree->nodes[2 * index + 1].lazy;\n        tree->nodes[2 * index + 2].lazy = !tree->nodes[2 * index + 2].lazy;\n        tree->nodes[index].lazy = false;\n    }\n}\n\n// Update the segment tree\nvoid updateSegmentTree(SegmentTree *tree, int index, int start, int end, int left, int right) {\n    if (tree->nodes[index].lazy) {\n        pushLazy(tree, index);\n    }\n    if (start > end || start > right || end < left) {\n        return;\n    }\n    if (start >= left && end <= right) {\n        tree->nodes[index].value = !tree->nodes[index].value;\n        if (start != end) {\n            tree->nodes[index].lazy = !tree->nodes[index].lazy;\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    updateSegmentTree(tree, 2 * index + 1, start, mid, left, right);\n    updateSegmentTree(tree, 2 * index + 2, mid + 1, end, left, right);\n    tree->nodes[index].value = tree->nodes[2 * index + 1].value != tree->nodes[2 * index + 2].value;\n}\n\n// Query the segment tree\nbool querySegmentTree(SegmentTree *tree, int index, int start, int end, int left, int right) {\n    if (tree->nodes[index].lazy) {\n        pushLazy(tree, index);\n    }\n    if (start > end || start > right || end < left) {\n        return false;\n    }\n    if (start >= left && end <= right) {\n        return tree->nodes[index].value;\n    }\n    int mid = (start + end) / 2;\n    bool leftValue = querySegmentTree(tree, 2 * index + 1, start, mid, left, right);\n    bool rightValue = querySegmentTree(tree, 2 * index + 2, mid + 1, end, left, right);\n    return leftValue != rightValue;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    char *s = (char *)g_malloc((n + 1) * sizeof(char));\n    scanf(\"%s\", s);\n\n    SegmentTree tree;\n    initSegmentTree(&tree, n);\n    buildSegmentTree(&tree, s, 0, 0, n - 1);\n\n    for (int i = 0; i < q; i++) {\n        int type, l, r;\n        scanf(\"%d %d %d\", &type, &l, &r);\n        l--;\n        r--;\n\n        if (type == 1) {\n            updateSegmentTree(&tree, 0, 0, n - 1, l, r);\n        } else if (type == 2) {\n            bool result = querySegmentTree(&tree, 0, 0, n - 1, l, r);\n            printf(result ? \"Yes\n\" : \"No\n\");\n        }\n    }\n\n    g_free(s);\n    g_free(tree.nodes);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently handle two types of queries on a binary string. The first type of query involves flipping a segment of the string, and the second type involves checking if a segment of the string is a good string. Given the constraints, a naive approach would be inefficient. Instead, we can use a segment tree to efficiently handle the range updates and range queries required by the problem.", "question_id": "abc341_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Adjacency list to represent the graph\n    GArray *adj[n+1];\n    for (int i = 1; i <= n; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Array to store weights of vertices\n    int weight[n+1];\n\n    // Read edges and build adjacency list\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        g_array_append_val(adj[u], v);\n        g_array_append_val(adj[v], u);\n    }\n\n    // Read weights and pieces on vertices\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &weight[i]);\n    }\n\n    int pieces[n+1];\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &pieces[i]);\n    }\n\n    int operations = 0;\n\n    // While there are pieces to remove\n    while (true) {\n        int min_weight = INT_MAX;\n        int min_vertex = -1;\n\n        // Find the vertex with the minimum weight that has pieces to remove\n        for (int i = 1; i <= n; i++) {\n            if (pieces[i] > 0 && weight[i] < min_weight) {\n                min_weight = weight[i];\n                min_vertex = i;\n            }\n        }\n\n        // If no such vertex is found, break the loop\n        if (min_vertex == -1) {\n            break;\n        }\n\n        // Remove one piece from the selected vertex\n        pieces[min_vertex]--;\n\n        // Place pieces on adjacent vertices if possible\n        for (int i = 0; i < adj[min_vertex]->len; i++) {\n            int neighbor = g_array_index(adj[min_vertex], int, i);\n            if (weight[neighbor] < min_weight && pieces[neighbor] < INT_MAX) {\n                pieces[neighbor]++;\n            }\n        }\n\n        // Increment the number of operations\n        operations++;\n    }\n\n    // Output the maximum number of operations\n    printf(\"%d\n\", operations);\n\n    // Clean up\n    for (int i = 1; i <= n; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "reasoning": "The problem involves simulating a process on a graph where we repeatedly remove a piece from a vertex and place pieces on its adjacent vertices if the sum of the weights of the adjacent vertices is less than the weight of the current vertex. The goal is to determine the maximum number of times this operation can be performed. To solve this, we can use a greedy approach by always selecting the vertex with the minimum weight that has pieces to remove and placing pieces on its adjacent vertices if possible. We need to keep track of the number of operations performed and ensure that we handle all edge cases, such as when there are no pieces to remove or when the graph is empty.", "question_id": "abc341_f"}
{"solution": "#include <stdio.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[101];\n    scanf(\"%s\", S);\n\n    int len = strlen(S);\n    GHashTable *char_count = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Count occurrences of each character\n    for (int i = 0; i < len; i++) {\n        char *key = &S[i];\n        int *count = g_hash_table_lookup(char_count, key);\n        if (count) {\n            (*count)++;\n        } else {\n            g_hash_table_insert(char_count, key, GINT_TO_POINTER(1));\n        }\n    }\n\n    // Find the character that appears only once and its position\n    int result = -1;\n    for (int i = 0; i < len; i++) {\n        char *key = &S[i];\n        int count = GPOINTER_TO_INT(g_hash_table_lookup(char_count, key));\n        if (count == 1) {\n            result = i + 1;\n            break;\n        }\n    }\n\n    // Output the result\n    printf(\"%d\\n\", result);\n\n    // Clean up\n    g_hash_table_destroy(char_count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to identify the character in the string that is different from the others. Given that all characters except one are the same, we can iterate through the string and count the occurrences of each character. The character that appears only once is the one we are looking for. We then return its position (1-based index).", "question_id": "abc342_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int positions[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &positions[i]);\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n\n        // Find the indices of A_i and B_i in the positions array\n        int index_a = -1, index_b = -1;\n        for (int j = 0; j < n; j++) {\n            if (positions[j] == a) {\n                index_a = j;\n            }\n            if (positions[j] == b) {\n                index_b = j;\n            }\n        }\n\n        // Determine which person is further to the front\n        int result = (index_a < index_b) ? a : b;\n        printf(\"%d\n\", result);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine which person is standing further to the front between two given positions in a line. The constraints are small enough to allow a direct approach using arrays and simple comparisons. Here's the step-by-step reasoning and solution:", "question_id": "abc342_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char s[200001];\n    scanf(\"%s\", s);\n\n    int q;\n    scanf(\"%d\", &q);\n\n    GHashTable *map = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < q; i++) {\n        char c[2], d[2];\n        scanf(\"%s %s\", c, d);\n\n        g_hash_table_insert(map, c, d);\n    }\n\n    for (int i = 0; i < n; i++) {\n        char *replacement = g_hash_table_lookup(map, s + i);\n        if (replacement != NULL) {\n            s[i] = replacement[0];\n        }\n    }\n\n    printf(\"%s\n\", s);\n\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to apply a series of character replacement operations to a given string. The operations are applied in the order they are given, and each operation replaces all occurrences of a specific character with another character. The constraints indicate that the string can be quite large (up to 200,000 characters), so we need an efficient approach to handle these operations without running into performance issues. Using a hash map (GHashTable) to keep track of the replacements and applying them in a single pass through the string is an efficient solution.", "question_id": "abc342_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n#define MAXP 17  // Maximum number of prime factors (2^16)\n\nint prime[MAXP] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53};\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int A[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Preprocess the numbers to count the parity of exponents of their prime factors\n    int parity[MAXN][MAXP];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < MAXP; j++) {\n            parity[i][j] = 0;\n        }\n        int num = A[i];\n        for (int j = 0; j < MAXP; j++) {\n            while (num % prime[j] == 0) {\n                parity[i][j]++;\n                num /= prime[j];\n            }\n        }\n        for (int j = 0; j < MAXP; j++) {\n            parity[i][j] %= 2;\n        }\n    }\n\n    // Use a hash map to count how many numbers have the same parity of exponents as a given number\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        int *key = (int *)g_hash_table_lookup(map, parity[i]);\n        if (key) {\n            count += *key;\n        }\n        int *value = (int *)malloc(sizeof(int));\n        *value = 1;\n        g_hash_table_insert(map, parity[i], value);\n    }\n\n    // Output the result\n    printf(\"%d\\n\", count);\n\n    // Clean up\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find pairs (i, j) such that the product A_i * A_j is a perfect square. A number is a perfect square if and only if all the exponents in its prime factorization are even. Therefore, we can preprocess the numbers to count the parity (even or odd) of the exponents of their prime factors. Then, we can use a hash map to count how many numbers have the same parity of exponents as a given number. For each number, we can then count the number of pairs that can be formed with numbers having the same parity of exponents.", "question_id": "abc342_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200005\n#define MAX_M 200005\n#define INF INT_MIN\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashTable *dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 1; i <= N; i++) {\n        g_hash_table_insert(dp, GINT_TO_POINTER(i), GINT_TO_POINTER(INF));\n    }\n\n    for (int i = 0; i < M; i++) {\n        int l, d, k, c, A, B;\n        scanf(\"%d %d %d %d %d %d\", &l, &d, &k, &c, &A, &B);\n\n        for (int j = 0; j < k; j++) {\n            int t = l + j * d;\n            int next_time = t + c;\n            int *latest_arrival = g_hash_table_lookup(dp, GINT_TO_POINTER(A));\n            if (latest_arrival != NULL && *latest_arrival <= t) {\n                int *new_latest_arrival = g_hash_table_lookup(dp, GINT_TO_POINTER(B));\n                if (new_latest_arrival != NULL) {\n                    if (*new_latest_arrival < next_time) {\n                        *new_latest_arrival = next_time;\n                    }\n                } else {\n                    g_hash_table_insert(dp, GINT_TO_POINTER(B), GINT_TO_POINTER(next_time));\n                }\n            }\n        }\n    }\n\n    for (int i = 2; i < N; i++) {\n        int *latest_arrival = g_hash_table_lookup(dp, GINT_TO_POINTER(i));\n        if (latest_arrival != NULL && *latest_arrival != INF) {\n            printf(\"%d\\n\", *latest_arrival);\n        } else {\n            printf(\"Unreachable\\n\");\n        }\n    }\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "reasoning": "The problem involves finding the latest time one can arrive at station N from station 1, considering the constraints and train schedules provided. We can approach this by using dynamic programming with a hash table to store the latest possible arrival times at each station. The key is to iterate through each train and update the latest arrival times accordingly. We need to handle edge cases such as trains arriving at the same station and the possibility of no valid arrival times.", "question_id": "abc342_e"}
{"solution": "#include <stdio.h>\n\nint main() {\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n    int sum = A + B;\n    int result = (sum == 0) ? 1 : 0;\n    printf(\"%d\n\", result);\n    return 0;\n}", "reasoning": "The problem requires us to find any integer between 0 and 9 that is not equal to the sum of two given integers A and B. Given the constraints, we can simply calculate the sum of A and B, and then print any other integer from 0 to 9 that is not equal to this sum. Since the sum is guaranteed to be between 0 and 9 (inclusive), and we are asked to print any integer that is not equal to this sum, we can simply print 0 if the sum is not 0, or 1 if the sum is 0, and so on. This approach ensures that we always print a valid integer that meets the problem requirements.", "question_id": "abc343_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create a GArray for each vertex to store its connected vertices\n    GArray *adj_lists[n];\n    for (int i = 0; i < n; i++) {\n        adj_lists[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read the adjacency matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int a;\n            scanf(\"%d\", &a);\n            if (a == 1) {\n                g_array_append_val(adj_lists[i], j + 1);\n            }\n        }\n    }\n\n    // Print the connected vertices for each vertex in ascending order\n    for (int i = 0; i < n; i++) {\n        g_array_sort(adj_lists[i], (GCompareFunc)g_int_compare);\n        for (int j = 0; j < adj_lists[i]->len; j++) {\n            printf(\"%d \", g_array_index(adj_lists[i], int, j));\n        }\n        printf(\"\\n\");\n    }\n\n    // Free the allocated memory\n    for (int i = 0; i < n; i++) {\n        g_array_free(adj_lists[i], TRUE);\n    }\n\n    return 0;\n}", "reasoning": "The problem requires us to find and print the vertices directly connected to each vertex in a given graph represented by an adjacency matrix. We will use a GArray to store the connected vertices for each vertex and then sort them before printing. Here's the step-by-step approach:", "question_id": "abc343_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to check if a number is a palindrome\nbool is_palindrome(long long num) {\n    char str[20];  // Assuming the number will fit in a 20-character string\n    sprintf(str, \"%lld\", num);\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    // Read input\n    long long N;\n    scanf(\"%lld\", &N);\n\n    // Initialize variables\n    long long max_palindromic_cube = 0;\n    for (long long i = 1; i * i * i <= N; i++) {\n        long long cube = i * i * i;\n        if (is_palindrome(cube)) {\n            max_palindromic_cube = cube;\n        }\n    }\n\n    // Output result\n    printf(\"%lld\n\", max_palindromic_cube);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum palindromic cube number not greater than a given integer N. Here's a step-by-step approach to achieve this:", "question_id": "abc343_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N, T;\n    scanf(\"%d %d\", &N, &T);\n\n    // Initialize data structures\n    GArray *scores = g_array_new(FALSE, FALSE, sizeof(int));\n    GHashTable *score_counts = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GArray *result = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Initialize scores to zero\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(scores, 0);\n        g_hash_table_insert(score_counts, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n    }\n\n    // Process each time step\n    for (int i = 0; i < T; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n\n        // Update the score of player A\n        int current_score = g_array_index(scores, int, A - 1);\n        int new_score = current_score + B;\n        g_array_index(scores, int, A - 1) = new_score;\n\n        // Update the count of the new score\n        int *count = (int *)g_hash_table_lookup(score_counts, GINT_TO_POINTER(new_score));\n        if (count) {\n            *count += 1;\n        } else {\n            g_hash_table_insert(score_counts, GINT_TO_POINTER(new_score), GINT_TO_POINTER(1));\n        }\n\n        // Remove the count of the old score\n        count = (int *)g_hash_table_lookup(score_counts, GINT_TO_POINTER(current_score));\n        if (count) {\n            *count -= 1;\n            if (*count == 0) {\n                g_hash_table_remove(score_counts, GINT_TO_POINTER(current_score));\n            }\n        }\n\n        // Get the number of unique scores\n        int unique_scores = g_hash_table_size(score_counts);\n        g_array_append_val(result, unique_scores);\n    }\n\n    // Output the result\n    for (int i = 0; i < T; i++) {\n        printf(\"%d\n\", g_array_index(result, int, i));\n    }\n\n    // Clean up\n    g_array_free(scores, TRUE);\n    g_hash_table_destroy(score_counts);\n    g_array_free(result, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to track the scores of players over time and determine the number of unique scores at each moment. Here's a step-by-step approach to achieve this:", "question_id": "abc343_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int V1, V2, V3;\n    scanf(\"%d %d %d\", &V1, &V2, &V3);\n\n    // Check if the given volumes are possible\n    if (V1 + 2 * V2 + V3 != 3 * 7 * 7 * 7) {\n        printf(\"No\\n\");\n        return 0;\n    }\n\n    // Calculate the coordinates of the cubes\n    int a1 = 0, b1 = 0, c1 = 0;\n    int a2 = 0, b2 = 6, c2 = 0;\n    int a3 = 6, b3 = 0, c3 = 0;\n\n    // Print the coordinates\n    printf(\"Yes\\n\");\n    printf(\"%d %d %d %d %d %d %d %d %d\\n\", a1, b1, c1, a2, b2, c2, a3, b3, c3);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exist three cubes with side length 7 such that the volumes of the regions contained in exactly one, two, and three cubes are given by V_1, V_2, and V_3 respectively. We will use the properties of the cubes and their intersections to derive the conditions under which such cubes can exist.", "question_id": "abc343_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_LEN 101\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint main() {\n    char T[MAX_LEN];\n    int N;\n    scanf(\"%s\", T);\n    scanf(\"%d\", &N);\n\n    GHashTable *dp = g_hash_table_new(g_str_hash, g_str_equal);\n    g_hash_table_insert(dp, \"\", GINT_TO_POINTER(0));\n\n    for (int i = 0; i < N; i++) {\n        int A;\n        scanf(\"%d\", &A);\n        char bags[A][MAX_LEN];\n        for (int j = 0; j < A; j++) {\n            scanf(\"%s\", bags[j]);\n        }\n\n        GHashTable *new_dp = g_hash_table_new(g_str_hash, g_str_equal);\n\n        for (int j = 0; j < A; j++) {\n            char *bag = bags[j];\n            int len = strlen(bag);\n\n            for (gpointer key = g_hash_table_lookup_extended(dp, \"\", NULL, NULL); key != NULL; key = g_hash_table_lookup_extended(dp, key, NULL, NULL)) {\n                char *prefix = key;\n                char *suffix = g_strconcat(prefix, bag, NULL);\n                int cost = GPOINTER_TO_INT(key) + len;\n\n                if (!g_hash_table_contains(dp, suffix)) {\n                    g_hash_table_insert(new_dp, suffix, GINT_TO_POINTER(cost));\n                } else {\n                    int existing_cost = GPOINTER_TO_INT(g_hash_table_lookup(dp, suffix));\n                    if (cost < existing_cost) {\n                        g_hash_table_insert(new_dp, suffix, GINT_TO_POINTER(cost));\n                    }\n                }\n\n                g_free(suffix);\n            }\n        }\n\n        g_hash_table_destroy(dp);\n        dp = new_dp;\n    }\n\n    int result = -1;\n    if (g_hash_table_contains(dp, T)) {\n        result = GPOINTER_TO_INT(g_hash_table_lookup(dp, T));\n    }\n\n    printf(\"%d\n\", result);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum cost to transform an empty string S into a target string T by concatenating strings from given bags. Here's a step-by-step approach to achieve this using dynamic programming and a hash table to keep track of the minimum cost to form substrings of T.", "question_id": "abc344_d"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char s[101];\n    scanf(\"%s\", s);\n\n    int len = strlen(s);\n    int first_pipe = -1;\n    int second_pipe = -1;\n\n    // Find the positions of the two | characters\n    for (int i = 0; i < len; i++) {\n        if (s[i] == '|') {\n            if (first_pipe == -1) {\n                first_pipe = i;\n            } else {\n                second_pipe = i;\n                break;\n            }\n        }\n    }\n\n    // Copy characters before the first | to a new string\n    char result[101];\n    int result_index = 0;\n    for (int i = 0; i < first_pipe; i++) {\n        result[result_index++] = s[i];\n    }\n\n    // Skip characters between the two | characters\n    for (int i = second_pipe + 1; i < len; i++) {\n        result[result_index++] = s[i];\n    }\n\n    // Null-terminate the result string\n    result[result_index] = '\\0';\n\n    // Print the result\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "reasoning": "The problem requires us to remove the characters between two | characters in a given string. We can achieve this by iterating through the string and copying characters to a new string until we encounter the first |. Then, we skip copying until we encounter the second |. Finally, we copy the remaining characters to the new string. We use a simple loop to traverse the string and conditional checks to determine whether to copy characters or skip them.", "question_id": "abc344_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m, l, q;\n    scanf(\"%d\", &n);\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    scanf(\"%d\", &m);\n    int *b = (int *)malloc(m * sizeof(int));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    scanf(\"%d\", &l);\n    int *c = (int *)malloc(l * sizeof(int));\n    for (int i = 0; i < l; i++) {\n        scanf(\"%d\", &c[i]);\n    }\n\n    scanf(\"%d\", &q);\n    int *x = (int *)malloc(q * sizeof(int));\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d\", &x[i]);\n    }\n\n    GHashTable *bc_sums = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < l; j++) {\n            int sum = b[i] + c[j];\n            g_hash_table_insert(bc_sums, GINT_TO_POINTER(sum), GINT_TO_POINTER(1));\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int target = x[i] - a[i];\n        gpointer found = g_hash_table_lookup(bc_sums, GINT_TO_POINTER(target));\n        if (found) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    g_hash_table_destroy(bc_sums);\n    free(a);\n    free(b);\n    free(c);\n    free(x);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if for each value in sequence X, we can find one element from each of sequences A, B, and C such that their sum equals the corresponding value in X. Given the constraints, a brute-force approach would be inefficient, so we need a more optimized solution. We can use a hash map to store the sums of pairs from sequences B and C, and then for each element in A, check if there exists a pair in B and C that sums up to X_i - A_i. This way, we can efficiently check for the existence of such pairs without needing to perform nested loops.", "question_id": "abc344_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    int num;\n\n    // Read integers until 0 is encountered\n    while (scanf(\"%d\", &num) == 1 && num != 0) {\n        g_array_append_val(arr, num);\n    }\n\n    // Print the integers in reverse order\n    for (int i = arr->len - 1; i >= 0; i--) {\n        printf(\"%d\n\", g_array_index(arr, int, i));\n    }\n\n    // Free the dynamically allocated array\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "reasoning": "The problem requires reading integers from standard input until a zero is encountered, and then printing the integers in reverse order. Since the number of integers is not given, we need to read until we encounter a zero. We can use a dynamic array to store the integers as we read them. Once we encounter a zero, we print the integers in reverse order from the dynamic array.", "question_id": "abc344_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Define a structure for the linked list node\ntypedef struct Node {\n    int value;\n    struct Node *next;\n    struct Node *prev;\n} Node;\n\n// Function to create a new node\nNode* create_node(int value) {\n    Node *new_node = (Node*)malloc(sizeof(Node));\n    new_node->value = value;\n    new_node->next = NULL;\n    new_node->prev = NULL;\n    return new_node;\n}\n\n// Function to insert a node after a given node\nvoid insert_after(Node *prev_node, int value) {\n    if (prev_node == NULL) {\n        return;\n    }\n    Node *new_node = create_node(value);\n    new_node->next = prev_node->next;\n    new_node->prev = prev_node;\n    if (prev_node->next != NULL) {\n        prev_node->next->prev = new_node;\n    }\n    prev_node->next = new_node;\n}\n\n// Function to delete a node\nvoid delete_node(Node *node) {\n    if (node == NULL) {\n        return;\n    }\n    if (node->prev != NULL) {\n        node->prev->next = node->next;\n    }\n    if (node->next != NULL) {\n        node->next->prev = node->prev;\n    }\n    free(node);\n}\n\nint main() {\n    // Read input\n    int N;\n    scanf(\"%d\", &N);\n    int A[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Initialize the linked list and hash table\n    GHashTable *hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n    Node *head = NULL;\n    Node *tail = NULL;\n\n    // Populate the linked list and hash table\n    for (int i = 0; i < N; i++) {\n        Node *new_node = create_node(A[i]);\n        g_hash_table_insert(hash, GINT_TO_POINTER(A[i]), new_node);\n        if (head == NULL) {\n            head = new_node;\n            tail = new_node;\n        } else {\n            tail->next = new_node;\n            new_node->prev = tail;\n            tail = new_node;\n        }\n    }\n\n    // Process queries\n    int Q;\n    scanf(\"%d\", &Q);\n    for (int i = 0; i < Q; i++) {\n        int type, x, y;\n        scanf(\"%d %d\", &type, &x);\n        if (type == 1) {\n            scanf(\"%d\", &y);\n            Node *x_node = (Node*)g_hash_table_lookup(hash, GINT_TO_POINTER(x));\n            insert_after(x_node, y);\n        } else if (type == 2) {\n            Node *x_node = (Node*)g_hash_table_lookup(hash, GINT_TO_POINTER(x));\n            delete_node(x_node);\n            g_hash_table_remove(hash, GINT_TO_POINTER(x));\n        }\n    }\n\n    // Print the final sequence\n    Node *current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->value);\n        current = current->next;\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_hash_table_destroy(hash);\n    Node *current_node = head;\n    while (current_node != NULL) {\n        Node *next_node = current_node->next;\n        free(current_node);\n        current_node = next_node;\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently handle insertions and deletions in a sequence. Given the constraints, a linked list is a suitable data structure because it allows for efficient insertion and deletion operations. However, we need to maintain the order of elements and handle queries in the given order. A doubly linked list would be ideal for this purpose, but since GLib does not provide a direct implementation, we will use a combination of a hash table for quick lookups and a linked list for maintaining the order.", "question_id": "abc344_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 7\n#define MAX_H 10\n#define MAX_W 10\n\ntypedef struct {\n    int A;\n    int B;\n} Tile;\n\nGHashTable *tile_positions;\nGArray *available_tiles;\n\nvoid print_grid(int H, int W) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            printf(\".\");\n        }\n        printf(\"\\n\");\n    }\n}\n\nbool can_place_tile(int H, int W, int x, int y, Tile tile, int orientation) {\n    int A = tile.A;\n    int B = tile.B;\n    if (orientation == 0) {\n        if (x + A > W || y + B > H) return false;\n        for (int i = x; i < x + A; i++) {\n            for (int j = y; j < y + B; j++) {\n                if (g_hash_table_lookup(tile_positions, GINT_TO_POINTER(j * W + i)) != NULL) return false;\n            }\n        }\n    } else {\n        if (x + B > W || y + A > H) return false;\n        for (int i = x; i < x + B; i++) {\n            for (int j = y; j < y + A; j++) {\n                if (g_hash_table_lookup(tile_positions, GINT_TO_POINTER(j * W + i)) != NULL) return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid place_tile(int H, int W, int x, int y, Tile tile, int orientation) {\n    int A = tile.A;\n    int B = tile.B;\n    if (orientation == 0) {\n        for (int i = x; i < x + A; i++) {\n            for (int j = y; j < y + B; j++) {\n                g_hash_table_insert(tile_positions, GINT_TO_POINTER(j * W + i), GINT_TO_POINTER(1));\n            }\n        }\n    } else {\n        for (int i = x; i < x + B; i++) {\n            for (int j = y; j < y + A; j++) {\n                g_hash_table_insert(tile_positions, GINT_TO_POINTER(j * W + i), GINT_TO_POINTER(1));\n            }\n        }\n    }\n}\n\nvoid remove_tile(int H, int W, int x, int y, Tile tile, int orientation) {\n    int A = tile.A;\n    int B = tile.B;\n    if (orientation == 0) {\n        for (int i = x; i < x + A; i++) {\n            for (int j = y; j < y + B; j++) {\n                g_hash_table_remove(tile_positions, GINT_TO_POINTER(j * W + i));\n            }\n        }\n    } else {\n        for (int i = x; i < x + B; i++) {\n            for (int j = y; j < y + A; j++) {\n                g_hash_table_remove(tile_positions, GINT_TO_POINTER(j * W + i));\n            }\n        }\n    }\n}\n\nbool solve(int H, int W, int index) {\n    if (index == available_tiles->len) return true;\n    Tile tile = g_array_index(available_tiles, Tile, index);\n    for (int x = 0; x <= W - tile.A; x++) {\n        for (int y = 0; y <= H - tile.B; y++) {\n            if (can_place_tile(H, W, x, y, tile, 0)) {\n                place_tile(H, W, x, y, tile, 0);\n                if (solve(H, W, index + 1)) return true;\n                remove_tile(H, W, x, y, tile, 0);\n            }\n            if (can_place_tile(H, W, x, y, tile, 1)) {\n                place_tile(H, W, x, y, tile, 1);\n                if (solve(H, W, index + 1)) return true;\n                remove_tile(H, W, x, y, tile, 1);\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int N, H, W;\n    scanf(\"%d %d %d\", &N, &H, &W);\n\n    tile_positions = g_hash_table_new(g_direct_hash, g_direct_equal);\n    available_tiles = g_array_new(FALSE, FALSE, sizeof(Tile));\n\n    for (int i = 0; i < N; i++) {\n        Tile tile;\n        scanf(\"%d %d\", &tile.A, &tile.B);\n        g_array_append_val(available_tiles, tile);\n    }\n\n    if (solve(H, W, 0)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    g_hash_table_destroy(tile_positions);\n    g_array_free(available_tiles, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can place N tiles on a grid of size H x W such that every cell is covered by exactly one tile. The tiles can be rotated or flipped, but they must be aligned with the edges of the cells. This problem can be approached using a backtracking algorithm to try placing each tile in every possible position and orientation on the grid, and then checking if the remaining cells can be covered by the remaining tiles. We will use a hash table to keep track of the positions of the tiles and a dynamic array to store the list of available tiles.", "question_id": "abc345_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint main() {\n    char X[20];\n    scanf(\"%s\", X);\n\n    // Convert string to double\n    double x = atof(X);\n\n    // Compute ceiling of X/10\n    double result = ceil(x / 10);\n\n    // Convert result back to integer and print\n    printf(\"%d\\n\", (int)result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to compute the ceiling of X/10, which means we need to find the smallest integer that is not less than the result of X/10. In C, we can use the ceil() function from the math.h library to achieve this. The ceil() function takes a double as an argument and returns the smallest integer not less than that value. Since X can be a very large integer, we need to ensure that we handle it correctly. We can read the input as a string and then convert it to a double before applying the ceil() function. Finally, we convert the result back to an integer and print it.", "question_id": "abc345_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    long long costs[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld\", &costs[i]);\n    }\n\n    GHashTable *dp = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < n; i++) {\n        char key[2];\n        key[0] = s[i];\n        key[1] = '\\0';\n\n        long long min_cost = LLONG_MAX;\n\n        if (i > 0) {\n            char prev_key[2];\n            prev_key[0] = s[i - 1];\n            prev_key[1] = '\\0';\n\n            gpointer prev_cost_ptr = g_hash_table_lookup(dp, prev_key);\n            if (prev_cost_ptr != NULL) {\n                long long prev_cost = GPOINTER_TO_INT(prev_cost_ptr);\n                min_cost = prev_cost;\n            }\n        }\n\n        if (i < n - 1) {\n            char next_key[2];\n            next_key[0] = s[i + 1];\n            next_key[1] = '\\0';\n\n            gpointer next_cost_ptr = g_hash_table_lookup(dp, next_key);\n            if (next_cost_ptr != NULL) {\n                long long next_cost = GPOINTER_TO_INT(next_cost_ptr);\n                min_cost = next_cost;\n            }\n        }\n\n        if (min_cost == LLONG_MAX) {\n            min_cost = 0;\n        }\n\n        min_cost += costs[i];\n\n        g_hash_table_insert(dp, key, GINT_TO_POINTER(min_cost));\n    }\n\n    long long min_cost = LLONG_MAX;\n\n    for (int i = 0; i < n; i++) {\n        char key[2];\n        key[0] = s[i];\n        key[1] = '\\0';\n\n        gpointer cost_ptr = g_hash_table_lookup(dp, key);\n        if (cost_ptr != NULL) {\n            long long cost = GPOINTER_TO_INT(cost_ptr);\n            if (cost < min_cost) {\n                min_cost = cost;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", min_cost);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum cost to transform the string S into a good string. A good string has exactly one pair of consecutive characters that are the same. We can achieve this by performing operations on the characters of S to make them equal at a specific position while minimizing the total cost.", "question_id": "abc346_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int W, B;\n    scanf(\"%d %d\", &W, &B);\n\n    // The repeating pattern is 'wbwbwwbwbwbw'\n    char pattern[] = \"wbwbwwbwbwbw\";\n    int pattern_len = strlen(pattern);\n\n    // We need a window of size W + B\n    int window_size = W + B;\n\n    // Iterate through the pattern to find the required window\n    for (int i = 0; i < pattern_len; i++) {\n        int w_count = 0;\n        int b_count = 0;\n\n        // Check the current window of size W + B\n        for (int j = 0; j < window_size; j++) {\n            char current_char = pattern[(i + j) % pattern_len];\n            if (current_char == 'w') {\n                w_count++;\n            } else if (current_char == 'b') {\n                b_count++;\n            }\n\n            // If we find the required counts, return 'Yes'\n            if (w_count == W && b_count == B) {\n                printf(\"Yes\\n\");\n                return 0;\n            }\n        }\n    }\n\n    // If no such window is found, return 'No'\n    printf(\"No\\n\");\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exists a substring in the infinite string S that consists of exactly W occurrences of 'w' and B occurrences of 'b'. The string S is formed by repeating the pattern 'wbwbwwbwbwbw'. We can approach this problem by iterating through the pattern and checking for the required occurrences of 'w' and 'b' in a sliding window of size W + B. If we find such a window, we return 'Yes'. If we complete the iteration without finding such a window, we return 'No'.", "question_id": "abc346_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int H, W, M;\n    scanf(\"%d %d %d\", &H, &W, &M);\n\n    GHashTable *color_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < M; i++) {\n        int T, A, X;\n        scanf(\"%d %d %d\", &T, &A, &X);\n\n        if (T == 1) {\n            // Repaint all cells in the A-th row with color X\n            for (int j = 0; j < W; j++) {\n                int current_color = 0; // Assuming initial color is 0\n                gpointer count_ptr = g_hash_table_lookup(color_count, GINT_TO_POINTER(current_color));\n                int count = count_ptr ? GPOINTER_TO_INT(count_ptr) : 0;\n                count -= 1; // Remove the current color count\n                g_hash_table_insert(color_count, GINT_TO_POINTER(current_color), GINT_TO_POINTER(count));\n\n                g_hash_table_insert(color_count, GINT_TO_POINTER(X), GINT_TO_POINTER(count + 1));\n            }\n        } else if (T == 2) {\n            // Repaint all cells in the A-th column with color X\n            for (int j = 0; j < H; j++) {\n                int current_color = 0; // Assuming initial color is 0\n                gpointer count_ptr = g_hash_table_lookup(color_count, GINT_TO_POINTER(current_color));\n                int count = count_ptr ? GPOINTER_TO_INT(count_ptr) : 0;\n                count -= 1; // Remove the current color count\n                g_hash_table_insert(color_count, GINT_TO_POINTER(current_color), GINT_TO_POINTER(count));\n\n                g_hash_table_insert(color_count, GINT_TO_POINTER(X), GINT_TO_POINTER(count + 1));\n            }\n        }\n    }\n\n    // Count distinct colors\n    int distinct_colors = 0;\n    GList *keys = g_hash_table_get_keys(color_count);\n    for (GList *node = keys; node != NULL; node = node->next) {\n        if (GPOINTER_TO_INT(node->data) > 0) {\n            distinct_colors++;\n        }\n    }\n\n    printf(\"%d\n\", distinct_colors);\n\n    // Print distinct colors and their counts\n    GList *sorted_keys = g_list_sort(keys, (GCompareFunc)g_int_compare);\n    for (GList *node = sorted_keys; node != NULL; node = node->next) {\n        int color = GPOINTER_TO_INT(node->data);\n        if (color > 0) {\n            gpointer count_ptr = g_hash_table_lookup(color_count, GINT_TO_POINTER(color));\n            int count = count_ptr ? GPOINTER_TO_INT(count_ptr) : 0;\n            printf(\"%d %d\n\", color, count);\n        }\n    }\n\n    // Clean up\n    g_hash_table_destroy(color_count);\n    g_list_free(sorted_keys);\n    g_list_free(keys);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the operations on a grid and keep track of the number of cells painted with each color. We will use a hash table to store the count of cells for each color. The operations are either repainting a row or a column, and we need to update the hash table accordingly. After all operations, we will output the distinct colors and their counts in ascending order.", "question_id": "abc346_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    int *a = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // Compute and print B_i\n    for (int i = 0; i < n - 1; i++) {\n        printf(\"%d \", a[i] * a[i + 1]);\n    }\n\n    // Free allocated memory\n    free(a);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to compute the product of each pair of consecutive integers in the given list and print the results. Here's a step-by-step approach to achieve this:", "question_id": "abc346_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    // Create a hash table to store the elements of A\n    GHashTable *hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the sequence A and insert elements into the hash table\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_hash_table_insert(hash, GINT_TO_POINTER(value), GINT_TO_POINTER(1));\n    }\n\n    // Calculate the sum of integers between 1 and K that do not appear in A\n    long long sum = 0;\n    for (int i = 1; i <= k; i++) {\n        if (!g_hash_table_lookup(hash, GINT_TO_POINTER(i))) {\n            sum += i;\n        }\n    }\n\n    // Print the result\n    printf(\"%lld\\n\", sum);\n\n    // Clean up\n    g_hash_table_destroy(hash);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the sum of integers between 1 and K that do not appear in the given sequence A. Here's a step-by-step approach to achieve this:", "question_id": "abc346_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint main() {\n    int N, A, B;\n    scanf(\"%d %d %d\", &N, &A, &B);\n\n    int total_days = A + B;\n    bool possible = true;\n\n    for (int i = 0; i < N; i++) {\n        int D;\n        scanf(\"%d\", &D);\n        if (D % total_days != 0) {\n            possible = false;\n            break;\n        }\n    }\n\n    if (possible) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if it's possible for all of Takahashi's N plans to be scheduled on holidays. The key insight is that a plan will be scheduled on a holiday if and only if the number of days until the plan (D_i) is a multiple of the total number of days in a week (A + B). This is because the holidays repeat every A + B days. Therefore, we need to check if all D_i values are multiples of A + B. If they are, the answer is Yes; otherwise, it's No.", "question_id": "abc347_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    // Create a hash table to store the quotients\n    GHashTable *quotients = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the sequence A and store the multiples of K and their quotients\n    for (int i = 0; i < N; i++) {\n        int A;\n        scanf(\"%d\", &A);\n        if (A % K == 0) {\n            int quotient = A / K;\n            g_hash_table_insert(quotients, GINT_TO_POINTER(quotient), GINT_TO_POINTER(1));\n        }\n    }\n\n    // Sort the keys of the hash table\n    GList *keys = g_hash_table_get_keys(quotients);\n    keys = g_list_sort(keys, (GCompareFunc)g_int_compare);\n\n    // Print the sorted keys\n    GList *node = keys;\n    while (node != NULL) {\n        printf(\"%d \", GPOINTER_TO_INT(node->data));\n        node = node->next;\n    }\n    printf(\"\\n\");\n\n    // Clean up the memory allocated for the hash table and the list\n    g_hash_table_destroy(quotients);\n    g_list_free(keys);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to follow these steps:\n1. Read the input values N, K, and the sequence A.\n2. Create a hash table to store the elements of A that are multiples of K and their corresponding quotients.\n3. Iterate through the sequence A and check if each element is a multiple of K.\n4. If it is, divide the element by K and store the quotient in the hash table.\n5. Sort the keys of the hash table in ascending order.\n6. Print the sorted keys.\n7. Clean up the memory allocated for the hash table.", "question_id": "abc347_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize the array A with all elements set to 0\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(A, 0);\n    }\n\n    // Initialize the set S\n    GHashTable *S = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Process each query\n    for (int i = 0; i < Q; i++) {\n        int x;\n        scanf(\"%d\", &x);\n\n        if (g_hash_table_contains(S, GINT_TO_POINTER(x))) {\n            // Remove x from S\n            g_hash_table_remove(S, GINT_TO_POINTER(x));\n        } else {\n            // Insert x into S\n            g_hash_table_insert(S, GINT_TO_POINTER(x), GINT_TO_POINTER(1));\n        }\n\n        // Update the array A based on the size of S\n        int size_S = g_hash_table_size(S);\n        for (int j = 0; j < N; j++) {\n            if (g_hash_table_contains(S, GINT_TO_POINTER(j + 1))) {\n                g_array_index(A, int, j) += size_S;\n            }\n        }\n    }\n\n    // Print the updated array A\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", g_array_index(A, int, i));\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_array_free(A, TRUE);\n    g_hash_table_destroy(S);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently handle set operations and update an array based on the size of the set. Here's a step-by-step approach to solve it using GLib data structures for optimal performance:", "question_id": "abc347_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char str[1001];\n    scanf(\"%s\", str);\n\n    // Set to store unique substrings\n    GHashTable *substr_set = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Length of the input string\n    int len = strlen(str);\n\n    // Generate all substrings and insert into the set\n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j <= len; j++) {\n            char *substring = g_strndup(str + i, j - i);\n            g_hash_table_insert(substr_set, substring, GINT_TO_POINTER(1));\n        }\n    }\n\n    // Count of unique substrings\n    int count = g_hash_table_size(substr_set);\n\n    // Output the result\n    printf(\"%d\n\", count);\n\n    // Clean up\n    g_hash_table_destroy(substr_set);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count all unique non-empty substrings of a given string S. A naive approach would involve generating all possible substrings and storing them in a set to ensure uniqueness. However, this approach would be inefficient for large strings due to its high time complexity. Instead, we can use a more efficient method by leveraging the properties of substrings and sets.", "question_id": "abc347_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *deliciousness = (int *)malloc(n * sizeof(int));\n    char **colors = (char **)malloc(n * sizeof(char *));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %s\", &deliciousness[i], colors[i] = (char *)malloc(10 * sizeof(char)));\n    }\n\n    qsort(deliciousness, n, sizeof(int), compare);\n\n    int max_min_deliciousness = 0;\n\n    for (int i = 0; i < n; i++) {\n        int current_min = deliciousness[i];\n        int count = 1;\n\n        for (int j = i + 1; j < n; j++) {\n            if (strcmp(colors[i], colors[j]) == 0) {\n                current_min = fmax(current_min, deliciousness[j]);\n                count++;\n            }\n\n            if (count == 2) {\n                break;\n            }\n        }\n\n        max_min_deliciousness = fmax(max_min_deliciousness, current_min);\n    }\n\n    printf(\"%d\\n\", max_min_deliciousness);\n\n    free(deliciousness);\n    for (int i = 0; i < n; i++) {\n        free(colors[i]);\n    }\n    free(colors);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maximize the minimum possible deliciousness of the bean we can eat by choosing one color of beans. Here's a step-by-step approach to achieve this:", "question_id": "abc348_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to calculate Euclidean distance\ndouble euclidean_distance(int x1, int y1, int x2, int y2) {\n    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create a GArray to store points\n    GArray *points = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Read points into the array\n    for (int i = 0; i < n * 2; i++) {\n        int coord;\n        scanf(\"%d\", &coord);\n        g_array_append_val(points, coord);\n    }\n\n    // Create a GArray to store the ID of the farthest point for each point\n    GArray *farthest_ids = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Iterate over each point\n    for (int i = 0; i < n; i++) {\n        int x1 = g_array_index(points, int, i * 2);\n        int y1 = g_array_index(points, int, i * 2 + 1);\n        double max_distance = 0;\n        int farthest_id = 1;\n\n        // Iterate over all other points to find the farthest one\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            int x2 = g_array_index(points, int, j * 2);\n            int y2 = g_array_index(points, int, j * 2 + 1);\n            double distance = euclidean_distance(x1, y1, x2, y2);\n\n            // Update the farthest point if a closer one is found\n            if (distance > max_distance || (distance == max_distance && j < farthest_id)) {\n                max_distance = distance;\n                farthest_id = j + 1;\n            }\n        }\n\n        // Store the ID of the farthest point\n        g_array_append_val(farthest_ids, farthest_id);\n    }\n\n    // Print the IDs of the farthest points\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\\n\", g_array_index(farthest_ids, int, i));\n    }\n\n    // Free allocated memory\n    g_array_free(points, TRUE);\n    g_array_free(farthest_ids, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the farthest point from each point in a given set of points on the xy-plane. The farthest point is determined based on the Euclidean distance. If multiple points are equidistant, we choose the one with the smallest ID number. Here's a step-by-step approach to solve the problem:", "question_id": "abc348_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    char result[N + 1];\n    result[N] = '\\0';\n\n    for (int i = 1; i <= N; i++) {\n        if (i % 3 == 0) {\n            result[i - 1] = 'x';\n        } else {\n            result[i - 1] = 'o';\n        }\n    }\n\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the outcome of each penalty kick based on its index. If the index is a multiple of 3, Takahashi fails; otherwise, he succeeds. We can use a loop to iterate through each penalty kick and determine its outcome. The results can be stored in a string and printed at the end.", "question_id": "abc348_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 201\n\nint H, W;\nchar grid[MAX][MAX];\nGHashTable *medicines;\n\nvoid read_input() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    int N;\n    scanf(\"%d\", &N);\n    medicines = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        int r, c, e;\n        scanf(\"%d %d %d\", &r, &c, &e);\n        g_hash_table_insert(medicines, GINT_TO_POINTER(r * W + c), GINT_TO_POINTER(e));\n    }\n}\n\nbool can_reach_goal(int start_r, int start_c, int energy) {\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(start_r * W + start_c));\n    bool visited[MAX * MAX] = {false};\n    visited[start_r * W + start_c] = true;\n\n    while (!g_queue_is_empty(queue)) {\n        int current = g_queue_pop_head(queue);\n        int r = current / W;\n        int c = current % W;\n\n        if (grid[r][c] == 'T') {\n            g_queue_free(queue);\n            return true;\n        }\n\n        int new_energy = energy + 1;\n        if (new_energy > 0 && r > 0 && grid[r - 1][c] != '#' && !visited[(r - 1) * W + c]) {\n            visited[(r - 1) * W + c] = true;\n            g_queue_push_tail(queue, GINT_TO_POINTER((r - 1) * W + c));\n        }\n        if (new_energy > 0 && r < H - 1 && grid[r + 1][c] != '#' && !visited[(r + 1) * W + c]) {\n            visited[(r + 1) * W + c] = true;\n            g_queue_push_tail(queue, GINT_TO_POINTER((r + 1) * W + c));\n        }\n        if (new_energy > 0 && c > 0 && grid[r][c - 1] != '#' && !visited[r * W + c - 1]) {\n            visited[r * W + c - 1] = true;\n            g_queue_push_tail(queue, GINT_TO_POINTER(r * W + c - 1));\n        }\n        if (new_energy > 0 && c < W - 1 && grid[r][c + 1] != '#' && !visited[r * W + c + 1]) {\n            visited[r * W + c + 1] = true;\n            g_queue_push_tail(queue, GINT_TO_POINTER(r * W + c + 1));\n        }\n\n        if (g_hash_table_contains(medicines, GINT_TO_POINTER(current))) {\n            int med_energy = GPOINTER_TO_INT(g_hash_table_lookup(medicines, GINT_TO_POINTER(current)));\n            if (med_energy > energy) {\n                visited[current] = false;\n                g_queue_push_tail(queue, GINT_TO_POINTER(current));\n            }\n        }\n    }\n\n    g_queue_free(queue);\n    return false;\n}\n\nint main() {\n    read_input();\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                if (can_reach_goal(i, j, 0)) {\n                    printf(\"Yes\n\");\n                    g_hash_table_destroy(medicines);\n                    return 0;\n                }\n            }\n        }\n    }\n\n    printf(\"No\n\");\n    g_hash_table_destroy(medicines);\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if Takahashi can reach the goal point from the start point in a grid, considering the energy he can gain from medicines. Here's a step-by-step approach to solve the problem:", "question_id": "abc348_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 100005\n\ntypedef struct {\n    int *children;\n    int num_children;\n} Node;\n\nNode nodes[MAXN];\nint C[MAXN];\nint N;\n\nvoid dfs(int node, int parent, int depth, int *sum, int *min_value) {\n    *sum += depth * C[node - 1];\n    if (*sum < *min_value) {\n        *min_value = *sum;\n    }\n    for (int i = 0; i < nodes[node].num_children; i++) {\n        int child = nodes[node].children[i];\n        if (child != parent) {\n            dfs(child, node, depth + 1, sum, min_value);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        nodes[i].children = NULL;\n        nodes[i].num_children = 0;\n    }\n    for (int i = 0; i < N - 1; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n        nodes[A].children = realloc(nodes[A].children, (nodes[A].num_children + 1) * sizeof(int));\n        nodes[A].children[nodes[A].num_children++] = B;\n        nodes[B].children = realloc(nodes[B].children, (nodes[B].num_children + 1) * sizeof(int));\n        nodes[B].children[nodes[B].num_children++] = A;\n    }\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &C[i - 1]);\n    }\n    int min_value = INT_MAX;\n    dfs(1, 0, 0, &min_value, &min_value);\n    printf(\"%d\n\", min_value);\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the function f(x) for each vertex x in the tree and find the minimum value. The function f(x) is defined as the sum of C_i * d(x, i) for all vertices i, where d(x, i) is the number of edges between vertices x and i. Since the given graph is a tree, we can use depth-first search (DFS) to traverse the tree and calculate the distances from the root to all other vertices. Then, we can calculate the function f(x) for each vertex x by summing up the contributions from all other vertices. To optimize the solution, we can use a depth-first search (DFS) traversal to calculate the distances and the function values in a single pass.", "question_id": "abc348_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[100001], T[4];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int lenS = strlen(S);\n    int lenT = strlen(T);\n\n    // Check for subsequence of length 3\n    for (int i = 0; i <= lenS - 3; i++) {\n        char temp[4];\n        temp[0] = toupper(S[i]);\n        temp[1] = toupper(S[i + 1]);\n        temp[2] = toupper(S[i + 2]);\n        temp[3] = '\\0';\n        if (strcmp(temp, T) == 0) {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n\n    // Check for subsequence of length 2 with 'X' appended\n    for (int i = 0; i <= lenS - 2; i++) {\n        char temp[4];\n        temp[0] = toupper(S[i]);\n        temp[1] = toupper(S[i + 1]);\n        temp[2] = 'X';\n        temp[3] = '\\0';\n        if (strcmp(temp, T) == 0) {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"No\\n\");\n\n    return 0;\n}", "reasoning": "To determine if T is an airport code for S, we need to check if T can be formed by either taking a subsequence of length 3 from S and converting it to uppercase or taking a subsequence of length 2 from S, converting it to uppercase, and appending 'X' to the end. We will use a sliding window approach to check for subsequences of length 3 and a nested loop approach to check for subsequences of length 2.", "question_id": "abc349_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *scores = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int sum = 0;\n    for (int i = 1; i < n; i++) {\n        int score;\n        scanf(\"%d\", &score);\n        sum += score;\n        g_hash_table_insert(scores, GINT_TO_POINTER(i), GINT_TO_POINTER(score));\n    }\n\n    int final_score = -sum;\n    printf(\"%d\n\", final_score);\n\n    g_hash_table_destroy(scores);\n\n    return 0;\n}", "reasoning": "The problem involves determining the final score of person N given the final scores of persons 1 to N-1 in a series of one-on-one games. The key insight is that the sum of the scores of all players remains constant throughout the games. Initially, each player has 0 points, so the total score is 0. As games are played, the total score remains unchanged. Therefore, the final score of person N can be calculated by taking the negative sum of the scores of persons 1 to N-1.", "question_id": "abc349_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char str[1000];\n    scanf(\"%s\", str);\n\n    GHashTable *char_freq = g_hash_table_new(g_str_hash, g_str_equal);\n    GHashTable *freq_count = g_hash_table_new(g_int_hash, g_int_equal);\n\n    int len = strlen(str);\n    for (int i = 0; i < len; i++) {\n        char *ch = malloc(sizeof(char) * 2);\n        ch[0] = str[i];\n        ch[1] = '\\0';\n\n        int *count = g_hash_table_lookup(char_freq, ch);\n        if (count) {\n            (*count)++;\n        } else {\n            g_hash_table_insert(char_freq, ch, GINT_TO_POINTER(1));\n        }\n\n        free(ch);\n    }\n\n    int *values = malloc(sizeof(int) * 27);  // Assuming ASCII values for lowercase letters\n    memset(values, 0, sizeof(int) * 27);\n\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, char_freq);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int *char_count = (int*)value;\n        values[*char_count]++;\n    }\n\n    int valid = 1;\n    for (int i = 1; i < 27; i++) {\n        if (values[i] != 0 && values[i] != 2) {\n            valid = 0;\n            break;\n        }\n    }\n\n    if (valid) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    g_hash_table_destroy(char_freq);\n    g_hash_table_destroy(freq_count);\n    free(values);\n\n    return 0;\n}", "reasoning": "To determine if a string is a good string, we need to check if for all integers i not less than 1, there are exactly zero or exactly two different letters that appear exactly i times in the string. We can use a hash table to count the frequency of each character and then another hash table to count how many characters have each frequency. If the number of characters with each frequency is either 0 or 2, the string is a good string.", "question_id": "abc349_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    long long L, R;\n    scanf(\"%lld %lld\", &L, &R);\n\n    // Initialize variables\n    int M = 0;\n    GQueue *queue = g_queue_new();\n\n    // Find the minimum number of good sequences needed\n    for (long long i = 1; i <= R; i *= 2) {\n        if (L <= i && i <= R) {\n            M++;\n            g_queue_push_tail(queue, GINT_TO_POINTER(i));\n        }\n    }\n\n    // Print the number of good sequences\n    printf(\"%d\n\", M);\n\n    // Print the divisions\n    while (!g_queue_is_empty(queue)) {\n        long long l = g_queue_pop_head(queue);\n        long long r = l * 2 - 1;\n        printf(\"%lld %lld\n\", l, r);\n    }\n\n    // Clean up\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to divide the sequence S(L, R) into the fewest number of good sequences. A good sequence is defined as S(2^i * j, 2^i * (j+1)) for non-negative integers i and j. The key insight is that the sequence can be divided based on powers of two. Specifically, we can divide the sequence into segments where each segment starts at a power of two and ends at the next power of two minus one. This ensures that each segment is a good sequence.", "question_id": "abc349_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int grid[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    int sum = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            sum += grid[i][j];\n        }\n    }\n\n    if (sum % 2 == 1) {\n        printf(\"Takahashi\n\");\n    } else {\n        printf(\"Aoki\n\");\n    }\n\n    return 0;\n}", "reasoning": "The game is a combinatorial game where both players play optimally. The key insight is that the game can be analyzed by considering the parity of the number of moves. Since the total sum of the grid is odd, the game will always end after an odd number of moves. Takahashi, as the first player, will always have the last move if both play optimally. Therefore, Takahashi can always force a win by ensuring that Aoki cannot form three consecutive cells of the same color in any row, column, or diagonal. The solution involves checking the initial configuration of the grid and determining if there is a winning strategy for Takahashi.", "question_id": "abc349_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char S[7];\n    scanf(\"%s\", S);\n\n    // Extract the digits from the string\n    int digits = atoi(&S[3]);\n\n    // Check if the digits are within the valid range\n    if ((digits >= 1 && digits <= 314) || (digits >= 317 && digits <= 349)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if the given string S, which is of the format ABC followed by three digits, is within a specific range of contest abbreviations. The valid range is from ABC001 to ABC314 and from ABC317 to ABC349. We can achieve this by extracting the digits from the string and checking if they fall within the valid range.", "question_id": "abc350_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 1000000000000000000\n#define MAX_A 6\n#define MAX_X 1000000000\n#define MAX_Y 1000000000\n#define EPS 1e-6\n\ntypedef struct {\n    double cost;\n    bool computed;\n} MemoEntry;\n\nMemoEntry memo[MAX_N + 1];\n\ndouble expected_cost(long long n, int a, int x, int y) {\n    if (n == 0)\n        return 0.0;\n    if (memo[n].computed)\n        return memo[n].cost;\n\n    double min_cost = n / a * x;\n    for (int b = 1; b <= 6; b++) {\n        min_cost = fmin(min_cost, y + expected_cost(n / b, a, x, y));\n    }\n\n    memo[n].cost = min_cost;\n    memo[n].computed = true;\n    return min_cost;\n}\n\nint main() {\n    long long n;\n    int a, x, y;\n    scanf(\"%lld %d %d %d\", &n, &a, &x, &y);\n\n    for (int i = 0; i <= MAX_N; i++) {\n        memo[i].computed = false;\n    }\n\n    double result = expected_cost(n, a, x, y);\n    printf(\"%.15f\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum expected cost to reduce N to 0 using the given operations. The operations are to either pay X yen to replace N with \u230aN/A\u230b or pay Y yen to roll a die and replace N with \u230aN/b\u230b, where b is the outcome of the die roll (1 to 6). We can use dynamic programming with memoization to solve this problem efficiently. The key is to calculate the expected cost for each possible value of N and choose the minimum cost operation at each step.", "question_id": "abc350_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    // Initialize a hash table to keep track of tooth presence in each hole\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initially, all holes have teeth, so set all values to 1\n    for (int i = 1; i <= n; i++) {\n        g_hash_table_insert(map, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n    }\n\n    // Process each treatment\n    for (int i = 0; i < q; i++) {\n        int t;\n        scanf(\"%d\", &t);\n\n        // Check if the hole has a tooth\n        gpointer value = g_hash_table_lookup(map, GINT_TO_POINTER(t));\n        int present = GPOINTER_TO_INT(value);\n\n        // If the hole has a tooth, remove it\n        if (present == 1) {\n            g_hash_table_insert(map, GINT_TO_POINTER(t), GINT_TO_POINTER(0));\n        } else {\n            // If the hole is empty, grow a tooth\n            g_hash_table_insert(map, GINT_TO_POINTER(t), GINT_TO_POINTER(1));\n        }\n    }\n\n    // Count the number of teeth remaining\n    int teeth_count = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, map);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int present = GPOINTER_TO_INT(value);\n        if (present == 1) {\n            teeth_count++;\n        }\n    }\n\n    // Output the number of teeth remaining\n    printf(\"%d\n\", teeth_count);\n\n    // Clean up\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "reasoning": "The problem requires tracking the presence of teeth in holes and performing operations based on the given treatments. We can use a hash table to keep track of the presence of teeth in each hole. Initially, all holes have teeth, so we start with a hash table containing all holes with a value of 1. For each treatment, we check if the hole has a tooth. If it does, we remove the tooth by setting the value to 0. If it doesn't, we grow a tooth by setting the value to 1. After all treatments, we count the number of holes with a value of 1, which represents the number of teeth remaining.", "question_id": "abc350_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GHashTable *pos = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < n; i++) {\n        g_hash_table_insert(pos, GINT_TO_POINTER(A[i]), GINT_TO_POINTER(i));\n    }\n\n    int swaps = 0;\n    int *visited = (int *)calloc(n, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        if (visited[i] || A[i] == i + 1) {\n            continue;\n        }\n\n        int cycle_size = 0;\n        int x = i;\n\n        while (!visited[x]) {\n            visited[x] = 1;\n            x = GPOINTER_TO_INT(g_hash_table_lookup(pos, GINT_TO_POINTER(x + 1)));\n            cycle_size++;\n        }\n\n        if (cycle_size > 0) {\n            swaps += (cycle_size - 1);\n        }\n    }\n\n    printf(\"%d\n\", swaps);\n\n    for (int i = 0; i < swaps; i++) {\n        int x = i + 1;\n        int y = GPOINTER_TO_INT(g_hash_table_lookup(pos, GINT_TO_POINTER(x + 1)));\n        printf(\"%d %d\n\", x, y);\n    }\n\n    free(A);\n    free(visited);\n    g_hash_table_destroy(pos);\n\n    return 0;\n}", "reasoning": "The problem requires transforming a given permutation into the identity permutation (1, 2, ..., N) using the minimum number of swaps. The solution involves identifying the minimum number of swaps needed to sort the permutation. This can be achieved by using a greedy algorithm that swaps elements to their correct positions one by one. The algorithm maintains a visited array to keep track of elements that have already been placed in their correct positions. For each element, if it is not in its correct position, we find the correct position and swap the elements until the current element is in its correct position. We count the number of swaps performed and print the results.", "question_id": "abc350_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Initialize adjacency list for the graph\n    GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i <= n; i++) {\n        g_hash_table_insert(adj_list, GINT_TO_POINTER(i), g_array_new(FALSE, FALSE, sizeof(int)));\n    }\n\n    // Build the graph from the input friendships\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        GArray *list_a = g_hash_table_lookup(adj_list, GINT_TO_POINTER(a));\n        GArray *list_b = g_hash_table_lookup(adj_list, GINT_TO_POINTER(b));\n        g_array_append_val(list_a, b);\n        g_array_append_val(list_b, a);\n    }\n\n    long long result = 0;\n\n    // For each user, count the number of triangles they can form\n    for (int i = 1; i <= n; i++) {\n        GArray *list_i = g_hash_table_lookup(adj_list, GINT_TO_POINTER(i));\n        for (int j = 0; j < list_i->len; j++) {\n            int y = g_array_index(list_i, int, j);\n            GArray *list_y = g_hash_table_lookup(adj_list, GINT_TO_POINTER(y));\n            for (int k = 0; k < list_y->len; k++) {\n                int z = g_array_index(list_y, int, k);\n                if (z != i && z != y && g_array_contains(list_i, z)) {\n                    result++;\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\n\", result);\n\n    // Clean up\n    for (int i = 1; i <= n; i++) {\n        GArray *list = g_hash_table_lookup(adj_list, GINT_TO_POINTER(i));\n        g_array_free(list, TRUE);\n    }\n    g_hash_table_destroy(adj_list);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum number of new friendships that can be formed by connecting pairs of friends. The key observation is that for a new friendship (X, Z) to be formed, there must already be a friendship (X, Y) and (Y, Z). This forms a triangle in the graph representation of the friendships. The maximum number of such triangles can be calculated by counting the number of common friends for each user and summing up the number of triangles that can be formed with each user as the middle node.", "question_id": "abc350_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int A[9], B[8];\n    int takahashi_total = 0, aoki_total = 0;\n\n    // Read input for Team Takahashi's scores\n    for (int i = 0; i < 9; i++) {\n        scanf(\"%d\", &A[i]);\n        takahashi_total += A[i];\n    }\n\n    // Read input for Team Aoki's scores\n    for (int i = 0; i < 8; i++) {\n        scanf(\"%d\", &B[i]);\n        aoki_total += B[i];\n    }\n\n    // Calculate the difference in scores at the end of the top of the ninth\n    int difference = takahashi_total - aoki_total;\n\n    // If Team Aoki has already won, print 0\n    if (difference > 0) {\n        printf(\"0\\n\");\n    } else {\n        // Find the minimum number of runs needed to win\n        int min_runs_needed = 1;\n        while (true) {\n            int aoki_ninth = min_runs_needed;\n            int new_aoki_total = aoki_total + aoki_ninth;\n            if (new_aoki_total > takahashi_total) {\n                printf(\"%d\\n\", aoki_ninth);\n                break;\n            }\n            min_runs_needed++;\n        }\n    }\n\n    return 0;\n}", "reasoning": "To determine the minimum number of runs Team Aoki needs to score in the bottom of the ninth inning to win the game, we need to consider the current scores and the constraints. We will iterate through the possible scores Team Aoki can achieve in the ninth inning and check if it results in a win. The minimum score that guarantees a win will be our answer.", "question_id": "abc351_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char A[n][n + 1];\n    char B[n][n + 1];\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", A[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", B[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (A[i][j] != B[i][j]) {\n                printf(\"%d %d\n\", i + 1, j + 1);\n                return 0;\n            }\n        }\n    }\n\n    return 0;\n}", "reasoning": "The problem requires finding the first differing cell between two grids. We can iterate through each cell of the grids and compare their characters. As soon as we find a difference, we output the indices of that cell. Since there is exactly one differing cell, we can stop after finding it.", "question_id": "abc351_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nint compare(const void *a, const void *b) {\n    return ((Point*)a)->x - ((Point*)b)->x;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    Point points[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    qsort(points, N, sizeof(Point), compare);\n\n    long long sum = 0;\n    long long prefix_sum = 0;\n\n    for (int i = 0; i < N; i++) {\n        prefix_sum += points[i].y;\n        for (int j = 0; j < i; j++) {\n            int dx = points[i].x - points[j].x;\n            int dy = points[i].y - points[j].y;\n            int dist = dx > dy ? dx : dy;\n            sum += dist;\n        }\n    }\n\n    printf(\"%lld\\n\", sum);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the minimum number of jumps required to move from one point to another on a coordinate plane. The rabbit can jump to (x+1, y+1), (x+1, y-1), (x-1, y+1), or (x-1, y-1). The key observation is that the minimum number of jumps between two points (x1, y1) and (x2, y2) is the maximum of the absolute differences in their x and y coordinates, i.e., max(abs(x2 - x1), abs(y2 - y1)). We then need to sum these distances for all pairs of points. Given the constraints, a naive approach would be too slow, so we need an efficient solution. We can use sorting and prefix sums to achieve this. First, we sort the points by their x-coordinates. Then, for each point, we calculate the prefix sum of the y-coordinates up to that point. Finally, we use these prefix sums to calculate the required distances for all pairs of points.", "question_id": "abc351_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    // Create a prefix maximum array\n    GArray *prefix_max = g_array_new(FALSE, FALSE, sizeof(int));\n    int max = G_MININT;\n    for (int i = 0; i < n; i++) {\n        max = g_max(max, g_array_index(arr, int, i));\n        g_array_append_val(prefix_max, max);\n    }\n\n    long long result = 0;\n    for (int i = 0; i < n; i++) {\n        int current = g_array_index(arr, int, i);\n        int prefix = g_array_index(prefix_max, int, i);\n        result += (long long)prefix - current;\n    }\n\n    printf(\"%lld\n\", result);\n\n    g_array_free(arr, TRUE);\n    g_array_free(prefix_max, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the sum of the maximum differences between pairs of elements in the sequence. The brute-force approach of checking all pairs would be too slow for large N, so we need an efficient method. One approach is to use a prefix maximum array to keep track of the maximum value encountered so far. This allows us to calculate the maximum difference for each element in linear time. Specifically, for each element A[i], we can calculate the sum of the maximum differences for all pairs (i, j) where j > i by subtracting A[i] from the prefix maximum at position i and multiplying by the number of elements to the right of i. This gives us the desired result.", "question_id": "abc351_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize GQueue for the sequence of ball sizes\n    GQueue *queue = g_queue_new();\n\n    // Process each ball\n    for (int i = 0; i < n; i++) {\n        int A_i;\n        scanf(\"%d\", &A_i);\n        int size = 1 << A_i;  // Calculate the size of the ball\n\n        // Add the ball to the sequence\n        g_queue_push_tail(queue, GINT_TO_POINTER(size));\n\n        // Perform the merging operation\n        while (g_queue_get_length(queue) > 1) {\n            int rightmost = GPOINTER_TO_INT(g_queue_peek_tail(queue));\n            int second_rightmost = GPOINTER_TO_INT(g_queue_peek_nth(queue, -2));\n\n            if (rightmost != second_rightmost) {\n                break;  // Stop merging if sizes are different\n            }\n\n            // Remove the two rightmost balls\n            g_queue_pop_tail(queue);\n            g_queue_pop_tail(queue);\n\n            // Add a new ball with the sum of the sizes\n            int new_size = rightmost + second_rightmost;\n            g_queue_push_tail(queue, GINT_TO_POINTER(new_size));\n        }\n    }\n\n    // Output the number of balls remaining in the sequence\n    printf(\"%d\\n\", g_queue_get_length(queue));\n\n    // Clean up\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of adding balls to a sequence and merging them according to the given rules. Here's a step-by-step approach to achieve this:", "question_id": "abc351_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 1000\n\n// Directions for moving up, down, left, and right\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\n// Function to perform DFS and calculate the degree of freedom\nint dfs(char grid[MAX][MAX], int visited[MAX][MAX], int x, int y, int H, int W) {\n    if (x < 0 || x >= H || y < 0 || y >= W || visited[x][y] || grid[x][y] == '#') {\n        return 0;\n    }\n    visited[x][y] = 1;\n    int degree = 1; // Include the cell itself\n    for (int i = 0; i < 4; i++) {\n        degree += dfs(grid, visited, x + dx[i], y + dy[i], H, W);\n    }\n    return degree;\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    char grid[MAX][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int max_degree = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.') {\n                int visited[MAX][MAX] = {0};\n                int degree = dfs(grid, visited, i, j, H, W);\n                max_degree = (degree > max_degree) ? degree : max_degree;\n            }\n        }\n    }\n\n    printf(\"%d\n\", max_degree);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum degree of freedom for any cell without a magnet in the grid. The degree of freedom of a cell is defined as the number of cells that can be reached from that cell by moving to adjacent cells that do not contain magnets. We can use Depth-First Search (DFS) to explore all reachable cells from each cell without a magnet and calculate the degree of freedom for each cell. Finally, we return the maximum degree of freedom found.", "question_id": "abc351_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    return ((Edge *)a)->w - ((Edge *)b)->w;\n}\n\nbool is_connected(int *parent, int n) {\n    for (int i = 1; i <= n; i++) {\n        if (parent[i] != 1)\n            return false;\n    }\n    return true;\n}\n\nint find(int *parent, int i) {\n    if (parent[i] != i)\n        parent[i] = find(parent, parent[i]);\n    return parent[i];\n}\n\nvoid union_set(int *parent, int *rank, int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n\n    if (rank[xroot] < rank[yroot])\n        parent[xroot] = yroot;\n    else if (rank[xroot] > rank[yroot])\n        parent[yroot] = xroot;\n    else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GArray *edges = g_array_new(FALSE, FALSE, sizeof(Edge));\n\n    for (int i = 0; i < m; i++) {\n        int k, c;\n        scanf(\"%d %d\", &k, &c);\n\n        for (int j = 0; j < k; j++) {\n            int u;\n            scanf(\"%d\", &u);\n            if (j > 0) {\n                Edge e = {u, prev, c};\n                g_array_append_val(edges, e);\n            }\n            prev = u;\n        }\n    }\n\n    qsort(edges->data, edges->len, sizeof(Edge), compare);\n\n    int *parent = (int *)malloc((n + 1) * sizeof(int));\n    int *rank = (int *)malloc((n + 1) * sizeof(int));\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int total_weight = 0;\n\n    for (int i = 0; i < edges->len; i++) {\n        Edge e = g_array_index(edges, Edge, i);\n\n        int x = find(parent, e.u);\n        int y = find(parent, e.v);\n\n        if (x != y) {\n            union_set(parent, rank, x, y);\n            total_weight += e.w;\n        }\n    }\n\n    g_array_free(edges, TRUE);\n\n    if (!is_connected(parent, n)) {\n        printf(\"-1\n\");\n        free(parent);\n        free(rank);\n        return 0;\n    }\n\n    printf(\"%d\n\", total_weight);\n\n    free(parent);\n    free(rank);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if the graph remains connected after performing all the operations and, if it does, find the total weight of the edges in a minimum spanning tree (MST). Here's a step-by-step approach to achieve this:", "question_id": "abc352_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, x, y, z;\n    scanf(\"%d %d %d %d\", &n, &x, &y, &z);\n\n    bool stops_at_z = false;\n\n    if (x < y) {\n        // Inbound train from station 1 to station N\n        stops_at_z = (z >= x && z <= y);\n    } else {\n        // Outbound train from station N to station 1\n        stops_at_z = (z >= y && z <= x);\n    }\n\n    if (stops_at_z) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine whether the train stops at station Z during the travel from station X to station Y, we need to consider the direction of the train and the stations it passes through. An inbound train starts at station 1 and moves to station N, while an outbound train starts at station N and moves to station 1. Therefore, if X < Y, the train is inbound, and if X > Y, the train is outbound. We can then check if station Z is within the range of stations the train passes through during the journey from X to Y.", "question_id": "abc352_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200000\n\ntypedef struct {\n    int a;\n    int b;\n} Giant;\n\nint compare(const void *a, const void *b) {\n    Giant *g1 = (Giant *)a;\n    Giant *g2 = (Giant *)b;\n    int diff1 = g1->b - g1->a;\n    int diff2 = g2->b - g2->a;\n    return diff2 - diff1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Giant giants[MAX_N];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &giants[i].a, &giants[i].b);\n    }\n\n    qsort(giants, n, sizeof(Giant), compare);\n\n    long long max_height = 0;\n    for (int i = 0; i < n; i++) {\n        max_height += giants[i].b;\n    }\n\n    printf(\"%lld\n\", max_height);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum possible height of the head of the topmost giant when they are stacked according to the given rules. The key observation is that the height of the head of the topmost giant is determined by the order in which the giants are stacked, specifically by the sequence of their head heights when they are placed on the shoulders of the previous giants. The optimal strategy is to place the giants in such a way that the sum of their head heights is maximized. This can be achieved by sorting the giants based on the difference between their head height and shoulder height in descending order. By doing this, we ensure that the giants with the largest height differences are placed first, maximizing the overall height of the stack.", "question_id": "abc352_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[200001], T[200001];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int n = strlen(S);\n    int m = strlen(T);\n\n    GHashTable *map = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < n; i++) {\n        g_hash_table_insert(map, &S[i], GINT_TO_POINTER(1));\n    }\n\n    GQueue *queue = g_queue_new();\n\n    for (int i = 0; i < m; i++) {\n        if (g_hash_table_lookup(map, &T[i])) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(i + 1));\n        }\n    }\n\n    while (!g_queue_is_empty(queue)) {\n        int pos = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        printf(\"%d \", pos);\n    }\n\n    g_hash_table_destroy(map);\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the positions of the correctly typed characters in the string T. The correctly typed characters are those that match the characters in the string S, ignoring the characters that were mistakenly typed due to the broken backspace key. Here's a step-by-step approach to solve the problem:", "question_id": "abc352_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    // Read the permutation\n    int *P = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n\n    // Create a hash table to store the positions of elements in the permutation\n    GHashTable *pos = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        g_hash_table_insert(pos, GINT_TO_POINTER(P[i]), GINT_TO_POINTER(i));\n    }\n\n    int min_diff = N; // Initialize the minimum difference to a large value\n\n    // Iterate over all possible starting points for the good index sequence\n    for (int i = 0; i <= N - K; i++) {\n        // Find the next consecutive elements in the permutation\n        int next = P[i] + 1;\n        int count = 1;\n        while (count < K) {\n            if (g_hash_table_lookup(pos, GINT_TO_POINTER(next)) != NULL) {\n                next++;\n                count++;\n            } else {\n                break;\n            }\n        }\n\n        // If we found K consecutive elements, calculate the difference\n        if (count == K) {\n            int diff = g_hash_table_lookup(pos, GINT_TO_POINTER(next - 1)) - g_hash_table_lookup(pos, GINT_TO_POINTER(P[i]));\n            if (diff < min_diff) {\n                min_diff = diff;\n            }\n        }\n    }\n\n    // Output the minimum difference\n    printf(\"%d\n\", min_diff);\n\n    // Free the allocated memory\n    free(P);\n    g_hash_table_destroy(pos);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum value of i_K - i_1 for a good index sequence (i_1, i_2, ..., i_K) in the given permutation P. A good index sequence must satisfy two conditions: the indices must be in increasing order, and the subsequence P[i_1:i_2:...:i_K] must be a rearrangement of consecutive integers. Here's a step-by-step approach to solve the problem:", "question_id": "abc352_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    long long total_sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n\n        // Calculate the remainder of a when divided by 10^8\n        int remainder = a % 100000000;\n\n        // Add the remainder to the total sum\n        total_sum += remainder;\n\n        // Update the count of this remainder in the hash table\n        gpointer count_ptr = g_hash_table_lookup(count, GINT_TO_POINTER(remainder));\n        if (count_ptr != NULL) {\n            int current_count = GPOINTER_TO_INT(count_ptr);\n            total_sum += (long long)remainder * current_count;\n        }\n\n        // Increment the count of this remainder in the hash table\n        g_hash_table_insert(count, GINT_TO_POINTER(remainder), GINT_TO_POINTER(1 + (count_ptr ? GPOINTER_TO_INT(count_ptr) : 0)));\n    }\n\n    // Print the total sum\n    printf(\"%lld\n\", total_sum);\n\n    // Clean up\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to compute the sum of the remainders of all pairs (A_i, A_j) in the given sequence A. The function f(x, y) is defined as the remainder of (x + y) divided by 10^8. Given the constraints, a direct approach would be computationally expensive, so we need an efficient method to calculate the result without iterating through all pairs explicitly.", "question_id": "abc353_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    GQueue *queue = g_queue_new();\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        g_queue_push_tail(queue, GINT_TO_POINTER(a));\n    }\n\n    int empty_seats = k;\n    int start_count = 0;\n\n    while (!g_queue_is_empty(queue)) {\n        int group_size = GPOINTER_TO_INT(g_queue_peek_head(queue));\n\n        if (group_size > empty_seats) {\n            start_count++;\n            empty_seats = k;\n        } else {\n            empty_seats -= group_size;\n            g_queue_pop_head(queue);\n        }\n    }\n\n    printf(\"%d\\n\", start_count);\n\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of guiding groups to the attraction according to the given rules. We will use a queue to manage the groups and a variable to keep track of the number of empty seats. We will iterate through the groups, guiding them to the attraction or starting the attraction when necessary. We will count the number of times the attraction is started and print the result.", "question_id": "abc353_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *heights = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n\n    int first_height = heights[0];\n    int position = -1;\n\n    for (int i = 1; i < n; i++) {\n        if (heights[i] > first_height) {\n            position = i + 1;\n            break;\n        }\n    }\n\n    printf(\"%d\n\", position);\n\n    free(heights);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there is any building taller than the first building from the left and find the position of the leftmost such building. Here's a step-by-step approach to achieve this:", "question_id": "abc353_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *strings = g_array_new(FALSE, FALSE, sizeof(char*));\n    for (int i = 0; i < n; i++) {\n        char *str = malloc(1000 * sizeof(char));\n        scanf(\"%s\", str);\n        g_array_append_val(strings, str);\n    }\n\n    int total_length = 0;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            char *s1 = g_array_index(strings, char*, i);\n            char *s2 = g_array_index(strings, char*, j);\n\n            int len1 = strlen(s1);\n            int len2 = strlen(s2);\n\n            int common_length = 0;\n            for (int k = 0; k < len1 && k < len2; k++) {\n                if (s1[k] == s2[k]) {\n                    common_length++;\n                } else {\n                    break;\n                }\n            }\n\n            total_length += common_length;\n        }\n    }\n\n    printf(\"%d\n\", total_length);\n\n    // Clean up\n    for (int i = 0; i < n; i++) {\n        free(g_array_index(strings, char*, i));\n    }\n    g_array_free(strings, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the sum of the lengths of the longest common prefixes for all pairs of strings in the given list. The direct approach of comparing every pair of strings would be inefficient due to its O(N^2) complexity, especially given the constraints. Instead, we can use a more efficient approach by leveraging the properties of common prefixes and using a hash table to store prefix lengths.", "question_id": "abc353_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        g_array_append_val(A, x);\n    }\n\n    long long sum = 0;\n\n    for (int i = 0; i < N; i++) {\n        int x = g_array_index(A, int, i);\n        long long count = 0;\n        for (int j = i + 1; j < N; j++) {\n            int y = g_array_index(A, int, j);\n            char z[20];\n            sprintf(z, \"%d%d\", x, y);\n            long long val = atoll(z);\n            sum = (sum + val) % MOD;\n        }\n    }\n\n    printf(\"%lld\\n\", sum);\n\n    g_array_free(A, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to compute the sum of f(A_i, A_j) for all i < j in the given sequence A. The function f(x, y) concatenates the decimal representations of x and y and interprets the result as a decimal integer. Given the constraints, a direct approach would be computationally expensive. Instead, we can use a more efficient method by leveraging properties of numbers and modular arithmetic.", "question_id": "abc353_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Define a structure to hold user data\ntypedef struct {\n    char name[17]; // 16 characters + 1 for null terminator\n    int rating;\n} User;\n\n// Comparison function for qsort to sort users by name\nint compare(const void *a, const void *b) {\n    User *user1 = (User *)a;\n    User *user2 = (User *)b;\n    return strcmp(user1->name, user2->name);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Allocate memory for the array of users\n    User *users = (User *)malloc(N * sizeof(User));\n\n    // Read user data\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s %d\", users[i].name, &users[i].rating);\n    }\n\n    // Sort users by name\n    qsort(users, N, sizeof(User), compare);\n\n    // Calculate the sum of ratings\n    int total_rating = 0;\n    for (int i = 0; i < N; i++) {\n        total_rating += users[i].rating;\n    }\n\n    // Determine the winner\n    int winner_index = total_rating % N;\n    printf(\"%s\n\", users[winner_index].name);\n\n    // Free allocated memory\n    free(users);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to follow these steps:\n1. Read the input values, including the number of users and their respective usernames and ratings.\n2. Sort the users based on their usernames in lexicographical order.\n3. Calculate the sum of all ratings.\n4. Determine the winner by finding the user whose index (sum of ratings modulo number of users) matches their position in the sorted list.\n5. Print the username of the winner.", "question_id": "abc354_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int H;\n    scanf(\"%d\", &H);\n\n    // Initialize variables\n    int day = 0;\n    int plant_height = 0;\n\n    // Loop until the plant's height exceeds Takahashi's height\n    while (plant_height <= H) {\n        day++;\n        plant_height += 1 << (day - 1);\n    }\n\n    // Output the result\n    printf(\"%d\n\", day);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the first day on which the plant's height exceeds Takahashi's height. The plant's height increases exponentially, doubling each day. We can use a loop to simulate each day and check the plant's height against Takahashi's height. The loop will continue until the plant's height is greater than Takahashi's height.", "question_id": "abc354_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Create a hash table to store the edges of the bipartite graph\n    GHashTable *edges = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the input and build the graph\n    for (int i = 0; i < N; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n\n        // Add edges for both sides of the card\n        GArray *arrayA = g_hash_table_lookup(edges, GINT_TO_POINTER(A));\n        if (!arrayA) {\n            arrayA = g_array_new(FALSE, FALSE, sizeof(int));\n            g_hash_table_insert(edges, GINT_TO_POINTER(A), arrayA);\n        }\n        g_array_append_val(arrayA, B);\n\n        GArray *arrayB = g_hash_table_lookup(edges, GINT_TO_POINTER(B));\n        if (!arrayB) {\n            arrayB = g_array_new(FALSE, FALSE, sizeof(int));\n            g_hash_table_insert(edges, GINT_TO_POINTER(B), arrayB);\n        }\n        g_array_append_val(arrayB, A);\n    }\n\n    // Use a set to keep track of visited vertices\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Function to perform DFS and count connected components\n    int dfs(int vertex, GHashTable *edges, GHashTable *visited) {\n        if (g_hash_table_lookup(visited, GINT_TO_POINTER(vertex))) {\n            return 0;\n        }\n        g_hash_table_insert(visited, GINT_TO_POINTER(vertex), GINT_TO_POINTER(1));\n\n        GArray *neighbors = g_hash_table_lookup(edges, GINT_TO_POINTER(vertex));\n        if (neighbors) {\n            for (guint i = 0; i < neighbors->len; i++) {\n                int neighbor = g_array_index(neighbors, int, i);\n                dfs(neighbor, edges, visited);\n            }\n        }\n\n        return 1;\n    }\n\n    // Count the number of connected components\n    int components = 0;\n    for (int i = 1; i <= 1000000000; i++) { // Assuming the maximum value of A or B\n        if (!g_hash_table_lookup(visited, GINT_TO_POINTER(i))) {\n            components += dfs(i, edges, visited);\n        }\n    }\n\n    // Determine the winner based on the number of connected components\n    if (components % 2 == 1) {\n        printf(\"Takahashi\\n\");\n    } else {\n        printf(\"Aoki\\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(edges);\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "reasoning": "The problem involves a game where two players take turns removing pairs of cards based on matching numbers on either side. The key insight is that the game can be analyzed using the concept of a bipartite graph. Each card can be considered as a vertex, and an edge exists between two vertices if the corresponding cards have the same number on either side. The game's outcome depends on the parity of the number of connected components in this bipartite graph. If the number of connected components is odd, the first player (Takahashi) wins; otherwise, the second player (Aoki) wins.", "question_id": "abc354_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Read input and store in arrays\n    int *A = (int *)malloc(N * sizeof(int));\n    int *C = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &C[i]);\n    }\n\n    // Sort the cards based on strength A\n    qsort(A, N, sizeof(int), compare);\n\n    // Use a GArray to store the indices of remaining cards\n    GArray *remaining = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Add the first card to the remaining list\n    g_array_append_val(remaining, 0);\n\n    // Iterate through the cards to find and discard cards\n    for (int i = 1; i < N; i++) {\n        int found = 0;\n        for (int j = 0; j < remaining->len; j++) {\n            int idx = g_array_index(remaining, int, j);\n            if (A[i] > A[idx] && C[i] < C[idx]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            g_array_append_val(remaining, i);\n        }\n    }\n\n    // Output the result\n    printf(\"%d\\n\", remaining->len);\n    for (int i = 0; i < remaining->len; i++) {\n        printf(\"%d \", g_array_index(remaining, int, i) + 1);\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    free(A);\n    free(C);\n    g_array_free(remaining, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to identify and discard cards based on the given conditions until no more cards can be discarded. The key is to maintain a data structure that allows us to efficiently find and discard cards. Here's a step-by-step approach to solve the problem:", "question_id": "abc354_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int A, B, C, D;\n    scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n\n    int blackArea = 0;\n\n    for (int x = A; x < C; x++) {\n        for (int y = B; y < D; y++) {\n            if ((x + y) % 2 == 0 && (x % 2 == y % 2)) {\n                blackArea++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", blackArea * 2);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the area of the black-painted region inside a given rectangle on a specific pattern. The pattern is defined by three types of lines: vertical lines (x = n), horizontal lines (y = 2n), and diagonal lines (x + y = 2n). Each region is painted black or white, and any two adjacent regions are painted in different colors. The region containing (0.5, 0.5) is painted black. We need to calculate the area of the black-painted region inside the rectangle and print twice that area.", "question_id": "abc354_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MOD 100\n\nvoid ask_question(int i, int j) {\n    printf(\"? %d %d\n\", i, j);\n    fflush(stdout);\n}\n\nint main() {\n    int N, L, R;\n    scanf(\"%d %d %d\", &N, &L, &R);\n\n    GHashTable *sums = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int i = 0;\n    int j = 0;\n    int size = 1 << N;\n\n    while (size > 1) {\n        int mid = L + (R - L) / 2;\n        ask_question(i, j);\n        int left_sum = 0;\n        int right_sum = 0;\n\n        for (int k = L; k <= mid; k++) {\n            left_sum += g_hash_table_lookup(sums, GINT_TO_POINTER(k)) ? GPOINTER_TO_INT(g_hash_table_lookup(sums, GINT_TO_POINTER(k))) : 0;\n        }\n\n        for (int k = mid + 1; k <= R; k++) {\n            right_sum += g_hash_table_lookup(sums, GINT_TO_POINTER(k)) ? GPOINTER_TO_INT(g_hash_table_lookup(sums, GINT_TO_POINTER(k))) : 0;\n        }\n\n        int total_sum = (left_sum + right_sum) % MOD;\n        g_hash_table_insert(sums, GINT_TO_POINTER(L), GINT_TO_POINTER(total_sum));\n\n        if (mid == L) {\n            R = mid;\n        } else {\n            L = mid + 1;\n        }\n\n        size /= 2;\n        j++;\n    }\n\n    int result = g_hash_table_lookup(sums, GINT_TO_POINTER(L)) ? GPOINTER_TO_INT(g_hash_table_lookup(sums, GINT_TO_POINTER(L))) : 0;\n    printf(\"! %d\n\", result);\n\n    g_hash_table_destroy(sums);\n\n    return 0;\n}", "reasoning": "The problem requires us to determine the remainder of a sum of elements in a sequence A, which is hidden from us. We can ask questions to the judge to find this sum efficiently. The key insight is to use a divide-and-conquer approach to narrow down the range of indices and calculate the sum incrementally. We start by asking questions to split the range in half repeatedly until we can determine the sum for the desired range [L, R]. This approach ensures that we use the minimum number of questions.", "question_id": "abc355_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(m * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    int *c = (int *)malloc((n + m) * sizeof(int));\n    memcpy(c, a, n * sizeof(int));\n    memcpy(c + n, b, m * sizeof(int));\n\n    qsort(c, n + m, sizeof(int), compare);\n\n    bool found = false;\n\n    for (int i = 0; i < n + m - 1; i++) {\n        if (c[i] == c[i + 1] - 1) {\n            found = true;\n            break;\n        }\n    }\n\n    if (found) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    free(a);\n    free(b);\n    free(c);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there are two consecutive elements in the sorted sequence C that are part of the sequence A. Here's a step-by-step approach to achieve this:", "question_id": "abc355_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, T;\n    scanf(\"%d %d\", &N, &T);\n\n    // Initialize the grid\n    int **grid = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        grid[i] = (int *)malloc(N * sizeof(int));\n        for (int j = 0; j < N; j++) {\n            grid[i][j] = N * (i - 1) + j + 1;\n        }\n    }\n\n    // Initialize hash tables to track marked cells in rows, columns, and diagonals\n    GHashTable *rows = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *cols = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *diag1 = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *diag2 = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initialize counters for marked cells in each row, column, and diagonal\n    for (int i = 0; i < N; i++) {\n        g_hash_table_insert(rows, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n        g_hash_table_insert(cols, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n    }\n    g_hash_table_insert(diag1, GINT_TO_POINTER(0), GINT_TO_POINTER(0));\n    g_hash_table_insert(diag2, GINT_TO_POINTER(0), GINT_TO_POINTER(0));\n\n    // Process each turn\n    for (int turn = 1; turn <= T; turn++) {\n        int A;\n        scanf(\"%d\", &A);\n\n        // Find the cell (i, j) containing A\n        int found = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (grid[i][j] == A) {\n                    // Mark the cell\n                    grid[i][j] = -1;\n\n                    // Increment the counter for the row and column\n                    int *row_count = (int *)g_hash_table_lookup(rows, GINT_TO_POINTER(i));\n                    int *col_count = (int *)g_hash_table_lookup(cols, GINT_TO_POINTER(j));\n                    (*row_count)++;\n                    (*col_count)++;\n\n                    // Check if the diagonal is marked\n                    if (i == j) {\n                        int *diag1_count = (int *)g_hash_table_lookup(diag1, GINT_TO_POINTER(0));\n                        (*diag1_count)++;\n                    }\n                    if (i + j == N - 1) {\n                        int *diag2_count = (int *)g_hash_table_lookup(diag2, GINT_TO_POINTER(0));\n                        (*diag2_count)++;\n                    }\n\n                    // Check for Bingo\n                    if (*row_count == N || *col_count == N || *diag1_count == N || *diag2_count == N) {\n                        printf(\"%d\\n\", turn);\n                        found = 1;\n                        break;\n                    }\n                }\n            }\n            if (found) {\n                break;\n            }\n        }\n\n        if (found) {\n            break;\n        }\n    }\n\n    // If no Bingo is achieved within T turns, print -1\n    if (!found) {\n        printf(\"-1\\n\");\n    }\n\n    // Free allocated memory\n    for (int i = 0; i < N; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n    g_hash_table_destroy(rows);\n    g_hash_table_destroy(cols);\n    g_hash_table_destroy(diag1);\n    g_hash_table_destroy(diag2);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the marking of cells on an N x N grid and check for Bingo conditions after each turn. Here's a step-by-step approach to achieve this:", "question_id": "abc355_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n\n    // Check if Ringo and Snuke point to different suspects\n    if (A != B) {\n        // If they point to different suspects, the culprit can be uniquely identified\n        if (A == 1 && B == 2) {\n            printf(\"3\n\");\n        } else if (A == 1 && B == 3) {\n            printf(\"2\n\");\n        } else if (A == 2 && B == 1) {\n            printf(\"3\n\");\n        } else if (A == 2 && B == 3) {\n            printf(\"1\n\");\n        } else if (A == 3 && B == 1) {\n            printf(\"2\n\");\n        } else if (A == 3 && B == 2) {\n            printf(\"1\n\");\n        }\n    } else {\n        // If they point to the same suspect, the culprit cannot be uniquely identified\n        printf(\"-1\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine if the culprit can be uniquely identified based on the memories of the two witnesses, we need to analyze the inputs provided by Ringo and Snuke. Ringo remembers that person A is not the culprit, and Snuke remembers that person B is not the culprit. If both Ringo and Snuke point to different suspects, then the culprit can be uniquely identified. If they point to the same person or do not provide any new information, then the culprit cannot be uniquely identified.", "question_id": "abc355_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *intervals = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        g_array_append_val(intervals, l);\n        g_array_append_val(intervals, r);\n    }\n\n    g_array_sort(intervals, compare);\n\n    int count = 0;\n    for (int i = 0; i < n * 2; i += 2) {\n        int l = g_array_index(intervals, int, i);\n        int r = g_array_index(intervals, int, i + 1);\n        int idx = g_array_index(intervals, int, i + 2);\n        if (idx >= n * 2) break;\n        int next_l = g_array_index(intervals, int, idx);\n        if (next_l <= r) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    g_array_free(intervals, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of pairs of intervals that intersect. An interval [l, r] intersects with another interval [l', r'] if and only if l' <= r and r' <= r. This means that for each interval, we need to count how many intervals to its right start before it ends. We can use a sorted data structure to efficiently find the number of such intervals.", "question_id": "abc355_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, L, R;\n    scanf(\"%d %d %d\", &N, &L, &R);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        A[i] = i + 1;\n    }\n\n    for (int i = L - 1, j = R - 1; i < j; i++, j--) {\n        int temp = A[i];\n        A[i] = A[j];\n        A[j] = temp;\n    }\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n\n    free(A);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to reverse a subarray of length R - L + 1 in the sequence A = (1, 2, ..., N). The subarray to be reversed starts at index L-1 and ends at index R-1. We can achieve this by swapping elements from the start of the subarray with elements from the end until the middle of the subarray is reached.", "question_id": "abc356_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Precompute the number of 1s in the binary representation of numbers with a given number of bits set to 1\n    int dp[61][61] = {0};\n    for (int i = 0; i <= 60; i++) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= 60; j++) {\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD;\n        }\n    }\n\n    // Compute the sum of the popcount of the bitwise AND of each number from 0 to n with m\n    long long sum = 0;\n    for (int i = 0; i <= n; i++) {\n        int k = 0;\n        for (int j = 0; j <= 60; j++) {\n            if ((i & (1 << j)) != 0) {\n                k++;\n            }\n        }\n        sum = (sum + dp[k][__builtin_popcount(m)]) % MOD;\n    }\n\n    // Print the result\n    printf(\"%lld\\n\", sum);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to compute the sum of the popcount of the bitwise AND of each number from 0 to N with M, modulo 998244353. The popcount function counts the number of 1s in the binary representation of a number. The bitwise AND operation compares each bit of two numbers and returns a new number with bits set to 1 only where both corresponding bits of the two numbers are 1. We can use dynamic programming to efficiently compute the sum by precomputing the number of 1s in the binary representation of numbers with a given number of bits set to 1. This allows us to quickly calculate the sum for any range of numbers.", "question_id": "abc356_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    GHashTable *max_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *min_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int max_val = arr[i] > arr[j] ? arr[i] : arr[j];\n            int min_val = arr[i] < arr[j] ? arr[i] : arr[j];\n\n            gpointer max_count_val = g_hash_table_lookup(max_count, GINT_TO_POINTER(max_val));\n            int max_count_int = max_count_val ? GPOINTER_TO_INT(max_count_val) : 0;\n            g_hash_table_insert(max_count, GINT_TO_POINTER(max_val), GINT_TO_POINTER(max_count_int + 1));\n\n            gpointer min_count_val = g_hash_table_lookup(min_count, GINT_TO_POINTER(min_val));\n            int min_count_int = min_count_val ? GPOINTER_TO_INT(min_count_val) : 0;\n            g_hash_table_insert(min_count, GINT_TO_POINTER(min_val), GINT_TO_POINTER(min_count_int + 1));\n        }\n    }\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        int max_val = arr[i];\n        int min_val = arr[i];\n\n        gpointer max_count_val = g_hash_table_lookup(max_count, GINT_TO_POINTER(max_val));\n        int max_count_int = max_count_val ? GPOINTER_TO_INT(max_count_val) : 0;\n\n        gpointer min_count_val = g_hash_table_lookup(min_count, GINT_TO_POINTER(min_val));\n        int min_count_int = min_count_val ? GPOINTER_TO_INT(min_count_val) : 0;\n\n        result += max_count_int - min_count_int;\n    }\n\n    printf(\"%d\\n\", result);\n\n    free(arr);\n    g_hash_table_destroy(max_count);\n    g_hash_table_destroy(min_count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the sum of the floor of the ratio of the maximum and minimum values for all pairs (i, j) where 1 <= i < j <= N. Given the constraints, a brute-force approach would be too slow, so we need an efficient method. The key insight is to count the number of times each value appears as the maximum and minimum in pairs and use these counts to compute the result. This approach avoids the need to compute the floor of the ratio for each pair individually.", "question_id": "abc356_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 15\n#define MAX_M 100\n\n// Function to check if a combination of real keys satisfies the test results\nbool is_valid_combination(int n, int k, int *tests, char *results, int *combination, GHashTable *test_map) {\n    for (int i = 0; i < n; i++) {\n        if (combination[i] == 1) {\n            // If the key is real, check all tests involving this key\n            for (int j = 0; j < n; j++) {\n                if (combination[j] == 1) {\n                    // If both keys are real, check if they are in the same test\n                    for (int test = 0; test < n; test++) {\n                        if (tests[test * n + j] == 1 && tests[test * n + i] == 1) {\n                            if (results[test] == 'x') {\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    int tests[n * n];\n    char results[n];\n\n    // Read test cases\n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        for (int j = 0; j < c; j++) {\n            int key;\n            scanf(\"%d\", &key);\n            tests[i * n + key - 1] = 1;\n        }\n        scanf(\" %c\", &results[i]);\n    }\n\n    int combination[n];\n    memset(combination, 0, sizeof(combination));\n\n    int count = 0;\n\n    // Generate all combinations of real and dummy keys\n    for (int i = 0; i < (1 << n); i++) {\n        bool valid = true;\n        for (int j = 0; j < n; j++) {\n            combination[j] = (i >> j) & 1;\n        }\n\n        if (is_valid_combination(n, k, tests, results, combination, NULL)) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of valid combinations of real and dummy keys that do not contradict the given test results. Here's a step-by-step approach to achieve this:", "question_id": "abc356_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Array to store the daily goal for each nutrient\n    int goals[M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &goals[i]);\n    }\n\n    // Array to store the total intake for each nutrient\n    int intake[M] = {0};\n\n    // Read the intake from each food and update the total intake\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            int units;\n            scanf(\"%d\", &units);\n            intake[j] += units;\n        }\n    }\n\n    // Check if the intake meets the goal for each nutrient\n    bool met_goal = true;\n    for (int i = 0; i < M; i++) {\n        if (intake[i] < goals[i]) {\n            met_goal = false;\n            break;\n        }\n    }\n\n    // Print the result\n    if (met_goal) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if Takahashi has met the daily goal for each of M types of nutrients based on the nutrients he consumed from N foods. Here's a step-by-step approach to solve the problem:", "question_id": "abc356_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid generateCarpet(char **carpet, int size, int offset) {\n    if (size == 1) {\n        carpet[offset][offset] = '#';\n        return;\n    }\n\n    int newSize = size / 3;\n\n    // Fill the central block with white cells\n    for (int i = offset; i < offset + newSize; i++) {\n        for (int j = offset; j < offset + newSize; j++) {\n            carpet[i][j] = '.';\n        }\n    }\n\n    // Fill the other eight blocks with level-(K-1) carpets\n    generateCarpet(carpet, newSize, offset);\n    generateCarpet(carpet, newSize, offset + newSize);\n    generateCarpet(carpet, newSize, offset + 2 * newSize);\n\n    generateCarpet(carpet, newSize, offset);\n    generateCarpet(carpet, newSize, offset + 2 * newSize);\n\n    generateCarpet(carpet, newSize, offset);\n    generateCarpet(carpet, newSize, offset + newSize);\n    generateCarpet(carpet, newSize, offset + 2 * newSize);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int size = 3 * (1 << N);\n    char **carpet = (char **)malloc(size * sizeof(char *));\n\n    for (int i = 0; i < size; i++) {\n        carpet[i] = (char *)malloc(size * sizeof(char));\n        memset(carpet[i], '.', size * sizeof(char));\n    }\n\n    generateCarpet(carpet, size, 0);\n\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            printf(\"%c\", carpet[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    for (int i = 0; i < size; i++) {\n        free(carpet[i]);\n    }\n    free(carpet);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate a level-N carpet based on the given rules. The key observation is that a level-K carpet can be constructed from a level-(K-1) carpet by following specific patterns. Here's a step-by-step approach to generate the carpet recursively:\n\n1. Base Case: For level-0, we have a 1x1 carpet with a single black cell represented by '#'.\n2. Recursive Case: For level-K, we start with a 3x3 grid where the central block is white (represented by '.') and the other eight blocks are recursively filled with level-(K-1) carpets.\n\nWe will use a recursive function to generate the carpet and store it in a 2D array. Finally, we will print the carpet according to the specified format.", "question_id": "abc357_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    int hands[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &hands[i]);\n    }\n\n    qsort(hands, N, sizeof(int), compare);\n\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        if (M >= hands[i]) {\n            M -= hands[i];\n            count++;\n        } else {\n            break;\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine how many aliens can be fully disinfect their hands using a given amount of disinfectant. The key steps are to sort the aliens based on the number of hands they have and then iterate through them, deducting the required amount of disinfectant for each alien until we run out. We keep a count of how many aliens can be fully disinfect.", "question_id": "abc357_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    long long n;\n    scanf(\"%lld\", &n);\n\n    // Convert N to string for easy manipulation\n    char str[20];\n    sprintf(str, \"%lld\", n);\n    int len = strlen(str);\n\n    // Calculate the length of V_N as a string\n    long long len_vn = n * len;\n\n    // Calculate the remainder of V_N when divided by MOD\n    long long remainder = 0;\n    for (int i = 0; i < len_vn; i++) {\n        remainder = (remainder * 10 + (str[i % len] - '0')) % MOD;\n    }\n\n    // Print the result\n    printf(\"%lld\\n\", remainder);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the remainder when a number N is concatenated N times and then divided by 998244353. Given the constraints, a direct approach of concatenating N copies of N and then converting it to an integer is impractical due to potential overflow. Instead, we can use properties of modular arithmetic to simplify our calculations.", "question_id": "abc357_d"}
{"solution": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    // Read input string\n    char str[1000];\n    scanf(\"%s\", str);\n\n    // Initialize counters for uppercase and lowercase letters\n    int upper_count = 0, lower_count = 0;\n\n    // Count the number of uppercase and lowercase letters\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (isupper(str[i])) {\n            upper_count++;\n        } else if (islower(str[i])) {\n            lower_count++;\n        }\n    }\n\n    // Convert the string based on the counts\n    if (upper_count > lower_count) {\n        // Convert all lowercase letters to uppercase\n        for (int i = 0; str[i] != '\\0'; i++) {\n            if (islower(str[i])) {\n                str[i] = toupper(str[i]);\n            }\n        }\n    } else {\n        // Convert all uppercase letters to lowercase\n        for (int i = 0; str[i] != '\\0'; i++) {\n            if (isupper(str[i])) {\n                str[i] = tolower(str[i]);\n            }\n        }\n    }\n\n    // Output the modified string\n    printf(\"%s\\n\", str);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of uppercase and lowercase letters in the given string. Based on this count, we will either convert all lowercase letters to uppercase or all uppercase letters to lowercase. Here's the step-by-step approach to achieve this:", "question_id": "abc357_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int *visited = (int *)calloc(n, sizeof(int));\n    int total_pairs = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (visited[i]) continue;\n\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(i));\n        int count = 0;\n\n        while (!g_queue_is_empty(queue)) {\n            int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n            if (visited[current]) continue;\n\n            visited[current] = 1;\n            count++;\n\n            int next = a[current] - 1;\n            if (next == current) {\n                break;\n            }\n\n            g_queue_push_tail(queue, GINT_TO_POINTER(next));\n        }\n\n        total_pairs += count * (n - count);\n        g_queue_free(queue);\n    }\n\n    printf(\"%d\n\", total_pairs);\n\n    free(a);\n    free(visited);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of pairs (u, v) where vertex v is reachable from vertex u in a directed graph. Given that each vertex has an out-degree of 1, we can determine reachability by following the directed edges. Here's a step-by-step approach to solve the problem:\n\n1. **Input Reading**: Read the number of vertices `N` and the array `a` where `a[i]` represents the vertex that vertex `i+1` points to.\n\n2. **Graph Representation**: Since each vertex has exactly one outgoing edge, we can represent the graph using an array where `graph[i]` points to `a[i]`.\n\n3. **Reachability Calculation**: For each vertex `u`, we need to count all vertices `v` that are reachable from `u`. This can be done by following the edges from `u` until we reach a vertex that has already been visited or we reach a vertex that points to itself (self-loop).\n\n4. **Counting Pairs**: For each vertex `u`, count all reachable vertices `v` and add this count to the total number of pairs. To avoid double-counting, we can use a visited array to keep track of vertices that have already been counted.\n\n5. **Output**: Print the total number of pairs.", "question_id": "abc357_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint dp[1001][27];\nGHashTable *memo;\n\nint countStrings(int length, int letter) {\n    if (length == 0) return 1;\n    if (letter == 0) return 0;\n    if (dp[length][letter] != -1) return dp[length][letter];\n\n    int result = 0;\n    for (int i = 0; i <= GPOINTER_TO_INT(g_hash_table_lookup(memo, GINT_TO_POINTER(letter))); i++) {\n        result = (result + countStrings(length - 1, letter - 1)) % MOD;\n    }\n    dp[length][letter] = result;\n    return result;\n}\n\nint main() {\n    int K;\n    scanf(\"%d\", &K);\n\n    memo = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int C[26];\n    for (int i = 0; i < 26; i++) {\n        scanf(\"%d\", &C[i]);\n        g_hash_table_insert(memo, GINT_TO_POINTER(i + 1), GINT_TO_POINTER(C[i]));\n    }\n\n    memset(dp, -1, sizeof(dp));\n\n    int total = 0;\n    for (int i = 1; i <= K; i++) {\n        total = (total + countStrings(i, 26)) % MOD;\n    }\n\n    printf(\"%d\n\", total);\n\n    g_hash_table_destroy(memo);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of valid strings of length up to K that can be formed using uppercase English letters, where the count of each letter is limited by the given values C_i. This problem can be approached using dynamic programming with memoization. We will use a 2D DP array where dp[i][j] represents the number of valid strings of length i that can be formed using the first j letters of the alphabet. We will use a hash table to store intermediate results to avoid redundant calculations. The final answer will be the sum of dp[i][26] for all i from 1 to K, modulo 998244353.", "question_id": "abc358_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 10\n#define MAXM 10\n\nint n, m;\nchar stands[MAXN][MAXM + 1];\n\nbool visited[MAXN];\nbool dfs(int stand, int *match, bool adj[MAXN][MAXM]) {\n    for (int flavor = 0; flavor < m; flavor++) {\n        if (adj[stand][flavor] && !visited[flavor]) {\n            visited[flavor] = true;\n            if (match[flavor] == -1 || dfs(match[flavor], match, adj)) {\n                match[flavor] = stand;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint hungarian(bool adj[MAXN][MAXM]) {\n    int match[MAXM];\n    memset(match, -1, sizeof(match));\n    int result = 0;\n    for (int stand = 0; stand < n; stand++) {\n        memset(visited, false, sizeof(visited));\n        if (dfs(stand, match, adj)) {\n            result++;\n        }\n    }\n    return result;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", stands[i]);\n    }\n\n    bool adj[MAXN][MAXM] = {false};\n    for (int stand = 0; stand < n; stand++) {\n        for (int flavor = 0; flavor < m; flavor++) {\n            if (stands[stand][flavor] == 'o') {\n                adj[stand][flavor] = true;\n            }\n        }\n    }\n\n    int max_match = hungarian(adj);\n    int min_stands = m - max_match;\n    printf(\"%d\\n\", min_stands);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of stands Takahashi needs to visit to buy all the flavors of popcorn. Here's a step-by-step approach to solve it:\n\n1. **Understand the Input and Output**: We are given N stands and M flavors. Each stand has a string of length M indicating which flavors it sells. We need to find the minimum number of stands to visit to get all flavors.\n\n2. **Graph Representation**: We can represent this problem as a bipartite graph where one set of vertices represents the stands and the other set represents the flavors. An edge exists between a stand and a flavor if the stand sells that flavor.\n\n3. **Bipartite Matching**: We need to find the maximum matching in this bipartite graph. The maximum number of stands we can visit to get all flavors is equal to the number of flavors minus the size of the maximum matching.\n\n4. **Implementation**: We can use the\u5308\u7259\u5229\u7b97\u6cd5 (Hungarian algorithm) to find the maximum matching in the bipartite graph. This algorithm is efficient for small graphs (N, M <= 10).\n\n5. **Edge Cases**: Handle edge cases such as empty input or boundary values. Ensure that each stand sells at least one flavor and each flavor is sold at least at one stand.", "question_id": "abc358_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, a;\n    scanf(\"%d %d\", &n, &a);\n\n    GQueue *queue = g_queue_new();\n    int *arrival_times = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arrival_times[i]);\n    }\n\n    int current_time = 0;\n    for (int i = 0; i < n; i++) {\n        if (g_queue_is_empty(queue)) {\n            current_time = arrival_times[i];\n        } else {\n            current_time = g_queue_peek_tail(queue) + a;\n        }\n        g_queue_push_tail(queue, GINT_TO_POINTER(current_time + a));\n        printf(\"%d\n\", current_time);\n    }\n\n    g_queue_free(queue);\n    free(arrival_times);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of people buying tickets at the ticket booth. We'll use a queue to keep track of the people in line and their arrival times. As each person arrives, we'll check if they can start purchasing immediately or if they need to wait for the person in front of them to finish. We'll use a variable to keep track of the current time and update it as people finish purchasing.", "question_id": "abc358_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(m * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    qsort(a, n, sizeof(int), compare);\n\n    int min_cost = 0;\n    int i = 0;\n\n    for (int j = 0; j < m; j++) {\n        while (i < n && a[i] < b[j]) {\n            i++;\n        }\n\n        if (i == n) {\n            min_cost = -1;\n            break;\n        }\n\n        min_cost += a[i];\n        i++;\n    }\n\n    printf(\"%d\\n\", min_cost);\n\n    free(a);\n    free(b);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if it's possible to buy M boxes such that each person gets at least B_i pieces of candy and then find the minimum total cost of these boxes. Here's a step-by-step approach to solve the problem:", "question_id": "abc358_d"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[11], T[11];\n    scanf(\"%s %s\", S, T);\n\n    if (strcmp(S, \"AtCoder\") == 0 && strcmp(T, \"Land\") == 0) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to check if the given two strings S and T match the expected values 'AtCoder' and 'Land' respectively. We will read the input strings, compare them with the expected values, and print 'Yes' if they match, otherwise print 'No'.", "question_id": "abc358_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long long sx, sy, tx, ty;\n    scanf(\"%lld %lld\", &sx, &sy);\n    scanf(\"%lld %lld\", &tx, &ty);\n\n    // Calculate the Manhattan distance in terms of tiles\n    long long dx = abs(tx - sx);\n    long long dy = abs(ty - sy);\n\n    // The minimum toll is the sum of the distances in the x and y directions\n    long long min_toll = dx + dy;\n\n    printf(\"%lld\n\", min_toll);\n\n    return 0;\n}", "reasoning": "The problem involves finding the minimum toll Takahashi must pay to reach a target point on a coordinate plane using 2x1 tiles. The key observation is that the tiles are laid out in a way that the parity of (i + j) determines whether two adjacent squares belong to the same tile. Takahashi's movements are constrained by the tile boundaries, and he must pay a toll each time he enters a new tile. To minimize the toll, we need to find the shortest path in terms of the number of tiles crossed, as each tile crossing incurs a toll of 1.", "question_id": "abc359_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create a hash table to store the positions of each color\n    GHashTable *positions = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the input and store the positions of each color\n    for (int i = 0; i < 2 * n; i++) {\n        int color;\n        scanf(\"%d\", &color);\n\n        // If the color is already in the hash table, store its position\n        if (g_hash_table_contains(positions, GINT_TO_POINTER(color))) {\n            GArray *pos_arr = g_hash_table_lookup(positions, GINT_TO_POINTER(color));\n            g_array_append_val(pos_arr, i);\n        } else {\n            // Otherwise, create a new array for this color and store the position\n            GArray *pos_arr = g_array_new(FALSE, FALSE, sizeof(int));\n            g_array_append_val(pos_arr, i);\n            g_hash_table_insert(positions, GINT_TO_POINTER(color), pos_arr);\n        }\n    }\n\n    // Initialize the result counter\n    int result = 0;\n\n    // Iterate over the colors and check the condition\n    for (int i = 1; i <= n; i++) {\n        // Get the positions of the current color\n        GArray *pos_arr = g_hash_table_lookup(positions, GINT_TO_POINTER(i));\n\n        // Check if there are exactly two positions for this color\n        if (pos_arr && pos_arr->len == 2) {\n            int pos1 = g_array_index(pos_arr, int, 0);\n            int pos2 = g_array_index(pos_arr, int, 1);\n\n            // Check if there is exactly one person between the two positions\n            if (abs(pos1 - pos2) == 3) {\n                result++;\n            }\n        }\n    }\n\n    // Output the result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_hash_table_destroy(positions);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine how many colors i (from 1 to N) have exactly one person between the two people wearing clothes of color i. Here's a step-by-step approach to achieve this:", "question_id": "abc359_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *h = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(h, value);\n    }\n\n    GArray *a = g_array_new(FALSE, FALSE, sizeof(long long));\n    g_array_append_val(a, 0);\n\n    for (int i = 1; i <= n; i++) {\n        g_array_append_val(a, 0);\n    }\n\n    long long operations = 0;\n    for (int i = 1; i <= n; i++) {\n        int h_i = g_array_index(h, int, i - 1);\n        long long a_i = g_array_index(a, long long, i);\n\n        while (a_i <= 0) {\n            a_i++;\n            operations++;\n\n            for (int j = i; j > 0; j--) {\n                long long a_j = g_array_index(a, long long, j);\n                long long a_j_minus_1 = g_array_index(a, long long, j - 1);\n\n                if (a_j_minus_1 > a_j && a_j_minus_1 > h_i) {\n                    a_j_minus_1--;\n                    a_j++;\n                    operations++;\n                }\n            }\n        }\n\n        g_array_index(a, long long, i) = a_i;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        printf(\"%lld \", g_array_index(a, long long, i));\n    }\n    printf(\"\\n\");\n\n    g_array_free(h, TRUE);\n    g_array_free(a, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the operations on the array A and count the number of operations required for each element A_i to become greater than 0. Here's a step-by-step approach to achieve this:", "question_id": "abc359_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Use a GHashTable to count occurrences of 'Takahashi'\n    GHashTable *count = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < n; i++) {\n        char str[1000];\n        scanf(\"%s\", str);\n\n        // If the string is 'Takahashi', increment the count\n        if (strcmp(str, \"Takahashi\") == 0) {\n            int current_count = GPOINTER_TO_INT(g_hash_table_lookup(count, \"Takahashi\")) + 1;\n            g_hash_table_insert(count, \"Takahashi\", GINT_TO_POINTER(current_count));\n        }\n    }\n\n    // Get the count of 'Takahashi'\n    int result = GPOINTER_TO_INT(g_hash_table_lookup(count, \"Takahashi\"));\n\n    // Print the result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of times the string 'Takahashi' appears in a list of N strings. We can achieve this by iterating through the list and incrementing a counter each time we encounter 'Takahashi'. The input is read from standard input, and the output is printed to standard output.", "question_id": "abc359_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    // Initialize DP table\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_append_val(dp, 1);\n\n    // Initialize prefix sum array for palindrome checks\n    GArray *prefix_sum = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_append_val(prefix_sum, 0);\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '?') {\n            // Calculate the number of good strings ending with 'A' and 'B'\n            int count_a = 0, count_b = 0;\n            for (int j = 0; j < dp->len; j++) {\n                count_a = (count_a + g_array_index(dp, int, j)) % MOD;\n                count_b = (count_b + g_array_index(dp, int, j)) % MOD;\n            }\n            g_array_append_val(dp, count_a);\n            g_array_append_val(dp, count_b);\n        } else {\n            // Update DP table based on the current character\n            int count = 0;\n            for (int j = 0; j < dp->len; j++) {\n                count = (count + g_array_index(dp, int, j)) % MOD;\n            }\n            g_array_append_val(dp, count);\n        }\n    }\n\n    // Calculate the number of good strings\n    int result = 0;\n    for (int i = 0; i < dp->len; i++) {\n        result = (result + g_array_index(dp, int, i)) % MOD;\n    }\n\n    // Output the result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_array_free(dp, TRUE);\n    g_array_free(prefix_sum, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of good strings that can be formed by replacing '?' characters in a given string S with 'A' or 'B'. A good string is defined as one where no contiguous substring of length K is a palindrome. Here's a step-by-step approach to solve the problem using dynamic programming and hash maps from GLib:", "question_id": "abc359_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    int *W = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &W[i]);\n    }\n\n    int *box_to_item = (int *)calloc(n + 1, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        box_to_item[A[i]] = i;\n    }\n\n    int *item_to_box = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        item_to_box[i] = i + 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        int item = A[i];\n        int box = item_to_box[item];\n        if (box != i + 1) {\n            int target_box = i + 1;\n            int target_item = box_to_item[target_box];\n\n            // Swap items\n            int temp_item = A[item_to_box[target_box]];\n            int temp_weight = W[item_to_box[target_box]];\n\n            A[item_to_box[target_box]] = A[i];\n            W[item_to_box[target_box]] = W[i];\n\n            A[i] = temp_item;\n            W[i] = temp_weight;\n\n            // Update mappings\n            box_to_item[item] = target_box;\n            item_to_box[target_box] = item;\n            box_to_item[target_item] = i + 1;\n            item_to_box[i + 1] = target_item;\n        }\n    }\n\n    int total_cost = 0;\n    for (int i = 0; i < n; i++) {\n        total_cost += W[i];\n    }\n\n    printf(\"%d\\n\", total_cost);\n\n    free(A);\n    free(W);\n    free(box_to_item);\n    free(item_to_box);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to ensure that each box contains exactly one item by moving items between boxes. The goal is to minimize the total cost of these moves. The key observation is that we can only move items between boxes that currently contain the same item. Therefore, we need to group items by their current box and then find the minimum cost to reassign each group to a unique box.", "question_id": "abc360_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S[101], T[101];\n    scanf(\"%s %s\", S, T);\n\n    int len_S = strlen(S);\n    int len_T = strlen(T);\n\n    // Iterate over possible values of w\n    for (int w = 1; w < len_S; w++) {\n        // Iterate over possible values of c\n        for (int c = 1; c <= len_T; c++) {\n            // Check if the condition is satisfied\n            char result[len_T + 1];\n            result[len_T] = '\\0';\n\n            for (int i = 0; i < len_S; i += w) {\n                if (i + c < len_S + 1) {\n                    result[i / w] = S[i + c - 1];\n                }\n            }\n\n            if (strcmp(result, T) == 0) {\n                printf(\"Yes\n\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"No\n\");\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exists a pair of integers c and w such that the condition is satisfied. The condition involves splitting the string S at every w characters and then concatenating the c-th characters of the substrings of length at least c to form the string T. Here's a step-by-step approach to solve the problem:", "question_id": "abc360_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    // The expected value of the position of the black ball after K operations is 1\n    int expected_value = 1;\n\n    // Output the result modulo 998244353\n    printf(\"%d\n\", expected_value % 998244353);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the expected value of the position of the black ball after K operations. The key insight is that after each operation, the black ball has an equal chance of being in any of the N positions. This can be proven through mathematical induction or by considering the symmetry of the problem. Given that the black ball starts at the leftmost position and each operation is equally likely to swap it with any other ball, the expected value remains constant after each operation. Therefore, the expected value after K operations is the same as the expected value after 0 operations, which is the initial position of the black ball, i.e., 1. However, the problem requires the expected value modulo 998244353. Since the expected value is 1, the result is 1 modulo 998244353, which is 1.", "question_id": "abc360_e"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    // Read input string S\n    char S[4];  // Array to hold the string (3 characters + null terminator)\n    scanf(\"%s\", S);\n\n    // Initialize variables to store positions of R and M\n    int posR = -1, posM = -1;\n\n    // Iterate through the string to find positions of R and M\n    for (int i = 0; i < 3; i++) {\n        if (S[i] == 'R') {\n            posR = i;\n        } else if (S[i] == 'M') {\n            posM = i;\n        }\n    }\n\n    // Check if R is to the left of M\n    if (posR < posM) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if the plate of rice (R) is to the left of the plate of miso soup (M) in a given string S of length 3. Here's the step-by-step approach:", "question_id": "abc360_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, T;\n    scanf(\"%d %d\", &N, &T);\n    char S[N+1];\n    scanf(\"%s\", S);\n    int X[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    GHashTable *hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        g_hash_table_insert(hash, GINT_TO_POINTER(X[i]), GINT_TO_POINTER(i));\n    }\n\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        int x = X[i];\n        int dir = S[i] - '0';\n        for (int j = i + 1; j < N; j++) {\n            int y = X[j];\n            int d = S[j] - '0';\n            if (dir != d) {\n                int time = abs(x - y);\n                if (time <= T) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    g_hash_table_destroy(hash);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of pairs of ants that will pass each other before time (T+0.1). Here's a step-by-step approach to solve it:\n\n1. Parse the input to get the number of ants (N), the time (T), the direction string (S), and the coordinates array (X).\n2. For each ant, calculate the time it will take for it to reach the coordinate of the ant in front of it if it is moving in the opposite direction.\n3. Count the number of pairs (i, j) such that ant i is moving in the positive direction and ant j is moving in the negative direction and they will pass each other before time (T+0.1).\n4. Output the count of such pairs.", "question_id": "abc360_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 15\n\nint min_operations(int N, char *S, char *T) {\n    int operations = 0;\n    for (int i = 0; i < N; i++) {\n        if (S[i] != T[i]) {\n            int j = i + 1;\n            while (j < N && S[j] != T[i]) {\n                j++;\n            }\n            if (j == N) {\n                return -1;\n            }\n            for (int k = j; k > i; k--) {\n                char temp = S[k];\n                S[k] = S[k - 1];\n                S[k - 1] = temp;\n                operations++;\n            }\n        }\n    }\n    return operations;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char S[MAX_N], T[MAX_N];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n    int result = min_operations(N, S, T);\n    printf(\"%d\n\", result);\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can transform the initial state of stones (S) into the target state (T) using the allowed operations. The operations allow us to move two adjacent stones to two empty cells while preserving their order. We need to find the minimum number of operations required to achieve the target state or determine if it's impossible.", "question_id": "abc361_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int a, b, c, d, e, f, g, h, i, j, k, l;\n\n    // Read input\n    scanf(\"%d %d %d %d %d %d\", &a, &b, &c, &d, &e, &f);\n    scanf(\"%d %d %d %d %d %d\", &g, &h, &i, &j, &k, &l);\n\n    // Check if there is overlap in all three dimensions\n    if (d > g && a < j && e > h && b < k && f > i && c < l) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine if the intersection of two cuboids has a positive volume, we need to check if there is any overlap in all three dimensions (x, y, and z). If there is overlap in all three dimensions, the intersection will have a positive volume. Otherwise, the intersection will have a volume of zero or negative.", "question_id": "abc361_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N, K, X;\n    scanf(\"%d %d %d\", &N, &K, &X);\n\n    // Initialize GArray to store the sequence A\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Read the sequence A\n    for (int i = 0; i < N; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(A, value);\n    }\n\n    // Insert X immediately after the K-th element\n    if (K > 0 && K <= N) {\n        g_array_insert_val(A, K, X);\n    }\n\n    // Print the resulting sequence B\n    for (int i = 0; i < A->len; i++) {\n        printf(\"%d \", g_array_index(A, int, i));\n    }\n    printf(\"\\n\");\n\n    // Free the allocated memory\n    g_array_free(A, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to insert an integer X immediately after the K-th element of a given sequence A. Here's a step-by-step approach to achieve this using GLib data structures in C:", "question_id": "abc361_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    long long N;\n    scanf(\"%lld\", &N);\n\n    // Use a hash set to avoid counting duplicates\n    GHashTable *set = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Iterate through possible values of a\n    for (long long a = 2; a * a <= N; a++) {\n        long long power = a * a;\n        // Iterate through possible values of b\n        while (power <= N) {\n            g_hash_table_insert(set, GINT_TO_POINTER(power), GINT_TO_POINTER(1));\n            power *= a;\n        }\n    }\n\n    // Count the number of unique elements in the set\n    int result = g_hash_table_size(set);\n\n    // Output result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_hash_table_destroy(set);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of integers between 1 and N that can be expressed as x = a^b where a and b are positive integers and b >= 2. The approach involves iterating through possible values of a and b to generate powers and checking if they are within the range [1, N]. We need to be careful to avoid duplicates and handle large numbers efficiently.", "question_id": "abc361_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    qsort(a, n, sizeof(int), compare);\n\n    int min_diff = INT_MAX;\n    for (int i = 0; i <= n - k; i++) {\n        int max_val = a[i + k - 1];\n        int min_val = a[i];\n        int diff = max_val - min_val;\n        if (diff < min_diff) {\n            min_diff = diff;\n        }\n    }\n\n    printf(\"%d\n\", min_diff);\n\n    free(a);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum possible value of the difference between the maximum and minimum values of the sequence B after removing exactly K elements from the sequence A. The key insight is that removing K elements means we are left with N-K elements. The goal is to minimize the difference between the maximum and minimum values of these remaining elements. By removing the K largest elements, we can ensure that the maximum value of the remaining sequence is as small as possible. Similarly, by removing the K smallest elements, we can ensure that the minimum value of the remaining sequence is as large as possible. The difference between these two values will give us the minimum possible value of the problem. However, we need to consider all possible combinations of K elements to find the minimum difference. This can be done by sorting the sequence A and then calculating the difference between the maximum and minimum values of the remaining sequence for each possible combination of K elements. The minimum of these differences will be our answer.", "question_id": "abc361_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_CITIES 200000\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int graph[MAX_CITIES][MAX_CITIES] = {0};\n    for (int i = 0; i < n - 1; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        graph[a - 1][b - 1] = c;\n        graph[b - 1][a - 1] = c;\n    }\n\n    int *visited = (int *)calloc(n, sizeof(int));\n    int *path = (int *)malloc(n * sizeof(int));\n    int total_distance = 0;\n\n    visited[0] = 1;\n    path[0] = 1;\n    int current_city = 0;\n\n    for (int i = 1; i < n; i++) {\n        int min_distance = INT_MAX;\n        int next_city = -1;\n\n        for (int j = 0; j < n; j++) {\n            if (!visited[j] && graph[current_city][j] < min_distance) {\n                min_distance = graph[current_city][j];\n                next_city = j;\n            }\n        }\n\n        if (next_city == -1) {\n            // If no unvisited city is found, break the loop\n            break;\n        }\n\n        visited[next_city] = 1;\n        path[i] = next_city + 1;\n        total_distance += min_distance;\n        current_city = next_city;\n    }\n\n    // Add the distance from the last city back to the starting city\n    total_distance += graph[path[n - 1] - 1][path[0] - 1];\n\n    printf(\"%d\n\", total_distance);\n\n    free(visited);\n    free(path);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum travel distance required to visit all cities at least once starting from any city. This problem can be approached using the concept of the Traveling Salesman Problem (TSP), which is a classic combinatorial optimization problem. However, given the constraints, a direct TSP solution is not feasible due to its exponential time complexity. Instead, we can use a heuristic approach such as the nearest neighbor algorithm or a more sophisticated algorithm like the 2-opt heuristic. For simplicity and given the constraints, we will use the nearest neighbor algorithm, which is a greedy approach that works well for this type of problem.", "question_id": "abc361_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200000\n#define MAX_E 200000\n\ntypedef struct {\n    int to;\n    long long weight;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    return ((Edge*)a)->weight - ((Edge*)b)->weight;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    long long A[MAX_N];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld\", &A[i]);\n    }\n\n    GArray *graph[MAX_N] = { NULL };\n    for (int i = 0; i < n; i++) {\n        graph[i] = g_array_new(FALSE, FALSE, sizeof(Edge));\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        long long b;\n        scanf(\"%d %d %lld\", &u, &v, &b);\n        u--;\n        v--;\n\n        Edge edge1 = { v, b + A[v] };\n        g_array_append_val(graph[u], edge1);\n\n        Edge edge2 = { u, b + A[u] };\n        g_array_append_val(graph[v], edge2);\n    }\n\n    long long *dist = (long long *)calloc(n, sizeof(long long));\n    for (int i = 0; i < n; i++) {\n        dist[i] = LLONG_MAX;\n    }\n\n    dist[0] = A[0];\n\n    GPriorityQueue *pq = g_priority_queue_new((GCompareFunc)compare, NULL);\n    g_priority_queue_push(pq, (gpointer)dist[0], (gpointer)0);\n\n    while (!g_priority_queue_is_empty(pq)) {\n        int u = GPOINTER_TO_INT(g_priority_queue_pop(pq));\n\n        for (int i = 0; i < g_array_get_n_items(graph[u]); i++) {\n            Edge edge = g_array_index(graph[u], Edge, i);\n            int v = edge.to;\n            long long weight = edge.weight;\n\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                g_priority_queue_push(pq, (gpointer)dist[v], (gpointer)v);\n            }\n        }\n    }\n\n    for (int i = 1; i < n; i++) {\n        printf(\"%lld \", dist[i]);\n    }\n\n    printf(\"\\n\");\n\n    for (int i = 0; i < n; i++) {\n        g_array_free(graph[i], TRUE);\n    }\n\n    g_priority_queue_free(pq);\n    free(dist);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum weight path from vertex 1 to each vertex i (2 <= i <= N) in a given graph. The graph is represented by vertices with weights and edges with weights. We can use Dijkstra's algorithm to find the shortest path from vertex 1 to all other vertices efficiently. Dijkstra's algorithm is well-suited for this problem because it handles graphs with non-negative edge weights and can find the shortest paths in O((V + E) log V) time complexity, where V is the number of vertices and E is the number of edges.", "question_id": "abc362_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // dp[i][d] will store the number of arithmetic subsequences ending at index i with difference d\n    GHashTable *dp[n];\n    for (int i = 0; i < n; i++) {\n        dp[i] = g_hash_table_new(g_direct_hash, g_direct_equal);\n    }\n\n    int result = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            long long diff = (long long)A[i] - A[j];\n            if (diff > INT_MAX || diff < INT_MIN) continue;\n\n            int d = (int)diff;\n            gpointer count = g_hash_table_lookup(dp[j], GINT_TO_POINTER(d));\n            int cnt = count ? GPOINTER_TO_INT(count) : 0;\n\n            g_hash_table_insert(dp[i], GINT_TO_POINTER(d), GINT_TO_POINTER((cnt + 1) % MOD));\n\n            result = (result + cnt + 1) % MOD;\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    for (int i = 0; i < n; i++) {\n        g_hash_table_destroy(dp[i]);\n    }\n\n    free(A);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of arithmetic subsequences of each length in the given sequence A. We will use dynamic programming to keep track of the number of arithmetic subsequences ending at each position for each possible difference. Here's the step-by-step approach:\n\n1. Initialize a 2D array `dp` where `dp[i][d]` represents the number of arithmetic subsequences ending at index `i` with a common difference `d`.\n2. For each element in the sequence, iterate through all previous elements to check if the current element can form an arithmetic sequence with the previous elements.\n3. Update the `dp` array accordingly and keep a count of all subsequences of each length.\n4. Finally, sum up the counts for subsequences of each length and print the results.", "question_id": "abc362_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *L = (int *)malloc(n * sizeof(int));\n    int *R = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &L[i], &R[i]);\n    }\n\n    int sum = 0;\n    int *X = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        if (L[i] <= 0 && R[i] >= 0) {\n            X[i] = 0;\n        } else if (L[i] > 0) {\n            X[i] = L[i];\n            sum += X[i];\n        } else {\n            X[i] = R[i];\n            sum += X[i];\n        }\n    }\n\n    if (sum != 0) {\n        printf(\"No\n\");\n        free(L);\n        free(R);\n        free(X);\n        return 0;\n    }\n\n    printf(\"Yes\n\");\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", X[i]);\n    }\n    printf(\"\\n\");\n\n    free(L);\n    free(R);\n    free(X);\n\n    return 0;\n}", "reasoning": "The problem requires finding a sequence of integers that satisfies two conditions: each integer in the sequence must lie within a given range [L_i, R_i], and the sum of all integers in the sequence must be zero. To solve this, we can use a greedy approach. For each pair (L_i, R_i), we can choose the smallest possible value that is greater than or equal to L_i and the largest possible value that is less than or equal to R_i. If the sum of these chosen values is not zero, we need to adjust the sequence to ensure the sum is zero. If at any point we cannot adjust the sequence to meet the sum condition, we conclude that no solution exists.", "question_id": "abc362_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int R, G, B;\n    char C[10];\n\n    // Read input\n    scanf(\"%d %d %d\", &R, &G, &B);\n    scanf(\"%s\", C);\n\n    // Initialize minimum cost to a large value\n    int min_cost = INT_MAX;\n\n    // Iterate through each pen color\n    if (strcmp(C, \"Red\") != 0) {\n        min_cost = R;\n    }\n    if (strcmp(C, \"Green\") != 0 && G < min_cost) {\n        min_cost = G;\n    }\n    if (strcmp(C, \"Blue\") != 0 && B < min_cost) {\n        min_cost = B;\n    }\n\n    // Print the minimum cost\n    printf(\"%d\\n\", min_cost);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum cost of buying a pen while considering Takahashi's dislike for a specific color. The steps are as follows:\n1. Read the costs of red, green, and blue pens.\n2. Read the color that Takahashi dislikes.\n3. Initialize a variable to store the minimum cost.\n4. Iterate through each pen color and check if it is the one Takahashi dislikes. If it is, skip it. Otherwise, update the minimum cost if the current pen's cost is lower.\n5. Print the minimum cost.", "question_id": "abc362_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint main() {\n    int x1, y1, x2, y2, x3, y3;\n    scanf(\"%d %d\", &x1, &y1);\n    scanf(\"%d %d\", &x2, &y2);\n    scanf(\"%d %d\", &x3, &y3);\n\n    double d1 = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n    double d2 = sqrt(pow(x3 - x2, 2) + pow(y3 - y2, 2));\n    double d3 = sqrt(pow(x3 - x1, 2) + pow(y3 - y1, 2));\n\n    if ((d1 * d1 == d2 * d2 + d3 * d3) ||\n        (d2 * d2 == d1 * d1 + d3 * d3) ||\n        (d3 * d3 == d1 * d1 + d2 * d2)) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine if a triangle is a right triangle, we can use the property that the square of the length of one side is equal to the sum of the squares of the lengths of the other two sides. We can calculate the distances between the points using the Euclidean distance formula and then check if any of the three conditions hold true.", "question_id": "abc362_b"}
{"solution": "#include <stdio.h>\n\nint main() {\n    int R;\n    scanf(\"%d\", &R);\n\n    int increase = 100;\n\n    printf(\"%d\n\", increase);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum increase in Takahashi's rating that will increase the number of displayed '^'. The number of '^' displayed is determined by the range in which the rating falls. Specifically, the number of '^' is 1 for ratings 1-99, 2 for ratings 100-199, and 3 for ratings 200-299. The goal is to find the smallest increase in rating that moves Takahashi from one range to the next, thus increasing the number of '^'. For ratings 1-99, the increase is 100. For ratings 100-199, the increase is 100. For ratings 200-299, the increase is 100. Therefore, the minimum increase in rating required is always 100 for the given constraints.", "question_id": "abc363_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nGHashTable *memo;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Recursive function to find the palindrome string that evaluates to N\nchar *find_palindrome(long long N) {\n    if (N == 0) {\n        return g_strdup(\"0\");\n    }\n\n    char *result = NULL;\n\n    // Try all possible first half values\n    for (long long i = 1; i * i <= N; i++) {\n        long long remainder = N - i * i;\n        char *second_half = find_palindrome(remainder);\n        if (second_half != NULL) {\n            char *first_half = g_strdup_printf(\"%lld\", i);\n            char *palindrome = g_strconcat(first_half, second_half, first_half, NULL);\n            if (is_palindrome(palindrome)) {\n                result = palindrome;\n                break;\n            }\n            g_free(first_half);\n            g_free(second_half);\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    // Read input\n    long long N;\n    scanf(\"%lld\", &N);\n\n    // Initialize memoization table\n    memo = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Find the palindrome string\n    char *result = find_palindrome(N);\n\n    // Output result\n    if (result != NULL) {\n        printf(\"%s\n\", result);\n        g_free(result);\n    } else {\n        printf(\"-1\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(memo);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to construct a palindrome string S that evaluates to the given integer N. The key observation is that the palindrome structure allows us to break down the problem into smaller parts. Specifically, we can use the fact that the palindrome structure can be divided into three parts: the first half, the middle character (if the length is odd), and the reverse of the first half. We can then try to construct these parts recursively to find a valid palindrome that evaluates to N.", "question_id": "abc363_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, T, P;\n    scanf(\"%d %d %d\", &N, &T, &P);\n\n    int *hair_lengths = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &hair_lengths[i]);\n    }\n\n    int days = 0;\n    int count = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (hair_lengths[i] >= T) {\n            count++;\n        }\n    }\n\n    if (count >= P) {\n        printf(\"0\\n\");\n        free(hair_lengths);\n        return 0;\n    }\n\n    while (count < P) {\n        days++;\n        for (int i = 0; i < N; i++) {\n            hair_lengths[i]++;\n            if (hair_lengths[i] >= T) {\n                count++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", days);\n\n    free(hair_lengths);\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of days after which the number of people with hair length at least T becomes P or more. We can approach this by iterating through each person's hair length and counting how many people have hair length at least T. We then increment the day count until the count reaches P or more. If the condition is already satisfied initially, we return 0.", "question_id": "abc363_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <glib.h>\n\n#define MAX_LEN 11\n\n// Function to check if a string contains a palindrome of length K\nbool contains_palindrome(const char *str, int n, int k) {\n    for (int i = 0; i <= n - k; i++) {\n        bool is_palindrome = true;\n        for (int j = 0; j < k / 2; j++) {\n            if (str[i + j] != str[i + k - 1 - j]) {\n                is_palindrome = false;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Recursive function to generate permutations and count valid ones\nvoid permute(char *str, int start, int end, int k, int *count) {\n    if (start == end) {\n        if (!contains_palindrome(str, end, k)) {\n            (*count)++;\n        }\n    } else {\n        for (int i = start; i <= end; i++) {\n            // Swap characters\n            char temp = str[start];\n            str[start] = str[i];\n            str[i] = temp;\n\n            // Recurse\n            permute(str, start + 1, end, k, count);\n\n            // Swap back\n            temp = str[start];\n            str[start] = str[i];\n            str[i] = temp;\n        }\n    }\n}\n\nint main() {\n    int n, k;\n    char s[MAX_LEN];\n\n    // Read input\n    scanf(\"%d %d\", &n, &k);\n    scanf(\"%s\", s);\n\n    int count = 0;\n\n    // Generate all permutations and count valid ones\n    permute(s, 0, n - 1, k, &count);\n\n    // Output result\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of permutations of the string S that do not contain any palindrome of length K as a substring. This involves several steps:\n\n1. **Generate Permutations**: We need to generate all possible permutations of the string S. Given the constraints (N \u2264 10), we can generate all permutations efficiently.\n2. **Check for Palindromes**: For each permutation, we need to check if it contains any palindrome of length K. This involves checking all substrings of length K in the permutation.\n3. **Count Valid Permutations**: We count the permutations that do not contain any palindrome of length K.\n\nThe solution uses a recursive approach to generate permutations and a helper function to check for palindromes.", "question_id": "abc363_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const char *str, int len) {\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    // Read input\n    unsigned long long n;\n    scanf(\"%llu\", &n);\n\n    // Variables to store the current palindrome and its length\n    char palindrome[20];  // 20 is enough to store the largest possible palindrome within the constraints\n    int len = 1;\n\n    // Generate palindromes until we find the N-th one\n    while (true) {\n        // Construct the first half of the palindrome\n        for (int i = 0; i < len; i++) {\n            palindrome[i] = '0' + (i < len / 2 ? i : len - i - 1);\n        }\n        palindrome[len] = '\n0';\n\n        // Form the full palindrome by mirroring the first half\n        for (int i = len; i < 2 * len; i++) {\n            palindrome[i] = palindrome[2 * len - i - 1];\n        }\n\n        // Check if the constructed palindrome is the N-th one\n        if (is_palindrome(palindrome, 2 * len)) {\n            n--;\n            if (n == 0) {\n                printf(\"%s\n\", palindrome);\n                break;\n            }\n        }\n\n        // Move to the next palindrome length\n        if (len == 1) {\n            len = 2;\n        } else {\n            len++;\n        }\n    }\n\n    return 0;\n}", "reasoning": "To find the N-th smallest palindrome number, we need to generate palindrome numbers in ascending order and count them until we reach the N-th one. Given the constraints, a direct approach of generating and checking each number for being a palindrome would be too slow. Instead, we can use a mathematical approach to generate palindromes more efficiently. We can generate palindromes by considering the first half of the number and then mirroring it to form the second half. For example, to generate a 4-digit palindrome, we can consider the first two digits and then mirror them to form the last two digits. To handle very large palindromes, we can use a string to store the number and then construct the palindrome by appending the reverse of the first half to the end.", "question_id": "abc363_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 1000\n\n// Function to perform flood fill and count the number of sections that sink\nint flood_fill(int **grid, int H, int W, int sea_level, int x, int y) {\n    if (x < 0 || x >= H || y < 0 || y >= W || grid[x][y] <= sea_level) {\n        return 0;\n    }\n    grid[x][y] = -1; // Mark the section as visited\n    int count = 1;\n    count += flood_fill(grid, H, W, sea_level, x + 1, y);\n    count += flood_fill(grid, H, W, sea_level, x - 1, y);\n    count += flood_fill(grid, H, W, sea_level, x, y + 1);\n    count += flood_fill(grid, H, W, sea_level, x, y - 1);\n    return count;\n}\n\nint main() {\n    int H, W, Y;\n    scanf(\"%d %d %d\", &H, &W, &Y);\n\n    int **grid = (int **)malloc(H * sizeof(int *));\n    for (int i = 0; i < H; i++) {\n        grid[i] = (int *)malloc(W * sizeof(int));\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    for (int year = 1; year <= Y; year++) {\n        int total_sunk = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] > year) {\n                    total_sunk += flood_fill(grid, H, W, year, i, j);\n                }\n            }\n        }\n        printf(\"%d\n\", H * W - total_sunk);\n    }\n\n    for (int i = 0; i < H; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n\n    return 0;\n}", "reasoning": "The problem requires simulating the process of the sea level rising year by year and determining the area of the island that remains above sea level at each step. The approach involves using a flood fill algorithm to determine which sections of the island sink when the sea level rises. Here's a step-by-step breakdown of the solution:", "question_id": "abc363_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    int S_i, S_j;\n    scanf(\"%d %d\", &S_i, &S_j);\n\n    char **grid = (char **)g_malloc(H * sizeof(char *));\n    for (int i = 0; i < H; i++) {\n        grid[i] = (char *)g_malloc(W * sizeof(char));\n        scanf(\" %c\", &grid[i][0]);\n    }\n\n    char X[51];\n    scanf(\"%s\", X);\n\n    int x = S_i - 1;\n    int y = S_j - 1;\n\n    for (int i = 0; i < strlen(X); i++) {\n        if (X[i] == 'L' && y > 0 && grid[x][y - 1] == '.') {\n            y--;\n        } else if (X[i] == 'R' && y < W - 1 && grid[x][y + 1] == '.') {\n            y++;\n        } else if (X[i] == 'U' && x > 0 && grid[x - 1][y] == '.') {\n            x--;\n        } else if (X[i] == 'D' && x < H - 1 && grid[x + 1][y] == '.') {\n            x++;\n        }\n    }\n\n    printf(\"%d %d\n\", x + 1, y + 1);\n\n    for (int i = 0; i < H; i++) {\n        g_free(grid[i]);\n    }\n    g_free(grid);\n\n    return 0;\n}", "reasoning": "The problem involves simulating Takahashi's movements on a grid based on a series of instructions. The grid is represented as a 2D array, and Takahashi's movements are controlled by a string of instructions (L, R, U, D). We need to track Takahashi's position after processing each instruction and ensure he does not move into walls (#). The solution involves parsing the input, simulating the movements, and outputting the final position.", "question_id": "abc364_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 80\n#define MAX_VALUE 10000\n\ntypedef struct {\n    int sweetness;\n    int saltiness;\n} Dish;\n\nint compare(const void *a, const void *b) {\n    return ((Dish *)b)->sweetness - ((Dish *)a)->sweetness;\n}\n\nint maxDishes(int N, int X, int Y, Dish dishes[]) {\n    qsort(dishes, N, sizeof(Dish), compare);\n\n    int maxCount = 0;\n    for (int i = 0; i < N; i++) {\n        int count = 0;\n        int currentSweetness = 0;\n        int currentSaltiness = 0;\n\n        for (int j = i; j < N; j++) {\n            currentSweetness += dishes[j].sweetness;\n            currentSaltiness += dishes[j].saltiness;\n\n            if (currentSweetness <= X && currentSaltiness <= Y) {\n                count++;\n            } else {\n                break;\n            }\n        }\n\n        maxCount = (count > maxCount) ? count : maxCount;\n    }\n\n    return maxCount;\n}\n\nint main() {\n    int N, X, Y;\n    scanf(\"%d %d %d\", &N, &X, &Y);\n\n    Dish dishes[MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &dishes[i].sweetness, &dishes[i].saltiness);\n    }\n\n    int result = maxDishes(N, X, Y, dishes);\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the optimal arrangement of dishes such that Snuke eats the maximum number of dishes without exceeding the total sweetness (X) or the total saltiness (Y). This is a combinatorial problem, and given the constraints (N \u2264 80), we can use a brute-force approach to try all possible permutations of the dishes and find the one that maximizes the number of dishes Snuke can eat. However, since brute-force is computationally expensive for large N, we need to optimize our approach. We can use a greedy algorithm to try to maximize the number of dishes by always adding the dish that has the highest remaining sweetness and saltiness that does not exceed the limits.", "question_id": "abc364_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200005\n\ntypedef struct {\n    int to;\n    int cost;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    return ((Edge *)a)->cost - ((Edge *)b)->cost;\n}\n\nint find(int *parent, int i) {\n    if (parent[i] == i)\n        return i;\n    return parent[i] = find(parent, parent[i]);\n}\n\nvoid union_sets(int *parent, int *rank, int x, int y) {\n    int rootX = find(parent, x);\n    int rootY = find(parent, y);\n\n    if (rank[rootX] > rank[rootY])\n        parent[rootY] = rootX;\n    else if (rank[rootX] < rank[rootY])\n        parent[rootX] = rootY;\n    else {\n        parent[rootY] = rootX;\n        rank[rootX]++;\n    }\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    GArray *edges = g_array_new(FALSE, FALSE, sizeof(Edge));\n\n    for (int i = 1; i <= Q; i++) {\n        int L, R, C;\n        scanf(\"%d %d %d\", &L, &R, &C);\n\n        for (int j = L; j <= R; j++) {\n            Edge e = {N + i, C};\n            g_array_append_val(edges, e);\n        }\n    }\n\n    g_array_sort(edges, compare);\n\n    int *parent = malloc((N + Q + 1) * sizeof(int));\n    int *rank = malloc((N + Q + 1) * sizeof(int));\n\n    for (int i = 1; i <= N + Q; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int cost = 0;\n    int edges_used = 0;\n\n    for (int i = 0; i < edges->len; i++) {\n        Edge e = g_array_index(edges, Edge, i);\n\n        int rootX = find(parent, e.to);\n        int rootY = find(parent, e.from);\n\n        if (rootX != rootY) {\n            union_sets(parent, rank, rootX, rootY);\n            cost += e.cost;\n            edges_used++;\n\n            if (edges_used == N - 1)\n                break;\n        }\n    }\n\n    g_array_free(edges, TRUE);\n    free(parent);\n    free(rank);\n\n    if (edges_used != N - 1)\n        printf(\"-1\n\");\n    else\n        printf(\"%d\n\", cost);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if the graph remains connected after adding edges and then find the minimum spanning tree (MST) if it is connected. Here's a step-by-step approach to achieve this:", "question_id": "abc364_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    int *B = (int *)malloc(Q * sizeof(int));\n    int *k = (int *)malloc(Q * sizeof(int));\n    for (int i = 0; i < Q; i++) {\n        scanf(\"%d %d\", &B[i], &k[i]);\n    }\n\n    for (int i = 0; i < Q; i++) {\n        int *dist = (int *)malloc(N * sizeof(int));\n        for (int j = 0; j < N; j++) {\n            dist[j] = abs(A[j] - B[i]);\n        }\n\n        qsort(dist, N, sizeof(int), compare);\n\n        printf(\"%d\\n\", dist[k[i] - 1]);\n\n        free(dist);\n    }\n\n    free(A);\n    free(B);\n    free(k);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the k-th closest point from a list of points A to a list of points B on a number line. Here's a step-by-step approach to solve it using GLib data structures and functions:", "question_id": "abc364_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Structure to hold the sweetness and saltiness of a dish\ntypedef struct {\n    int sweetness;\n    int saltiness;\n} Dish;\n\n// Comparison function for qsort\nint compare(const void *a, const void *b) {\n    Dish *d1 = (Dish *)a;\n    Dish *d2 = (Dish *)b;\n    return d1->sweetness - d2->sweetness;\n}\n\nint main() {\n    int N;\n    long long X, Y;\n    scanf(\"%d %lld %lld\", &N, &X, &Y);\n\n    Dish *dishes = (Dish *)malloc(N * sizeof(Dish));\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &dishes[i].sweetness, &dishes[i].saltiness);\n    }\n\n    // Sort dishes by sweetness\n    qsort(dishes, N, sizeof(Dish), compare);\n\n    long long total_sweetness = 0;\n    long long total_saltiness = 0;\n    int count = 0;\n\n    for (int i = 0; i < N; i++) {\n        total_sweetness += dishes[i].sweetness;\n        total_saltiness += dishes[i].saltiness;\n        count++;\n\n        if (total_sweetness > X || total_saltiness > Y) {\n            break;\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    free(dishes);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of dishes Takahashi will eat such that the total sweetness exceeds X or the total saltiness exceeds Y. The key insight is to sort the dishes based on their sweetness and saltiness and then greedily select the dishes in that order until either of the limits (X or Y) is exceeded. This approach ensures that we are minimizing the number of dishes eaten while still meeting the conditions.", "question_id": "abc364_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Process using appropriate data structure\n    char *dishes = (char *)malloc(n * sizeof(char));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", &dishes[i]);\n    }\n\n    // Your algorithm here\n    bool canEatAll = true;\n    for (int i = 0; i < n - 1; i++) {\n        if (strcmp(&dishes[i], \"sweet\") == 0 && strcmp(&dishes[i + 1], \"sweet\") == 0) {\n            canEatAll = false;\n            break;\n        }\n    }\n\n    // Output result\n    if (canEatAll) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    // Clean up\n    free(dishes);\n\n    return 0;\n}", "reasoning": "The problem requires determining if Takahashi can eat all the dishes without eating two sweet dishes consecutively. We can solve this by iterating through the list of dishes and checking if there are any two consecutive sweet dishes. If we find any, we return 'No'. If we finish iterating through the list without finding any consecutive sweet dishes, we return 'Yes'.", "question_id": "abc364_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    int first = INT_MIN, second = INT_MIN;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > first) {\n            second = first;\n            first = arr[i];\n        } else if (arr[i] > second && arr[i] != first) {\n            second = arr[i];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == second) {\n            printf(\"%d\\n\", i + 1);\n            break;\n        }\n    }\n\n    free(arr);\n\n    return 0;\n}", "reasoning": "To find the second largest element in a sequence of distinct integers, we need to iterate through the sequence and keep track of the largest and second largest elements. Here's a step-by-step approach to solve the problem:", "question_id": "abc365_b"}
{"solution": "#include <stdio.h>\n\nint main() {\n    int Y;\n    scanf(\"%d\", &Y);\n\n    int days;\n    if (Y % 400 == 0) {\n        days = 366;\n    } else if (Y % 100 == 0) {\n        days = 365;\n    } else if (Y % 4 == 0) {\n        days = 366;\n    } else {\n        days = 365;\n    }\n\n    printf(\"%d\\n\", days);\n\n    return 0;\n}", "reasoning": "To determine the number of days in a given year Y within the range of 1583 to 2023, we need to follow these steps:\n1. Read the input integer Y from standard input.\n2. Check if Y is a multiple of 400. If it is, then Y has 366 days.\n3. If Y is not a multiple of 400, check if it is a multiple of 100. If it is, then Y has 365 days.\n4. If Y is not a multiple of 100, check if it is a multiple of 4. If it is, then Y has 366 days.\n5. If Y does not meet any of the above conditions, then it has 365 days.\n6. Print the number of days in the year Y.", "question_id": "abc365_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    // Calculate prefix XORs\n    int *prefix_xor = (int *)malloc(n * sizeof(int));\n    prefix_xor[0] = arr[0];\n    for (int i = 1; i < n; i++) {\n        prefix_xor[i] = prefix_xor[i - 1] ^ arr[i];\n    }\n\n    // Use a hash map to count occurrences of prefix XORs\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int result = 0;\n\n    for (int i = 0; i < n; i++) {\n        // For each prefix XOR, add its count to the result\n        result += GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(prefix_xor[i]))) + 1;\n\n        // Update the count of the current prefix XOR\n        g_hash_table_insert(count, GINT_TO_POINTER(prefix_xor[i]), GINT_TO_POINTER(GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(prefix_xor[i]))) + 1));\n    }\n\n    // Output the result\n    printf(\"%d\\n\", result);\n\n    // Free allocated memory\n    free(arr);\n    free(prefix_xor);\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently compute the sum of XORs for all subarrays of the given sequence. The direct approach of computing XOR for each subarray would be too slow for large N (up to 200,000). Instead, we can use a prefix XOR technique combined with a hash map to achieve a more efficient solution.", "question_id": "abc365_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    GHashTable *map = g_hash_table_new(g_str_hash, g_str_equal);\n    int win = 0;\n\n    for (int i = 0; i < n; i++) {\n        char aoki = s[i];\n        char takahashi = 'A';\n\n        if (aoki == 'R') {\n            takahashi = 'P';\n        } else if (aoki == 'P') {\n            takahashi = 'S';\n        } else if (aoki == 'S') {\n            takahashi = 'R';\n        }\n\n        if (g_hash_table_lookup(map, &takahashi) == NULL) {\n            g_hash_table_insert(map, &takahashi, GINT_TO_POINTER(1));\n            win++;\n        }\n    }\n\n    printf(\"%d\\n\", win);\n\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum number of games Takahashi could have won given the constraints. The key points to consider are:\n1. Takahashi never lost to Aoki.\n2. Takahashi's moves are different from his move in the next game.\n3. We need to maximize the number of wins.\nTo achieve this, we can use a greedy approach. We will iterate through the moves of Aoki and try to find the best move for Takahashi that maximizes the number of wins while satisfying the conditions. We will keep track of the moves Takahashi has made and ensure that he never loses to Aoki and that his moves are different from the previous move.", "question_id": "abc365_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    long long m;\n    scanf(\"%d %lld\", &n, &m);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    long long total_cost = 0;\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n        total_cost += a[i];\n    }\n\n    if (total_cost <= m) {\n        printf(\"infinite\n\");\n    } else {\n        qsort(a, n, sizeof(int), compare);\n        long long sum = 0;\n        int x = 0;\n\n        for (int i = 0; i < n; i++) {\n            int min_val = a[i];\n            if (sum + min_val <= m) {\n                sum += min_val;\n                x = min_val;\n            } else {\n                break;\n            }\n        }\n\n        printf(\"%d\n\", x);\n    }\n\n    free(a);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum possible value of the subsidy limit x such that the total transportation subsidy for all N people does not exceed M yen. The key observation is that if the sum of all transportation costs A_i is less than or equal to M, then the subsidy limit can be made infinitely large. Otherwise, we need to find the maximum x such that the sum of min(x, A_i) for all i is less than or equal to M.", "question_id": "abc365_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n// Function to compare two pairs based on A_i and B_i\nint compare(const void *a, const void *b) {\n    int *pair1 = (int *)a;\n    int *pair2 = (int *)b;\n    if (pair1[0] != pair2[0]) {\n        return pair2[0] - pair1[0]; // Compare A_i in descending order\n    } else {\n        return pair2[1] - pair1[1]; // Compare B_i in descending order if A_i are equal\n    }\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    // Read coefficients and store them in an array of pairs\n    int **coeffs = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        coeffs[i] = (int *)malloc(2 * sizeof(int));\n        scanf(\"%d %d\", &coeffs[i][0], &coeffs[i][1]);\n    }\n\n    // Sort the coefficients array using the custom comparator\n    qsort(coeffs, N, sizeof(int *), compare);\n\n    // Initialize the result with the first function's value\n    int result = coeffs[0][0] * 1 + coeffs[0][1];\n\n    // Apply the remaining functions to the result\n    for (int i = 1; i < K; i++) {\n        result = coeffs[i][0] * result + coeffs[i][1];\n    }\n\n    // Print the result\n    printf(\"%d\\n\", result);\n\n    // Free allocated memory\n    for (int i = 0; i < N; i++) {\n        free(coeffs[i]);\n    }\n    free(coeffs);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum possible value of the nested function evaluations f_{p_1}(f_{p_2}(\u2026 f_{p_K}(1) \u2026 )) for a sequence p = (p_1, p_2, \u2026, p_K) of K distinct integers between 1 and N. Given the constraints, a brute-force approach is not feasible due to the large number of possible sequences. Instead, we can use a greedy approach to select the functions that maximize the value at each step. Specifically, we should always choose the function with the highest coefficient A_i, as it will have the largest impact on the value of the nested function. If there are multiple functions with the same coefficient, we should choose the one with the highest constant term B_i, as it will also contribute to maximizing the value. We can implement this approach using a priority queue to always select the function with the highest A_i (and B_i if there are ties). We will repeat this process K times to find the maximum value.", "question_id": "abc366_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Read input strings\n    GArray *strings = g_array_new(FALSE, FALSE, sizeof(char*));\n    for (int i = 0; i < n; i++) {\n        char *str = malloc(101 * sizeof(char));\n        scanf(\"%s\", str);\n        g_array_append_val(strings, str);\n    }\n\n    // Find the maximum length of the strings\n    int max_len = 0;\n    for (int i = 0; i < n; i++) {\n        char *str = g_array_index(strings, char*, i);\n        if (strlen(str) > max_len) {\n            max_len = strlen(str);\n        }\n    }\n\n    // Construct the vertical strings\n    for (int j = 0; j < max_len; j++) {\n        char *result = malloc((n + 1) * sizeof(char));\n        result[n] = '\\0';\n\n        for (int i = 0; i < n; i++) {\n            char *str = g_array_index(strings, char*, i);\n            if (j < strlen(str)) {\n                result[i] = str[j];\n            } else {\n                result[i] = '*';\n            }\n        }\n\n        // Ensure the result does not end with '*'\n        if (result[n - 1] == '*') {\n            result[n - 1] = '\\0';\n        }\n\n        printf(\"%s\\n\", result);\n        free(result);\n    }\n\n    // Free allocated memory\n    for (int i = 0; i < n; i++) {\n        free(g_array_index(strings, char*, i));\n    }\n    g_array_free(strings, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to convert a given set of horizontally written strings into vertically written strings, filling spaces with '*'. The key steps are as follows:\n1. Determine the maximum length of the input strings (M).\n2. Iterate through each character position from 0 to M-1.\n3. For each position, construct a string T_i by appending the character at the current position from each input string if it exists, or '*' otherwise.\n4. Ensure that each T_i does not end with '*'.\n5. Print the resulting strings T_1, T_2, ..., T_M.", "question_id": "abc366_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n#define MAXD 1000000\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint compare(const void *a, const void *b) {\n    return ((Point*)a)->x - ((Point*)b)->x;\n}\n\nint main() {\n    int n, d;\n    scanf(\"%d %d\", &n, &d);\n\n    Point points[MAXN];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    qsort(points, n, sizeof(Point), compare);\n\n    int result = 0;\n    GHashTable *y_counts = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        int x = points[i].x;\n        int y = points[i].y;\n\n        // Remove points that are out of the range\n        GList *node = g_hash_table_lookup(y_counts, GINT_TO_POINTER(x - d));\n        if (node) {\n            int count = GPOINTER_TO_INT(node->data);\n            if (count == 1) {\n                g_hash_table_remove(y_counts, GINT_TO_POINTER(x - d));\n            } else {\n                g_hash_table_replace(y_counts, GINT_TO_POINTER(x - d), GINT_TO_POINTER(count - 1));\n            }\n        }\n\n        // Add current point\n        node = g_hash_table_lookup(y_counts, GINT_TO_POINTER(x + d));\n        if (node) {\n            int count = GPOINTER_TO_INT(node->data);\n            g_hash_table_replace(y_counts, GINT_TO_POINTER(x + d), GINT_TO_POINTER(count + 1));\n        } else {\n            g_hash_table_insert(y_counts, GINT_TO_POINTER(x + d), GINT_TO_POINTER(1));\n        }\n\n        // Count valid points within the range\n        result += g_hash_table_size(y_counts);\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(y_counts);\n\n    return 0;\n}", "reasoning": "The problem requires counting the number of integer points (x, y) within a Manhattan distance D from a set of N given points. The Manhattan distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|. A direct approach would involve checking all possible integer points within the bounding box defined by the given points, but this would be inefficient for large N and D. Instead, we can use a sweep line algorithm to count the valid points efficiently. We will sort the points by their x-coordinates and use a sliding window to count the points within the Manhattan distance D for each x-coordinate. We will also maintain a hash table to keep track of the points' y-coordinates and their corresponding counts.", "question_id": "abc366_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create a 3D array using GArray for dynamic sizing\n    GArray *array = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n * n * n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(array, value);\n    }\n\n    // Create a prefix sum 3D array\n    GArray *prefix_sum = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n * n * n; i++) {\n        int value = g_array_index(array, int, i);\n        if (i > 0) {\n            value += g_array_index(prefix_sum, int, i - 1);\n        }\n        g_array_append_val(prefix_sum, value);\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n\n    for (int i = 0; i < q; i++) {\n        int lx, rx, ly, ry, lz, rz;\n        scanf(\"%d %d %d %d %d %d\", &lx, &rx, &ly, &ry, &lz, &rz);\n\n        int result = 0;\n        int index = (lx - 1) * n * n + (ly - 1) * n + lz - 1;\n        int end_index = (rx - 1) * n * n + (ry - 1) * n + rz - 1;\n\n        if (index >= 0 && end_index < n * n * n) {\n            result = g_array_index(prefix_sum, int, end_index);\n            if (index > 0) {\n                result -= g_array_index(prefix_sum, int, index - 1);\n            }\n        }\n\n        printf(\"%d\\n\", result);\n    }\n\n    // Clean up\n    g_array_free(array, TRUE);\n    g_array_free(prefix_sum, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem efficiently, we need to handle large numbers of queries on a 3D array. A direct approach of calculating the sum for each query would be too slow due to the constraints. Instead, we can preprocess the 3D array to create a prefix sum array, which allows us to answer each query in constant time.", "question_id": "abc366_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, T, A;\n    scanf(\"%d %d %d\", &N, &T, &A);\n\n    // Calculate the difference in votes\n    int diff = abs(T - A);\n\n    // Check if the difference is more than half of the total votes\n    if (diff > N / 2) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine if the outcome of the election is already decided, we need to check if the current lead of one candidate is so large that it cannot be overcome even if the remaining votes are all given to the other candidate. Given that N is odd, the remaining votes will also be odd, and we can use this to our advantage. If the difference between the votes of the leading candidate and the votes of the trailing candidate is more than half of the total votes (N/2), then the outcome is decided.", "question_id": "abc366_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int Q;\n    scanf(\"%d\", &Q);\n\n    GHashTable *bag = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < Q; i++) {\n        int query_type, x;\n        scanf(\"%d\", &query_type);\n\n        if (query_type == 1) {\n            scanf(\"%d\", &x);\n            g_hash_table_insert(bag, GINT_TO_POINTER(x), GINT_TO_POINTER(1));\n        } else if (query_type == 2) {\n            scanf(\"%d\", &x);\n            g_hash_table_remove(bag, GINT_TO_POINTER(x));\n        } else if (query_type == 3) {\n            printf(\"%zu\n\", g_hash_table_size(bag));\n        }\n    }\n\n    g_hash_table_destroy(bag);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently manage a collection of unique integers. The operations required are adding an integer to the collection, removing an integer from the collection, and determining the number of unique integers in the collection. Using a hash table (GHashTable in GLib) is ideal for this purpose because it provides fast insertions, deletions, and lookups. The hash table will store the integers as keys, and we can use the presence of keys to determine the number of unique integers. For the removal operation, we simply remove the key from the hash table.", "question_id": "abc366_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 60\n#define MAXM (MAXN * (MAXN - 1) / 2)\n\nGArray *adj[MAXN];\nint color[MAXN];  // 0: uncolored, 1: color 1, -1: color -1\n\nbool is_bipartite(int v, int c) {\n    color[v] = c;\n    for (int i = 0; i < adj[v]->len; i++) {\n        int u = g_array_index(adj[v], int, i);\n        if (color[u] == c) return false;\n        if (color[u] == 0 && !is_bipartite(u, -c)) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n        color[i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        g_array_append_val(adj[u], v);\n        g_array_append_val(adj[v], u);\n    }\n\n    if (!is_bipartite(0, 1)) {\n        printf(\"No\n\");\n        for (int i = 0; i < n; i++) {\n            g_array_free(adj[i], TRUE);\n        }\n        return 0;\n    }\n\n    printf(\"Yes\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", color[i] == 1 ? 1 : 2);\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < n; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can assign integers to each vertex of the graph such that the XOR of the integers on the adjacent vertices of each vertex is zero. This problem can be approached using the concept of bipartite graphs and properties of XOR. Here's the step-by-step reasoning:\n\n1. **Graph Representation**: We represent the graph using an adjacency list to facilitate easy traversal and access to adjacent vertices.\n2. **Bipartite Graph Check**: We check if the graph is bipartite. A bipartite graph is a graph whose vertices can be divided into two disjoint sets such that no two vertices within the same set are adjacent. If the graph is not bipartite, it's impossible to satisfy the condition, and we return 'No'.\n3. **XOR Assignment**: If the graph is bipartite, we can assign values to the vertices in two sets such that the XOR condition is satisfied. We can assign the same value to all vertices in one set and a different value to all vertices in the other set.\n4. **Output**: We print 'Yes' followed by the assigned values for each vertex.", "question_id": "abc366_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int *x = (int *)malloc(n * sizeof(int));\n    int *a = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &x[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // Find the cycle lengths\n    int *cycle = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        cycle[i] = 1;\n        int next = x[i] - 1;\n        while (next != i) {\n            cycle[i]++;\n            next = x[next] - 1;\n        }\n    }\n\n    // Determine the effective number of operations\n    for (int i = 0; i < n; i++) {\n        k %= cycle[i];\n    }\n\n    // Apply the operations\n    for (int i = 0; i < n; i++) {\n        int start = i;\n        int len = cycle[i];\n        int temp[len];\n\n        for (int j = 0; j < len; j++) {\n            temp[j] = a[start];\n            start = x[start] - 1;\n        }\n\n        start = i;\n        for (int j = 0; j < len; j++) {\n            a[start] = temp[(j + k) % len];\n            start = x[start] - 1;\n        }\n    }\n\n    // Output the result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Free memory\n    free(x);\n    free(a);\n    free(cycle);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to understand the operation and its effect on the sequence A. The operation involves replacing A with B where B_i = A_{X_i}. This means that each element in A is replaced by the element at the index specified by the corresponding element in X. The operation is repeated K times. Given the constraints, a direct approach would be inefficient, so we need to find a pattern or a more efficient way to handle the operations. By analyzing the problem, we can see that the operation is cyclical and can be reduced to a few key steps. Specifically, we can find the cycle lengths and determine the effective number of operations needed. This allows us to efficiently compute the result without performing the operation K times directly.", "question_id": "abc367_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    for (int q_id = 0; q_id < q; q_id++) {\n        int l, r, L, R;\n        scanf(\"%d %d %d %d\", &l, &r, &L, &R);\n\n        // Create frequency maps for the subsequences\n        GHashTable *freq_a = g_hash_table_new(g_direct_hash, g_direct_equal);\n        GHashTable *freq_b = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n        for (int i = l - 1; i < r; i++) {\n            int key = a[i];\n            int *count = (int *)g_hash_table_lookup(freq_a, GINT_TO_POINTER(key));\n            if (count == NULL) {\n                count = (int *)malloc(sizeof(int));\n                *count = 0;\n                g_hash_table_insert(freq_a, GINT_TO_POINTER(key), count);\n            }\n            (*count)++;\n        }\n\n        for (int i = L - 1; i < R; i++) {\n            int key = b[i];\n            int *count = (int *)g_hash_table_lookup(freq_b, GINT_TO_POINTER(key));\n            if (count == NULL) {\n                count = (int *)malloc(sizeof(int));\n                *count = 0;\n                g_hash_table_insert(freq_b, GINT_TO_POINTER(key), count);\n            }\n            (*count)++;\n        }\n\n        // Compare the frequency maps\n        bool possible = true;\n        GList *keys = g_hash_table_get_keys(freq_a);\n        for (GList *node = keys; node != NULL; node = node->next) {\n            int key = GPOINTER_TO_INT(node->data);\n            int *count_a = (int *)g_hash_table_lookup(freq_a, GINT_TO_POINTER(key));\n            int *count_b = (int *)g_hash_table_lookup(freq_b, GINT_TO_POINTER(key));\n            if (count_b == NULL || *count_a != *count_b) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (possible) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n\n        // Clean up\n        g_hash_table_destroy(freq_a);\n        g_hash_table_destroy(freq_b);\n        g_list_free(keys);\n    }\n\n    free(a);\n    free(b);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can rearrange a subsequence of A to match a subsequence of B for each query. The key insight is that for two subsequences to be rearrangements of each other, they must have the same frequency of each element. Here's how we can approach the problem step-by-step:", "question_id": "abc367_f"}
{"solution": "#include <stdio.h>\n\nint main() {\n    int A, B, C;\n    scanf(\"%d %d %d\", &A, &B, &C);\n\n    if ((C > B && B > A) || (A > C && C > B)) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine whether Takahashi can shout his love for takoyaki every day, we need to check if there is any overlap between his sleeping and waking times. If there is no overlap, then he can shout his love for takoyaki every day. We can solve this problem by checking if the waking time (C) is greater than the sleeping time (B) and if the sleeping time (B) is greater than the waking time (A). If both conditions are true, then there is no overlap, and Takahashi can shout his love for takoyaki every day.", "question_id": "abc367_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    GArray *a = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        g_array_append_val(a, x);\n    }\n\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(long long));\n    g_array_append_val(dp, 0);\n\n    for (int i = 0; i < n; i++) {\n        GArray *new_dp = g_array_new(FALSE, FALSE, sizeof(long long));\n        g_array_append_val(new_dp, 0);\n\n        for (int j = 0; j < dp->len; j++) {\n            long long prev = g_array_index(dp, long long, j);\n            long long current = prev ^ g_array_index(a, int, i);\n\n            g_array_append_val(new_dp, (prev + current) % MOD);\n        }\n\n        for (int j = 0; j < new_dp->len; j++) {\n            long long value = g_array_index(new_dp, long long, j);\n            if ((j + 1) % m == 0) {\n                value = (value * value) % MOD;\n            }\n            g_array_append_val(dp, value);\n        }\n\n        g_array_free(new_dp, TRUE);\n    }\n\n    long long result = 0;\n    for (int i = 0; i < dp->len; i++) {\n        result = (result + g_array_index(dp, long long, i)) % MOD;\n    }\n\n    printf(\"%lld\\n\", result);\n\n    g_array_free(dp, TRUE);\n    g_array_free(a, TRUE);\n\n    return 0;\n}", "reasoning": "The problem requires calculating the sum of scores of all non-empty subsequences of a given sequence A, where the score of a subsequence is defined based on its length and the bitwise XOR of its elements. The solution involves dynamic programming and properties of bitwise XOR to efficiently compute the result modulo 998244353.", "question_id": "abc367_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    // Read input\n    char input[100];\n    scanf(\"%s\", input);\n\n    // Convert input to a double\n    double X = atof(input);\n\n    // Check if the number is an integer\n    if (X == (int)X) {\n        printf(\"%d\n\", (int)X);\n    } else {\n        // Convert the number to a string\n        char formatted[100];\n        sprintf(formatted, \"%.3f\", X);\n\n        // Remove trailing zeros and the unnecessary decimal point\n        char *end = formatted + strlen(formatted) - 1;\n        while (*end == '0' || *end == '.') {\n            *end = '\\0';\n            end--;\n        }\n\n        // Print the formatted number\n        printf(\"%s\n\", formatted);\n    }\n\n    return 0;\n}", "reasoning": "The problem requires processing a real number given to the third decimal place and printing it in a specific format. The key conditions are to remove trailing zeros from the decimal part and remove the unnecessary trailing decimal point if the number is an integer. To achieve this, we can use string manipulation techniques to process the input and format the output accordingly.", "question_id": "abc367_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    g_hash_table_insert(map, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n\n    long long sum = 0;\n    long long count = 0;\n\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        sum += a;\n        int remainder = sum % m;\n\n        gpointer value = g_hash_table_lookup(map, GINT_TO_POINTER(remainder));\n        if (value != NULL) {\n            count += GPOINTER_TO_INT(value);\n        }\n\n        g_hash_table_insert(map, GINT_TO_POINTER(remainder), GINT_TO_POINTER(GPOINTER_TO_INT(value) + 1));\n    }\n\n    printf(\"%lld\n\", count);\n\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find pairs (s, t) such that the minimum number of steps required to walk clockwise from rest area s to rest area t is a multiple of M. The key observation is that if the cumulative steps modulo M at two rest areas are the same, then the number of steps between them is a multiple of M. Therefore, we can use a hash table to store the cumulative steps modulo M and count the pairs based on these values.", "question_id": "abc367_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 8\n#define MAX_R 5\n#define MAX_K 10\n\ntypedef struct {\n    int *sequence;\n    int length;\n} Sequence;\n\nGHashTable *printed_sequences;\n\nvoid dfs(int n, int k, int *r, int *current_sequence, int current_sum, int index) {\n    if (index == n) {\n        if (current_sum % k == 0) {\n            int *new_sequence = (int *)g_malloc(n * sizeof(int));\n            memcpy(new_sequence, current_sequence, n * sizeof(int));\n            g_hash_table_insert(printed_sequences, new_sequence, NULL);\n        }\n        return;\n    }\n\n    for (int i = 1; i <= r[index]; i++) {\n        current_sequence[index] = i;\n        dfs(n, k, r, current_sequence, current_sum + i, index + 1);\n    }\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int r[MAX_N];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &r[i]);\n    }\n\n    printed_sequences = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int *current_sequence = (int *)g_malloc(n * sizeof(int));\n    dfs(n, k, r, current_sequence, 0, 0);\n\n    GList *keys = g_hash_table_get_keys(printed_sequences);\n    int count = g_list_length(keys);\n\n    printf(\"%d\\n\", count);\n\n    GList *node = keys;\n    while (node != NULL) {\n        int *sequence = (int *)node->data;\n        for (int i = 0; i < n; i++) {\n            printf(\"%d \", sequence[i]);\n        }\n        printf(\"\\n\");\n        node = node->next;\n    }\n\n    g_list_free(keys);\n    g_hash_table_destroy(printed_sequences);\n    g_free(current_sequence);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate all possible sequences of length N where each element is between 1 and R_i, inclusive, and the sum of all elements is a multiple of K. We will use a depth-first search (DFS) approach to explore all possible sequences and check the conditions at each step. We will also use a hash table to keep track of sequences that have already been printed to avoid duplicates. The sequences will be printed in ascending lexicographical order, which is naturally handled by the DFS approach.", "question_id": "abc367_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 100000\n\nGArray *A, *B;\nGArray *prefix_max, *suffix_max;\n\nvoid preprocess(int n) {\n    prefix_max = g_array_new(FALSE, FALSE, sizeof(long long));\n    suffix_max = g_array_new(FALSE, FALSE, sizeof(long long));\n\n    long long v = 0;\n    for (int i = 0; i < n; i++) {\n        v = v + A->data[i] * B->data[i];\n        g_array_append_val(prefix_max, v);\n    }\n\n    v = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        v = v + A->data[i] * B->data[i];\n        g_array_append_val(suffix_max, v);\n    }\n}\n\nlong long query(int l, int r) {\n    long long result = 0;\n    if (l == 0) {\n        result = prefix_max->data[r];\n    } else if (r == A->len - 1) {\n        result = suffix_max->data[A->len - 1 - l];\n    } else {\n        result = prefix_max->data[r] - prefix_max->data[l - 1];\n    }\n    return result;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d\", &n);\n\n    A = g_array_new(FALSE, FALSE, sizeof(int));\n    B = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        g_array_append_val(A, x);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        g_array_append_val(B, x);\n    }\n\n    scanf(\"%d\", &q);\n\n    preprocess(n);\n\n    for (int i = 0; i < q; i++) {\n        int type, l, r;\n        scanf(\"%d %d %d\", &type, &l, &r);\n        l--;\n        r--;\n\n        if (type == 1) {\n            g_array_index(A, int, l) = r;\n        } else if (type == 2) {\n            g_array_index(B, int, l) = r;\n        } else if (type == 3) {\n            long long result = query(l, r);\n            printf(\"%lld\\n\", result);\n        }\n    }\n\n    g_array_free(A, TRUE);\n    g_array_free(B, TRUE);\n    g_array_free(prefix_max, TRUE);\n    g_array_free(suffix_max, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently handle three types of queries on two sequences, A and B. The key challenge is to process type 3 queries quickly, which involves computing the maximum possible value of v for a given range [l, r] by either adding or multiplying A[i] or B[i] to/from v. Given the constraints, a direct approach would be too slow, so we need to use a more efficient data structure and algorithm. We can use a segment tree to achieve this, but since GLib provides convenient data structures, we will use GArray and GQueue to implement a more straightforward solution. The idea is to preprocess the sequences to store the maximum possible values for each prefix and suffix, and then use these preprocessed values to answer type 3 queries efficiently.", "question_id": "abc368_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    GQueue *queue = g_queue_new();\n\n    // Read the initial stack of cards and add them to the queue\n    for (int i = 0; i < n; i++) {\n        int card;\n        scanf(\"%d\", &card);\n        g_queue_push_tail(queue, GINT_TO_POINTER(card));\n    }\n\n    // Move the bottom K cards to the top\n    for (int i = 0; i < k; i++) {\n        int card = GPOINTER_TO_INT(g_queue_pop_tail(queue));\n        g_queue_push_head(queue, GINT_TO_POINTER(card));\n    }\n\n    // Print the cards in the new order\n    for (int i = 0; i < n; i++) {\n        int card = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        printf(\"%d \", card);\n        g_queue_push_tail(queue, GINT_TO_POINTER(card));  // Reinsert the card to maintain the queue\n    }\n\n    printf(\"\\n\");\n\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "The problem requires us to simulate the operation of moving K cards from the bottom of a stack to the top. This can be achieved by using a queue to manage the stack operations efficiently. Here's a step-by-step breakdown of the solution:", "question_id": "abc368_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    int operations = 0;\n\n    while (g_array_index(arr, int, 0) > 0 && g_array_index(arr, int, 1) > 0) {\n        // Sort in descending order\n        g_array_sort(arr, (GCompareFunc)g_int_compare);\n\n        // Decrease the first two elements by 1\n        int first = g_array_index(arr, int, 0);\n        int second = g_array_index(arr, int, 1);\n        g_array_index(arr, int, 0) = first - 1;\n        g_array_index(arr, int, 1) = second - 1;\n\n        operations++;\n    }\n\n    printf(\"%d\n\", operations);\n\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the operations described. The key steps are:\n1. Sort the array in descending order.\n2. Decrease both the first and second elements by 1.\n3. Repeat the process until the array contains one or fewer positive elements.\n4. Count the number of operations performed.\n\nWe will use a loop to perform the operations and a GArray to manage the array dynamically.", "question_id": "abc368_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n\n        int odd_divisors = 0;\n        for (int j = 2; j <= a; j++) {\n            if (a % j == 0 && (j & 1) == 1) {\n                odd_divisors++;\n            }\n        }\n\n        if (odd_divisors % 2 == 1) {\n            g_hash_table_insert(count, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n        } else {\n            g_hash_table_insert(count, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n        }\n    }\n\n    int total_odd = 0;\n    for (gpointer key, value; g_hash_table_iter_init(&iter, count); g_hash_table_iter_next(&iter, &key, &value)) {\n        total_odd += GPOINTER_TO_INT(value);\n    }\n\n    if (total_odd % 2 == 1) {\n        printf(\"Anna\n\");\n    } else {\n        printf(\"Bruno\n\");\n    }\n\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "To determine the winner of the game, we need to analyze the game mechanics and the properties of the numbers involved. The key insight is that the game can be reduced to a problem of determining the number of odd divisors of each number. If a number has an odd number of odd divisors, it can be reduced to 1 in one move. If it has an even number of odd divisors, it cannot be reduced to 1 in one move. The game is essentially a Nim game where the players are trying to reduce the numbers to 1. The player who faces a position with an odd number of numbers that can be reduced in one move will lose if both play optimally.", "question_id": "abc368_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize variables\n    GArray *enemies = g_array_new(FALSE, FALSE, sizeof(int));\n    int T = 0;\n\n    // Read enemy healths\n    for (int i = 0; i < n; i++) {\n        int health;\n        scanf(\"%d\", &health);\n        g_array_append_val(enemies, health);\n    }\n\n    // Process until all enemies have health 0 or less\n    while (g_array_length(enemies) > 0) {\n        // Attack the frontmost enemy\n        int *frontmost = &g_array_index(enemies, int, 0);\n        if (*frontmost > 0) {\n            if (T % 3 == 0) {\n                *frontmost -= 3;\n            } else {\n                *frontmost -= 1;\n            }\n            T++;\n        }\n\n        // If the frontmost enemy's health is 0 or less, remove it\n        if (*frontmost <= 0) {\n            g_array_remove_range(enemies, 0, 1);\n        }\n    }\n\n    // Output the number of actions performed\n    printf(\"%d\\n\", T);\n\n    // Clean up\n    g_array_free(enemies, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of attacking the enemies until their healths become 0 or less. We will use a variable T to keep track of the number of actions performed. The key observation is that if T is a multiple of 3, the enemy's health decreases by 3; otherwise, it decreases by 1. We will iterate through the enemies, decreasing their health based on the current value of T, and increment T accordingly. We need to handle large numbers and avoid integer overflow, so we will use the modulo operation to simulate the health decrease correctly.", "question_id": "abc368_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\nGArray *adj[MAXN];\nGHashTable *parent;\nGHashTable *depth;\n\nvoid add_edge(int u, int v) {\n    g_array_append_val(adj[u], v);\n    g_array_append_val(adj[v], u);\n}\n\nvoid dfs(int u, int p, int d) {\n    parent = g_hash_table_new(g_direct_hash, g_direct_equal);\n    g_hash_table_insert(parent, GINT_TO_POINTER(u), GINT_TO_POINTER(p));\n    depth = g_hash_table_new(g_direct_hash, g_direct_equal);\n    g_hash_table_insert(depth, GINT_TO_POINTER(u), GINT_TO_POINTER(d));\n\n    for (int i = 0; i < g_array_get_length(adj[u]); i++) {\n        int v = g_array_index(adj[u], int, i);\n        if (v != p) {\n            dfs(v, u, d + 1);\n        }\n    }\n\n    g_hash_table_destroy(parent);\n    g_hash_table_destroy(depth);\n}\n\nint lca(int u, int v) {\n    int d1 = g_hash_table_lookup(depth, GINT_TO_POINTER(u));\n    int d2 = g_hash_table_lookup(depth, GINT_TO_POINTER(v));\n\n    if (d1 > d2) {\n        u = g_hash_table_lookup(parent, GINT_TO_POINTER(u));\n    } else if (d1 < d2) {\n        v = g_hash_table_lookup(parent, GINT_TO_POINTER(v));\n    }\n\n    while (u != v) {\n        u = g_hash_table_lookup(parent, GINT_TO_POINTER(u));\n        v = g_hash_table_lookup(parent, GINT_TO_POINTER(v));\n    }\n\n    return u;\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    for (int i = 0; i < n; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a - 1, b - 1);\n    }\n\n    int *vertices = (int *)malloc(k * sizeof(int));\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d\", &vertices[i]);\n        vertices[i]--;\n    }\n\n    int lca_result = vertices[0];\n    for (int i = 1; i < k; i++) {\n        lca_result = lca(lca_result, vertices[i]);\n    }\n\n    int count = 0;\n    dfs(lca_result, -1, 0);\n    for (int i = 0; i < k; i++) {\n        count += g_hash_table_lookup(depth, GINT_TO_POINTER(vertices[i])) + 1;\n    }\n\n    printf(\"%d\\n\", count);\n\n    for (int i = 0; i < n; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    free(vertices);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum number of vertices in a subtree that includes all given K vertices. The key insight is that the minimum number of vertices in such a subtree is equal to the number of vertices in the smallest connected component that includes all K vertices. Here's a step-by-step approach to solve the problem:\n\n1. **Build the Tree**: Use an adjacency list to represent the tree. Since the input guarantees that the graph is a tree, we can use an array of GArrays to store the adjacency list for each vertex.\n\n2. **Find the Lowest Common Ancestor (LCA)**: For each pair of vertices among the K given vertices, find their LCA. The LCA is the deepest node that is an ancestor of all the vertices in the pair. This can be done using a depth-first search (DFS) approach.\n\n3. **Calculate the Minimum Number of Vertices**: The minimum number of vertices in the subtree that includes all K vertices is the number of vertices in the smallest connected component that includes all K vertices. This can be found by counting the number of vertices in the subtree rooted at the LCA of all K vertices.\n\n4. **Output the Result**: Print the result, which is the number of vertices in the smallest connected component that includes all K vertices.", "question_id": "abc368_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Define a structure to hold train details\ntypedef struct {\n    int A, B, S, T;\n} Train;\n\n// Comparison function for qsort to sort trains by arrival time\nint compare(const void *a, const void *b) {\n    Train *t1 = (Train *)a;\n    Train *t2 = (Train *)b;\n    return t1->T - t2->T;\n}\n\nint main() {\n    int N, M, X1;\n    scanf(\"%d %d %d\", &N, &M, &X1);\n\n    Train *trains = (Train *)malloc(M * sizeof(Train));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d %d\", &trains[i].A, &trains[i].B, &trains[i].S, &trains[i].T);\n    }\n\n    // Sort trains by their arrival time\n    qsort(trains, M, sizeof(Train), compare);\n\n    // Initialize the delays array with X1\n    int *delays = (int *)malloc(M * sizeof(int));\n    memset(delays, X1, M * sizeof(int));\n\n    // Calculate the minimum delays required for each train\n    for (int i = 1; i < M; i++) {\n        for (int j = 0; j < i; j++) {\n            if (trains[j].B == trains[i].A && trains[i].S <= trains[j].T) {\n                delays[i] = delays[j] + (trains[j].T - trains[i].S + 1);\n            }\n        }\n    }\n\n    // Print the delays for trains 2 to M\n    for (int i = 1; i < M; i++) {\n        printf(\"%d \", delays[i]);\n    }\n    printf(\"\\n\");\n\n    // Free allocated memory\n    free(trains);\n    free(delays);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find a way to delay the departure and arrival times of trains such that the condition for transferring between trains is still satisfied. The condition states that if a train i can transfer to train j, then after delaying both trains, the arrival time of train i should not exceed the departure time of train j. We need to minimize the total delay (X_2 + ... + X_M) while satisfying this condition for all pairs of trains that can transfer between each other. We can achieve this by sorting the trains based on their arrival and departure times and then iterating through them to calculate the minimum delays required for each train.", "question_id": "abc368_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    qsort(A, n, sizeof(int), compare);\n\n    long long max_points = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            max_points += A[i];\n        } else {\n            max_points += 2 * A[i];\n        }\n    }\n\n    printf(\"%lld\\n\", max_points);\n\n    free(A);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maximize the total experience points Takahashi can gain by either defeating or letting go of each monster. The key insight is that defeating monsters with higher strengths should be prioritized, especially if they are even-numbered. We can achieve this by sorting the monsters by their strength in descending order and then iterating through them to decide whether to defeat or let go based on the position of the monster in the sorted list.", "question_id": "abc369_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    return ((Edge *)a)->w - ((Edge *)b)->w;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Edge edges[n - 1];\n    for (int i = 0; i < n - 1; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n        edges[i].u--;\n        edges[i].v--;\n    }\n\n    qsort(edges, n - 1, sizeof(Edge), compare);\n\n    GHashTable *graph[n];\n    for (int i = 0; i < n; i++) {\n        graph[i] = g_hash_table_new(g_direct_hash, g_direct_equal);\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        g_hash_table_insert(graph[edges[i].u], GINT_TO_POINTER(edges[i].v), GINT_TO_POINTER(edges[i].w));\n        g_hash_table_insert(graph[edges[i].v], GINT_TO_POINTER(edges[i].u), GINT_TO_POINTER(edges[i].w));\n    }\n\n    for (int k = 1; k <= n; k++) {\n        long long total = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int dist = 0;\n                GQueue *queue = g_queue_new();\n                GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n                g_queue_push_tail(queue, GINT_TO_POINTER(i));\n                g_hash_table_insert(visited, GINT_TO_POINTER(i), NULL);\n\n                while (!g_queue_is_empty(queue)) {\n                    int curr = GPOINTER_TO_INT(g_queue_pop_head(queue));\n                    if (curr == j) {\n                        break;\n                    }\n                    GHashTable *adj = graph[curr];\n                    GHashTableIter iter;\n                    gpointer key, value;\n                    g_hash_table_iter_init(&iter, adj);\n                    while (g_hash_table_iter_next(&iter, &key, &value)) {\n                        int neighbor = GPOINTER_TO_INT(key);\n                        int weight = GPOINTER_TO_INT(value);\n                        if (!g_hash_table_contains(visited, GINT_TO_POINTER(neighbor))) {\n                            dist += weight;\n                            g_queue_push_tail(queue, GINT_TO_POINTER(neighbor));\n                            g_hash_table_insert(visited, GINT_TO_POINTER(neighbor), NULL);\n                        }\n                    }\n                }\n\n                g_queue_free(queue);\n                g_hash_table_destroy(visited);\n\n                total += dist;\n            }\n        }\n\n        printf(\"%lld\n\", total);\n    }\n\n    for (int i = 0; i < n; i++) {\n        g_hash_table_destroy(graph[i]);\n    }\n\n    return 0;\n}", "reasoning": "The problem involves finding the optimal walk for Takahashi and Aoki on a tree structure. The key insight is that for any given K, the optimal strategy for Takahashi is to connect the specified vertices in a way that minimizes the total distance traveled. Aoki, on the other hand, aims to maximize this distance. For K=1, the problem is straightforward as Aoki can specify any vertex, and Takahashi can construct a path that goes through that vertex twice. For K=2, Aoki can specify any two vertices, and Takahashi can construct a path that goes through both vertices twice. For K>=3, the optimal strategy is to connect the specified vertices in a way that forms a cycle, as this will minimize the total distance traveled. The solution involves calculating the sum of the distances between all pairs of vertices and using this to determine the optimal score for each K.", "question_id": "abc369_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Initialize variables\n    long long count = 0;\n\n    // Iterate over all possible subarrays\n    for (int i = 0; i < n; i++) {\n        // Use a hash map to store the differences and their counts\n        GHashTable *diff_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (int j = i + 1; j < n; j++) {\n            int diff = A[j] - A[j - 1];\n            gpointer value = g_hash_table_lookup(diff_count, GINT_TO_POINTER(diff));\n            if (value != NULL) {\n                count += GPOINTER_TO_INT(value);\n            }\n            g_hash_table_insert(diff_count, GINT_TO_POINTER(diff), GINT_TO_POINTER(GPOINTER_TO_INT(value) + 1));\n        }\n        g_hash_table_destroy(diff_count);\n    }\n\n    // Output result\n    printf(\"%lld\n\", count);\n\n    // Free memory\n    free(A);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the number of subarrays that form an arithmetic progression. An arithmetic progression is a sequence of numbers such that the difference between consecutive numbers is constant. Here's a step-by-step approach to solve the problem using a hash map and two-pointer technique:", "question_id": "abc369_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n\n    int count = 0;\n\n    // Check for x = (2*A + B) / 2\n    if ((2*A + B) % 2 == 0) {\n        int x = (2*A + B) / 2;\n        if (x >= 1 && x <= 100) {\n            count++;\n        }\n    }\n\n    // Check for x = (A + 2*B) / 2\n    if ((A + 2*B) % 2 == 0) {\n        int x = (A + 2*B) / 2;\n        if (x >= 1 && x <= 100) {\n            count++;\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine how many integers x can be arranged with A and B to form an arithmetic sequence. An arithmetic sequence requires that the difference between consecutive terms is constant. Therefore, for three numbers p, q, and r to form an arithmetic sequence, the condition q-p = r-q must hold. We can rearrange this to find x: x = (2*A + B) / 2 or x = (A + 2*B) / 2. We need to check if these values of x are integers and within the given range. If they are, they satisfy the condition.", "question_id": "abc369_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *positions = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int left_hand = 0, right_hand = 0;\n    int fatigue = 0;\n\n    for (int i = 0; i < n; i++) {\n        int key;\n        char hand;\n        scanf(\"%d %c\", &key, &hand);\n\n        if (hand == 'L') {\n            if (left_hand != 0) {\n                fatigue += abs(key - left_hand);\n            }\n            left_hand = key;\n        } else {\n            if (right_hand != 0) {\n                fatigue += abs(key - right_hand);\n            }\n            right_hand = key;\n        }\n    }\n\n    printf(\"%d\n\", fatigue);\n\n    g_hash_table_destroy(positions);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to keep track of the positions of both hands and calculate the minimum fatigue level based on the movements required to press the keys with the appropriate hand. Here's a step-by-step approach to achieve this:", "question_id": "abc369_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 400\n#define MAX_M 200000\n#define MAX_Q 3000\n#define MAX_K 5\n\ntypedef struct {\n    int u, v, t;\n} Bridge;\n\ntypedef struct {\n    int island, time;\n} State;\n\nint compare(const void *a, const void *b) {\n    return ((State *)a)->time - ((State *)b)->time;\n}\n\nint min_time_to_travel(int n, int m, Bridge *bridges, int q, int *k, int **queries) {\n    // Build the graph using adjacency list\n    GArray *adj[MAX_N] = {NULL};\n    for (int i = 1; i <= n; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n    for (int i = 0; i < m; i++) {\n        g_array_append_val(adj[bridges[i].u], bridges[i].v);\n        g_array_append_val(adj[bridges[i].v], bridges[i].u);\n    }\n\n    // Initialize DP table\n    int dp[n + 1][1 << m];\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j < 1 << m; j++) {\n            dp[i][j] = INT_MAX;\n        }\n    }\n    dp[1][0] = 0;\n\n    // Perform Dijkstra's algorithm with memoization\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER((State){1, 0}));\n\n    while (!g_queue_is_empty(queue)) {\n        State current = *(State *)g_queue_pop_head(queue);\n\n        for (int i = 0; i < adj[current.island].len; i++) {\n            int next_island = g_array_index(adj[current.island], int, i);\n\n            for (int j = 0; j < m; j++) {\n                if (bridges[j].u == current.island && bridges[j].v == next_island ||\n                    bridges[j].u == next_island && bridges[j].v == current.island) {\n                    int next_state = (1 << j) | current.time;\n\n                    if (dp[next_island][next_state] > dp[current.island][current.time] + bridges[j].t) {\n                        dp[next_island][next_state] = dp[current.island][current.time] + bridges[j].t;\n                        g_queue_push_tail(queue, GINT_TO_POINTER((State){next_island, dp[next_island][next_state]}));\n                    }\n                }\n            }\n        }\n    }\n\n    // Find the minimum time for each query\n    int result[q];\n    for (int i = 0; i < q; i++) {\n        int min_time = INT_MAX;\n\n        for (int j = 0; j < k[i]; j++) {\n            int bridge_index = queries[i][j] - 1;\n\n            for (int state = 0; state < 1 << m; state++) {\n                if (state & (1 << bridge_index)) {\n                    min_time = fmin(min_time, dp[n][state]);\n                }\n            }\n        }\n\n        result[i] = min_time;\n    }\n\n    // Free memory\n    for (int i = 1; i <= n; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n    g_queue_free(queue);\n\n    return result;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    Bridge bridges[m];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &bridges[i].u, &bridges[i].v, &bridges[i].t);\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n\n    int k[q];\n    int queries[q][MAX_K];\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d\", &k[i]);\n        for (int j = 0; j < k[i]; j++) {\n            scanf(\"%d\", &queries[i][j]);\n        }\n    }\n\n    int *result = min_time_to_travel(n, m, bridges, q, k, queries);\n\n    for (int i = 0; i < q; i++) {\n        printf(\"%d\\n\", result[i]);\n    }\n\n    free(result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum time required to travel from island 1 to island N using each of the given bridges at least once. This problem can be approached using dynamic programming with memoization, combined with a priority queue to efficiently find the shortest path. Here's a step-by-step breakdown of the solution:", "question_id": "abc369_e"}
{"solution": "#include <stdio.h>\n\nint main() {\n    int L, R;\n    scanf(\"%d %d\", &L, &R);\n\n    if (L == 1 && R == 0) {\n        printf(\"Yes\n\");\n    } else if (L == 0 && R == 1) {\n        printf(\"No\n\");\n    } else {\n        printf(\"Invalid\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the state of Snuke's hand raising and based on that, decide if he wants to eat takoyaki or if the input is invalid. Here are the steps to follow:\n\n1. Read the input values for L and R.\n2. Check if Snuke is raising only one hand by verifying if either L or R is 1 and the other is 0.\n3. If Snuke is raising only one hand, print 'Yes' if he is raising his left hand (L = 1) and 'No' if he is raising his right hand (R = 1).\n4. If Snuke is raising both hands (L = 1 and R = 1) or not raising any hand (L = 0 and R = 0), print 'Invalid'.\n\nThis approach ensures that we correctly interpret Snuke's actions and provide the appropriate response based on the given constraints.", "question_id": "abc370_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nGHashTable *factorization(int n) {\n    GHashTable *fact = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 2; i * i <= n; i++) {\n        int count = 0;\n        while (n % i == 0) {\n            n /= i;\n            count++;\n        }\n        if (count > 0) {\n            g_hash_table_insert(fact, GINT_TO_POINTER(i), GINT_TO_POINTER(count));\n        }\n    }\n    if (n > 1) {\n        g_hash_table_insert(fact, GINT_TO_POINTER(n), GINT_TO_POINTER(1));\n    }\n    return fact;\n}\n\nint dp[100001][100001];\n\nint count_sequences(int product, int length, int M, GHashTable *factorization) {\n    if (length == M) {\n        return product % 3 == 0 ? 1 : 0;\n    }\n    if (dp[product][length] != -1) {\n        return dp[product][length];\n    }\n    int count = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, factorization);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int prime = GPOINTER_TO_INT(key);\n        int exp = GPOINTER_TO_INT(value);\n        for (int i = 0; i <= exp; i++) {\n            count = (count + count_sequences(product * pow(prime, i), length + 1, M, factorization)) % MOD;\n        }\n    }\n    dp[product][length] = count;\n    return count;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    memset(dp, -1, sizeof(dp));\n    int result = 0;\n    for (int i = 1; i <= N; i++) {\n        GHashTable *fact = factorization(i);\n        result = (result + count_sequences(i, 1, M, fact)) % MOD;\n        g_hash_table_destroy(fact);\n    }\n    printf(\"%d\n\", result);\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the number of length-M sequences A of positive integers such that the product of the elements in A is a good integer not exceeding N. A good integer is defined as a positive integer n where the sum of its positive divisors is divisible by 3. The constraints are quite large, so we need an efficient approach. We will use dynamic programming with memoization to count the number of valid sequences. The key steps are as follows:\n\n1. **Factorization**: We need to factorize the numbers up to N to understand their divisors and their sums of divisors.\n2. **Dynamic Programming**: We will use a DP table to count the number of valid sequences of length M with a given product. The DP state will be defined by the product of the sequence and the current length of the sequence.\n3. **Modulo Operation**: Since the result can be very large, we will take results modulo 998244353 at each step.\n4. **Memoization**: To avoid recomputation, we will use memoization to store the results of subproblems.", "question_id": "abc370_g"}
{"solution": null, "reasoning": "", "question_id": "abc370_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <glib.h>\n\n#define MAX_H 400000\n#define MAX_W 400000\n\nint main() {\n    int H, W, Q;\n    scanf(\"%d %d %d\", &H, &W, &Q);\n\n    GHashTable *walls = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            g_hash_table_insert(walls, GINT_TO_POINTER(i * W + j), GINT_TO_POINTER(1));\n        }\n    }\n\n    for (int q = 0; q < Q; q++) {\n        int R, C;\n        scanf(\"%d %d\", &R, &C);\n\n        int pos = (R - 1) * W + (C - 1);\n        if (g_hash_table_lookup(walls, GINT_TO_POINTER(pos))) {\n            g_hash_table_remove(walls, GINT_TO_POINTER(pos));\n        } else {\n            for (int i = R - 1; i >= 0; i--) {\n                int up_pos = (i - 1) * W + (C - 1);\n                if (g_hash_table_lookup(walls, GINT_TO_POINTER(up_pos))) {\n                    g_hash_table_remove(walls, GINT_TO_POINTER(up_pos));\n                    break;\n                }\n            }\n\n            for (int i = R - 1; i < H; i++) {\n                int down_pos = i * W + (C - 1);\n                if (g_hash_table_lookup(walls, GINT_TO_POINTER(down_pos))) {\n                    g_hash_table_remove(walls, GINT_TO_POINTER(down_pos));\n                    break;\n                }\n            }\n\n            for (int j = C - 1; j >= 0; j--) {\n                int left_pos = (R - 1) * W + (j - 1);\n                if (g_hash_table_lookup(walls, GINT_TO_POINTER(left_pos))) {\n                    g_hash_table_remove(walls, GINT_TO_POINTER(left_pos));\n                    break;\n                }\n            }\n\n            for (int j = C - 1; j < W; j++) {\n                int right_pos = (R - 1) * W + j;\n                if (g_hash_table_lookup(walls, GINT_TO_POINTER(right_pos))) {\n                    g_hash_table_remove(walls, GINT_TO_POINTER(right_pos));\n                    break;\n                }\n            }\n        }\n    }\n\n    printf(\"%zu\\n\", g_hash_table_size(walls));\n\n    g_hash_table_destroy(walls);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of placing bombs on a grid and destroying walls according to the given rules. We will use a 2D array to represent the grid and a set to keep track of the positions of the walls. For each query, we will check if there is a wall at the specified position and destroy it if present. If not, we will destroy the first walls that appear when looking up, down, left, and right from the specified position. To efficiently manage the positions of the walls, we will use a set to store the positions of the walls and use the set operations to find and remove the walls.", "question_id": "abc370_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nGHashTable *memo;\n\n// Function to calculate the number of ways to divide the sequence such that no subsequence sums to K\nlong long countWays(int *arr, int n, int k, long long currentSum) {\n    // Base case: if we have processed all elements\n    if (n == 0) {\n        return (currentSum != k);\n    }\n\n    // Check if the result is already computed\n    gpointer result = g_hash_table_lookup(memo, GINT_TO_POINTER((n << 32) | (currentSum & 0xFFFFFFFFLL) | (k & 0xFFFFFFFFLL)));\n    if (result != NULL) {\n        return GPOINTER_TO_LONG(result);\n    }\n\n    // Option 1: Continue the current subsequence\n    long long continueCurrent = countWays(arr, n - 1, k, currentSum + arr[n - 1]);\n\n    // Option 2: Start a new subsequence\n    long long startNewSubsequence = countWays(arr, n - 1, k, arr[n - 1]);\n\n    // Total ways = ways to continue current + ways to start new\n    long long totalWays = (continueCurrent + startNewSubsequence) % MOD;\n\n    // Store the result in the memo table\n    g_hash_table_insert(memo, GINT_TO_POINTER((n << 32) | (currentSum & 0xFFFFFFFFLL) | (k & 0xFFFFFFFFLL)), GINT_TO_POINTER(totalWays));\n\n    return totalWays;\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    memo = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    long long result = countWays(arr, n, k, 0);\n\n    printf(\"%lld\\n\", result);\n\n    free(arr);\n    g_hash_table_destroy(memo);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of ways to divide the sequence A into contiguous subsequences such that no subsequence sums to K. We can approach this problem using dynamic programming with memoization. Here's a step-by-step explanation of the approach and the implementation details:", "question_id": "abc370_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Create a hash table to store transformation results\n    GHashTable *transformation = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the transformation matrix\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= i; j++) {\n            int value;\n            scanf(\"%d\", &value);\n            g_hash_table_insert(transformation, GINT_TO_POINTER(i * 100 + j), GINT_TO_POINTER(value));\n        }\n    }\n\n    // Initialize the queue with the first element\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(1));\n\n    // Process the queue to find the final element\n    while (!g_queue_is_empty(queue)) {\n        int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        for (int i = 1; i <= N; i++) {\n            int key = current * 100 + i;\n            if (g_hash_table_contains(transformation, GINT_TO_POINTER(key))) {\n                int next = GPOINTER_TO_INT(g_hash_table_lookup(transformation, GINT_TO_POINTER(key)));\n                g_queue_push_tail(queue, GINT_TO_POINTER(next));\n            }\n        }\n    }\n\n    // Output the final element\n    printf(\"%d\n\", GPOINTER_TO_INT(g_queue_pop_head(queue)));\n\n    // Clean up\n    g_hash_table_destroy(transformation);\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "The problem involves combining elements based on a transformation matrix and finding the final element after a series of combinations. The key is to simulate the process of combining elements starting from 1 and following the given transformation rules. We can use a hash table to keep track of the transformation results and a queue to manage the order of combinations.", "question_id": "abc370_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    qsort(a, n, sizeof(int), compare);\n\n    int prefix_sum[n + 1];\n    prefix_sum[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1];\n    }\n\n    int min_weight = INT_MAX;\n    int never_cut = 0;\n\n    for (int i = 0; i < n; i++) {\n        int current_weight = prefix_sum[n] - prefix_sum[i];\n        int cut_lines = n - i;\n\n        if (current_weight < min_weight) {\n            min_weight = current_weight;\n            never_cut = cut_lines;\n        } else if (current_weight == min_weight) {\n            never_cut = fmin(never_cut, cut_lines);\n        }\n    }\n\n    printf(\"%d %d\n\", min_weight, never_cut);\n\n    free(a);\n\n    return 0;\n}", "reasoning": "The problem requires dividing a circular cake into K parts such that the minimum weight among the parts is maximized, and we need to find the minimum weight and the number of cut lines that are never cut. To solve this, we can use a greedy approach combined with dynamic programming and prefix sums.", "question_id": "abc370_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Initialize a hash table to store the earliest-born male child for each family\n    GHashTable *earliest_male = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < m; i++) {\n        int family, gender;\n        scanf(\"%d %d\", &family, &gender);\n\n        // Check if the baby is male\n        if (gender == 1) {\n            // Check if this is the earliest-born male in the family\n            gpointer existing_earliest = g_hash_table_lookup(earliest_male, GINT_TO_POINTER(family));\n            if (existing_earliest == NULL || GPOINTER_TO_INT(existing_earliest) > i) {\n                // Update the hash table with the current baby\n                g_hash_table_insert(earliest_male, GINT_TO_POINTER(family), GINT_TO_POINTER(i));\n            }\n        }\n\n        // Determine if the name given is Taro\n        if (g_hash_table_lookup(earliest_male, GINT_TO_POINTER(family)) == GINT_TO_POINTER(i)) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    // Clean up\n    g_hash_table_destroy(earliest_male);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if each baby born is the earliest-born male child in their respective family. We can use a hash table to keep track of the earliest-born male child for each family. Here's the step-by-step approach:\n\n1. Initialize a hash table to store the earliest-born male child for each family.\n2. Iterate through the list of babies.\n3. For each baby, check if they are male and if they are the earliest-born male in their family.\n4. Update the hash table with the current baby if they are the earliest-born male in their family.\n5. Print 'Yes' if the baby is the earliest-born male, otherwise print 'No'.", "question_id": "abc371_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d\", &n);\n\n    int *x = (int *)malloc(n * sizeof(int));\n    int *p = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &x[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n\n    scanf(\"%d\", &q);\n\n    GArray *prefix_sum = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_append_val(prefix_sum, 0);\n\n    for (int i = 0; i < n; i++) {\n        g_array_append_val(prefix_sum, g_array_index(prefix_sum, int, i) + p[i]);\n    }\n\n    qsort(x, n, sizeof(int), compare);\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n\n        int idx_l = g_array_bsearch(prefix_sum, GINT_TO_POINTER(l), 0, prefix_sum->len, compare);\n        int idx_r = g_array_bsearch(prefix_sum, GINT_TO_POINTER(r), 0, prefix_sum->len, compare);\n\n        if (idx_l == -1) idx_l = 0;\n        if (idx_r == -1) idx_r = prefix_sum->len - 1;\n\n        int result = g_array_index(prefix_sum, int, idx_r) - g_array_index(prefix_sum, int, idx_l);\n        printf(\"%d\n\", result);\n    }\n\n    g_array_free(prefix_sum, TRUE);\n    free(x);\n    free(p);\n\n    return 0;\n}", "reasoning": "To solve this problem efficiently, we need to handle large inputs and multiple queries. The key is to preprocess the data so that we can quickly answer each query. Here's a step-by-step approach:\n\n1. **Input Reading**: Read the number of villages, their coordinates, and the number of queries.\n2. **Sorting**: Sort the villages based on their coordinates to facilitate range queries.\n3. **Prefix Sum Calculation**: Calculate the prefix sum of the number of villagers up to each village. This allows us to quickly determine the number of villagers in any range.\n4. **Query Processing**: For each query, use the prefix sum to find the number of villagers in the specified range.\n5. **Output**: Print the results for each query.\n\nThis approach ensures that each query is answered in constant time after an initial preprocessing step.", "question_id": "abc371_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *P = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        g_array_append_val(P, p);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        g_array_append_val(A, a);\n    }\n\n    int *visited = (int *)calloc(n, sizeof(int));\n    int *cycle = (int *)malloc(n * sizeof(int));\n    int cycle_size = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            int start = i;\n            do {\n                cycle[cycle_size++] = A->data[i];\n                visited[i] = 1;\n                i = P->data[i] - 1;\n            } while (i != start);\n        }\n    }\n\n    qsort(cycle, cycle_size, sizeof(int), compare);\n\n    int *result = (int *)malloc(n * sizeof(int));\n    int result_index = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (visited[i]) {\n            result[result_index++] = cycle[i % cycle_size];\n        } else {\n            result[result_index++] = A->data[i];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", result[i]);\n    }\n    printf(\"\\n\");\n\n    free(visited);\n    free(cycle);\n    free(result);\n    g_array_free(P, TRUE);\n    g_array_free(A, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the lexicographically smallest permutation A that can be obtained by repeatedly applying the given permutation P. The key observation is that the sequence of operations will eventually cycle through all possible permutations of A. Therefore, we need to find the smallest permutation in the cycle generated by the given permutation P.", "question_id": "abc371_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    int *positions = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &positions[i]);\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < n; i++) {\n        g_hash_table_insert(map, GINT_TO_POINTER(positions[i]), GINT_TO_POINTER(i));\n    }\n\n    long long total_moves = 0;\n    for (int i = 0; i < q; i++) {\n        int t, g;\n        scanf(\"%d %d\", &t, &g);\n        int *pos = (int *)g_hash_table_lookup(map, GINT_TO_POINTER(g));\n        if (pos != NULL) {\n            total_moves += abs(*pos - t);\n        }\n    }\n\n    // Output result\n    printf(\"%lld\n\", total_moves);\n\n    // Clean up\n    free(positions);\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "reasoning": "The problem requires finding the minimum total number of movements for N persons to reach their respective goals on an infinitely long road. Each person can only move 1 meter at a time to the east or west. The solution involves using a hash table to keep track of the positions of the persons and then using a greedy algorithm to determine the minimum number of movements required for each task. The hash table allows for quick lookups of the positions of the persons, and the greedy algorithm ensures that the minimum number of movements is used.", "question_id": "abc371_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 8\n#define INF 1e9\n\nint N, M_G, M_H;\nint edges_G[MAXN][MAXN] = {0};\nint edges_H[MAXN][MAXN] = {0};\nint costs[MAXN][MAXN] = {0};\n\nvoid read_input() {\n    scanf(\"%d\", &N);\n    scanf(\"%d\", &M_G);\n    for (int i = 0; i < M_G; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        edges_G[u - 1][v - 1] = 1;\n        edges_G[v - 1][u - 1] = 1;\n    }\n    scanf(\"%d\", &M_H);\n    for (int i = 0; i < M_H; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        edges_H[a - 1][b - 1] = 1;\n        edges_H[b - 1][a - 1] = 1;\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            scanf(\"%d\", &costs[i][j]);\n            costs[j][i] = costs[i][j];\n        }\n    }\n}\n\nint min_cost_to_isomorphic() {\n    int dp[MAXN][1 << N] = {0};\n\n    for (int i = 0; i < 1 << N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[j][i] = INF;\n        }\n    }\n\n    dp[0][0] = 0;\n\n    for (int i = 1; i < 1 << N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i & (1 << j)) {\n                int prev = i ^ (1 << j);\n                for (int k = 0; k < N; k++) {\n                    if (prev & (1 << k)) {\n                        dp[j][i] = fmin(dp[j][i], dp[k][prev] + costs[j][k]);\n                    }\n                }\n            }\n        }\n    }\n\n    int min_cost = INF;\n    for (int i = 0; i < N; i++) {\n        min_cost = fmin(min_cost, dp[i][(1 << N) - 1]);\n    }\n\n    return min_cost;\n}\n\nint main() {\n    read_input();\n    printf(\"%d\n\", min_cost_to_isomorphic());\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum cost to make two graphs G and H isomorphic. The key steps are as follows:\n1. Calculate the number of edges that need to be added or removed in graph H to match the structure of graph G.\n2. Use dynamic programming to find the minimum cost to achieve this.\n3. Handle the constraints and edge cases appropriately.", "question_id": "abc371_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int *prefix = (int *)calloc(n, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int key = arr[i];\n        gpointer value = g_hash_table_lookup(count, GINT_TO_POINTER(key));\n        if (value == NULL) {\n            g_hash_table_insert(count, GINT_TO_POINTER(key), GINT_TO_POINTER(1));\n            prefix[i] = prefix[i - 1] + 1;\n        } else {\n            int prev_count = GPOINTER_TO_INT(value);\n            g_hash_table_insert(count, GINT_TO_POINTER(key), GINT_TO_POINTER(prev_count + 1));\n            prefix[i] = prefix[i - 1];\n        }\n    }\n\n    long long result = 0;\n    for (int i = 0; i < n; i++) {\n        result += prefix[i];\n    }\n\n    printf(\"%lld\\n\", result);\n\n    free(arr);\n    free(prefix);\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently calculate the sum of f(i, j) for all possible subsequences (i, j) in the given array A. The function f(l, r) represents the number of distinct values in the subsequence (A_l, A_{l+1}, ..., A_r). Given the constraints, a naive approach would be too slow, so we need a more efficient method.", "question_id": "abc371_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char relationships[4];\n    scanf(\"%s\", relationships);\n\n    // Initialize age relationships\n    bool A_older_than_B = (relationships[0] == \">\");\n    bool A_older_than_C = (relationships[1] == \">\");\n    bool B_older_than_C = (relationships[2] == \">\");\n\n    // Determine the middle brother\n    char middle_brother;\n    if (A_older_than_B && A_older_than_C) {\n        if (B_older_than_C) {\n            middle_brother = 'B';\n        } else {\n            middle_brother = 'C';\n        }\n    } else if (A_older_than_B && !A_older_than_C) {\n        middle_brother = 'A';\n    } else if (!A_older_than_B && A_older_than_C) {\n        middle_brother = 'A';\n    } else {\n        middle_brother = 'B';\n    }\n\n    // Output the result\n    printf(\"%c\n\", middle_brother);\n\n    return 0;\n}", "reasoning": "To determine the middle brother among A, B, and C, we need to analyze the given age relationships. Each relationship (S_AB, S_AC, S_BC) provides a comparison between two brothers. By combining these relationships, we can deduce the order of their ages. The middle brother will be the one who is neither the oldest nor the youngest based on the given constraints.", "question_id": "abc371_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n// Function to compare two integers for sorting\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize a hash table to store adjacency lists\n    GHashTable *graph = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < Q; i++) {\n        int type;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n\n            // Add edge u -> v\n            GArray *list_u = g_hash_table_lookup(graph, GINT_TO_POINTER(u));\n            if (!list_u) {\n                list_u = g_array_new(FALSE, FALSE, sizeof(int));\n                g_hash_table_insert(graph, GINT_TO_POINTER(u), list_u);\n            }\n            g_array_append_val(list_u, v);\n\n            // Add edge v -> u\n            GArray *list_v = g_hash_table_lookup(graph, GINT_TO_POINTER(v));\n            if (!list_v) {\n                list_v = g_array_new(FALSE, FALSE, sizeof(int));\n                g_hash_table_insert(graph, GINT_TO_POINTER(v), list_v);\n            }\n            g_array_append_val(list_v, u);\n        } else if (type == 2) {\n            int v, k;\n            scanf(\"%d %d\", &v, &k);\n\n            // Get the list of connected vertices\n            GArray *list = g_hash_table_lookup(graph, GINT_TO_POINTER(v));\n            if (!list || list->len < k) {\n                printf(\"-1\n\");\n                continue;\n            }\n\n            // Sort the list in descending order\n            qsort(list->data, list->len, sizeof(int), compare);\n\n            // Print the k-th largest element\n            printf(\"%d\n\", g_array_index(list, int, k-1));\n        }\n    }\n\n    // Free the allocated memory\n    g_hash_table_destroy(graph);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to handle two types of queries efficiently. Type 1 queries add edges to the graph, and Type 2 queries find the k-th largest vertex connected to a given vertex. Given the constraints, we need a data structure that can handle these operations quickly. A suitable data structure for this problem is a combination of a hash table and a priority queue (implemented using GLib's GQueue). The hash table will store the adjacency list for each vertex, and the priority queue will help in efficiently finding the k-th largest element among the connected vertices.", "question_id": "abc372_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    char *s = (char *)malloc(n + 1);\n    scanf(\"%s\", s);\n\n    GHashTable *abc_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initialize the count of 'ABC' in the initial string\n    int count = 0;\n    for (int i = 0; i <= n - 3; i++) {\n        if (s[i] == 'A' && s[i + 1] == 'B' && s[i + 2] == 'C') {\n            count++;\n        }\n    }\n    g_hash_table_insert(abc_count, GINT_TO_POINTER(0), GINT_TO_POINTER(count));\n\n    for (int i = 0; i < q; i++) {\n        int x;\n        char c;\n        scanf(\"%d %c\", &x, &c);\n\n        // Update the string and count 'ABC'\n        if (s[x - 1] != c) {\n            char old_char = s[x - 1];\n            s[x - 1] = c;\n\n            // Update the count based on the change\n            if (x >= 2 && x <= n - 2) {\n                int prev_count = GPOINTER_TO_INT(g_hash_table_lookup(abc_count, GINT_TO_POINTER(i - 1)));\n                int new_count = prev_count;\n\n                // Check if the previous 'ABC' is still valid\n                if (old_char == 'A' && s[x - 2] == 'B' && s[x - 1] == 'C') {\n                    new_count--;\n                }\n\n                // Check if the new 'ABC' is valid\n                if (s[x - 2] == 'A' && s[x - 1] == 'B' && c == 'C') {\n                    new_count++;\n                }\n\n                g_hash_table_insert(abc_count, GINT_TO_POINTER(i), GINT_TO_POINTER(new_count));\n            } else {\n                g_hash_table_insert(abc_count, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n            }\n        }\n\n        // Print the count of 'ABC' after the update\n        int final_count = GPOINTER_TO_INT(g_hash_table_lookup(abc_count, GINT_TO_POINTER(i)));\n        printf(\"%d\\n\", final_count);\n    }\n\n    // Free allocated memory\n    free(s);\n    g_hash_table_destroy(abc_count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently handle string updates and count the occurrences of the substring 'ABC' after each update. Given the constraints, a direct approach would be too slow. Instead, we can use a sliding window technique to count 'ABC' efficiently and update the count based on the changes in the string.", "question_id": "abc372_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *heights = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n\n    GArray *result = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n        while (result->len > 0 && heights[i] > g_array_index(result, int, result->len - 1)) {\n            count++;\n            g_array_remove_index(result, result->len - 1);\n        }\n        count++;\n        g_array_append_val(result, count);\n    }\n\n    for (int i = 0; i < result->len; i++) {\n        printf(\"%d\", g_array_index(result, int, i));\n        if (i < result->len - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    g_array_free(result, TRUE);\n    free(heights);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine for each building the number of buildings to its right that are not taller than it. This requires a way to efficiently check the heights of buildings and count the valid j values for each i. We can use a stack to keep track of the buildings in a way that allows us to efficiently determine the number of valid j values for each i. The stack will help us maintain the buildings in a decreasing order of height, which allows us to count the valid j values in a single pass through the buildings.", "question_id": "abc372_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define LL long long\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N;\n        scanf(\"%d\", &N);\n\n        GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n        LL total = 0;\n\n        for (int i = 0; i < N; i++) {\n            int A, B, C;\n            scanf(\"%d %d %d\", &A, &B, &C);\n\n            // Calculate the maximum possible value of x that satisfies the inequality\n            LL max_x = (C - 1) / A;\n\n            // Calculate the number of valid y values for each x\n            for (LL x = 1; x <= max_x; x++) {\n                LL y = (C - A * x) / B;\n                if (A * x + B * y < C) {\n                    total += y;\n                }\n            }\n        }\n\n        printf(\"%lld\\n\", total);\n\n        g_hash_table_destroy(map);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of pairs (x, y) that satisfy the inequality A_i * x + B_i * y < C_i for all 1 <= i <= N for each test case. Given the constraints, a direct brute-force approach is not feasible due to its high computational complexity. Instead, we can use a more efficient approach by leveraging mathematical insights and data structures provided by GLib.", "question_id": "abc372_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    GArray *adj = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i <= N; i++) {\n        g_array_append_val(adj, 0);\n    }\n\n    for (int i = 0; i < M; i++) {\n        int X, Y;\n        scanf(\"%d %d\", &X, &Y);\n        g_array_append_val(adj, Y);\n    }\n\n    int dp[K + 1][N + 1];\n    memset(dp, 0, sizeof(dp));\n\n    dp[0][1] = 1;\n\n    for (int i = 1; i <= K; i++) {\n        for (int v = 1; v <= N; v++) {\n            int next = g_array_index(adj, int, v);\n            dp[i][v] = (dp[i][v] + dp[i - 1][next]) % MOD;\n        }\n    }\n\n    int result = 0;\n    for (int v = 1; v <= N; v++) {\n        result = (result + dp[K][v]) % MOD;\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_array_free(adj, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to compute the number of ways Takahashi can move from vertex 1 to any vertex in exactly K steps. The graph is a combination of a cycle and additional edges. We can use dynamic programming to solve this problem efficiently. Here's a step-by-step breakdown of the approach:", "question_id": "abc372_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input string\n    char input[101];  // 100 characters + 1 for the null terminator\n    scanf(\"%s\", input);\n\n    // Create a dynamic array to store the result\n    GArray *result = g_array_new(FALSE, FALSE, sizeof(char));\n\n    // Iterate through the input string\n    for (int i = 0; input[i] != '\\0'; i++) {\n        // If the character is not '.', append it to the result array\n        if (input[i] != \".\") {\n            g_array_append_val(result, input[i]);\n        }\n    }\n\n    // Convert the GArray to a null-terminated string\n    char *output = (char *)g_array_free(result, FALSE);\n\n    // Print the result\n    printf(\"%s\\n\", output);\n\n    // Free the dynamically allocated string\n    free(output);\n\n    return 0;\n}", "reasoning": "The problem requires removing all occurrences of the character '.' from a given string. This can be efficiently done by iterating through the string and constructing a new string that includes only the characters that are not '.'. We can use a dynamic array (GArray) from GLib to handle the dynamic resizing of the string as we build it.", "question_id": "abc372_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Initialize a hash table to count the number of valid strings\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initialize the count for each index to 0\n    for (int i = 1; i <= 12; i++) {\n        g_hash_table_insert(count, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n    }\n\n    // Read the 12 strings from standard input\n    for (int i = 0; i < 12; i++) {\n        char str[101]; // Buffer to store the string\n        scanf(\"%s\", str);\n\n        // Get the length of the string\n        int len = strlen(str);\n\n        // Check if the length matches the index (1-based)\n        if (len == i + 1) {\n            // Increment the count for this length\n            int *current_count = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(i + 1)));\n            *current_count += 1;\n        }\n    }\n\n    // Initialize the result to 0\n    int result = 0;\n\n    // Sum up the counts for all valid lengths\n    for (int i = 1; i <= 12; i++) {\n        int *count_value = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(i)));\n        result += *count_value;\n    }\n\n    // Print the result\n    printf(\"%d\\n\", result);\n\n    // Clean up the hash table\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to read 12 strings from standard input and check if each string's length matches its index (1-based). We will use a GHashTable to keep track of the counts of strings that satisfy this condition. Here's the step-by-step approach:", "question_id": "abc373_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[1000];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n    int total_distance = 0;\n\n    // Initialize the starting position of the finger at the key for A (coordinate 1)\n    int current_position = 1;\n\n    // Iterate through the permutation string\n    for (int i = 0; i < n; i++) {\n        // Calculate the coordinate of the current key\n        int current_key = S[i] - 'A' + 1;\n\n        // Calculate the distance from the current position to the current key\n        int distance = abs(current_key - current_position);\n\n        // Accumulate the total distance\n        total_distance += distance;\n\n        // Update the current position to the current key\n        current_position = current_key;\n    }\n\n    // Output the total distance\n    printf(\"%d\n\", total_distance);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the minimal possible total traveled distance of the right index finger from pressing the key for A to pressing the key for Z on a keyboard arranged as a permutation of the alphabet. The finger starts at the key for A, which is at coordinate 1. We will iterate through the given permutation string, calculate the distance from the current key to the next key, and accumulate the total distance. The distance between two keys is the absolute difference between their coordinates.", "question_id": "abc373_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, W;\n    scanf(\"%d %d\", &N, &W);\n\n    GArray *items = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        int w, v;\n        scanf(\"%d %d\", &w, &v);\n        g_array_append_val(items, w);\n        g_array_append_val(items, v);\n    }\n\n    int dp[N + 1][W + 1];\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 1; i <= N; i++) {\n        int w = g_array_index(items, int, (i - 1) * 2);\n        int v = g_array_index(items, int, (i - 1) * 2 + 1);\n        for (int j = 0; j <= W; j++) {\n            dp[i][j] = dp[i - 1][j];\n            for (int k = 1; k * w <= j; k++) {\n                dp[i][j] = fmax(dp[i][j], dp[i - 1][j - k * w] + k * v - k * k);\n            }\n        }\n    }\n\n    printf(\"%d\\n\", dp[N][W]);\n\n    g_array_free(items, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maximize the total happiness while respecting the weight constraint. The happiness for choosing k_i items of type i is given by k_i * v_i - k_i^2. This can be rewritten as k_i * (v_i - k_i). To maximize this, we need to find the optimal k_i for each item type. We can use dynamic programming to solve this problem by maintaining a DP array where dp[i][w] represents the maximum happiness we can achieve with the first i item types and a weight limit of w. We iterate through each item type and update the DP array accordingly. Finally, we return the maximum happiness we can achieve with the given weight limit.", "question_id": "abc373_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 300\n#define MAX_COORD 5000\n\n// Structure to store points\ntypedef struct {\n    int x, y;\n} Point;\n\n// Comparison function for qsort\nint compare(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    int slope1 = p1->y * MAX_COORD + p1->x;\n    int slope2 = p2->y * MAX_COORD + p2->x;\n    return slope1 - slope2;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    Point P[MAXN], Q[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &P[i].x, &P[i].y);\n    }\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &Q[i].x, &Q[i].y);\n    }\n\n    // Sort points based on their slopes with respect to the origin\n    qsort(P, N, sizeof(Point), compare);\n    qsort(Q, N, sizeof(Point), compare);\n\n    // Construct the permutation R\n    int R[MAXN];\n    for (int i = 0; i < N; i++) {\n        R[i] = i + 1;\n    }\n\n    // Output the permutation\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", R[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exists a permutation R of (1, 2, ..., N) such that the line segments connecting P_i and Q_{R_i} do not intersect for any i and j (1 <= i < j <= N). The key observation here is that if we can sort the points in such a way that the segments do not intersect, we can find a valid permutation. One way to achieve this is by using a greedy algorithm that sorts points based on their slopes with respect to the origin and then constructs the permutation accordingly.", "question_id": "abc373_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    int *B = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n\n    int maxA = A[0];\n    int maxB = B[0];\n\n    for (int i = 1; i < n; i++) {\n        if (A[i] > maxA) {\n            maxA = A[i];\n        }\n        if (B[i] > maxB) {\n            maxB = B[i];\n        }\n    }\n\n    printf(\"%d\n\", maxA + maxB);\n\n    free(A);\n    free(B);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum possible value of A_i + B_j for given sequences A and B of length N. The key insight is that we need to find the maximum value in A and the maximum value in B, and then sum these two maximum values. This is because the maximum sum will be achieved by adding the largest elements from both sequences.", "question_id": "abc373_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %lld\", &N, &M, &K);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Sort the votes in descending order\n    qsort(A, N, sizeof(int), compare);\n\n    // Calculate the total votes already counted\n    long long total_votes = 0;\n    for (int i = 0; i < N; i++) {\n        total_votes += A[i];\n    }\n\n    // Calculate the remaining votes\n    long long remaining_votes = K - total_votes;\n\n    // Calculate the minimum additional votes needed for each candidate\n    int *C = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        if (A[i] >= remaining_votes / (M + 1)) {\n            C[i] = -1;\n        } else {\n            C[i] = remaining_votes / (M + 1) - A[i];\n        }\n    }\n\n    // Print the result\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", C[i]);\n    }\n    printf(\"\\n\");\n\n    // Free allocated memory\n    free(A);\n    free(C);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of additional votes each candidate needs to guarantee their victory regardless of how the remaining votes are distributed. Here's a step-by-step approach to achieve this:", "question_id": "abc373_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\n// Function to update the Fenwick Tree\nvoid update(GArray *tree, int index, int value) {\n    while (index < tree->len) {\n        g_array_index(tree, int, index) += value;\n        index += index & -index;\n    }\n}\n\n// Function to get the prefix sum from the Fenwick Tree\nint prefix_sum(GArray *tree, int index) {\n    int sum = 0;\n    while (index > 0) {\n        sum += g_array_index(tree, int, index);\n        index -= index & -index;\n    }\n    return sum;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d\", &N);\n    int P[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n    scanf(\"%d\", &M);\n    int A[M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Initialize Fenwick Tree\n    GArray *tree = g_array_sized_new(FALSE, FALSE, sizeof(int), N + 1);\n    g_array_set_size(tree, N + 1);\n    memset(g_array_data(tree), 0, (N + 1) * sizeof(int));\n\n    // Calculate initial inversion number\n    int inversions = 0;\n    for (int i = 0; i < N; i++) {\n        inversions += i - prefix_sum(tree, P[i] - 1);\n        update(tree, P[i], 1);\n    }\n\n    // Process each operation\n    for (int i = 0; i < M; i++) {\n        int a = A[i];\n        int b = P[a - 1];\n        if (a == 1 || b == 1) {\n            printf(\"%d\\n\", inversions);\n            continue;\n        }\n\n        int pos1 = prefix_sum(tree, b - 1);\n        int pos2 = prefix_sum(tree, a - 2);\n        inversions -= pos1 - pos2;\n        update(tree, b, -1);\n        update(tree, a, 1);\n        inversions += pos1 - pos2;\n\n        printf(\"%d\\n\", inversions);\n    }\n\n    // Free resources\n    g_array_free(tree, TRUE);\n\n    return 0;\n}", "reasoning": "The problem requires us to find the inversion number of a permutation after performing a series of operations. Each operation involves swapping adjacent elements if the current element is greater than the next one. We need to calculate the inversion number after each operation. To solve this, we can use a Fenwick Tree (Binary Indexed Tree) to efficiently calculate and update the inversion numbers as we perform the operations.", "question_id": "arc181_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define N 500\n\nvoid backtrack(int row, int col, char grid[N][N], int *P, int *Q, int N, GHashTable **row_used, GHashTable **col_used, bool *result) {\n    if (row == N) {\n        *result = true;\n        return;\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (!g_hash_table_contains(row_used[row], GINT_TO_POINTER(i)) && !g_hash_table_contains(col_used[col], GINT_TO_POINTER(i))) {\n            grid[row][col] = '0' + i;\n            g_hash_table_insert(row_used[row], GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n            g_hash_table_insert(col_used[col], GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n\n            int next_row = row + (col == N - 1 ? 1 : 0);\n            int next_col = (col + 1) % N;\n\n            backtrack(next_row, next_col, grid, P, Q, N, row_used, col_used, result);\n\n            if (*result) {\n                return;\n            }\n\n            g_hash_table_remove(row_used[row], GINT_TO_POINTER(i));\n            g_hash_table_remove(col_used[col], GINT_TO_POINTER(i));\n        }\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int P[N], Q[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &Q[i]);\n    }\n\n    char grid[N][N];\n    GHashTable *row_used[N];\n    GHashTable *col_used[N];\n\n    for (int i = 0; i < N; i++) {\n        row_used[i] = g_hash_table_new(g_direct_hash, g_direct_equal);\n        col_used[i] = g_hash_table_new(g_direct_hash, g_direct_equal);\n    }\n\n    bool result = false;\n    backtrack(0, 0, grid, P, Q, N, row_used, col_used, &result);\n\n    if (result) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                printf(\"%c\", grid[i][j]);\n            }\n            printf(\"\\n\");\n        }\n    } else {\n        printf(\"No solution found\\n\");\n    }\n\n    for (int i = 0; i < N; i++) {\n        g_hash_table_destroy(row_used[i]);\n        g_hash_table_destroy(col_used[i]);\n    }\n\n    return 0;\n}", "reasoning": "The problem requires filling an N-by-N grid with 0s and 1s such that the rows and columns are sorted lexicographically according to the given permutations P and Q. To achieve this, we can use a backtracking approach to try placing 0s and 1s in the grid and checking if the conditions are satisfied. We will use a hash table to keep track of the used characters in each row and column. If at any point we cannot place a 0 or 1 without violating the conditions, we backtrack and try the other option.", "question_id": "arc181_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    for (int i = 0; i < t; i++) {\n        char s[500001];\n        char x[500001];\n        char y[500001];\n        scanf(\"%s %s %s\", s, x, y);\n\n        int len_x = strlen(x);\n        int len_y = strlen(y);\n\n        GHashTable *count_x = g_hash_table_new(g_str_hash, g_str_equal);\n        GHashTable *count_y = g_hash_table_new(g_str_hash, g_str_equal);\n\n        // Count frequency of characters in f(S, T, X)\n        for (int j = 0; j < len_x; j++) {\n            char *c = (char *)malloc(2 * sizeof(char));\n            c[0] = s[j];\n            c[1] = '\\0';\n            int *count = (int *)g_hash_table_lookup(count_x, c);\n            if (count == NULL) {\n                count = (int *)malloc(sizeof(int));\n                *count = 0;\n                g_hash_table_insert(count_x, c, count);\n            }\n            if (x[j] == '0') {\n                (*count)++;\n            } else {\n                (*count)++;\n            }\n        }\n\n        // Count frequency of characters in f(S, T, Y)\n        for (int j = 0; j < len_y; j++) {\n            char *c = (char *)malloc(2 * sizeof(char));\n            c[0] = s[j];\n            c[1] = '\\0';\n            int *count = (int *)g_hash_table_lookup(count_y, c);\n            if (count == NULL) {\n                count = (int *)malloc(sizeof(int));\n                *count = 0;\n                g_hash_table_insert(count_y, c, count);\n            }\n            if (y[j] == '0') {\n                (*count)++;\n            } else {\n                (*count)++;\n            }\n        }\n\n        // Compare the frequency of characters\n        bool is_equal = true;\n        GList *keys = g_hash_table_get_keys(count_x);\n        GList *node = keys;\n        while (node != NULL) {\n            char *key = (char *)node->data;\n            int *count_x_val = (int *)g_hash_table_lookup(count_x, key);\n            int *count_y_val = (int *)g_hash_table_lookup(count_y, key);\n            if (count_x_val == NULL || count_y_val == NULL || *count_x_val != *count_y_val) {\n                is_equal = false;\n                break;\n            }\n            node = g_list_next(node);\n        }\n\n        // Free memory\n        g_hash_table_destroy(count_x);\n        g_hash_table_destroy(count_y);\n        g_list_free(keys);\n\n        // Print result\n        if (is_equal) {\n            printf(\"Yes\\n\");\n        } else {\n            printf(\"No\\n\");\n        }\n    }\n\n    return 0;\n}", "reasoning": "The problem requires determining if there exists a string T such that the concatenation of S and T according to the binary string X results in the same string as the concatenation of S and T according to the binary string Y. This can be approached by comparing the frequency of each character in the concatenated strings formed by S and T according to X and Y. If the frequency of each character is the same in both cases, then such a T exists. We can use a hash table to count the frequency of each character in the concatenated strings.", "question_id": "arc181_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint count_inversions(int *arr, int n) {\n    int inversions = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inversions++;\n            }\n        }\n    }\n    return inversions;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N;\n        scanf(\"%d\", &N);\n\n        int *P = (int *)malloc(N * sizeof(int));\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &P[i]);\n        }\n\n        int result = count_inversions(P, N);\n        printf(\"%d\n\", result);\n\n        free(P);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of operations required to transform a given permutation into the identity permutation (1, 2, ..., N). Each operation allows us to sort a prefix and a suffix of the permutation. The key insight is to count the number of inversions in the permutation. An inversion is a pair (i, j) such that i < j and P[i] > P[j]. Each operation can resolve at most one inversion, so the minimum number of operations required is equal to the number of inversions in the permutation.", "question_id": "arc181_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GArray *a = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *b = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(a, value);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(b, value);\n    }\n\n    int operations = 0;\n\n    for (int i = 0; i < n; i++) {\n        int diff = abs(g_array_index(a, int, i) - g_array_index(b, int, i));\n        int min_operations = diff < m - diff ? diff : m - diff;\n        operations += min_operations;\n    }\n\n    printf(\"%d\n\", operations);\n\n    g_array_free(a, TRUE);\n    g_array_free(b, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can transform sequence A into sequence B using the allowed operations and, if so, find the minimum number of operations required. The key observation is that we can only change an element in A if it doesn't affect the 'good sequence' property. Therefore, we can only change elements that are not adjacent to each other. The solution involves iterating through the sequences and counting the minimum number of operations needed to make corresponding elements equal while ensuring the 'good sequence' property is maintained.", "question_id": "arc182_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M, C, K;\n    scanf(\"%d %d %d %d\", &N, &M, &C, &K);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GHashTable *min_values = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < N; i++) {\n        int remainder = (A[i] % M + M) % M;\n        if (!g_hash_table_contains(min_values, GINT_TO_POINTER(remainder))) {\n            g_hash_table_insert(min_values, GINT_TO_POINTER(remainder), GINT_TO_POINTER(remainder));\n        } else {\n            int current_min = GPOINTER_TO_INT(g_hash_table_lookup(min_values, GINT_TO_POINTER(remainder)));\n            if (remainder < current_min) {\n                g_hash_table_insert(min_values, GINT_TO_POINTER(remainder), GINT_TO_POINTER(remainder));\n            }\n        }\n    }\n\n    long long sum = 0;\n    for (int k = 0; k < K; k++) {\n        int remainder = (C * k % M + M) % M;\n        if (g_hash_table_contains(min_values, GINT_TO_POINTER(remainder))) {\n            sum += GPOINTER_TO_INT(g_hash_table_lookup(min_values, GINT_TO_POINTER(remainder)));\n        }\n    }\n\n    printf(\"%lld\n\", sum);\n\n    g_hash_table_destroy(min_values);\n    free(A);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently compute the sum of the minimum values of a specific expression for a range of values of k. The expression is (Ck + A_i) % M, where A_i are elements of the input array A. The constraints suggest that a naive approach would be too slow, so we need an optimized solution. The key observation is that for each value of k, we need to find the minimum of (Ck + A_i) % M for all i. This can be done using a hash table to keep track of the minimum values for each remainder. We then iterate over the range of k values and sum up the minimum values.", "question_id": "arc182_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int p;\n    int v;\n} Operation;\n\nint compare(const void *a, const void *b) {\n    return ((Operation *)a)->p - ((Operation *)b)->p;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    Operation ops[q];\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d\", &ops[i].p, &ops[i].v);\n    }\n\n    qsort(ops, q, sizeof(Operation), compare);\n\n    GHashTable *dp = g_hash_table_new(g_int_hash, g_int_equal);\n    g_hash_table_insert(dp, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n\n    for (int i = 0; i < q; i++) {\n        int p = ops[i].p;\n        int v = ops[i].v;\n\n        GHashTable *new_dp = g_hash_table_new(g_int_hash, g_int_equal);\n\n        int sum = 0;\n        GHashTableIter iter;\n        gpointer key, value;\n        g_hash_table_iter_init(&iter, dp);\n        while (g_hash_table_iter_next(&iter, &key, &value)) {\n            int key_val = GPOINTER_TO_INT(key);\n            int val = GPOINTER_TO_INT(value);\n\n            if (key_val + p > n) {\n                sum = (sum + val) % MOD;\n            } else {\n                int next_val = (val * 2) % MOD;\n                g_hash_table_insert(new_dp, GINT_TO_POINTER(key_val + p), GINT_TO_POINTER(next_val));\n            }\n        }\n\n        g_hash_table_destroy(dp);\n        dp = new_dp;\n    }\n\n    int result = 0;\n    g_hash_table_iter_init(&iter, dp);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        result = (result + GPOINTER_TO_INT(value)) % MOD;\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of valid sequences of operations Snuke can perform on the sequence S without crying. The operations involve replacing a subsequence of S with a given value, and Snuke will cry if any element in the subsequence is strictly greater than the new value. We need to count all valid sequences modulo 998244353.", "question_id": "arc182_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    long long n, m;\n    scanf(\"%lld %lld\", &n, &m);\n\n    // Initialize DP table\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(long long));\n    g_array_append_val(dp, 1);\n\n    // Precompute factorials and their modular inverses\n    GArray *fact = g_array_new(FALSE, FALSE, sizeof(long long));\n    GArray *inv_fact = g_array_new(FALSE, FALSE, sizeof(long long));\n    g_array_append_val(fact, 1);\n    g_array_append_val(inv_fact, 1);\n\n    for (long long i = 1; i <= n; i++) {\n        g_array_append_val(fact, (g_array_index(fact, long long, i - 1) * i) % MOD);\n        g_array_append_val(inv_fact, pow_mod(g_array_index(fact, long long, i), MOD - 2, MOD));\n    }\n\n    // Process each element in the sequence\n    for (long long i = 1; i <= m; i++) {\n        GArray *new_dp = g_array_new(FALSE, FALSE, sizeof(long long));\n        g_array_append_val(new_dp, 1);\n\n        for (long long j = 1; j <= n; j++) {\n            long long score = 0;\n            for (long long k = 1; k <= i; k++) {\n                if (i % k == 0) {\n                    score += (g_array_index(dp, long long, j - 1) * pow_mod(k, j, MOD)) % MOD;\n                    score %= MOD;\n                }\n            }\n            g_array_append_val(new_dp, score);\n        }\n\n        g_array_free(dp, TRUE);\n        dp = new_dp;\n    }\n\n    // Output the result\n    printf(\"%lld\\n\", g_array_index(dp, long long, n - 1));\n\n    // Clean up\n    g_array_free(dp, TRUE);\n    g_array_free(fact, TRUE);\n    g_array_free(inv_fact, TRUE);\n\n    return 0;\n}\n\n// Helper function to compute (base^exp) % mod using modular exponentiation\nlong long pow_mod(long long base, long long exp, long long mod) {\n    long long result = 1;\n    base = base % mod;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}", "reasoning": "To solve this problem, we need to understand the properties of divisors and how they relate to the product of elements in a sequence. The key insight is that the score of a sequence is determined by the prime factorization of the product of its elements. Specifically, if the prime factorization of the product is p1^e1 * p2^e2 * ... * pk^ek, then the number of divisors is (e1+1) * (e2+1) * ... * (ek+1). Given that each element in the sequence can be between 1 and M, we need to consider all possible products of sequences and their corresponding scores. However, due to the constraints, a direct approach is not feasible. Instead, we use a combination of combinatorial mathematics and dynamic programming to efficiently compute the result modulo 998244353.", "question_id": "arc182_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 250001\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N, K;\n        scanf(\"%d %d\", &N, &K);\n\n        int A[MAXN], B[MAXN];\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &A[i]);\n        }\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &B[i]);\n        }\n\n        GHashTable *freq_A = g_hash_table_new(g_direct_hash, g_direct_equal);\n        GHashTable *freq_B = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n        for (int i = 0; i < N; i++) {\n            int count_A = GPOINTER_TO_INT(g_hash_table_lookup(freq_A, GINT_TO_POINTER(A[i]))) + 1;\n            int count_B = GPOINTER_TO_INT(g_hash_table_lookup(freq_B, GINT_TO_POINTER(B[i]))) + 1;\n            g_hash_table_insert(freq_A, GINT_TO_POINTER(A[i]), GINT_TO_POINTER(count_A));\n            g_hash_table_insert(freq_B, GINT_TO_POINTER(B[i]), GINT_TO_POINTER(count_B));\n        }\n\n        bool possible = true;\n\n        for (int i = 1; i <= N; i++) {\n            int count_A = GPOINTER_TO_INT(g_hash_table_lookup(freq_A, GINT_TO_POINTER(i)));\n            int count_B = GPOINTER_TO_INT(g_hash_table_lookup(freq_B, GINT_TO_POINTER(i)));\n\n            if (count_A < count_B) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (possible) {\n            int window_size = K + 1;\n            int extra_elements = 0;\n\n            for (int i = 0; i < N; i++) {\n                int count_A = GPOINTER_TO_INT(g_hash_table_lookup(freq_A, GINT_TO_POINTER(A[i])));\n                int count_B = GPOINTER_TO_INT(g_hash_table_lookup(freq_B, GINT_TO_POINTER(B[i])));\n\n                if (count_A > count_B) {\n                    extra_elements += count_A - count_B;\n                }\n\n                if (i >= window_size) {\n                    int count_A_out = GPOINTER_TO_INT(g_hash_table_lookup(freq_A, GINT_TO_POINTER(A[i - window_size])));\n                    if (count_A_out > 0) {\n                        extra_elements -= count_A_out;\n                    }\n                }\n\n                if (extra_elements > window_size) {\n                    possible = false;\n                    break;\n                }\n            }\n        }\n\n        if (possible) {\n            printf(\"Yes\\n\");\n        } else {\n            printf(\"No\\n\");\n        }\n\n        g_hash_table_destroy(freq_A);\n        g_hash_table_destroy(freq_B);\n    }\n\n    return 0;\n}", "reasoning": "To determine if we can make sequence A identical to sequence B using the given operation, we need to consider the following points:\n\n1. The operation allows us to change the value of A_i to A_j if |i - j| <= K.\n2. This means we can move elements within a sliding window of size K+1 in sequence A to match elements in sequence B.\n3. We need to count the frequency of each element in both sequences and ensure that we can move elements within the allowed range to match the frequencies in sequence B.\n4. If for any element, the frequency in sequence B is greater than the frequency in sequence A, it's impossible to match, and we should return No.\n5. If we can match the frequencies for all elements, we need to check if the elements can be moved within the allowed range to match the sequence B.\n6. To check the feasibility of moving elements, we can use a sliding window approach to count the number of elements that need to be moved within the allowed range.\n7. If the number of elements that need to be moved is within the allowed range, we can return Yes; otherwise, we return No.\n\nBy following these steps, we can determine if it's possible to make sequence A identical to sequence B using the given operation.", "question_id": "arc183_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int l, r, x;\n} Condition;\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    Condition *conditions = (Condition *)malloc(m * sizeof(Condition));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &conditions[i].l, &conditions[i].r, &conditions[i].x);\n    }\n\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_append_val(dp, 1);\n\n    for (int i = 1; i <= n; i++) {\n        int *new_dp = (int *)malloc(n * sizeof(int));\n        memset(new_dp, 0, n * sizeof(int));\n\n        for (int j = 0; j < m; j++) {\n            Condition c = conditions[j];\n            if (i >= c.l && i <= c.r) {\n                if (i != c.x) {\n                    for (int k = 0; k < n; k++) {\n                        if (k != c.x - 1) {\n                            new_dp[k] = (new_dp[k] + dp[k]) % MOD;\n                        }\n                    }\n                }\n            } else {\n                for (int k = 0; k < n; k++) {\n                    new_dp[k] = (new_dp[k] + dp[k]) % MOD;\n                }\n            }\n        }\n\n        g_array_free(dp, TRUE);\n        dp = g_array_new(FALSE, FALSE, sizeof(int));\n        for (int j = 0; j < n; j++) {\n            g_array_append_val(dp, new_dp[j]);\n        }\n        free(new_dp);\n    }\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        result = (result + dp->data[i]) % MOD;\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_array_free(dp, TRUE);\n    free(conditions);\n\n    return 0;\n}", "reasoning": "The problem requires finding the number of permutations of (1,2,...,N) that satisfy given conditions. Each condition specifies that in a subarray, the maximum element should not be at a specific position. This problem can be approached using dynamic programming and bit manipulation to efficiently count valid permutations. The key is to use a DP table to store the number of valid permutations up to a certain point, considering the constraints imposed by the conditions.", "question_id": "arc183_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    // Initialize the sequence with the first sequence\n    int *sequence = (int *)malloc(n * k * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < k; j++) {\n            sequence[i * k + j] = i + 1;\n        }\n    }\n\n    // Generate the lexicographically third sequence\n    for (int i = 0; i < n * k - 2; i++) {\n        int min_index = i;\n        for (int j = i + 1; j < n * k; j++) {\n            if (sequence[j] < sequence[min_index]) {\n                min_index = j;\n            }\n        }\n        if (min_index != i) {\n            int temp = sequence[min_index];\n            sequence[min_index] = sequence[i];\n            sequence[i] = temp;\n        }\n    }\n\n    // Print the sequence\n    for (int i = 0; i < n * k; i++) {\n        printf(\"%d\", sequence[i]);\n        if (i != n * k - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    // Free the allocated memory\n    free(sequence);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate the lexicographically \nthird sequence of length NK where each integer from 1 to N appears exactly K times. \nHere's a step-by-step approach to achieve this:", "question_id": "arc183_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 250000\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GQueue *queue = g_queue_new();\n    int leaves[MAXN];\n    int leaf_count = 0;\n\n    // Read input and add leaves to the queue\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        if (a == 1) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(b));\n            leaves[leaf_count++] = b;\n        } else if (b == 1) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(a));\n            leaves[leaf_count++] = a;\n        }\n    }\n\n    // Process operations to maximize score\n    for (int i = 0; i < n / 2; i++) {\n        int leaf1 = g_queue_pop_head(queue);\n        int leaf2 = g_queue_pop_tail(queue);\n        printf(\"%d %d\n\", leaf1, leaf2);\n    }\n\n    // Free memory\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "To maximize the total score of removing leaves from the tree, we need to consider the structure of the tree and the distances between leaves. The given tree is a perfect binary tree, and the leaves are located at the outermost level. To maximize the score, we should always remove the two farthest leaves available at each step. In a perfect binary tree, the farthest leaves are located at opposite ends of the longest path. Therefore, we can traverse the tree from the root and always choose the two leaves that are at the opposite ends of the longest path. This can be done by maintaining a queue of leaves and always choosing the two leaves that are at the opposite ends of the queue.", "question_id": "arc183_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to check if a given maximum number of people can be achieved\nbool canAchieveMax(int *departments, int n, int maxPeople) {\n    int groupA = 0, groupB = 0;\n    for (int i = 0; i < n; i++) {\n        if (groupA <= groupB) {\n            groupA += departments[i];\n        } else {\n            groupB += departments[i];\n        }\n        if (groupA > maxPeople || groupB > maxPeople) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *departments = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &departments[i]);\n    }\n\n    // Sort departments in descending order\n    g_array_sort(g_array_new(FALSE, FALSE, sizeof(int)), departments, n, (GCompareFunc)compare);\n\n    int low = 1, high = 0;\n    for (int i = 0; i < n; i++) {\n        high += departments[i];\n    }\n\n    int result = high;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (canAchieveMax(departments, n, mid)) {\n            result = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    printf(\"%d\n\", result);\n\n    free(departments);\n    return 0;\n}", "reasoning": "To solve this problem, we need to minimize the maximum number of people taking lunch breaks in either group. This can be achieved by using a binary search approach combined with a greedy algorithm. Here's a step-by-step breakdown of the solution:\n\n1. **Binary Search Setup**: We will perform a binary search on the possible maximum number of people in either group. The lower bound will be 1 (the smallest possible number of people in a group), and the upper bound will be the sum of all people in all departments (the largest possible number of people in a single group).\n\n2. **Greedy Algorithm**: For each midpoint value in our binary search, we will use a greedy approach to assign departments to groups. We will sort the departments in descending order of their sizes and try to assign them to the group with the smaller current total until it exceeds the midpoint value. If it does, we move the department to the other group.\n\n3. **Check Feasibility**: After assigning departments, we check if either group exceeds the midpoint value. If it does, we know the midpoint is too small, and we need to increase the lower bound. Otherwise, we can try a smaller midpoint value.\n\n4. **Optimal Result**: The binary search will converge to the minimum possible value of the maximum number of people in either group.", "question_id": "abc374_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, K, X;\n    scanf(\"%d %d %d\", &N, &K, &X);\n\n    int *T = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &T[i]);\n    }\n\n    qsort(T, N, sizeof(int), compare);\n\n    int *next_shipment = (int *)malloc((N + 1) * sizeof(int));\n    memset(next_shipment, 0, (N + 1) * sizeof(int));\n\n    int dissatisfaction = 0;\n    int current_shipment = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (i > 0 && T[i] == T[i - 1]) {\n            current_shipment++;\n        } else {\n            current_shipment = 1;\n        }\n\n        if (current_shipment > K) {\n            int next = T[i] + X;\n            for (int j = i - 1; j >= 0 && T[j] >= next; j--) {\n                dissatisfaction += T[j] - next;\n                next += X;\n            }\n            i = j;\n        } else {\n            next_shipment[i + 1] = T[i] + X;\n        }\n    }\n\n    printf(\"%d\\n\", dissatisfaction);\n\n    free(T);\n    free(next_shipment);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to minimize the total dissatisfaction accumulated over all orders. The key is to schedule shipments in a way that balances the number of orders shipped together and respects the constraints on shipping dates and intervals between shipments. Here's a step-by-step approach to achieve this:", "question_id": "abc374_f"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[101], T[101];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int len1 = strlen(S);\n    int len2 = strlen(T);\n    int min_len = (len1 < len2) ? len1 : len2;\n\n    for (int i = 0; i < min_len; i++) {\n        if (S[i] != T[i]) {\n            printf(\"%d\n\", i + 1);\n            return 0;\n        }\n    }\n\n    if (len1 != len2) {\n        printf(\"%d\n\", min_len + 1);\n    } else {\n        printf(\"0\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to compare two strings S and T character by character. The goal is to find the first position where the characters differ or determine if the strings are identical. We will iterate through both strings simultaneously, comparing characters at each position. If we find a difference, we return the position (1-based index). If we reach the end of both strings without finding a difference, we return 0, indicating the strings are identical.", "question_id": "abc374_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <glib.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point p1, p2;\n} Line;\n\n// Calculate Euclidean distance between two points\ndouble distance(Point p1, Point p2) {\n    return sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n}\n\n// Function to compare two lines based on their starting points\nint compare_lines(const void *a, const void *b) {\n    Line *l1 = (Line *)a;\n    Line *l2 = (Line *)b;\n    return (l1->p1.x != l2->p1.x) ? l1->p1.x - l2->p1.x : l1->p1.y - l2->p1.y;\n}\n\n// Calculate the minimum time to print all line segments\ndouble min_time(int n, int S, int T, Line lines[]) {\n    qsort(lines, n, sizeof(Line), compare_lines);\n\n    double total_time = 0.0;\n    Point current = {0, 0};\n\n    for (int i = 0; i < n; i++) {\n        Line *line = &lines[i];\n        double dist = distance(current, line->p1);\n        total_time += dist / S;\n        current = line->p1;\n\n        dist = distance(current, line->p2);\n        total_time += dist / T;\n        current = line->p2;\n    }\n\n    return total_time;\n}\n\nint main() {\n    int n, S, T;\n    scanf(\"%d %d %d\", &n, &S, &T);\n\n    Line lines[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d\", &lines[i].p1.x, &lines[i].p1.y, &lines[i].p2.x, &lines[i].p2.y);\n    }\n\n    double result = min_time(n, S, T, lines);\n    printf(\"%.15f\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the minimum time required to print all the line segments. The key observation is that we can move the laser between line segments without emitting it, but we need to emit it to print each segment. The time to move the laser between segments is calculated based on the Euclidean distance between the endpoints of the segments. The time to print each segment is calculated based on the length of the segment divided by the printing speed T. We need to consider overlapping segments and ensure that we emit the laser only when necessary.", "question_id": "abc374_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_NAME_LEN 2\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *names = g_hash_table_new(g_str_hash, g_str_equal);\n    GArray *ng_list = g_array_new(FALSE, FALSE, sizeof(char*));\n\n    for (int i = 0; i < n; i++) {\n        char name[MAX_NAME_LEN + 1];\n        scanf(\"%s\", name);\n        g_hash_table_insert(names, name, GINT_TO_POINTER(1));\n    }\n\n    for (int i = 0; i < n; i++) {\n        char name[MAX_NAME_LEN + 1];\n        scanf(\"%s\", name);\n\n        bool found = false;\n        for (gpointer key = g_hash_table_get_first_key(names); key != NULL; key = g_hash_table_get_next_key(names, key)) {\n            char *ng_name = (char*)key;\n            if (strstr(ng_name, name) != NULL) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            char *new_ng_name = (char*)malloc(MAX_NAME_LEN * (n + 1));\n            strcpy(new_ng_name, name);\n\n            for (int j = 0; j < n; j++) {\n                char ng_name[MAX_NAME_LEN + 1];\n                scanf(\"%s\", ng_name);\n                strcat(new_ng_name, ng_name);\n            }\n\n            g_array_append_val(ng_list, new_ng_name);\n        }\n    }\n\n    printf(\"%d\\n\", ng_list->len);\n\n    for (int i = 0; i < ng_list->len; i++) {\n        char *ng_name = g_array_index(ng_list, char*, i);\n        free(ng_name);\n    }\n\n    g_hash_table_destroy(names);\n    g_array_free(ng_list, TRUE);\n\n    return 0;\n}", "reasoning": "The problem requires us to create an NG list with the minimum number of strings such that each already used product name is a substring of at least one string in the list, and no string contains a length-2 substring that is not an already used product name. To achieve this, we can use a greedy approach by constructing the NG list one by one, ensuring that each added string covers as many unused product names as possible without violating the constraints.", "question_id": "abc374_g"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    // Read input string S\n    char S[31];  // Ensure enough space for the string and the null terminator\n    scanf(\"%s\", S);\n\n    // Check if the string ends with 'san'\n    int len = strlen(S);\n    if (len >= 3 && strcmp(S + len - 3, \"san\") == 0) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to check if the given string S ends with the substring 'san'. Here's a step-by-step approach to achieve this:", "question_id": "abc374_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_PROCESSES 100\n#define MAX_VALUE 10000000\n\ntypedef struct {\n    int A, P, B, Q;\n} Process;\n\n// Function to check if a given production capacity can be achieved within the budget\nbool canAchieveCapacity(Process processes[], int n, int budget, int capacity) {\n    int totalCost = 0;\n    for (int i = 0; i < n; i++) {\n        int S_units = (capacity + processes[i].A - 1) / processes[i].A; // Ceiling division\n        int T_units = (capacity + processes[i].B - 1) / processes[i].B; // Ceiling division\n        int cost = S_units * processes[i].P + T_units * processes[i].Q;\n        if (cost > budget) {\n            return false;\n        }\n        totalCost += cost;\n    }\n    return totalCost <= budget;\n}\n\nint main() {\n    int n, budget;\n    scanf(\"%d %d\", &n, &budget);\n\n    Process processes[MAX_PROCESSES];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d\", &processes[i].A, &processes[i].P, &processes[i].B, &processes[i].Q);\n    }\n\n    int low = 0, high = MAX_VALUE;\n    int result = 0;\n\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (canAchieveCapacity(processes, n, budget, mid)) {\n            result = mid;\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maximize the production capacity given a budget constraint. The production capacity for each process is determined by the minimum production rate achievable with the available machines. We can approach this problem using a binary search on the production capacity. For each capacity value, we check if it's possible to achieve that capacity within the given budget by using a greedy approach to allocate machines to processes.", "question_id": "abc374_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int A[n], B[n];\n    int team_strength[4] = {0};\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n        team_strength[A[i]] += B[i];\n    }\n\n    int total_strength = team_strength[1] + team_strength[2] + team_strength[3];\n    if (total_strength % 3 != 0) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int target_strength = total_strength / 3;\n\n    int switches = 0;\n    GHashTable *excess = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *deficit = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        if (team_strength[A[i]] > target_strength) {\n            g_hash_table_insert(excess, GINT_TO_POINTER(A[i]), GINT_TO_POINTER(team_strength[A[i]] - target_strength));\n        } else if (team_strength[A[i]] < target_strength) {\n            g_hash_table_insert(deficit, GINT_TO_POINTER(A[i]), GINT_TO_POINTER(target_strength - team_strength[A[i]]));\n        }\n    }\n\n    int *excess_vals = g_hash_table_get_values(excess);\n    int *deficit_vals = g_hash_table_get_values(deficit);\n\n    int excess_count = g_hash_table_size(excess);\n    int deficit_count = g_hash_table_size(deficit);\n\n    if (excess_count != deficit_count) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    for (int i = 0; i < excess_count; i++) {\n        int need = GPOINTER_TO_INT(deficit_vals[i]);\n        int have = GPOINTER_TO_INT(excess_vals[i]);\n\n        if (need > have) {\n            switches += have;\n        } else {\n            switches += need;\n        }\n    }\n\n    printf(\"%d\\n\", switches);\n\n    g_hash_table_destroy(excess);\n    g_hash_table_destroy(deficit);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if it's possible to balance the strength of three teams by switching members between them. The key steps are:\n1. Calculate the total strength of all teams.\n2. Check if the total strength is divisible by 3. If not, it's impossible to balance the teams.\n3. If divisible by 3, calculate the target strength for each team.\n4. Use a combination of hash maps and sorting to find the minimum number of switches required.\n5. If the minimum number of switches exceeds the total number of members, it's not possible to balance the teams.", "question_id": "abc375_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    double total_cost = 0.0;\n    double x_prev = 0.0, y_prev = 0.0;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n\n        double distance = sqrt((x - x_prev) * (x - x_prev) + (y - y_prev) * (y - y_prev));\n        total_cost += distance;\n\n        x_prev = x;\n        y_prev = y;\n    }\n\n    // Add the cost of returning to the origin\n    total_cost += sqrt(x_prev * x_prev + y_prev * y_prev);\n\n    printf(\"%.10f\\n\", total_cost);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the total cost of Takahashi's journey, which involves moving from the origin to each of the N points and then returning to the origin. The cost of moving from point (a, b) to point (c, d) is given by the Euclidean distance formula: sqrt((a - c)^2 + (b - d)^2). We can use a loop to iterate through each point, calculate the cost of moving to that point from the previous point, and accumulate the total cost. Finally, we need to add the cost of moving from the last point back to the origin. To handle large numbers and ensure precision, we will use the sqrt function from the math.h library.", "question_id": "abc375_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define N 3000\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char grid[N][N];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i < n / 2; i++) {\n        for (int x = i; x <= n - 1 - i; x++) {\n            int y = n - 1 - x;\n            char temp = grid[x][y];\n            grid[x][y] = grid[i][x];\n            grid[i][x] = temp;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i]);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the operations on the grid as described. The operations involve flipping the colors of cells in a specific pattern. Here's a step-by-step approach to solve the problem:", "question_id": "abc375_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[200001];\n    scanf(\"%s\", s);\n\n    int count = 0;\n    for (int i = 0; i < n - 2; i++) {\n        if (s[i] == '#' && s[i + 1] == '.' && s[i + 2] == '#') {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to iterate through the given string S and check for each seat i if it satisfies the condition that seats i and i + 2 are occupied, and seat i + 1 is unoccupied. We can use a simple loop to traverse the string and count the number of such valid positions.", "question_id": "abc375_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[200001];\n    scanf(\"%s\", S);\n    int n = strlen(S);\n\n    GHashTable *count = g_hash_table_new(g_str_hash, g_str_equal);\n    long long result = 0;\n\n    for (int j = 1; j < n - 1; j++) {\n        char ch = S[j];\n\n        // Count pairs (i, k) such that S[i] == S[k] and i < j < k\n        char key[3];\n        key[0] = S[0];\n        key[1] = ch;\n        key[2] = S[n - 1];\n        gpointer value = g_hash_table_lookup(count, key);\n        if (value) {\n            result += GPOINTER_TO_INT(value);\n        }\n\n        // Update the hash table with the current character positions\n        for (int i = 0; i < j; i++) {\n            char key[2];\n            key[0] = S[i];\n            key[1] = S[j];\n            value = g_hash_table_lookup(count, key);\n            if (value) {\n                g_hash_table_insert(count, key, GINT_TO_POINTER(GPOINTER_TO_INT(value) + 1));\n            } else {\n                g_hash_table_insert(count, key, GINT_TO_POINTER(1));\n            }\n        }\n    }\n\n    g_hash_table_destroy(count);\n\n    printf(\"%lld\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find all possible integer triples (i, j, k) such that the concatenation of S_i, S_j, and S_k forms a palindrome. A key observation is that for a string to be a palindrome, the characters at the corresponding positions from both ends must be the same. Therefore, we can use a hash map to count the occurrences of characters at specific positions to efficiently find valid triples.", "question_id": "abc375_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define INF 1000000000\n\ntypedef struct {\n    int to;\n    int weight;\n} Edge;\n\nvoid dijkstra(int n, GArray *graph[], int start, int *dist) {\n    memset(dist, INF, sizeof(int) * n);\n    dist[start] = 0;\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(start));\n\n    while (!g_queue_is_empty(queue)) {\n        int u = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n        for (int i = 0; i < graph[u]->len; i++) {\n            Edge edge = g_array_index(graph[u], Edge, i);\n            int v = edge.to;\n            int weight = edge.weight;\n\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                g_queue_push_tail(queue, GINT_TO_POINTER(v));\n            }\n        }\n    }\n\n    g_queue_free(queue);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GArray **graph = g_new(GArray *, n);\n    for (int i = 0; i < n; i++) {\n        graph[i] = g_array_new(FALSE, FALSE, sizeof(Edge));\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        a--; b--;\n        g_array_append_val(graph[a], (Edge){b, c});\n        g_array_append_val(graph[b], (Edge){a, c});\n    }\n\n    int *dist_all = g_new(int, n);\n    dijkstra(n, graph, 0, dist_all);\n\n    for (int i = 0; i < m; i++) {\n        int *dist_removed = g_new(int, n);\n        dijkstra(n, graph, 0, dist_removed);\n\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        a--; b--;\n\n        for (int j = 0; j < graph[a]->len; j++) {\n            Edge edge = g_array_index(graph[a], Edge, j);\n            if (edge.to == b) {\n                g_array_remove_index(graph[a], j);\n                break;\n            }\n        }\n\n        for (int j = 0; j < graph[b]->len; j++) {\n            Edge edge = g_array_index(graph[b], Edge, j);\n            if (edge.to == a) {\n                g_array_remove_index(graph[b], j);\n                break;\n            }\n        }\n\n        if (dist_all[n - 1] != dist_removed[n - 1]) {\n            printf(\"Yes\\n\");\n        } else {\n            printf(\"No\\n\");\n        }\n\n        for (int j = 0; j < graph[a]->len; j++) {\n            Edge edge = g_array_index(graph[a], Edge, j);\n            if (edge.to == b) {\n                g_array_append_val(graph[a], (Edge){b, c});\n                break;\n            }\n        }\n\n        for (int j = 0; j < graph[b]->len; j++) {\n            Edge edge = g_array_index(graph[b], Edge, j);\n            if (edge.to == a) {\n                g_array_append_val(graph[b], (Edge){a, c});\n                break;\n            }\n        }\n\n        g_free(dist_removed);\n    }\n\n    for (int i = 0; i < n; i++) {\n        g_array_free(graph[i], TRUE);\n    }\n    g_free(graph);\n    g_free(dist_all);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if removing each road affects the shortest path from city 1 to city N. We can use Dijkstra's algorithm to find the shortest path in both scenarios: with all roads and with all roads except one. By comparing the results, we can determine if the shortest path is different when the road is removed.", "question_id": "abc375_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define INF 1000000000\n\n// Function to compare two integers for qsort\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, M, Q;\n    scanf(\"%d %d %d\", &N, &M, &Q);\n\n    // Adjacency list for the graph\n    GArray *adj[N + 1];\n    for (int i = 1; i <= N; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Array to store the cost of each edge\n    int cost[M + 1];\n\n    // Array to store the state of each edge (closed or open)\n    bool closed[M + 1];\n    memset(closed, false, sizeof(closed));\n\n    // Read the edges and their costs\n    for (int i = 1; i <= M; i++) {\n        int A, B, C;\n        scanf(\"%d %d %d\", &A, &B, &C);\n        g_array_append_val(adj[A], B);\n        g_array_append_val(adj[B], A);\n        cost[i] = C;\n    }\n\n    // Process each query\n    for (int q = 0; q < Q; q++) {\n        int type;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            int i;\n            scanf(\"%d\", &i);\n            closed[i] = true;\n        } else if (type == 2) {\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n\n            // Create a new adjacency list excluding the closed roads\n            GArray *adj_new[N + 1];\n            for (int i = 1; i <= N; i++) {\n                adj_new[i] = g_array_new(FALSE, FALSE, sizeof(int));\n            }\n\n            for (int i = 1; i <= M; i++) {\n                if (!closed[i]) {\n                    int A = i == 1 ? 1 : 2;\n                    int B = i == 1 ? 2 : 1;\n                    g_array_append_val(adj_new[A], B);\n                    g_array_append_val(adj_new[B], A);\n                }\n            }\n\n            // Use Dijkstra's algorithm to find the shortest path\n            int dist[N + 1];\n            for (int i = 1; i <= N; i++) {\n                dist[i] = INF;\n            }\n            dist[x] = 0;\n\n            GPriorityQueue *pq = g_priority_queue_new((GCompareFunc)compare);\n            g_priority_queue_push(pq, GINT_TO_POINTER(x), 0);\n\n            while (!g_priority_queue_is_empty(pq)) {\n                int u = GPOINTER_TO_INT(g_priority_queue_pop_head(pq));\n\n                for (int i = 0; i < adj_new[u]->len; i++) {\n                    int v = g_array_index(adj_new[u], int, i);\n                    if (dist[u] + cost[i] < dist[v]) {\n                        dist[v] = dist[u] + cost[i];\n                        g_priority_queue_push(pq, GINT_TO_POINTER(v), dist[v]);\n                    }\n                }\n            }\n\n            g_priority_queue_unref(pq);\n\n            // Free the new adjacency list\n            for (int i = 1; i <= N; i++) {\n                g_array_free(adj_new[i], TRUE);\n            }\n\n            if (dist[y] == INF) {\n                printf(\"-1\\n\");\n            } else {\n                printf(\"%d\\n\", dist[y]);\n            }\n        }\n    }\n\n    // Free the adjacency list\n    for (int i = 1; i <= N; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently handle the dynamic nature of the road network, where roads can be closed and we need to find the shortest path between cities. Given the constraints, a suitable data structure for the graph is a adjacency list, and we can use Dijkstra's algorithm to find the shortest paths. However, since roads can be closed, we need to maintain a list of closed roads and adjust our graph accordingly. We will use a priority queue to implement Dijkstra's algorithm and a hash table to keep track of the shortest distances.", "question_id": "abc375_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    // Initialize current positions of left and right hands\n    int left_hand = 1;\n    int right_hand = 2;\n\n    // Initialize total operations counter\n    int total_operations = 0;\n\n    // Process each instruction\n    for (int i = 0; i < q; i++) {\n        char hand;\n        int target;\n        scanf(\"%c %d\", &hand, &target);\n\n        if (hand == 'L') {\n            // Move left hand to target part\n            int steps = abs(target - left_hand);\n            if (right_hand != target) {\n                total_operations += steps;\n                left_hand = target;\n            }\n        } else if (hand == 'R') {\n            // Move right hand to target part\n            int steps = abs(target - right_hand);\n            if (left_hand != target) {\n                total_operations += steps;\n                right_hand = target;\n            }\n        }\n    }\n\n    // Output the total number of operations\n    printf(\"%d\\n\", total_operations);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the movement of the left and right hands around the ring according to the given instructions. The key is to keep track of the current positions of both hands and calculate the minimum number of operations required to move each hand to the target part. We can use a loop to process each instruction and update the hand positions accordingly. The total number of operations will be accumulated and printed at the end.", "question_id": "abc376_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n\n        GArray *edges = g_hash_table_lookup(adj_list, GINT_TO_POINTER(a));\n        if (edges == NULL) {\n            edges = g_array_new(FALSE, FALSE, sizeof(int));\n            g_hash_table_insert(adj_list, GINT_TO_POINTER(a), edges);\n        }\n        g_array_append_val(edges, b);\n    }\n\n    int *dist = malloc((n + 1) * sizeof(int));\n    for (int i = 0; i <= n; i++) {\n        dist[i] = INT_MAX;\n    }\n\n    dist[1] = 0;\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(1));\n\n    bool found_cycle = false;\n    int min_edges = INT_MAX;\n\n    while (!g_queue_is_empty(queue)) {\n        int u = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n        GArray *edges = g_hash_table_lookup(adj_list, GINT_TO_POINTER(u));\n        if (edges != NULL) {\n            for (gsize i = 0; i < edges->len; i++) {\n                int v = g_array_index(edges, int, i);\n\n                if (dist[u] + 1 < dist[v]) {\n                    dist[v] = dist[u] + 1;\n                    g_queue_push_tail(queue, GINT_TO_POINTER(v));\n                }\n\n                if (v == 1) {\n                    found_cycle = true;\n                    min_edges = dist[u] + 1;\n                }\n            }\n        }\n    }\n\n    if (found_cycle) {\n        printf(\"%d\n\", min_edges);\n    } else {\n        printf(\"-1\n\");\n    }\n\n    g_hash_table_destroy(adj_list);\n    g_queue_free(queue);\n    free(dist);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exists a cycle that contains vertex 1 and find the minimum number of edges in such a cycle. Here's a step-by-step approach to achieve this:", "question_id": "abc376_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int *parent;\n    int *prob;\n    GArray *children;\n} Node;\n\ntypedef struct {\n    GHashTable *dp;\n} Solution;\n\nvoid init_node(Node *node, int *parent, int *prob, int n) {\n    node->parent = parent;\n    node->prob = prob;\n    node->children = g_array_new(FALSE, FALSE, sizeof(int));\n}\n\nvoid add_child(Node *node, int child) {\n    g_array_append_val(node->children, child);\n}\n\nvoid free_node(Node *node) {\n    g_array_free(node->children, TRUE);\n}\n\nvoid init_solution(Solution *sol) {\n    sol->dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n}\n\nvoid free_solution(Solution *sol) {\n    g_hash_table_destroy(sol->dp);\n}\n\nint dfs(Node *node, Solution *sol, int *sum_prob) {\n    int node_id = g_array_index(node->children, int, 0);\n    int parent_id = node->parent[node_id];\n\n    if (g_hash_table_contains(sol->dp, GINT_TO_POINTER(parent_id))) {\n        return GPOINTER_TO_INT(g_hash_table_lookup(sol->dp, GINT_TO_POINTER(parent_id)));\n    }\n\n    int expected = 0;\n    int total_prob = 0;\n\n    for (int i = 0; i < node->children->len; i++) {\n        int child_id = g_array_index(node->children, int, i);\n        int child_prob = node->prob[child_id];\n\n        total_prob += child_prob;\n        expected += dfs(node, sol, sum_prob) + child_prob;\n    }\n\n    expected = (expected * sum_prob[node_id]) / total_prob;\n    g_hash_table_insert(sol->dp, GINT_TO_POINTER(parent_id), GINT_TO_POINTER(expected));\n\n    return expected;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N;\n        scanf(\"%d\", &N);\n\n        int *parent = (int *)malloc(N * sizeof(int));\n        int *prob = (int *)malloc(N * sizeof(int));\n\n        for (int i = 1; i < N; i++) {\n            scanf(\"%d\", &parent[i]);\n        }\n\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &prob[i]);\n        }\n\n        Node *nodes = (Node *)malloc(N * sizeof(Node));\n\n        for (int i = 0; i < N; i++) {\n            init_node(&nodes[i], parent, prob, N);\n        }\n\n        for (int i = 1; i < N; i++) {\n            add_child(&nodes[parent[i]], i);\n        }\n\n        int sum_prob[N];\n        sum_prob[0] = 0;\n\n        for (int i = 1; i < N; i++) {\n            sum_prob[i] = sum_prob[parent[i]] + prob[i];\n        }\n\n        Solution sol;\n        init_solution(&sol);\n\n        int expected = dfs(&nodes[0], &sol, sum_prob);\n\n        printf(\"%d\\n\", expected);\n\n        for (int i = 0; i < N; i++) {\n            free_node(&nodes[i]);\n        }\n\n        free(parent);\n        free(prob);\n        free(nodes);\n        free_solution(&sol);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the expected number of operations required to find the treasure in a tree structure. The expected value can be calculated using dynamic programming and depth-first search (DFS). We will use a hash table to store the expected values for each node to avoid redundant calculations. The key insight is to calculate the expected value for each node based on the probabilities of the treasure being in its children and the expected values of those children.", "question_id": "abc376_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, C;\n    scanf(\"%d %d\", &N, &C);\n\n    int *times = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &times[i]);\n    }\n\n    int last_received = -1; // Initialize to -1 to ensure the first press always counts\n    int candy_count = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (times[i] - last_received >= C) {\n            candy_count++;\n            last_received = times[i];\n        }\n    }\n\n    printf(\"%d\n\", candy_count);\n\n    free(times);\n    return 0;\n}", "reasoning": "The problem requires determining how many candies Takahashi will receive based on the times he presses a button, given a cooldown period C. We need to iterate through the times and check if the time elapsed since the last candy is greater than or equal to C. If it is, we count it as a candy received. We use a variable to keep track of the last received candy time and increment our candy count accordingly.", "question_id": "abc376_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    // Initialize current positions of left and right hands\n    int left_hand = 1;\n    int right_hand = 2;\n\n    // Initialize total number of operations\n    int total_operations = 0;\n\n    // Process each instruction\n    for (int i = 0; i < q; i++) {\n        char hand;\n        int target;\n        scanf(\" %c %d\", &hand, &target);\n\n        // Calculate the number of operations to move the left hand\n        if (hand == 'L') {\n            if (target == left_hand) continue;\n            int operations = abs(target - left_hand);\n            if (target > left_hand) {\n                if (right_hand == target - 1) {\n                    operations -= 1;\n                }\n            } else {\n                if (right_hand == target + 1) {\n                    operations -= 1;\n                }\n            }\n            total_operations += operations;\n            left_hand = target;\n        }\n\n        // Calculate the number of operations to move the right hand\n        if (hand == 'R') {\n            if (target == right_hand) continue;\n            int operations = abs(target - right_hand);\n            if (target > right_hand) {\n                if (left_hand == target - 1) {\n                    operations -= 1;\n                }\n            } else {\n                if (left_hand == target + 1) {\n                    operations -= 1;\n                }\n            }\n            total_operations += operations;\n            right_hand = target;\n        }\n    }\n\n    // Output the total number of operations\n    printf(\"%d\\n\", total_operations);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the movements of the left and right hands on the ring to achieve the given instructions. The key is to keep track of the current positions of both hands and calculate the minimum number of operations required to move each hand to the target part for each instruction. We can use a simple loop to process each instruction and update the positions of the hands accordingly. The total number of operations is accumulated and printed at the end.", "question_id": "abc376_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    int *B = (int *)malloc((n - 1) * sizeof(int));\n    for (int i = 0; i < n - 1; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n\n    qsort(A, n, sizeof(int), compare);\n    qsort(B, n - 1, sizeof(int), compare);\n\n    int min_size = 0;\n    for (int i = 0; i < n - 1; i++) {\n        min_size = fmax(min_size, A[i] + B[i]);\n    }\n\n    int left = min_size, right = INT_MAX;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        int placed = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (mid >= A[i] + B[i]) {\n                placed++;\n            }\n        }\n        if (placed == n - 1) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    if (left >= min_size) {\n        printf(\"%d\\n\", left);\n    } else {\n        printf(\"-1\\n\");\n    }\n\n    free(A);\n    free(B);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the smallest box size x that can accommodate all the toys in separate boxes. The key insight is that we need to find the smallest box size that is greater than or equal to the maximum of the minimum sizes of the toys that can fit into the existing boxes. This is because we can always place the largest toy into the smallest available box, and then work our way down. We can use a binary search approach to find the minimum such x efficiently.", "question_id": "abc376_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MAX_N 200000\n#define MAX_T 200000\n\ntypedef struct {\n    int A[MAX_N];\n    int B[MAX_N];\n} Sequence;\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N, K;\n        scanf(\"%d %d\", &N, &K);\n\n        Sequence seq;\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &seq.A[i]);\n        }\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &seq.B[i]);\n        }\n\n        qsort(seq.A, N, sizeof(int), compare);\n        qsort(seq.B, N, sizeof(int), compare);\n\n        int min_value = INT_MAX;\n        for (int i = 0; i <= N - K; i++) {\n            int max_A = seq.A[i];\n            int sum_B = 0;\n            for (int j = 0; j < K; j++) {\n                sum_B += seq.B[i + j];\n            }\n            min_value = fmin(min_value, max_A * sum_B);\n        }\n\n        printf(\"%d\\n\", min_value);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum possible value of the expression \\\\(\\max_{i \\in S} A_i \\times \\sum_{i \\in S} B_i\\\\) for a subset S of size K from the given sequences A and B. Here's a step-by-step approach to solve it:\n\n1. **Sort the Sequences**: We need to sort the sequences A and B in descending order. This helps in easily finding the maximum element in the subset and the sum of elements in the subset.\n\n2. **Iterate Through Possible Subsets**: For each test case, we iterate through the sorted sequences to find the minimum value of the expression for all possible subsets of size K.\n\n3. **Calculate the Expression**: For each subset, we calculate the expression and keep track of the minimum value.\n\n4. **Output the Result**: Finally, we output the minimum value for each test case.", "question_id": "abc376_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashSet *capturable = g_hash_set_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n\n        for (int x = -2; x <= 2; x++) {\n            for (int y = -2; y <= 2; y++) {\n                if (abs(x) + abs(y) == 3) {\n                    int new_x = a + x;\n                    int new_y = b + y;\n\n                    if (new_x >= 1 && new_x <= N && new_y >= 1 && new_y <= N) {\n                        g_hash_set_add(capturable, GINT_TO_POINTER(new_x * 1000000 + new_y));\n                    }\n                }\n            }\n        }\n    }\n\n    long long empty_squares = (long long)N * N - g_hash_set_size(capturable);\n\n    printf(\"%lld\\n\", empty_squares);\n\n    g_hash_set_destroy(capturable);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of empty squares on an N x N grid that cannot be captured by any of the M pieces already placed on the grid. A piece can capture another piece if it is located at one of the 8 possible positions relative to the piece being captured. We can use a set to keep track of all positions that can be captured by any piece. Then, we can iterate through all possible empty squares and count those that are not in the set of capturable positions.", "question_id": "abc377_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char grid[8][9];  // 8 rows, 9 columns for null terminator\n    for (int i = 0; i < 8; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    // Initialize variables\n    int count = 0;\n    GHashTable *rows = g_hash_table_new(g_str_hash, g_str_equal);\n    GHashTable *cols = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Mark occupied rows and columns\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (grid[i][j] == '#') {\n                char row_key[2] = { (char)(i + '0'), 0 };  // Convert row index to string\n                char col_key[2] = { (char)(j + '0'), 0 };  // Convert column index to string\n                g_hash_table_insert(rows, row_key, GINT_TO_POINTER(1));\n                g_hash_table_insert(cols, col_key, GINT_TO_POINTER(1));\n            }\n        }\n    }\n\n    // Count empty squares not in occupied rows or columns\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (grid[i][j] == '.' &&\n                !g_hash_table_lookup(rows, GINT_TO_POINTER(i)) &&\n                !g_hash_table_lookup(cols, GINT_TO_POINTER(j))) {\n                count++;\n            }\n        }\n    }\n\n    // Output result\n    printf(\"%d\n\", count);\n\n    // Clean up\n    g_hash_table_destroy(rows);\n    g_hash_table_destroy(cols);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of empty squares on an 8x8 grid where placing a piece would not result in it being captured by any existing pieces. A piece is captured if it is placed on a square in the same row or column as an existing piece. Here's a step-by-step approach to solve the problem:", "question_id": "abc377_b"}
{"solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[4];\n    scanf(\"%s\", S);\n\n    int countA = 0, countB = 0, countC = 0;\n\n    // Count occurrences of each character\n    for (int i = 0; i < 3; i++) {\n        if (S[i] == 'A') countA++;\n        else if (S[i] == 'B') countB++;\n        else if (S[i] == 'C') countC++;\n    }\n\n    // Check if counts match ABC\n    if (countA == 1 && countB == 1 && countC == 1) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine if the string S can be rearranged to match the string ABC, we need to check if the characters in S are exactly 'A', 'B', and 'C' in any order. We can achieve this by counting the occurrences of each character in S and comparing them to the expected counts in the string ABC. If the counts match, then it is possible to rearrange S to match ABC; otherwise, it is not.", "question_id": "abc377_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *prefix_costs = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int k = 1; k <= n; k++) {\n        char s[100001];\n        scanf(\"%s\", s);\n\n        int len = strlen(s);\n        int min_cost = len;\n\n        for (int i = 0; i < len; i++) {\n            char prefix[100001];\n            strncpy(prefix, s, i + 1);\n            prefix[i + 1] = '\\0';\n\n            gpointer cost_ptr = g_hash_table_lookup(prefix_costs, prefix);\n            int cost = (cost_ptr) ? GPOINTER_TO_INT(cost_ptr) : 0;\n\n            min_cost = fmin(min_cost, cost + (len - i - 1));\n        }\n\n        printf(\"%d\n\", min_cost);\n\n        g_hash_table_insert(prefix_costs, strdup(s), GINT_TO_POINTER(min_cost));\n    }\n\n    g_hash_table_destroy(prefix_costs);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the minimum cost for each string S_k to either become empty or match one of the previous strings S_1, S_2, ..., S_{k-1}. The cost involves deleting characters from the end of the string and adding characters to the end. We can use dynamic programming with a hash table to keep track of the minimum cost for each prefix of the strings.", "question_id": "abc377_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAXN 1000000000\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Sets to keep track of occupied rows, columns, and diagonals\n    bool rows[MAXN] = {false};\n    bool cols[MAXN] = {false};\n    bool diags1[MAXN * 2] = {false};\n    bool diags2[MAXN * 2] = {false};\n\n    // Mark occupied rows, columns, and diagonals\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        rows[a - 1] = true;\n        cols[b - 1] = true;\n        diags1[a + b - 2] = true;\n        diags2[a - b + N - 2] = true;\n    }\n\n    // Count valid squares\n    int count = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (!rows[i - 1] && !cols[j - 1] && !diags1[i + j - 2] && !diags2[i - j + N - 2]) {\n                count++;\n            }\n        }\n    }\n\n    // Print the result\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of empty squares on an N x N grid that cannot be captured by any existing pieces. A piece can capture other pieces if it is placed in the same row, column, or diagonal as an existing piece. Here's a step-by-step approach to solve the problem:\n\n1. Read the input values for N, M, and the positions of the M pieces.\n2. Use a set to keep track of the rows, columns, and diagonals that are occupied by pieces.\n3. Iterate through each square on the grid and check if it is in any of the occupied rows, columns, or diagonals.\n4. If a square is not in any occupied row, column, or diagonal, it is a valid square to place a piece on.\n5. Count the number of valid squares and print the result.", "question_id": "abc377_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int p[MAXN];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int cycle_length = 0;\n    int current = 0;\n\n    // Find the cycle length\n    while (!g_hash_table_contains(visited, GINT_TO_POINTER(current))) {\n        g_hash_table_insert(visited, GINT_TO_POINTER(current), GINT_TO_POINTER(1));\n        current = p[current] - 1;\n        cycle_length++;\n    }\n\n    // If the cycle length is 1, the permutation does not change\n    if (cycle_length == 1) {\n        for (int i = 0; i < n; i++) {\n            printf(\"%d \", p[i] + 1);\n        }\n    } else {\n        // Find the starting point of the cycle\n        int start = 0;\n        while (start != current) {\n            start++;\n        }\n\n        // Find the position of the current element in the cycle\n        int pos = 0;\n        current = start;\n        while (current != start || pos == 0) {\n            current = p[current] - 1;\n            pos++;\n        }\n\n        // Apply the operation K times\n        for (int i = 0; i < n; i++) {\n            int new_pos = (pos + (k % cycle_length)) % cycle_length;\n            int new_start = start;\n            for (int j = 0; j < new_pos; j++) {\n                new_start = p[new_start] - 1;\n            }\n            printf(\"%d \", new_start + 1);\n        }\n    }\n\n    printf(\"\\n\");\n\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to understand the effect of the operation on the permutation P. The operation involves updating each element P_i to P_{P_i} simultaneously. This operation can be interpreted as a series of cycles in the permutation. After K operations, we need to determine the state of the permutation P. The key observation is that if the permutation is a single cycle, the cycle length determines the final state after K operations. If the cycle length is d, then after d operations, the permutation returns to its original state. Therefore, after K operations, the permutation will be in the state it would be in after K % d operations. If the permutation is not a single cycle, we need to handle each cycle separately. The solution involves identifying the cycles in the permutation and then applying the above logic to determine the final state of the permutation after K operations.", "question_id": "abc377_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GArray *L = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *R = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        g_array_append_val(L, l);\n        g_array_append_val(R, r);\n    }\n\n    int count = 0;\n\n    for (int l = 1; l <= M; l++) {\n        for (int r = l; r <= M; r++) {\n            bool valid = true;\n            for (int i = 0; i < N; i++) {\n                if (l >= g_array_index(L, int, i) && r <= g_array_index(R, int, i)) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) {\n                count++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    g_array_free(L, TRUE);\n    g_array_free(R, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find pairs (l, r) such that the interval [l, r] does not completely contain any interval [L_i, R_i] from the given sequences L and R. Here's a step-by-step approach to solve it:\n\n1. **Input Reading**: Read the input values for N, M, and the sequences L and R.\n2. **Interval Representation**: Represent each interval [L_i, R_i] as a range in the form of (L_i, R_i).\n3. **Pair Generation**: Generate all possible pairs (l, r) where 1 <= l <= r <= M.\n4. **Validation**: For each pair (l, r), check if it contains any interval [L_i, R_i]. If it does, skip it; otherwise, count it.\n5. **Output**: Print the count of valid pairs.\n\nThis approach ensures that we check all possible pairs and validate them against the given conditions.", "question_id": "abc377_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    long long result = 0;\n    for (int i = 0; i < n; i++) {\n        long long sum = 0;\n        for (int j = i; j < n; j++) {\n            sum += a[j];\n            result += (sum % m);\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n\n    free(a);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the sum of the remainders of all possible subarray sums modulo M. Here's a step-by-step approach to achieve this efficiently:", "question_id": "abc378_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_H 10\n#define MAX_W 10\n#define MAX_K 11\n\ntypedef struct {\n    int h, w, k;\n    char grid[MAX_H][MAX_W];\n} Problem;\n\ntypedef struct {\n    int x, y;\n} Point;\n\nGHashTable *visited;\n\nbool is_valid(Problem *problem, Point p) {\n    return p.x >= 0 && p.x < problem->h && p.y >= 0 && p.y < problem->w && problem->grid[p.x][p.y] == '.' && !g_hash_table_contains(visited, GINT_TO_POINTER(p.x * MAX_W + p.y));\n}\n\nvoid dfs(Problem *problem, Point current, int steps) {\n    if (steps == problem->k) {\n        g_hash_table_insert(visited, GINT_TO_POINTER(current.x * MAX_W + current.y), GINT_TO_POINTER(1));\n        return;\n    }\n    Point directions[4] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    for (int i = 0; i < 4; i++) {\n        Point next = {current.x + directions[i].x, current.y + directions[i].y};\n        if (is_valid(problem, next)) {\n            dfs(problem, next, steps + 1);\n        }\n    }\n}\n\nint count_paths(Problem *problem) {\n    visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int count = 0;\n    for (int i = 0; i < problem->h; i++) {\n        for (int j = 0; j < problem->w; j++) {\n            if (problem->grid[i][j] == '.' && !g_hash_table_contains(visited, GINT_TO_POINTER(i * MAX_W + j))) {\n                dfs(problem, (Point){i, j}, 0);\n                if (g_hash_table_contains(visited, GINT_TO_POINTER(i * MAX_W + j))) {\n                    count++;\n                }\n                g_hash_table_remove(visited, GINT_TO_POINTER(i * MAX_W + j));\n            }\n        }\n    }\n    g_hash_table_destroy(visited);\n    return count;\n}\n\nint main() {\n    Problem problem;\n    scanf(\"%d %d %d\", &problem.h, &problem.w, &problem.k);\n    for (int i = 0; i < problem.h; i++) {\n        scanf(\"%s\", problem.grid[i]);\n    }\n    int result = count_paths(&problem);\n    printf(\"%d\\n\", result);\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of valid paths of length K+1 in a grid, starting from an empty cell and moving to adjacent empty cells without revisiting any cell. This is a classic combinatorial problem that can be approached using depth-first search (DFS) with backtracking. Here's a step-by-step breakdown of the solution:", "question_id": "abc378_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Read the collection schedule for each type of garbage\n    GHashTable *schedule = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        int q, r;\n        scanf(\"%d %d\", &q, &r);\n        g_hash_table_insert(schedule, GINT_TO_POINTER(i + 1), GINT_TO_POINTER(q * (r / q + 1) + (r % q != 0 ? 1 : 0)));\n    }\n\n    int Q;\n    scanf(\"%d\", &Q);\n\n    // Process each query\n    for (int j = 0; j < Q; j++) {\n        int t, d;\n        scanf(\"%d %d\", &t, &d);\n\n        // Get the next collection day for the given type of garbage\n        int next_collection_day = GPOINTER_TO_INT(g_hash_table_lookup(schedule, GINT_TO_POINTER(t)));\n\n        // If the garbage is already collected on day d, the next collection day is the same\n        if (d % next_collection_day == 0) {\n            printf(\"%d\n\", d);\n        } else {\n            // Otherwise, find the next collection day after day d\n            int days_passed = d % next_collection_day;\n            int days_until_next_collection = next_collection_day - days_passed;\n            printf(\"%d\n\", d + days_until_next_collection);\n        }\n    }\n\n    // Clean up\n    g_hash_table_destroy(schedule);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the next collection day for each type of garbage based on the given rules. Here's a step-by-step approach to achieve this:", "question_id": "abc378_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n// Function to add an edge to the graph\nvoid add_edge(GHashTable *adj_list, int u, int v) {\n    g_hash_table_add(adj_list, GINT_TO_POINTER(u), g_array_append_val(g_array_new(FALSE, FALSE, sizeof(int)), v));\n    g_hash_table_add(adj_list, GINT_TO_POINTER(v), g_array_append_val(g_array_new(FALSE, FALSE, sizeof(int)), u));\n}\n\n// Function to check if adding an edge (u, v) forms a valid cycle with degree 3\nbool is_valid_cycle(GHashTable *adj_list, int u, int v) {\n    GArray *adj_u = g_hash_table_lookup(adj_list, GINT_TO_POINTER(u));\n    GArray *adj_v = g_hash_table_lookup(adj_list, GINT_TO_POINTER(v));\n    int degree_u = adj_u ? adj_u->len : 0;\n    int degree_v = adj_v ? adj_v->len : 0;\n    return degree_u == 2 && degree_v == 2;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read edges and build the graph\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(adj_list, u, v);\n    }\n\n    int count = 0;\n\n    // Try adding an edge between every pair of non-adjacent vertices\n    for (int u = 1; u <= n; u++) {\n        for (int v = u + 1; v <= n; v++) {\n            if (!g_hash_table_contains(adj_list, GINT_TO_POINTER(u)) || !g_hash_table_contains(adj_list, GINT_TO_POINTER(v))) {\n                continue;\n            }\n            if (is_valid_cycle(adj_list, u, v)) {\n                count++;\n            }\n        }\n    }\n\n    // Output the result\n    printf(\"%d\n\", count);\n\n    // Clean up\n    g_hash_table_destroy(adj_list);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine how many ways we can add one edge to a given tree such that the resulting graph has exactly one cycle and all vertices in the cycle have a degree of 3. Here's a step-by-step approach to solve the problem:", "question_id": "abc378_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 1000000007\n\ntypedef struct {\n    int a;\n    int b;\n    int len;\n} State;\n\ntypedef struct {\n    State key;\n    int value;\n} MemoEntry;\n\nGHashTable *memo;\n\nint hash_func(const void *key) {\n    const State *state = (const State *)key;\n    return (state->a * 1000000001 + state->b * 1000000001 + state->len) % 1000000007;\n}\n\nint equal_func(const void *a, const void *b) {\n    const State *state1 = (const State *)a;\n    const State *state2 = (const State *)b;\n    return state1->a == state2->a && state1->b == state2->b && state1->len == state2->len;\n}\n\nint dp(int a, int b, int len) {\n    State key = {a, b, len};\n    gpointer result = g_hash_table_lookup(memo, &key);\n    if (result != NULL) {\n        return GPOINTER_TO_INT(result);\n    }\n\n    if (a == 0 && b == 0) {\n        return 1;\n    }\n\n    int count = 0;\n\n    if (a > 0) {\n        for (int i = 1; i <= len; i++) {\n            count = (count + dp(a - 1, b, i - 1)) % MOD;\n        }\n    }\n\n    if (b > 0) {\n        for (int i = 1; i <= len; i++) {\n            count = (count + dp(a, b - 1, i - 1)) % MOD;\n        }\n    }\n\n    g_hash_table_insert(memo, &key, GINT_TO_POINTER(count));\n    return count;\n}\n\nint main() {\n    int a, b, m;\n    scanf(\"%d %d %d\", &a, &b, &m);\n\n    memo = g_hash_table_new(hash_func, equal_func);\n\n    int result = dp(a, b, a + b - 1);\n\n    g_hash_table_destroy(memo);\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of permutations of (1, 2, ..., AB-1) that satisfy the given conditions. The conditions are that the length of the longest increasing subsequence (LIS) is A, the length of the longest decreasing subsequence (LDS) is B, and appending n + 0.5 to the end of the permutation does not change either the LIS or the LDS. Given the constraints, we can use dynamic programming with memoization to count the valid permutations. We will use a hash table to store the results of subproblems to avoid redundant calculations.", "question_id": "abc378_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int a[4];\n    for (int i = 0; i < 4; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < 4; i++) {\n        int *val = (int *)g_hash_table_lookup(count, GINT_TO_POINTER(a[i]));\n        if (val == NULL) {\n            g_hash_table_insert(count, GINT_TO_POINTER(a[i]), GINT_TO_POINTER(1));\n        } else {\n            *val += 1;\n        }\n    }\n\n    int result = 0;\n    for (gpointer key, value; g_hash_table_iter_init(&iter, count); g_hash_table_iter_next(&iter, &key, &value)) {\n        int occurrences = GPOINTER_TO_INT(value);\n        result += occurrences / 2;\n    }\n\n    printf(\"%d\n\", result);\n\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "The problem involves finding the maximum number of pairs of balls that can be discarded because they have the same color. To solve this, we can use a hash table to count the occurrences of each ball color. For each color, we can perform as many operations as the number of pairs we can form from the occurrences of that color. Since we can only pair two balls of the same color, we divide the count by 2 and take the floor of the result to get the number of pairs.", "question_id": "abc378_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize the hash table to store the most recent index of each element\n    GHashTable *last_index = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initialize the array to store the result\n    int *b = (int *)malloc(n * sizeof(int));\n\n    // Iterate through the sequence A\n    for (int i = 0; i < n; i++) {\n        int a_i;\n        scanf(\"%d\", &a_i);\n\n        // Check if the element has appeared before\n        gpointer index = g_hash_table_lookup(last_index, GINT_TO_POINTER(a_i));\n        if (index != NULL) {\n            // Store the most recent index in the result array\n            b[i] = GPOINTER_TO_INT(index);\n        } else {\n            // If the element has not appeared before, store -1\n            b[i] = -1;\n        }\n\n        // Update the most recent index of the current element\n        g_hash_table_insert(last_index, GINT_TO_POINTER(a_i), GINT_TO_POINTER(i));\n    }\n\n    // Print the result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", b[i]);\n    }\n    printf(\"\\n\");\n\n    // Free the memory\n    free(b);\n    g_hash_table_destroy(last_index);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to keep track of the most recent positions of each element in the sequence A. We can use a hash table to store the most recent index of each element. As we iterate through the sequence, we can use this hash table to determine the most recent position of the current element and store it in the corresponding position in the sequence B. If the current element has not appeared before, we store -1 in the sequence B.", "question_id": "abc378_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    char s[101];\n    scanf(\"%s\", s);\n\n    int count = 0;\n    int healthy = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'O') {\n            healthy++;\n            if (healthy == k) {\n                count++;\n                healthy = 0;\n            }\n        } else {\n            healthy = 0;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum number of strawberries Takahashi can eat. Each strawberry is eaten using K consecutive healthy teeth, and after eating, those teeth become cavities. We can use a sliding window approach to count the number of consecutive healthy teeth and determine how many strawberries can be eaten.", "question_id": "abc379_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[200001];\n    scanf(\"%s\", s);\n\n    GHashTable *prefix_sum = g_hash_table_new(g_str_hash, g_str_equal);\n    g_hash_table_insert(prefix_sum, \"0\", GINT_TO_POINTER(0));\n\n    long long result = 0;\n    long long current_sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        int digit = s[i] - '0';\n        current_sum = (current_sum * 10 + digit) % 1000000007;\n        result = (result + current_sum) % 1000000007;\n\n        char key[20];\n        sprintf(key, \"%lld\", current_sum);\n        gpointer value = g_hash_table_lookup(prefix_sum, key);\n        if (value) {\n            int count = GPOINTER_TO_INT(value);\n            result = (result + count * (i + 1)) % 1000000007;\n        }\n\n        g_hash_table_insert(prefix_sum, key, GINT_TO_POINTER(1 + GPOINTER_TO_INT(value)));\n    }\n\n    printf(\"%lld\\n\", result);\n\n    g_hash_table_destroy(prefix_sum);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the sum of all possible substrings of a given string S, where each substring is interpreted as a decimal integer. The key observation is that each digit in the string contributes to multiple substrings, and we can use this observation to optimize our solution.", "question_id": "abc379_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < m; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        int *count = (int *)g_hash_table_lookup(map, GINT_TO_POINTER(x));\n        if (count == NULL) {\n            count = (int *)malloc(sizeof(int));\n            *count = 0;\n            g_hash_table_insert(map, GINT_TO_POINTER(x), count);\n        }\n        (*count)++;\n    }\n\n    int total_stones = 0;\n    int max_stones = 0;\n\n    for (GList *node = g_hash_table_get_keys(map); node != NULL; node = node->next) {\n        int *count = (int *)g_hash_table_lookup(map, node->data);\n        total_stones += *count;\n        max_stones = MAX(max_stones, *count);\n    }\n\n    if (total_stones != n) {\n        printf(\"-1\n\");\n        g_hash_table_destroy(map);\n        return 0;\n    }\n\n    int operations = 0;\n\n    for (GList *node = g_hash_table_get_keys(map); node != NULL; node = node->next) {\n        int *count = (int *)g_hash_table_lookup(map, node->data);\n        operations += abs(*count - 1);\n    }\n\n    printf(\"%d\n\", operations);\n\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "reasoning": "The problem requires finding the minimum number of operations to distribute stones in N cells such that each cell contains exactly one stone. The operation allows moving one stone from cell i to cell i+1. To solve this, we need to calculate the total number of stones and check if it is possible to distribute them in N cells. If the total number of stones is not equal to N, it is impossible to achieve the goal. Otherwise, we need to calculate the minimum number of operations required to move the stones to the correct positions.", "question_id": "abc379_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_QUERIES 200000\n\nint main() {\n    // Read input\n    int Q;\n    scanf(\"%d\", &Q);\n\n    // Prepare data structures\n    GQueue *queue = g_queue_new();  // To keep track of plant growth\n    GHashTable *height_count = g_hash_table_new(g_direct_hash, g_direct_equal);  // To count plants by height\n    GArray *harvested_count = g_array_new(FALSE, FALSE, sizeof(int));  // To store results of type 3 queries\n\n    // Process each query\n    for (int i = 0; i < Q; i++) {\n        int query_type;\n        scanf(\"%d\", &query_type);\n\n        if (query_type == 1) {\n            // Plant a new plant of height 0\n            g_queue_push_tail(queue, GINT_TO_POINTER(0));\n            g_hash_table_insert(height_count, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n        } else if (query_type == 2) {\n            // Wait for T days\n            int T;\n            scanf(\"%d\", &T);\n            int n = g_queue_get_length(queue);\n            for (int j = 0; j < n; j++) {\n                int *height = g_queue_pop_head(queue);\n                *height += T;\n                g_queue_push_tail(queue, height);\n                g_hash_table_insert(height_count, GINT_TO_POINTER(*height), GINT_TO_POINTER(g_hash_table_lookup(height_count, GINT_TO_POINTER(*height)) + 1));\n            }\n        } else if (query_type == 3) {\n            // Harvest plants with height at least H\n            int H;\n            scanf(\"%d\", &H);\n            int count = 0;\n            while (g_queue_get_length(queue) > 0) {\n                int *height = g_queue_peek_head(queue);\n                if (*height < H) {\n                    break;\n                }\n                g_queue_pop_head(queue);\n                count++;\n                g_hash_table_insert(height_count, GINT_TO_POINTER(*height), GINT_TO_POINTER(g_hash_table_lookup(height_count, GINT_TO_POINTER(*height)) - 1));\n                if (g_hash_table_lookup(height_count, GINT_TO_POINTER(*height)) == 0) {\n                    g_hash_table_remove(height_count, GINT_TO_POINTER(*height));\n                }\n            }\n            g_array_append_val(harvested_count, count);\n        }\n    }\n\n    // Output results of type 3 queries\n    for (int i = 0; i < harvested_count->len; i++) {\n        printf(\"%d\n\", g_array_index(harvested_count, int, i));\n    }\n\n    // Clean up\n    g_queue_free(queue);\n    g_hash_table_destroy(height_count);\n    g_array_free(harvested_count, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of planting, growing, and harvesting plants. Given the constraints, a direct approach using arrays or lists would be impractical due to the large number of plants. Instead, we can use a combination of hash tables and queues to efficiently manage the plants and their growth. Here's a step-by-step breakdown of the solution approach:", "question_id": "abc379_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int n;\n    int m;\n    int **grid;\n    GArray *adj[200];\n} Grid;\n\nvoid init_grid(Grid *g, int H, int W) {\n    g->n = H;\n    g->m = W;\n    g->grid = (int **)malloc(H * sizeof(int *));\n    for (int i = 0; i < H; i++) {\n        g->grid[i] = (int *)malloc(W * sizeof(int));\n    }\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            g->grid[i][j] = 0;\n        }\n    }\n    for (int i = 0; i < 200; i++) {\n        g->adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n}\n\nvoid free_grid(Grid *g) {\n    for (int i = 0; i < g->n; i++) {\n        free(g->grid[i]);\n    }\n    free(g->grid);\n    for (int i = 0; i < 200; i++) {\n        g_array_free(g->adj[i], TRUE);\n    }\n}\n\nvoid build_adjacency_list(Grid *g) {\n    for (int i = 0; i < g->n; i++) {\n        for (int j = 0; j < g->m; j++) {\n            if (i > 0 && g->grid[i - 1][j] == 0) {\n                g_array_append_val(g->adj[g->m * i + j], g->m * (i - 1) + j);\n            }\n            if (i < g->n - 1 && g->grid[i + 1][j] == 0) {\n                g_array_append_val(g->adj[g->m * i + j], g->m * (i + 1) + j);\n            }\n            if (j > 0 && g->grid[i][j - 1] == 0) {\n                g_array_append_val(g->adj[g->m * i + j], g->m * i + (j - 1));\n            }\n            if (j < g->m - 1 && g->grid[i][j + 1] == 0) {\n                g_array_append_val(g->adj[g->m * i + j], g->m * i + (j + 1));\n            }\n        }\n    }\n}\n\nint dfs(Grid *g, int node, int prev, int *visited) {\n    if (visited[node]) {\n        return 0;\n    }\n    visited[node] = 1;\n    int count = 1;\n    GArray *neighbors = g->adj[node];\n    for (int i = 0; i < neighbors->len; i++) {\n        int neighbor = g_array_index(neighbors, int, i);\n        if (g->grid[neighbor / g->m][neighbor % g->m] != 0 && g->grid[neighbor / g->m][neighbor % g->m] != prev) {\n            count = (count + dfs(g, neighbor, g->grid[neighbor / g->m][neighbor % g->m], visited)) % MOD;\n        }\n    }\n    return count;\n}\n\nint count_valid_grids(Grid *g) {\n    int total_count = 1;\n    for (int i = 0; i < g->n; i++) {\n        for (int j = 0; j < g->m; j++) {\n            if (g->grid[i][j] == 0) {\n                int *visited = (int *)calloc(g->n * g->m, sizeof(int));\n                total_count = (total_count * dfs(g, g->m * i + j, 0, visited)) % MOD;\n                free(visited);\n            }\n        }\n    }\n    return total_count;\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    Grid g;\n    init_grid(&g, H, W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            char ch;\n            scanf(\"%c\", &ch);\n            if (ch == '1') {\n                g.grid[i][j] = 1;\n            } else if (ch == '2') {\n                g.grid[i][j] = 2;\n            } else if (ch == '3') {\n                g.grid[i][j] = 3;\n            } else {\n                g.grid[i][j] = 0;\n            }\n        }\n    }\n    build_adjacency_list(&g);\n    int result = count_valid_grids(&g);\n    printf(\"%d\n\", result);\n    free_grid(&g);\n    return 0;\n}", "reasoning": "The problem involves counting the number of valid grids that can be formed by replacing '?' characters in a given grid with digits 1, 2, or 3, such that no two adjacent cells (sharing an edge) contain the same digit. The solution involves dynamic programming and graph traversal using adjacency lists. The adjacency list is created based on the grid, and then a depth-first search (DFS) is performed to count the number of valid configurations. The result is computed modulo 998244353.", "question_id": "abc379_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    int *heights = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n\n    GHashTable *left_max = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *right_max = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int current_max = 0;\n    for (int i = 0; i < n; i++) {\n        current_max = MAX(current_max, heights[i]);\n        g_hash_table_insert(left_max, GINT_TO_POINTER(i), GINT_TO_POINTER(current_max));\n    }\n\n    current_max = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        current_max = MAX(current_max, heights[i]);\n        g_hash_table_insert(right_max, GINT_TO_POINTER(i), GINT_TO_POINTER(current_max));\n    }\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n\n        int left_max_height = GPOINTER_TO_INT(g_hash_table_lookup(left_max, GINT_TO_POINTER(r - 1)));\n        int right_max_height = GPOINTER_TO_INT(g_hash_table_lookup(right_max, GINT_TO_POINTER(l + 1)));\n\n        int visible_count = 0;\n        for (int j = r + 1; j < n; j++) {\n            if (heights[j] > left_max_height && heights[j] > right_max_height) {\n                visible_count++;\n            }\n        }\n\n        printf(\"%d\\n\", visible_count);\n    }\n\n    free(heights);\n    g_hash_table_destroy(left_max);\n    g_hash_table_destroy(right_max);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine how many buildings to the east of building r_i can be seen from both buildings l_i and r_i. This requires checking for buildings that are taller than r_i and ensuring no building between l_i and r_i is taller. We can use a hash table to keep track of the tallest building seen so far as we traverse from left to right and from right to left. By comparing these two hash tables, we can find the number of buildings visible from both l_i and r_i.", "question_id": "abc379_f"}
{"solution": "#include <stdio.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Extract digits\n    int hundreds = N / 100;\n    int tens = (N / 10) % 10;\n    int ones = N % 10;\n\n    // Form new integers\n    int new1 = tens * 100 + ones * 10 + hundreds;\n    int new2 = ones * 100 + hundreds * 10 + tens;\n\n    // Print the new integers\n    printf(\"%d %d\n\", new1, new2);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to extract the hundreds, tens, and ones digits from the given three-digit integer N. Then, we will rearrange these digits to form two new integers: one by arranging the tens and ones digits first, followed by the hundreds digit, and another by arranging the ones and hundreds digits first, followed by the tens digit. Finally, we will print these two new integers separated by a space.", "question_id": "abc379_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 500005\n#define MAX_Q 200005\n\ntypedef struct {\n    int parent;\n    int size;\n} UnionFind;\n\nUnionFind uf[MAX_N];\n\nvoid init_uf(int n) {\n    for (int i = 1; i <= n; i++) {\n        uf[i].parent = i;\n        uf[i].size = 1;\n    }\n}\n\nint find(int u) {\n    if (uf[u].parent != u) {\n        uf[u].parent = find(uf[u].parent);\n    }\n    return uf[u].parent;\n}\n\nvoid union_sets(int u, int v) {\n    int pu = find(u);\n    int pv = find(v);\n    if (pu != pv) {\n        if (uf[pu].size < uf[pv].size) {\n            uf[pu].parent = pv;\n            uf[pv].size += uf[pu].size;\n        } else {\n            uf[pv].parent = pu;\n            uf[pu].size += uf[pv].size;\n        }\n    }\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    init_uf(n);\n\n    for (int i = 0; i < q; i++) {\n        int type, x, c;\n        scanf(\"%d\", &type);\n        if (type == 1) {\n            scanf(\"%d %d\", &x, &c);\n            for (int j = x; j <= n; j++) {\n                if (find(j) != find(j - 1)) {\n                    union_sets(j, j - 1);\n                }\n            }\n            for (int j = x; j >= 1; j--) {\n                if (find(j) != find(j + 1)) {\n                    union_sets(j, j + 1);\n                }\n            }\n        } else if (type == 2) {\n            scanf(\"%d\", &c);\n            int count = 0;\n            for (int j = 1; j <= n; j++) {\n                if (find(j) == j && uf[j].size == 1) {\n                    count++;\n                }\n            }\n            printf(\"%d\\n\", count);\n        }\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently handle cell repainting and querying the number of cells painted with a specific color. Given the constraints, using a graph-based approach with a union-find data structure (implemented using GLib's GHashTable) is suitable. Here's a step-by-step breakdown of the solution:", "question_id": "abc380_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_CARDS 12\n\n// Function to compare integers for qsort\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\n// Function to determine the winner\nvoid determine_winner(int N, int M, int L, int A[N], int B[M], int C[L]) {\n    // Sort the cards in descending order\n    qsort(A, N, sizeof(int), compare);\n    qsort(B, M, sizeof(int), compare);\n    qsort(C, L, sizeof(int), compare);\n\n    // Initialize the game state\n    GArray *table = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *takahashi_hand = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *aoki_hand = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Transfer Takahashi's cards to his hand\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(takahashi_hand, A[i]);\n    }\n\n    // Transfer Aoki's cards to his hand\n    for (int i = 0; i < M; i++) {\n        g_array_append_val(aoki_hand, B[i]);\n    }\n\n    // Transfer table cards to the table\n    for (int i = 0; i < L; i++) {\n        g_array_append_val(table, C[i]);\n    }\n\n    // Game loop\n    while (g_array_get_length(takahashi_hand) > 0 || g_array_get_length(aoki_hand) > 0) {\n        if (g_array_get_length(takahashi_hand) > 0) {\n            // Takahashi's turn\n            int card = g_array_index(takahashi_hand, int, 0);\n            g_array_remove_index(takahashi_hand, 0);\n            g_array_append_val(table, card);\n\n            // Check for cards Takahashi can take\n            int i = 0;\n            while (i < g_array_get_length(table)) {\n                if (g_array_index(table, int, i) < card) {\n                    int taken_card = g_array_index(table, int, i);\n                    g_array_remove_index(table, i);\n                    g_array_append_val(takahashi_hand, taken_card);\n                } else {\n                    i++;\n                }\n            }\n        } else {\n            // Aoki's turn\n            int card = g_array_index(aoki_hand, int, 0);\n            g_array_remove_index(aoki_hand, 0);\n            g_array_append_val(table, card);\n\n            // Check for cards Aoki can take\n            int i = 0;\n            while (i < g_array_get_length(table)) {\n                if (g_array_index(table, int, i) < card) {\n                    int taken_card = g_array_index(table, int, i);\n                    g_array_remove_index(table, i);\n                    g_array_append_val(aoki_hand, taken_card);\n                } else {\n                    i++;\n                }\n            }\n        }\n    }\n\n    // Determine the winner\n    if (g_array_get_length(takahashi_hand) > 0) {\n        printf(\"Takahashi\\n\");\n    } else {\n        printf(\"Aoki\\n\");\n    }\n\n    // Clean up\n    g_array_free(table, TRUE);\n    g_array_free(takahashi_hand, TRUE);\n    g_array_free(aoki_hand, TRUE);\n}\n\nint main() {\n    // Read input\n    int N, M, L;\n    scanf(\"%d %d %d\", &N, &M, &L);\n    int A[N], B[M], C[L];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n    for (int i = 0; i < L; i++) {\n        scanf(\"%d\", &C[i]);\n    }\n\n    // Determine the winner\n    determine_winner(N, M, L, A, B, C);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to analyze the game mechanics and determine the optimal strategy for both players. The key observation is that the game can be reduced to a series of decisions based on the current state of the cards. Here's a step-by-step approach to solving the problem:", "question_id": "abc380_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    GArray *ones = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '1') {\n            g_array_append_val(ones, i);\n        }\n    }\n\n    int l_k = g_array_index(ones, int, k - 1);\n    int r_k = g_array_index(ones, int, k);\n    int l_k_minus_1 = g_array_index(ones, int, k - 2);\n\n    char result[n + 1];\n    int index = 0;\n\n    for (int i = 0; i <= r_k_minus_1; i++) {\n        result[index++] = s[i];\n    }\n\n    for (int i = l_k; i <= r_k; i++) {\n        result[index++] = '1';\n    }\n\n    for (int i = r_k + 1; i < n; i++) {\n        result[index++] = s[i];\n    }\n\n    result[index] = '\\0';\n\n    printf(\"%s\\n\", result);\n\n    g_array_free(ones, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to identify the K-th 1-block and the (K-1)-th 1-block in the given string S. Once identified, we will construct the new string T by moving the K-th 1-block immediately after the (K-1)-th 1-block. We will handle the string manipulation using GLib data structures to efficiently manage the operations.", "question_id": "abc380_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[200005];\n    int Q;\n    scanf(\"%s\", S);\n    scanf(\"%d\", &Q);\n\n    int len = strlen(S);\n    char T[len + 1];\n\n    // Create the transformed string T\n    for (int i = 0; i < len; i++) {\n        if (islower(S[i])) {\n            T[i] = toupper(S[i]);\n        } else {\n            T[i] = tolower(S[i]);\n        }\n    }\n    T[len] = '\\0';\n\n    // Answer the queries\n    for (int i = 0; i < Q; i++) {\n        long long K;\n        scanf(\"%lld\", &K);\n\n        // Determine the character at position K\n        if (K <= len) {\n            printf(\"%c \", S[K - 1]);\n        } else {\n            K -= len;\n            if (K <= len) {\n                printf(\"%c \", T[K - 1]);\n            } else {\n                K -= len;\n                printf(\"%c \", S[K - 1]);\n            }\n        }\n    }\n\n    return 0;\n}", "reasoning": "The problem involves simulating a transformation on a string multiple times and then answering queries about the resulting string. The transformation involves changing the case of all letters and then concatenating the original string with the transformed string. This process repeats 10^100 times, which is impractical to simulate directly. Instead, we can observe the pattern in the string after a few transformations and use that to answer the queries efficiently.", "question_id": "abc380_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize counters for digits 1, 2, and 3\n    int count_1 = 0, count_2 = 0, count_3 = 0;\n\n    // Convert the number to a string to iterate through each digit\n    char str[7]; // 6 digits + 1 for null terminator\n    sprintf(str, \"%d\", n);\n\n    // Iterate through each digit and update the corresponding counter\n    for (int i = 0; i < 6; i++) {\n        if (str[i] == '1') {\n            count_1++;\n        } else if (str[i] == '2') {\n            count_2++;\n        } else if (str[i] == '3') {\n            count_3++;\n        }\n    }\n\n    // Check if the counters match the required frequencies\n    if (count_1 == 1 && count_2 == 2 && count_3 == 3) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to check if a given 6-digit number N satisfies specific conditions regarding the frequency of its digits. The conditions are:\n1. The digit 1 appears exactly once.\n2. The digit 2 appears exactly twice.\n3. The digit 3 appears exactly three times.\n\nWe can achieve this by iterating through the digits of the number and counting their occurrences. If the counts match the required frequencies, we print 'Yes'; otherwise, we print 'No'.\n\nTo implement this, we will:\n1. Read the input number N.\n2. Initialize counters for the digits 1, 2, and 3.\n3. Iterate through each digit of N and update the corresponding counter.\n4. Check if the counters match the required frequencies.\n5. Print 'Yes' or 'No' based on the check.", "question_id": "abc380_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int num;\n        scanf(\"%d\", &num);\n        g_array_append_val(arr, num);\n    }\n\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i <= n; i++) {\n        g_array_append_val(dp, 0);\n    }\n\n    for (int i = 1; i <= k; i++) {\n        for (int j = n - 1; j >= 0; j--) {\n            int sum = 0;\n            for (int l = 0; l < n - j; l++) {\n                sum = (sum + g_array_index(dp, int, l) + (g_array_index(arr, int, j + l) > g_array_index(arr, int, j + l + 1))) % MOD;\n            }\n            g_array_index(dp, int, j) = sum;\n        }\n    }\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        result = (result + g_array_index(dp, int, i)) % MOD;\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_array_free(arr, TRUE);\n    g_array_free(dp, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the expected value of the inversion number of a permutation P after performing a specific operation. The operation involves choosing a random segment of the permutation and shuffling it. The expected value of the inversion number is the average of the inversion numbers for all possible segments after shuffling each one. We can use dynamic programming and combinatorial mathematics to efficiently compute this expected value modulo 998244353.", "question_id": "abc380_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S[1001];\n    scanf(\"%s\", S);\n\n    // Length of the string S\n    int len = strlen(S);\n\n    // Initialize GArray to store the sequence A\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Initialize variables to count the number of '-' characters\n    int count = 0;\n\n    // Iterate through the string S\n    for (int i = 0; i < len; i++) {\n        if (S[i] == '-') {\n            // Increment the count of '-' characters\n            count++;\n        } else if (S[i] == '|') {\n            // If we encounter a '|', append the count to the sequence A\n            g_array_append_val(A, count);\n            // Reset the count to 0\n            count = 0;\n        }\n    }\n\n    // Print the sequence A\n    for (int i = 0; i < A->len; i++) {\n        printf(\"%d \", g_array_index(A, int, i));\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_array_free(A, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to reconstruct the sequence A from the given string S. The string S is generated by appending A_i copies of '-' followed by a '|' for each element in A. We can break down the problem into the following steps:\n\n1. Identify the number of '-' characters between each '|' in the string S.\n2. Count the number of '-' characters to determine the value of A_i for each segment.\n3. Store the values of A_i in the sequence A.\n\nWe will iterate through the string S, count the number of '-' characters, and store the count in the sequence A.", "question_id": "abc380_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    if (n % 2 == 0) {\n        printf(\"No\n\");\n        return 0;\n    }\n\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    int mid = (n + 1) / 2;\n\n    for (int i = 0; i < mid - 1; i++) {\n        if (s[i] != '1') {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    if (s[mid - 1] != '/') {\n        printf(\"No\n\");\n        return 0;\n    }\n\n    for (int i = mid; i < n; i++) {\n        if (s[i] != '2') {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\n\");\n\n    return 0;\n}", "reasoning": "To determine if a given string S is an 11/22 string, we need to check if it meets the following conditions:\n1. The length of S is odd.\n2. The first (|T|+1)/2 - 1 characters are all '1'.\n3. The (|T|+1)/2-th character is '/'\n4. The (|T|+1)/2 + 1-th through |T|-th characters are all '2'.\nWe can iterate through the string and check these conditions. If any condition fails, we return 'No'. If all conditions pass, we return 'Yes'.", "question_id": "abc381_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to check if a character is 1, 2, or /\nbool is_valid_char(char c) {\n    return c == '1' || c == '2' || c == '/';\n}\n\n// Function to find the maximum length of a subsequence that is an 11/22 string\nint max_1122_subseq_len(const char *s, int start, int end) {\n    int n = end - start + 1;\n    if (n % 2 == 0) return 0; // Length must be odd\n\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_set_size(dp, n);\n    memset(dp->data, 0, n * sizeof(int));\n\n    for (int i = start; i <= end; i++) {\n        if (!is_valid_char(s[i])) continue;\n\n        int len = i - start + 1;\n        if (len == 1 && s[i] == '1') {\n            dp->data[i - start] = 1;\n        } else if (len == 2 && s[i] == '2') {\n            dp->data[i - start] = 2;\n        } else if (len > 2 && s[i] == '2' && dp->data[len - 3] > 0) {\n            dp->data[i - start] = dp->data[len - 3] + 1;\n        }\n    }\n\n    int max_len = 0;\n    for (int i = 0; i < n; i++) {\n        if (dp->data[i] > max_len) {\n            max_len = dp->data[i];\n        }\n    }\n\n    g_array_free(dp, TRUE);\n    return max_len;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        l--; // Adjust to 0-based index\n        r--;\n\n        int result = max_1122_subseq_len(s, l, r);\n        printf(\"%d\n\", result);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to efficiently determine the maximum length of a subsequence that is an 11/22 string for each query. The key observation is that an 11/22 string has a specific structure, and we can use dynamic programming to find the longest subsequence that matches this structure. Here's a step-by-step approach to solve the problem:", "question_id": "abc381_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char s[101];\n    scanf(\"%s\", s);\n\n    int n = strlen(s);\n    if (n % 2 != 0) {\n        printf(\"No\n\");\n        return 0;\n    }\n\n    GHashTable *count = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < n; i++) {\n        char *c = &s[i];\n        int *value = (int *)g_hash_table_lookup(count, c);\n        if (value) {\n            (*value)++;\n        } else {\n            g_hash_table_insert(count, c, GINT_TO_POINTER(1));\n        }\n    }\n\n    int odd_count = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, count);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int val = GPOINTER_TO_INT(value);\n        if (val % 2 != 0) {\n            odd_count++;\n        }\n    }\n\n    if (odd_count != 0) {\n        printf(\"No\n\");\n    } else {\n        printf(\"Yes\n\");\n    }\n\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "To determine if a string is a 1122 string, we need to check three conditions. We will use a hash table to count the occurrences of each character. If the string length is odd, it cannot be a 1122 string. If any character appears more than twice, it cannot be a 1122 string. Finally, we will check if the string can be split into pairs of equal characters.", "question_id": "abc381_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    int max_length = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '/') {\n            int j = i + 1;\n            while (j < n && s[j] == '2') {\n                j++;\n            }\n            if (j - i > max_length) {\n                max_length = j - i;\n            }\n            i = j - 1;\n        }\n    }\n\n    printf(\"%d\n\", max_length);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to identify contiguous substrings of the given string S that are 11/22 strings. An 11/22 string has specific properties, and we can use a sliding window approach to efficiently find the longest such substring. Here's a step-by-step breakdown of the solution:", "question_id": "abc381_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    int max_length = 0;\n    for (int i = 0; i < n; i++) {\n        GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n        int length = 0;\n\n        for (int j = i; j < n; j++) {\n            int key = arr[j];\n            int *val = (int *)g_hash_table_lookup(count, GINT_TO_POINTER(key));\n\n            if (val == NULL) {\n                g_hash_table_insert(count, GINT_TO_POINTER(key), GINT_TO_POINTER(1));\n                length += 2;\n            } else {\n                if (*val == 1) {\n                    length += 2;\n                    g_hash_table_insert(count, GINT_TO_POINTER(key), GINT_TO_POINTER(2));\n                } else {\n                    break;\n                }\n            }\n\n            if (length % 2 == 0) {\n                max_length = (length > max_length) ? length : max_length;\n            }\n        }\n\n        g_hash_table_destroy(count);\n    }\n\n    printf(\"%d\\n\", max_length);\n\n    free(arr);\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum length of a contiguous subarray that forms a 1122 sequence. A 1122 sequence has specific properties: it must have an even length, each pair of consecutive elements must be equal, and each positive integer must appear exactly twice. We can use a sliding window approach combined with a hash table to efficiently find the longest valid subarray.", "question_id": "abc381_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nvoid generate_sequences(int N, int M, int *sequence, int index) {\n    if (index == N) {\n        for (int i = 0; i < N; i++) {\n            printf(\"%d\", sequence[i]);\n            if (i < N - 1) {\n                printf(\" \");\n            }\n        }\n        printf(\"\\n\");\n        return;\n    }\n\n    if (index == 0) {\n        for (int i = 1; i <= M; i++) {\n            sequence[index] = i;\n            generate_sequences(N, M, sequence, index + 1);\n        }\n    } else {\n        for (int i = sequence[index - 1] + 10; i <= M; i++) {\n            sequence[index] = i;\n            generate_sequences(N, M, sequence, index + 1);\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    int *sequence = (int *)malloc(N * sizeof(int));\n    int count = 0;\n\n    generate_sequences(N, M, sequence, 0);\n\n    free(sequence);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate all valid sequences of length N that satisfy the given conditions and print them in lexicographical order. Here's a step-by-step approach to achieve this:", "question_id": "abc382_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n    char S[1000];\n    scanf(\"%s\", S);\n\n    // Count the initial number of cookies\n    int cookies = 0;\n    for (int i = 0; i < N; i++) {\n        if (S[i] == '@') {\n            cookies++;\n        }\n    }\n\n    // Calculate the number of empty boxes after D days\n    int empty_boxes = cookies - D;\n    if (empty_boxes < 0) {\n        empty_boxes = 0;\n    }\n\n    // Output the result\n    printf(\"%d\n\", empty_boxes);\n\n    return 0;\n}", "reasoning": "The problem requires determining how many boxes will be empty after D days, given a string S that represents the initial state of the boxes. Each '@' in the string represents a box containing a cookie, and each '.' represents an empty box. Takahashi will eat one cookie per day from among the cookies in these boxes. The key insight is that the number of empty boxes after D days does not depend on which cookies Takahashi chooses each day; it only depends on the initial number of cookies and the number of days. Therefore, the solution involves counting the initial number of cookies and subtracting the number of days from it, ensuring that the result is not negative (since the number of empty boxes cannot be less than zero).", "question_id": "abc382_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n    char S[N + 1];\n    scanf(\"%s\", S);\n\n    GQueue *queue = g_queue_new();\n    int *days = (int *)malloc(N * sizeof(int));\n    memset(days, 0, N * sizeof(int));\n\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '@') {\n            g_queue_push_head(queue, GINT_TO_POINTER(i));\n            days[i] = D;\n        }\n    }\n\n    for (int i = 0; i < D; i++) {\n        if (!g_queue_is_empty(queue)) {\n            int index = GPOINTER_TO_INT(g_queue_pop_head(queue));\n            if (index > 0) {\n                g_queue_push_head(queue, GINT_TO_POINTER(index - 1));\n                days[index - 1] = days[index] - 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (days[i] > 0) {\n            printf(\"@\");\n        } else {\n            printf(\".\");\n        }\n    }\n    printf(\"\\n\");\n\n    g_queue_free(queue);\n    free(days);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of Takahashi eating cookies from the rightmost box containing a cookie each day. We will use a stack to keep track of the boxes that contain cookies. Here's the step-by-step approach:\n\n1. **Initialize**: Read the input values N, D, and the string S.\n2. **Stack Simulation**: Use a stack to simulate the process of eating cookies. We will iterate through the string from right to left, and for each cookie, we will keep track of the days it will be eaten.\n3. **Track Days**: For each cookie, we will calculate the number of days it will be eaten based on its position and the number of days D.\n4. **Output**: After processing all cookies, we will output the state of each box after D days.", "question_id": "abc382_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 1000000007\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    GHashTable *bars = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < N; i++) {\n        int R, C, L;\n        scanf(\"%d %d %d\", &R, &C, &L);\n\n        int cycle = H - R + 1;\n        int final_R = (R + (MOD * (1000000000 - 1) / 2) * cycle) % H;\n\n        g_hash_table_insert(bars, GINT_TO_POINTER(i + 1), GINT_TO_POINTER(final_R));\n    }\n\n    for (int i = 1; i <= N; i++) {\n        int final_R = GPOINTER_TO_INT(g_hash_table_lookup(bars, GINT_TO_POINTER(i)));\n        printf(\"%d\n\", final_R);\n    }\n\n    g_hash_table_destroy(bars);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the movement of the bars on the grid over a very large number of time steps (10^100). However, since the movement of each bar is periodic, we can determine the final position of each bar by finding the equivalent position within one cycle of its movement. The cycle length is determined by the number of rows the bar can move before hitting the bottom or another bar. Once we know the cycle length, we can compute the final position of each bar by taking the modulo of 10^100 with the cycle length.", "question_id": "abc382_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        long long K, S_x, S_y, T_x, T_y;\n        scanf(\"%lld %lld %lld %lld %lld\", &K, &S_x, &S_y, &T_x, &T_y);\n\n        // Calculate the tile coordinates for the starting and target points\n        int start_i = (S_x + 0.5) / K;\n        int start_j = (S_y + 0.5) / K;\n        int start_k = (S_x + 0.5) - start_i * K;\n\n        int target_i = (T_x + 0.5) / K;\n        int target_j = (T_y + 0.5) / K;\n        int target_k = (T_x + 0.5) - target_i * K;\n\n        // Calculate the minimum number of moves required\n        int moves = 0;\n\n        if (start_i % 2 == target_i % 2) {\n            moves += abs(start_j - target_j);\n        } else {\n            moves += abs(start_i - target_i);\n        }\n\n        if (start_j % 2 == target_j % 2) {\n            moves += abs(start_k - target_k);\n        } else {\n            moves += abs(start_k - target_k);\n        }\n\n        // Output the result\n        printf(\"%d\\n\", moves);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of moves required to reach a target tile from a starting tile on a two-dimensional coordinate plane. Each tile is defined by an integer triple (i, j, k) and covers a specific area based on the parity of i and j. The key steps are to calculate the coordinates of the starting and target tiles and then determine the minimum number of moves required to reach the target tile from the starting tile. This involves calculating the differences in the coordinates and determining how many moves are needed to cover these differences.", "question_id": "abc382_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Read gourmet levels\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Read sushi deliciousness\n    int *B = (int *)malloc(m * sizeof(int));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n\n    // Initialize a GQueue to keep track of people\n    GQueue *queue = g_queue_new();\n    for (int i = 0; i < n; i++) {\n        g_queue_push_tail(queue, GINT_TO_POINTER(i + 1));\n    }\n\n    // Process each sushi\n    for (int i = 0; i < m; i++) {\n        int sushi = B[i];\n        int eaten = -1;\n\n        // Check people in order\n        while (!g_queue_is_empty(queue)) {\n            int person = GPOINTER_TO_INT(g_queue_pop_head(queue));\n            if (sushi >= A[person - 1]) {\n                eaten = person;\n                break;\n            }\n        }\n\n        // Print the result for this sushi\n        printf(\"%d\\n\", eaten);\n\n        // If someone ate the sushi, add them back to the end of the queue\n        if (eaten != -1) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(eaten));\n        }\n    }\n\n    // Clean up\n    free(A);\n    free(B);\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of sushi passing in front of people and determine who eats each sushi. Here's a step-by-step approach to achieve this:", "question_id": "abc382_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 1000\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int H, W, D;\n    scanf(\"%d %d %d\", &H, &W, &D);\n\n    char grid[MAX][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    GQueue *queue = g_queue_new();\n    int directions[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    // Initialize visited array\n    bool visited[MAX][MAX];\n    memset(visited, false, sizeof(visited));\n\n    // Enqueue all humidifier positions\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'H') {\n                g_queue_push_tail(queue, GINT_TO_POINTER(i * W + j));\n                visited[i][j] = true;\n            }\n        }\n    }\n\n    // Perform BFS to mark all reachable cells\n    while (!g_queue_is_empty(queue)) {\n        int pos = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        int row = pos / W;\n        int col = pos % W;\n\n        for (int k = 0; k < 4; k++) {\n            int new_row = row + directions[k][0];\n            int new_col = col + directions[k][1];\n\n            if (new_row >= 0 && new_row < H && new_col >= 0 && new_col < W && !visited[new_row][new_col] && grid[new_row][new_col] != '#') {\n                visited[new_row][new_col] = true;\n                g_queue_push_tail(queue, GINT_TO_POINTER(new_row * W + new_col));\n            }\n        }\n    }\n\n    // Count the number of humidified floor cells\n    int humidified_count = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.' && visited[i][j]) {\n                humidified_count++;\n            }\n        }\n    }\n\n    printf(\"%d\n\", humidified_count);\n\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine which floor cells in the grid are humidified. A cell is considered humidified if it can be reached from at least one humidifier cell within at most D moves (up, down, left, or right) without passing through a wall. Here's a step-by-step approach to solve the problem:", "question_id": "abc383_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GArray *events = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        int T, V;\n        scanf(\"%d %d\", &T, &V);\n        g_array_append_val(events, T);\n        g_array_append_val(events, V);\n    }\n\n    int time = 0;\n    int water = 0;\n\n    for (int i = 0; i < events->len; i += 2) {\n        int T = g_array_index(events, int, i);\n        int V = g_array_index(events, int, i + 1);\n\n        while (time < T) {\n            water = water - 1;\n            time = time + 1;\n        }\n\n        water = water + V;\n        time = T;\n    }\n\n    printf(\"%d\\n\", water);\n\n    g_array_free(events, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of adding water to the humidifier at different times and account for the water that leaks out over time. Here's a step-by-step approach to solving the problem:", "question_id": "abc383_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n#define MAXM 200005\n#define INF 1e9\n\ntypedef struct {\n    int to, weight;\n} Edge;\n\ntypedef struct {\n    int vertex, dist;\n} Node;\n\nint n, m, k;\nEdge edges[MAXM];\nint A[MAXN], B[MAXN];\nGArray *adj[MAXN];\n\nvoid dijkstra(int start, int *dist) {\n    memset(dist, 0x3f, sizeof(int) * n);\n    dist[start] = 0;\n    GPriorityQueue *pq = g_priority_queue_new((GCompareFunc)g_int_compare);\n    g_priority_queue_push(pq, GINT_TO_POINTER(start), GINT_TO_POINTER(0));\n\n    while (!g_priority_queue_is_empty(pq)) {\n        int u = GPOINTER_TO_INT(g_priority_queue_pop_head(pq));\n        for (int i = 0; i < g_array_get_length(adj[u]); i++) {\n            Edge e = g_array_index(adj[u], Edge, i);\n            int v = e.to;\n            int weight = e.weight;\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                g_priority_queue_push(pq, GINT_TO_POINTER(v), GINT_TO_POINTER(dist[v]));\n            }\n        }\n    }\n\n    g_priority_queue_free(pq);\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        u--;\n        v--;\n        edges[i] = (Edge){v, w};\n        adj[u] = g_array_append_val(adj[u], edges[i]);\n        adj[v] = g_array_append_val(adj[v], edges[i]);\n    }\n\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d\", &A[i]);\n        A[i]--;\n    }\n\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d\", &B[i]);\n        B[i]--;\n    }\n\n    int *dist = (int *)malloc(n * sizeof(int));\n\n    int result = 0;\n\n    for (int i = 0; i < k; i++) {\n        dijkstra(A[i], dist);\n        int min_dist = INF;\n        for (int j = 0; j < k; j++) {\n            if (A[i] != B[j]) {\n                min_dist = g_min(min_dist, dist[B[j]]);\n            }\n        }\n        result += min_dist;\n    }\n\n    printf(\"%d\\n\", result);\n\n    free(dist);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum possible path weight from each vertex in sequence A to a vertex in sequence B. The path weight is defined as the maximum weight of an edge in the path. We can use Dijkstra's algorithm to find the shortest path from each vertex in A to all other vertices, and then use this information to determine the minimum possible path weight for each pair (A_i, B_i). To minimize the total sum, we need to find the best permutation of B that minimizes the sum of these path weights.", "question_id": "abc383_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 10\n\nint manhattan_distance(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint max_humidified_cells(char grid[MAX][MAX], int H, int W, int D) {\n    int max_humidified = 0;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.') {\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        if (grid[k][l] == '.') {\n                            int humidified = 0;\n\n                            for (int m = 0; m < H; m++) {\n                                for (int n = 0; n < W; n++) {\n                                    if (grid[m][n] == '.' && manhattan_distance(i, j, m, n) <= D && manhattan_distance(k, l, m, n) <= D) {\n                                        humidified++;\n                                    }\n                                }\n                            }\n\n                            if (humidified > max_humidified) {\n                                max_humidified = humidified;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return max_humidified;\n}\n\nint main() {\n    int H, W, D;\n    scanf(\"%d %d %d\", &H, &W, &D);\n\n    char grid[MAX][MAX];\n\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int result = max_humidified_cells(grid, H, W, D);\n\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum number of floor cells that can be humidified by placing two humidifiers on the grid. The key is to explore all possible pairs of floor cells and calculate the number of humidified cells for each pair. We will use a nested loop to iterate through all pairs of floor cells and a helper function to calculate the Manhattan distance between them. If the distance is less than or equal to D, the cell is considered humidified. We will keep track of the maximum number of humidified cells and return it as the result.", "question_id": "abc383_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    long long N;\n    scanf(\"%lld\", &N);\n\n    // Initialize a hash table to store prime numbers up to sqrt(N)\n    GHashTable *primes = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Function to check if a number is prime\n    bool is_prime(long long num) {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n        for (long long i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n\n    // Populate the hash table with prime numbers up to sqrt(N)\n    for (long long i = 2; i * i <= N; i++) {\n        if (is_prime(i)) {\n            g_hash_table_insert(primes, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n        }\n    }\n\n    // Function to count numbers with exactly 9 divisors\n    long long count = 0;\n    GList *list = g_hash_table_get_keys(primes);\n\n    for (GList *node = list; node != NULL; node = node->next) {\n        long long p = GPOINTER_TO_INT(node->data);\n        if (p * p * p * p * p * p * p * p * p <= N) {\n            count++;\n        }\n        if (p * p * p * p * p * p * p * p * p * p * p <= N) {\n            count++;\n        }\n    }\n\n    g_list_free(list);\n\n    // Output the result\n    printf(\"%lld\\n\", count);\n\n    // Clean up\n    g_hash_table_destroy(primes);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the number of positive integers not greater than N that have exactly 9 positive divisors. The key insight is that a number has exactly 9 divisors if and only if it is of the form p^8 or p^2 * q^2, where p and q are distinct prime numbers. This is because the number of divisors of a number n = p1^e1 * p2^e2 * ... * pk^ek is given by (e1 + 1) * (e2 + 1) * ... * (ek + 1). For this product to be 9, the only possible factorizations are 9 = 9 * 1 or 9 = 3 * 3.", "question_id": "abc383_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, R;\n    scanf(\"%d %d\", &N, &R);\n\n    for (int i = 0; i < N; i++) {\n        int D, A;\n        scanf(\"%d %d\", &D, &A);\n\n        if ((D == 1 && R >= 1600 && R <= 2799) || (D == 2 && R >= 1200 && R <= 2399)) {\n            R += A;\n        }\n    }\n\n    printf(\"%d\\n\", R);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate Takahashi's participation in N ARCs and update his rating based on the rules provided. We will use a loop to iterate through each ARC, check if Takahashi is subject to a rating update based on his current division, and then update his rating accordingly. We will use a simple conditional check to determine the division and apply the rating update if necessary. Finally, we will print Takahashi's final rating after all ARCs are completed.", "question_id": "abc384_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n, s;\n    scanf(\"%d %d\", &n, &s);\n\n    // Read the sequence\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // Initialize variables\n    GHashTable *prefix_sum_map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    long long sum = 0;\n    g_hash_table_insert(prefix_sum_map, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n\n    // Iterate through the sequence\n    for (int i = 0; i < n; i++) {\n        sum += a[i];\n        long long target = (sum - s + n) % n;\n\n        // Check if the target exists in the hash map\n        if (g_hash_table_contains(prefix_sum_map, GINT_TO_POINTER(target))) {\n            printf(\"Yes\\n\");\n            free(a);\n            g_hash_table_destroy(prefix_sum_map);\n            return 0;\n        }\n\n        // Insert the current sum into the hash map\n        g_hash_table_insert(prefix_sum_map, GINT_TO_POINTER(sum % n), GINT_TO_POINTER(1));\n    }\n\n    // If no valid subsequence is found\n    printf(\"No\\n\");\n\n    // Clean up\n    free(a);\n    g_hash_table_destroy(prefix_sum_map);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exists a contiguous subsequence of the infinite sequence A whose sum is S. Given that the sequence is periodic with period N, we can leverage this property to simplify our search. The key insight is to use a hash map to keep track of the cumulative sums modulo N. This allows us to efficiently check if the required subsequence exists.", "question_id": "abc384_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    int k;\n    scanf(\"%d\", &k);\n\n    int *x = (int *)malloc(k * sizeof(int));\n    int *y = (int *)malloc(k * sizeof(int));\n\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d %d\", &x[i], &y[i]);\n    }\n\n    int *prefix_sum = (int *)malloc((n + 1) * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        prefix_sum[i + 1] = prefix_sum[i] + abs(a[i] - b[i]);\n    }\n\n    for (int i = 0; i < k; i++) {\n        int result = prefix_sum[x[i]] - prefix_sum[y[i] - 1];\n        printf(\"%d\n\", result);\n    }\n\n    free(a);\n    free(b);\n    free(x);\n    free(y);\n    free(prefix_sum);\n\n    return 0;\n}", "reasoning": "The problem involves calculating the sum of absolute differences between elements of two sequences A and B, for multiple subsequence ranges specified by X and Y. To efficiently solve this, we can preprocess the sequences A and B to compute prefix sums of their absolute differences. This allows us to quickly calculate the sum for any subsequence range in constant time. Here's a step-by-step breakdown of the approach:", "question_id": "abc384_g"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char c1, c2;\n    scanf(\" %c %c\", &c1, &c2);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] != c1) {\n            s[i] = c2;\n        }\n    }\n\n    printf(\"%s\\n\", s);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to iterate through each character of the input string S and replace it with c_2 if it is not equal to c_1. We can achieve this using a simple loop and conditional checks. The constraints are small enough to allow a linear time complexity solution, which is efficient for this problem.", "question_id": "abc384_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 500\n#define INF 1e12\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    int value;\n    Point point;\n} Node;\n\nint compare(const void *a, const void *b) {\n    return ((Node*)a)->value - ((Node*)b)->value;\n}\n\nint main() {\n    int H, W, X, P, Q;\n    scanf(\"%d %d %d\", &H, &W, &X);\n    scanf(\"%d %d\", &P, &Q);\n\n    int grid[H][W];\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    Point directions[] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(P * W + Q));\n\n    int max_strength = grid[P - 1][Q - 1];\n    while (!g_queue_is_empty(queue)) {\n        int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        int x = current / W + 1;\n        int y = current % W + 1;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + directions[i].x;\n            int ny = y + directions[i].y;\n\n            if (nx >= 1 && nx <= H && ny >= 1 && ny <= W) {\n                int neighbor_strength = grid[nx - 1][ny - 1];\n                if (neighbor_strength < (grid[x - 1][y - 1] / X)) {\n                    max_strength += neighbor_strength;\n                    grid[nx - 1][ny - 1] = 0;\n                    g_queue_push_tail(queue, GINT_TO_POINTER(nx * W + ny));\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_strength);\n\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate the process of Takahashi absorbing slimes from the grid. The key steps are as follows:\n1. Identify all adjacent slimes to Takahashi.\n2. Check if any of these slimes have a strength strictly less than Takahashi's strength divided by X.\n3. If such a slime exists, absorb it and update Takahashi's strength and adjacency list.\n4. Repeat the process until no more slimes can be absorbed.\n5. Output the final strength of Takahashi.\nWe use a priority queue to always consider the slime with the smallest strength that can be absorbed first, ensuring we maximize Takahashi's strength.", "question_id": "abc384_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint f(int x) {\n    while (x % 2 == 0) {\n        x /= 2;\n    }\n    return x;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int *arr = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n        int fx = f(arr[i]);\n        g_hash_table_insert(map, GINT_TO_POINTER(fx), GINT_TO_POINTER(GPOINTER_TO_INT(g_hash_table_lookup(map, GINT_TO_POINTER(fx))) + 1));\n    }\n\n    long long sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int fx = f(arr[i] + arr[j]);\n            sum += GPOINTER_TO_INT(g_hash_table_lookup(map, GINT_TO_POINTER(fx)));\n        }\n    }\n\n    printf(\"%lld\\n\", sum);\n\n    g_hash_table_destroy(map);\n    free(arr);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the function f(x) for all possible sums of pairs in the given sequence and then sum up these values. The function f(x) reduces x to its odd part by repeatedly dividing by 2. We can use a hash table to store the results of f(x) for all possible values of x to avoid redundant calculations. Here's a step-by-step approach to solve the problem:", "question_id": "abc384_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define NUM_PROBLEMS 5\n#define MAX_NAME_LENGTH 6\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int score;\n} Participant;\n\nint compare(const void *a, const void *b) {\n    Participant *pa = (Participant *)a;\n    Participant *pb = (Participant *)b;\n    if (pa->score != pb->score) {\n        return pb->score - pa->score;\n    } else {\n        return strcmp(pa->name, pb->name);\n    }\n}\n\nvoid generateParticipants(int scores[], Participant participants[], int index, char currentName[], int currentScore) {\n    if (index == NUM_PROBLEMS) {\n        strcpy(participants[index - 1].name, currentName);\n        participants[index - 1].score = currentScore;\n        return;\n    }\n    generateParticipants(scores, participants, index + 1, currentName, currentScore);\n    currentName[index] = 'A' + index;\n    currentName[index + 1] = '\\0';\n    generateParticipants(scores, participants, index + 1, currentName, currentScore + scores[index]);\n}\n\nint main() {\n    int scores[NUM_PROBLEMS];\n    for (int i = 0; i < NUM_PROBLEMS; i++) {\n        scanf(\"%d\", &scores[i]);\n    }\n\n    Participant participants[31];\n    char currentName[NUM_PROBLEMS + 1];\n    currentName[0] = '\\0';\n    generateParticipants(scores, participants, 0, currentName, 0);\n\n    qsort(participants, 31, sizeof(Participant), compare);\n\n    for (int i = 0; i < 31; i++) {\n        printf(\"%s\\n\", participants[i].name);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate all possible participants based on the given problem scores and then sort them by their scores and lexicographical order. Here's a step-by-step approach to achieve this:", "question_id": "abc384_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    int x;\n    int h;\n} Building;\n\nint compare(const void *a, const void *b) {\n    return ((Building *)a)->x - ((Building *)b)->x;\n}\n\nbool is_visible(Building *buildings, int n, double height) {\n    for (int i = 0; i < n; i++) {\n        double x = buildings[i].x;\n        double h = buildings[i].h;\n        if (h <= height) continue;\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            double x2 = buildings[j].x;\n            double h2 = buildings[j].h;\n            if (h2 <= height) continue;\n            double slope = (h - h2) / (x - x2);\n            if (slope * (x - x2) + h2 > height) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Building *buildings = (Building *)malloc(n * sizeof(Building));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &buildings[i].x, &buildings[i].h);\n    }\n\n    qsort(buildings, n, sizeof(Building), compare);\n\n    double low = 0, high = 1e9;\n    while (high - low > EPS) {\n        double mid = (low + high) / 2;\n        if (is_visible(buildings, n, mid)) {\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n\n    if (low == 0) {\n        printf(\"-1\n\");\n    } else {\n        printf(\"%.15f\n\", low);\n    }\n\n    free(buildings);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum height from which it is not possible to see all buildings. This involves checking the visibility of buildings from coordinate 0 and height 0. We can use a binary search approach to find the maximum height where at least one building is not visible. The visibility condition is determined by checking if there exists a point Q on a building such that the line segment PQ does not intersect with any other building.", "question_id": "abc385_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int A, B, C;\n    scanf(\"%d %d %d\", &A, &B, &C);\n\n    int totalSum = A + B + C;\n\n    // Check if the total sum is even\n    if (totalSum % 2 != 0) {\n        printf(\"No\\n\");\n        return 0;\n    }\n\n    int halfSum = totalSum / 2;\n\n    // Check if any of the numbers is half of the total sum\n    if (A == halfSum || B == halfSum || C == halfSum) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "reasoning": "To determine whether it is possible to divide three integers A, B, and C into two or more groups with equal sums, we need to consider the following steps:\n\n1. Calculate the total sum of A, B, and C.\n2. Check if the total sum is even. If it is odd, it's impossible to divide it into groups with equal sums, so we return 'No'.\n3. If the total sum is even, check if any of the numbers A, B, or C is half of the total sum. If so, we can divide the numbers into two groups with equal sums, so we return 'Yes'. Otherwise, we return 'No'.", "question_id": "abc385_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *heights = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n\n    int max_count = 1;\n\n    for (int i = 0; i < n; i++) {\n        int count = 1;\n        for (int j = i + 1; j < n; j++) {\n            if (heights[i] == heights[j]) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        max_count = (count > max_count) ? count : max_count;\n    }\n\n    printf(\"%d\n\", max_count);\n\n    free(heights);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum number of buildings that have the same height and are arranged at equal intervals. Here's a step-by-step approach to achieve this:", "question_id": "abc385_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m, sx, sy;\n    scanf(\"%d %d %d %d\", &n, &m, &sx, &sy);\n\n    GHashTable *houses = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        g_hash_table_insert(houses, GINT_TO_POINTER(x), GINT_TO_POINTER(y));\n    }\n\n    int cx = sx, cy = sy;\n    GHashSet *visited = g_hash_set_new(g_direct_hash, g_direct_equal);\n    g_hash_set_add(visited, GINT_TO_POINTER(cx));\n    g_hash_set_add(visited, GINT_TO_POINTER(cy));\n\n    for (int i = 0; i < m; i++) {\n        char direction;\n        int distance;\n        scanf(\" %c %d\", &direction, &distance);\n\n        for (int j = 0; j < distance; j++) {\n            if (direction == 'U') {\n                cy += 1;\n            } else if (direction == 'D') {\n                cy -= 1;\n            } else if (direction == 'L') {\n                cx -= 1;\n            } else if (direction == 'R') {\n                cx += 1;\n            }\n\n            if (g_hash_table_contains(houses, GINT_TO_POINTER(cx)) && g_hash_table_contains(houses, GINT_TO_POINTER(cy))) {\n                if (!g_hash_set_contains(visited, GINT_TO_POINTER(cx))) {\n                    g_hash_set_add(visited, GINT_TO_POINTER(cx));\n                }\n                if (!g_hash_set_contains(visited, GINT_TO_POINTER(cy))) {\n                    g_hash_set_add(visited, GINT_TO_POINTER(cy));\n                }\n            }\n        }\n    }\n\n    int distinct_houses = g_hash_set_size(visited);\n    printf(\"%d %d %d\\n\", cx, cy, distinct_houses);\n\n    g_hash_table_destroy(houses);\n    g_hash_set_destroy(visited);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate Santa Claus's movements on a 2D plane and keep track of the distinct houses he passes through. Here's a step-by-step approach to achieve this:", "question_id": "abc385_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N;\n    scanf(\"%d\", &N);\n\n    // Create adjacency list for the tree\n    GArray *adj[N + 1];\n    for (int i = 1; i <= N; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read edges and build the adjacency list\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        g_array_append_val(adj[u], v);\n        g_array_append_val(adj[v], u);\n    }\n\n    // Function to perform DFS and count vertices\n    int dfs(int node, int parent, int *x, int *y) {\n        int count = 1;\n        int child_count = 0;\n        int leaves = 0;\n\n        for (guint i = 0; i < adj[node]->len; i++) {\n            int neighbor = g_array_index(adj[node], int, i);\n            if (neighbor != parent) {\n                int child_leaves = dfs(neighbor, node, x, y);\n                child_count++;\n                leaves += child_leaves;\n            }\n        }\n\n        if (child_count > *x) {\n            *x = child_count;\n        }\n\n        if (leaves > *y) {\n            *y = leaves;\n        }\n\n        return count;\n    }\n\n    // Initialize variables to store x and y\n    int x = 0, y = 0;\n\n    // Perform DFS to find x and y\n    dfs(1, 0, &x, &y);\n\n    // Calculate the minimum number of vertices to delete\n    int min_deletes = N - (x + 1 + y);\n\n    // Output the result\n    printf(\"%d\n\", min_deletes);\n\n    // Clean up\n    for (int i = 1; i <= N; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to understand the structure of a Snowflake Tree and how to transform a given tree into it. A Snowflake Tree can be represented as a central vertex with x children, and each of these children has y leaves. The goal is to find the minimum number of vertices to delete to transform the given tree into such a structure. Here's a step-by-step approach to solve the problem:", "question_id": "abc385_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <glib.h>\n\n#define MAX_H 100\n#define MAX_W 100\n\nint main() {\n    int H, W, X, Y;\n    scanf(\"%d %d %d %d\", &H, &W, &X, &Y);\n\n    char grid[MAX_H][MAX_W];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    char T[10001];\n    scanf(\"%s\", T);\n\n    GHashTable *visited_houses = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; T[i] != '\\0'; i++) {\n        int new_X = X, new_Y = Y;\n        if (T[i] == 'U') new_X--;\n        else if (T[i] == 'D') new_X++;\n        else if (T[i] == 'L') new_Y--;\n        else if (T[i] == 'R') new_Y++;\n\n        if (new_X >= 0 && new_X < H && new_Y >= 0 && new_Y < W && grid[new_X][new_Y] != '#') {\n            X = new_X;\n            Y = new_Y;\n            if (grid[X][Y] == '@') {\n                char house[2] = {grid[X][Y], '\\0'};\n                if (!g_hash_table_contains(visited_houses, house)) {\n                    g_hash_table_insert(visited_houses, house, GINT_TO_POINTER(1));\n                }\n            }\n        }\n    }\n\n    printf(\"%d %d %zu\\n\", X, Y, g_hash_table_size(visited_houses));\n\n    g_hash_table_destroy(visited_houses);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to simulate Santa Claus's movements on a grid and keep track of the distinct houses he passes through. Here's a step-by-step breakdown of the approach:\n\n1. **Input Reading**: Read the grid dimensions (H and W), Santa's initial position (X, Y), and the grid itself. Also, read the movement string T.\n\n2. **Grid Representation**: Use a 2D array to represent the grid. Each cell can store its state (passable, impassable, house, etc.). Use a set to keep track of distinct houses Santa passes through.\n\n3. **Movement Simulation**: Iterate through the movement string T and update Santa's position based on the direction specified. Check if the new position is within bounds and passable. If it's a house, add it to the set of visited houses.\n\n4. **Output**: Print Santa's final position and the number of distinct houses he visited.\n\n5. **Memory Management**: Ensure to free any dynamically allocated memory to avoid leaks.", "question_id": "abc385_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    // Read the array A\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(guint64));\n    for (int i = 0; i < n; i++) {\n        guint64 value;\n        scanf(\"%llu\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    // Sort the array to facilitate finding the maximum XOR\n    qsort(arr->data, arr->len, sizeof(guint64), (int (*)(const void *, const void *))guint64_compare);\n\n    // Initialize a hash table to keep track of the maximum XOR values\n    GHashTable *max_xor = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Iterate through the sorted array and calculate the maximum XOR for each possible subset of size K\n    for (int i = 0; i <= n - k; i++) {\n        guint64 current_xor = 0;\n        for (int j = i; j < i + k; j++) {\n            current_xor ^= g_array_index(arr, guint64, j);\n        }\n        g_hash_table_insert(max_xor, GINT_TO_POINTER(i), GINT_TO_POINTER(current_xor));\n    }\n\n    // Find the maximum value in the hash table\n    guint64 max_value = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, max_xor);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        if (GPOINTER_TO_INT(value) > max_value) {\n            max_value = GPOINTER_TO_INT(value);\n        }\n    }\n\n    // Output the result\n    printf(\"%llu\\n\", max_value);\n\n    // Clean up\n    g_array_free(arr, TRUE);\n    g_hash_table_destroy(max_xor);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum possible value of the XOR of K chosen elements from the given sequence A. The key insight is to leverage the properties of the XOR operation and the constraints provided. Here's a step-by-step approach to solve the problem:", "question_id": "abc386_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int A, B, C, D;\n    scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n\n    // Create a hash table to count occurrences of each card\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Function to update the count of a card\n    auto update_count = [](GHashTable *hash, int card) {\n        gpointer value = g_hash_table_lookup(hash, GINT_TO_POINTER(card));\n        int count = (value != NULL) ? GPOINTER_TO_INT(value) : 0;\n        g_hash_table_insert(hash, GINT_TO_POINTER(card), GINT_TO_POINTER(count + 1));\n    };\n\n    // Update counts for all four cards\n    update_count(count, A);\n    update_count(count, B);\n    update_count(count, C);\n    update_count(count, D);\n\n    // Get the counts of each card\n    int a_count = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(A)));\n    int b_count = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(B)));\n    int c_count = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(C)));\n    int d_count = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(D)));\n\n    // Check if adding one card can form a Full House\n    if ((a_count == 2 && (b_count == 3 || c_count == 3 || d_count == 3)) ||\n        (a_count == 3 && (b_count == 2 || c_count == 2 || d_count == 2))) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "reasoning": "To determine if a Full House can be formed by adding one card to the given four cards, we need to check the frequency of each card. A Full House requires either one card with a frequency of 3 and another card with a frequency of 2, or three cards with a frequency of 2 and one card with a frequency of 3. We will count the occurrences of each card and then check if adding one card can result in one of these configurations.", "question_id": "abc386_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashTable *rows = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *cols = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < M; i++) {\n        int X, Y;\n        char C;\n        scanf(\"%d %d %c\", &X, &Y, &C);\n\n        if (C == 'B') {\n            g_hash_table_insert(rows, GINT_TO_POINTER(X), GINT_TO_POINTER(1));\n            g_hash_table_insert(cols, GINT_TO_POINTER(Y), GINT_TO_POINTER(1));\n        }\n    }\n\n    bool isPossible = true;\n\n    for (int i = 1; i <= N; i++) {\n        if (g_hash_table_lookup(rows, GINT_TO_POINTER(i)) == NULL) {\n            if (i % 2 == 1) {\n                g_hash_table_insert(rows, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n            } else {\n                isPossible = false;\n                break;\n            }\n        }\n\n        if (g_hash_table_lookup(cols, GINT_TO_POINTER(i)) == NULL) {\n            if (i % 2 == 1) {\n                g_hash_table_insert(cols, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n            } else {\n                isPossible = false;\n                break;\n            }\n        }\n    }\n\n    if (isPossible) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    g_hash_table_destroy(rows);\n    g_hash_table_destroy(cols);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can color the remaining cells of an N x N grid such that the conditions are satisfied. The conditions require that each row and each column must start with a black cell and then alternate between black and white cells. Given that M cells are already colored, we need to check if the coloring of these cells allows us to complete the grid while maintaining the conditions.", "question_id": "abc386_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int K;\n    scanf(\"%d\", &K);\n\n    char S[500001], T[500001];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int lenS = strlen(S);\n    int lenT = strlen(T);\n\n    int diff = 0;\n\n    if (lenS == lenT) {\n        // If lengths are equal, check for character replacements\n        for (int i = 0; i < lenS; i++) {\n            if (S[i] != T[i]) {\n                diff++;\n            }\n        }\n    } else if (lenS == lenT + 1) {\n        // If S is one character longer, check for deletions\n        int i = 0, j = 0;\n        while (i < lenS && j < lenT) {\n            if (S[i] == T[j]) {\n                i++;\n                j++;\n            } else {\n                i++;\n                diff++;\n            }\n        }\n    } else if (lenS == lenT - 1) {\n        // If S is one character shorter, check for insertions\n        int i = 0, j = 0;\n        while (i < lenS && j < lenT) {\n            if (S[i] == T[j]) {\n                i++;\n                j++;\n            } else {\n                j++;\n                diff++;\n            }\n        }\n    } else {\n        // If lengths differ by more than 1, conversion is not possible\n        diff = 2;\n    }\n\n    if (diff <= 1) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "The problem requires determining if we can convert string S to string T with at most one operation. Given K=1, we can perform one of three operations: insert a character, delete a character, or replace a character. The solution involves comparing the two strings and counting the number of differences. If the number of differences is less than or equal to 1, the conversion is possible.", "question_id": "abc386_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S[1001];\n    scanf(\"%s\", S);\n\n    // Initialize result\n    int result = 0;\n\n    // Iterate through each character in the string\n    int n = strlen(S);\n    for (int i = 0; i < n; i++) {\n        // Increment result by 1 for each character press\n        result++;\n\n        // If the current character is '0', we need to press '00' instead of '0'\n        if (S[i] == '0') {\n            result++;\n        }\n    }\n\n    // Output result\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the minimum number of button presses required to display a given string S on a calculator with buttons for digits 0-9. The key insight is that pressing '00' is equivalent to pressing '0' twice, so we should always prefer '00' over '0'. Here's a step-by-step approach to solve the problem:", "question_id": "abc386_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint min(int a, int b, int c) {\n    return min(min(a, b), c);\n}\n\nint levenshtein_distance(char *s, char *t) {\n    int m = strlen(s);\n    int n = strlen(t);\n    int *d = (int *)g_malloc((m + 1) * (n + 1) * sizeof(int));\n\n    for (int i = 0; i <= m; i++) {\n        d[i * (n + 1)] = i;\n    }\n\n    for (int j = 0; j <= n; j++) {\n        d[j] = j;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                d[i * (n + 1) + j] = d[(i - 1) * (n + 1) + j - 1];\n            } else {\n                d[i * (n + 1) + j] = min(\n                    d[(i - 1) * (n + 1) + j],\n                    d[i * (n + 1) + j - 1],\n                    d[(i - 1) * (n + 1) + j - 1]\n                ) + 1;\n            }\n        }\n    }\n\n    int result = d[m * (n + 1) + n];\n    g_free(d);\n    return result;\n}\n\nint main() {\n    int k;\n    scanf(\"%d\", &k);\n\n    char s[500001], t[500001];\n    scanf(\"%s\", s);\n    scanf(\"%s\", t);\n\n    int distance = levenshtein_distance(s, t);\n\n    if (distance <= k) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can transform string S into string T using at most K operations. The operations allowed are insert, delete, and replace a character. We can approach this problem by calculating the minimum number of operations required to convert S to T and then checking if this number is less than or equal to K. If it is, we print 'Yes'; otherwise, we print 'No'. To calculate the minimum operations, we can use dynamic programming to find the Levenshtein distance between S and T. The Levenshtein distance is the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one word into the other.", "question_id": "abc386_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nGHashTable *dp;\n\nint dfs(Point *points, int n, int index, int prev) {\n    if (index == n) return 1;\n    if (g_hash_table_contains(dp, GINT_TO_POINTER(index * 300 + prev))) return GPOINTER_TO_INT(g_hash_table_lookup(dp, GINT_TO_POINTER(index * 300 + prev)));\n\n    int res = 0;\n    if (prev == -1 || (points[index].x > points[prev].x && points[index].y > points[prev].y) || (points[index].x < points[prev].x && points[index].y < points[prev].y)) {\n        res = (res + dfs(points, n, index + 1, index)) % MOD;\n    }\n    res = (res + dfs(points, n, index + 1, prev)) % MOD;\n\n    g_hash_table_insert(dp, GINT_TO_POINTER(index * 300 + prev), GINT_TO_POINTER(res));\n    return res;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Point *points = (Point *)malloc(n * sizeof(Point));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int result = dfs(points, n, 0, -1);\n\n    printf(\"%d\n\", result);\n\n    free(points);\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to understand the operations and constraints given. The key observation is that the operation of removing balls based on their positions relative to a chosen ball can be reduced to a problem of finding subsets of points that satisfy a certain condition. Specifically, we need to find subsets of points such that no point in the subset is dominated by another point in the subset. A point (x1, y1) is said to dominate another point (x2, y2) if both x1 < x2 and y1 < y2 or both x1 > x2 and y1 > y2. The problem can be solved using dynamic programming with memoization, where we use a hash table to store the results of subproblems to avoid redundant calculations.", "question_id": "arc184_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 1; i <= n; i++) {\n        int gap = i;\n        g_hash_table_insert(hash, GINT_TO_POINTER(gap), GINT_TO_POINTER(1));\n    }\n\n    int max_folds = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int gap = i;\n        int count = GPOINTER_TO_INT(g_hash_table_lookup(hash, GINT_TO_POINTER(gap)));\n        if (count > max_folds) {\n            max_folds = count;\n        }\n    }\n\n    printf(\"%d\n\", max_folds);\n\n    g_hash_table_destroy(hash);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to understand the nature of the creases and how they form mountain and valley folds. Given a sequence of non-negative integers A, we need to determine the maximum number of mountain folds in any subsequence of creases. The key observation is that the number of mountain folds in a subsequence is determined by the gaps between the indices of the sequence A. Specifically, for each i from 1 to 2^100 - A_N - 1, we need to count the number of k such that the (i + A_k)-th crease is a mountain fold. This is equivalent to counting the number of gaps between the indices of the sequence A that are greater than or equal to i. We can use a hash table to keep track of the gaps and their counts, and then iterate over the sequence to find the maximum number of mountain folds.", "question_id": "arc184_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GHashTable *states = g_hash_table_new(g_str_hash, g_str_equal);\n    GArray *sequences = g_array_new(FALSE, FALSE, sizeof(char*));\n\n    for (int i = 0; i < n; i++) {\n        char *seq = malloc((m + 1) * sizeof(char));\n        scanf(\"%s\", seq);\n        g_array_append_val(sequences, seq);\n    }\n\n    long long result = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            char *seq1 = g_array_index(sequences, char*, i);\n            char *seq2 = g_array_index(sequences, char*, j);\n\n            int x = 0;\n            bool changed = true;\n\n            while (changed) {\n                changed = false;\n\n                for (int k = 0; k < m; k++) {\n                    int sum = 0;\n                    for (int l = 0; l <= k; l++) {\n                        sum += seq1[l] - '0';\n                    }\n                    sum %= 2;\n\n                    if (sum != seq2[k] - '0') {\n                        seq1[k] = '0' + sum;\n                        changed = true;\n                    }\n                }\n\n                x++;\n            }\n\n            result = (result + x) % MOD;\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n\n    for (int i = 0; i < n; i++) {\n        free(g_array_index(sequences, char*, i));\n    }\n\n    g_array_free(sequences, TRUE);\n    g_hash_table_destroy(states);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the function f(i, j) for all pairs (i, j) and sum them up. The function f(i, j) is defined as the smallest non-negative integer x such that sequences A_i and A_j become identical after performing the specified operation x times. The operation involves replacing A_{i, k} with (sum_{l=1}^{k} A_{i, l}) % 2 for all k simultaneously. We need to find the smallest x for which this condition holds for all i and j. We can use a hash table to store the states of the sequences after each operation and check if we have encountered the same state before. If we have, we can calculate the number of operations needed to reach that state. We then sum up the results for all pairs (i, j) and take the result modulo 998244353.", "question_id": "arc184_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, X;\n    scanf(\"%d %d\", &N, &X);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    qsort(A, N, sizeof(int), compare);\n\n    for (int i = 0; i < N - 2; i++) {\n        int j = i + 1, k = N - 1;\n        while (j < k) {\n            int sum = A[i] + A[j] + A[k];\n            if (sum == X) {\n                printf(\"%d %d %d\n\", i + 1, j + 1, k + 1);\n                free(A);\n                return 0;\n            } else if (sum < X) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n\n    printf(\"-1\n\");\n    free(A);\n    return 0;\n}", "reasoning": "To solve this problem, we need to find a triple of integers (i, j, k) from the given sequence A such that their sum equals X. The constraints suggest that a brute-force approach would be too slow, so we need an efficient algorithm. One efficient approach is to sort the array first and then use a two-pointer technique to find the triple. Here's the step-by-step process:\n\n1. Read the input values N, X, and the sequence A.\n2. Sort the sequence A.\n3. Iterate through the array with the first pointer i from 0 to N-3.\n4. For each i, use two pointers j and k such that j = i + 1 and k = N - 1.\n5. Check the sum of A[i], A[j], and A[k]. If it equals X, print the indices (i+1, j+1, k+1) and return.\n6. If the sum is less than X, increment j to increase the sum. If the sum is greater than X, decrement k to decrease the sum.\n7. If no such triple is found after the loop, print -1.\n\nThis approach ensures that we find the first triple that satisfies the condition, if it exists, in an efficient manner.", "question_id": "arc185_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    GHashTable *hash;\n} State;\n\nvoid init_state(State *state) {\n    state->hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n}\n\nvoid free_state(State *state) {\n    g_hash_table_destroy(state->hash);\n}\n\nvoid update_state(State *state, int key, int value) {\n    gpointer existing_value = g_hash_table_lookup(state->hash, GINT_TO_POINTER(key));\n    if (existing_value) {\n        int sum = GPOINTER_TO_INT(existing_value) + value;\n        g_hash_table_insert(state->hash, GINT_TO_POINTER(key), GINT_TO_POINTER(sum % MOD));\n    } else {\n        g_hash_table_insert(state->hash, GINT_TO_POINTER(key), GINT_TO_POINTER(value % MOD));\n    }\n}\n\nint get_state(State *state, int key) {\n    gpointer value = g_hash_table_lookup(state->hash, GINT_TO_POINTER(key));\n    return value ? GPOINTER_TO_INT(value) : 0;\n}\n\nvoid solve(int *A, int N) {\n    for (int m = 1; m <= N; m++) {\n        State state;\n        init_state(&state);\n\n        for (int i = 0; i < (1 << m); i++) {\n            if (i == 0) {\n                update_state(&state, 0, 0);\n                continue;\n            }\n\n            int sum = 0;\n            for (int j = 0; j < m; j++) {\n                if (i & (1 << j)) {\n                    sum += A[j];\n                }\n            }\n\n            update_state(&state, sum, get_state(&state, sum) + 1);\n        }\n\n        int result = 0;\n        for (int i = 0; i < (1 << m); i++) {\n            int sum = 0;\n            for (int j = 0; j < m; j++) {\n                if (i & (1 << j)) {\n                    sum += A[j];\n                }\n            }\n\n            int count = get_state(&state, sum);\n            for (int j = 0; j < m; j++) {\n                if (i & (1 << j)) {\n                    int gcd = 0;\n                    for (int k = 0; k < m; k++) {\n                        if (i & (1 << k) && k != j) {\n                            gcd = gcd ? gcd : A[j];\n                            gcd = gcd > A[k] ? gcd : A[k];\n                            while (gcd) {\n                                int temp = gcd;\n                                gcd = A[k] % gcd;\n                                A[k] = temp;\n                            }\n                        }\n                    }\n                    result = (result + count * gcd) % MOD;\n                }\n            }\n        }\n\n        printf(\"%d\\n\", result);\n\n        free_state(&state);\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    solve(A, N);\n\n    free(A);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to calculate the sum of the scores of all non-empty subsequences of a given sequence A for m = 1 to N. The score of a sequence B is defined as the sum of gcd(B_i, B_{i+1}) for all pairs of adjacent elements in B. We can approach this problem by using dynamic programming and bit manipulation to efficiently calculate the required sums for each m.", "question_id": "arc185_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N;\n        scanf(\"%d\", &N);\n\n        GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n        for (int i = 0; i < N; i++) {\n            int value;\n            scanf(\"%d\", &value);\n            g_array_append_val(arr, value);\n        }\n\n        int balance = 0;\n        int possible = 1;\n\n        for (int i = 1; i < N; i++) {\n            balance += arr->data[i] - arr->data[i - 1];\n            if (balance < 0) {\n                possible = 0;\n                break;\n            }\n        }\n\n        if (possible) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n\n        g_array_free(arr, TRUE);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can make the sequence A non-decreasing by performing the allowed operations. The key insight is that the operations can be used to balance the sequence, effectively moving smaller values to the left and larger values to the right. Here's a step-by-step approach to solve the problem:", "question_id": "arc185_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Initialize DP table\n    GHashTable *dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Base case: if only one vertex, no operations needed\n    g_hash_table_insert(dp, GINT_TO_POINTER(1), GINT_TO_POINTER(0));\n\n    // Iterate over each vertex count from 2 to N*M + 1\n    for (int i = 2; i <= N * M + 1; i++) {\n        int sum = 0;\n\n        // Iterate over each possible previous vertex count\n        for (int j = 1; j < i; j++) {\n            int key = i - j;\n            gpointer value = g_hash_table_lookup(dp, GINT_TO_POINTER(key));\n            if (value != NULL) {\n                sum = (sum + GPOINTER_TO_INT(value)) % MOD;\n            }\n        }\n\n        // Calculate the expected number of operations for the current vertex count\n        int expected = (sum * (i - 1)) % MOD;\n        g_hash_table_insert(dp, GINT_TO_POINTER(i), GINT_TO_POINTER(expected));\n    }\n\n    // Get the expected number of operations for N*M + 1 vertices\n    gpointer result = g_hash_table_lookup(dp, GINT_TO_POINTER(N * M + 1));\n    printf(\"%d\n\", GPOINTER_TO_INT(result));\n\n    // Clean up\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the expected number of operations Takahashi performs until all vertices are painted. The problem involves a tree structure where each vertex has a probability of moving to an adjacent vertex, and the goal is to find the expected number of steps until all vertices are painted. This can be approached using dynamic programming and combinatorial mathematics.", "question_id": "arc185_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <glib.h>\n\nbool is_valid_fixed_count(int N, int K) {\n    // Check if K is a valid fixed count for an N x N matrix\n    // A matrix can have at most N^2 fixed elements\n    // A matrix can have at least 0 fixed elements\n    return K >= 0 && K <= N * N;\n}\n\nbool can_have_fixed_count(int N, int K) {\n    // Check if it's possible to have exactly K fixed elements in an N x N matrix\n    // If K is 0, it's always possible\n    if (K == 0) {\n        return true;\n    }\n    // If K is N^2, it's always possible\n    if (K == N * N) {\n        return true;\n    }\n    // For other values of K, check if it's possible\n    // A matrix can have exactly K fixed elements if and only if K is even\n    return K % 2 == 0;\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    for (int i = 0; i < Q; i++) {\n        int K;\n        scanf(\"%d\", &K);\n\n        if (is_valid_fixed_count(N, K) && can_have_fixed_count(N, K)) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exists an N x N matrix with exactly K fixed elements for each query. The key insight is that for a matrix to have exactly K fixed elements, it must be a special type of matrix where the fixed elements are distributed in a way that allows for the existence of a similar matrix with the same fixed elements. This involves understanding the properties of similar matrices and how fixed elements can be preserved under similarity transformations.", "question_id": "arc186_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nGHashTable *dp;\n\nint countPolishSequences(int *A, int N, int pos) {\n    if (pos == N) return 1;\n    if (g_hash_table_contains(dp, GINT_TO_POINTER(pos))) return GPOINTER_TO_INT(g_hash_table_lookup(dp, GINT_TO_POINTER(pos)));\n\n    int count = 0;\n    for (int i = 0; i <= A[pos]; i++) {\n        count = (count + countPolishSequences(A, N, pos + i + 1)) % MOD;\n    }\n\n    g_hash_table_insert(dp, GINT_TO_POINTER(pos), GINT_TO_POINTER(count));\n    return count;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int result = countPolishSequences(A, N, 0);\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(dp);\n    free(A);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of Polish sequences of length N that are lexicographically not greater than the given sequence A_1, A_2, ..., A_N. A sequence is Polish if it can be broken down into a sequence of Polish sequences, and the sequence (0) is considered Polish. We can use dynamic programming with memoization to count the number of valid sequences. The key is to use a hash table to store the results of subproblems to avoid redundant calculations. The result should be taken modulo 998244353 to handle large numbers.", "question_id": "arc186_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nGHashTable *memo;\n\nint dp(int i, int prev, int *A, int *used) {\n    if (i == 0) return 1;\n    gpointer key = GINT_TO_POINTER(i * 1000000 + prev * 1000 + used[0] * 100 + used[1] * 10 + used[2]);\n    if (g_hash_table_contains(memo, key)) return GPOINTER_TO_INT(g_hash_table_lookup(memo, key));\n\n    int res = 0;\n    for (int j = 1; j <= i; j++) {\n        if (A[i-1] < j && !used[j]) {\n            used[j] = 1;\n            res = (res + dp(i-1, j, A, used)) % MOD;\n            used[j] = 0;\n        }\n    }\n\n    g_hash_table_insert(memo, key, GINT_TO_POINTER(res));\n    return res;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int A[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    int used[3] = {0, 0, 0};\n    memo = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int result = dp(N, 0, A, used);\n\n    printf(\"%d\n\", result);\n\n    g_hash_table_destroy(memo);\n\n    return 0;\n}", "reasoning": "The problem requires finding the number of permutations of (1, ..., N) that satisfy certain conditions given a sequence A_1, ..., A_N. The conditions involve constraints on the relative positions of elements in the permutation based on the values in A. To solve this, we can use dynamic programming with memoization using a hash table to store intermediate results and avoid redundant calculations. The approach involves breaking down the problem into smaller subproblems and using the results of these subproblems to build up to the final solution. We need to handle large numbers by taking results modulo 998244353.", "question_id": "arc186_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    int X[M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    // Initialize DP table\n    int dp[N + 1][M + 1];\n    memset(dp, 0, sizeof(dp));\n\n    // Base case: There is one way to form an empty sequence\n    dp[0][0] = 1;\n\n    // Fill DP table\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= M; j++) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % MOD;\n            if (X[j - 1] == 1) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD;\n            }\n        }\n    }\n\n    // Calculate the number of valid sequences\n    int result = 0;\n    for (int i = 1; i <= N; i++) {\n        result = (result + dp[i][M]) % MOD;\n    }\n\n    // Subtract the invalid sequences (those that can be formed as a subsequence of X)\n    int invalid = 0;\n    for (int i = 1; i <= M; i++) {\n        invalid = (invalid + dp[N][i]) % MOD;\n    }\n\n    result = (result - invalid + MOD) % MOD;\n\n    // Print the result\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the number of sequences (A_1, ..., A_N) of length N consisting of 1, ..., K that cannot be obtained as a subsequence of the given sequence (X_1, ..., X_M). We can approach this problem using dynamic programming and combinatorial mathematics.", "question_id": "arc186_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int N, M;\n        scanf(\"%d %d\", &N, &M);\n\n        GArray *boxes = g_array_new(FALSE, FALSE, sizeof(int));\n        for (int i = 0; i < N; i++) {\n            int V, P;\n            scanf(\"%d %d\", &V, &P);\n            g_array_append_val(boxes, P);\n        }\n\n        g_array_sort(boxes, (GCompareFunc)g_int_compare);\n\n        int total_cost = 0;\n        for (int i = 0; i < M; i++) {\n            total_cost += g_array_index(boxes, int, i);\n        }\n\n        printf(\"%d\\n\", total_cost);\n\n        g_array_free(boxes, TRUE);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to analyze the optimal strategies for both Mr. Ball and Mr. Box. Mr. Ball wants to minimize the money Mr. Box spends, while Mr. Box wants to maximize the money he earns. The key insight is that Mr. Box should buy boxes that can hold the maximum number of balls of any single type, as this will maximize his earnings. Mr. Ball, on the other hand, should give balls to Mr. Box in such a way that Mr. Box can maximize his earnings by using the boxes he has bought optimally.", "question_id": "arc186_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    int B[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Generate all possible sequences B'\n    int q = 0;\n    for (int i = 0; i < N; i++) {\n        if (B[i] == -1) {\n            q++;\n        }\n    }\n\n    int *order = (int *)malloc(q * sizeof(int));\n    int *values = (int *)malloc(q * sizeof(int));\n\n    int index = 0;\n    for (int i = 0; i < N; i++) {\n        if (B[i] == -1) {\n            order[index] = i;\n            values[index] = 1;\n            index++;\n        }\n    }\n\n    for (int i = 1; i <= M; i++) {\n        for (int j = 0; j < q; j++) {\n            values[j] = i;\n        }\n\n        int connected_components = 0;\n        GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n        for (int j = 0; j < N; j++) {\n            if (B[j] != -1) {\n                int val = B[j];\n                if (!g_hash_table_contains(visited, GINT_TO_POINTER(val))) {\n                    connected_components++;\n                    GQueue *queue = g_queue_new();\n                    g_queue_push_tail(queue, GINT_TO_POINTER(val));\n                    while (!g_queue_is_empty(queue)) {\n                        int node = GPOINTER_TO_INT(g_queue_pop_head(queue));\n                        if (!g_hash_table_contains(visited, GINT_TO_POINTER(node))) {\n                            g_hash_table_insert(visited, GINT_TO_POINTER(node), GINT_TO_POINTER(1));\n                            for (int k = 0; k < N; k++) {\n                                if (B[k] != -1 && B[k] > node) {\n                                    g_queue_push_tail(queue, GINT_TO_POINTER(B[k]));\n                                }\n                            }\n                        }\n                    }\n                    g_queue_free(queue);\n                }\n            }\n        }\n\n        g_hash_table_insert(count, GINT_TO_POINTER(connected_components), GINT_TO_POINTER(GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(connected_components))) + 1));\n\n        g_hash_table_destroy(visited);\n    }\n\n    long long sum = 0;\n    GList *keys = g_hash_table_get_keys(count);\n    GList *node;\n    for (node = keys; node != NULL; node = node->next) {\n        int key = GPOINTER_TO_INT(node->data);\n        int value = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(key)));\n        sum = (sum + (long long)key * value) % MOD;\n    }\n\n    printf(\"%lld\n\", sum);\n\n    g_hash_table_destroy(count);\n    free(order);\n    free(values);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of connected components in a graph for each possible sequence B' obtained by replacing -1 in sequence B with integers between 1 and M. The key observation is that the number of connected components in the graph depends only on the relative order of the elements, not their actual values. Therefore, we can focus on the relative order of the elements in B and count the number of connected components for each unique order.", "question_id": "arc187_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200000\n#define MAX_M 200000\n\ntypedef struct {\n    int a;\n    int b;\n    int c;\n} Testimony;\n\nGHashTable *hash;\nGArray *testimonies;\n\nbool is_valid(int n, int *confused) {\n    for (int i = 0; i < n; i++) {\n        int a = g_array_index(testimonies, Testimony, i).a - 1;\n        int b = g_array_index(testimonies, Testimony, i).b - 1;\n        int c = g_array_index(testimonies, Testimony, i).c;\n        int status_a = (confused[a] == 1) ? (rand() % 2) : (c == 0 ? 1 : 0);\n        int status_b = (confused[b] == 1) ? (rand() % 2) : (c == 0 ? 1 : 0);\n        if (status_a == status_b) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid backtrack(int n, int *confused, int pos) {\n    if (pos == n) {\n        if (is_valid(n, confused)) {\n            for (int i = 0; i < n; i++) {\n                printf(\"%d\", confused[i]);\n            }\n            printf(\"\\n\");\n            exit(0);\n        }\n        return;\n    }\n    confused[pos] = 0;\n    backtrack(n, confused, pos + 1);\n    confused[pos] = 1;\n    backtrack(n, confused, pos + 1);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n    testimonials = g_array_new(FALSE, FALSE, sizeof(Testimony));\n\n    for (int i = 0; i < m; i++) {\n        Testimony t;\n        scanf(\"%d %d %d\", &t.a, &t.b, &t.c);\n        g_array_append_val(testimonies, t);\n    }\n\n    int *confused = (int *)malloc(n * sizeof(int));\n    memset(confused, 0, n * sizeof(int));\n\n    backtrack(n, confused, 0);\n\n    printf(\"-1\\n\");\n\n    g_hash_table_destroy(hash);\n    g_array_free(testimonies, TRUE);\n    free(confused);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if there exists a set of confused villagers such that the given set of testimonies does not contradict. We can approach this problem using a brute-force approach with backtracking. Here's the step-by-step reasoning:\n\n1. **Understand the Rules**: We need to understand how different types of villagers (honest, liar, confused honest, confused liar) behave based on their testimonies.\n2. **Brute-Force Approach**: We will try all possible combinations of confused villagers and check if the testimonies are consistent with these combinations.\n3. **Backtracking**: If we find a combination that works, we return it. If we exhaust all possibilities without finding a valid combination, we return -1.\n4. **Implementation**: We will use a recursive function to try different combinations and use a hash table to keep track of the status of each villager.", "question_id": "arc188_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int N, K;\n        scanf(\"%d %d\", &N, &K);\n\n        // Check if N is even and if K is such that the points can be symmetrically colored\n        if (N % 2 == 0 && (K == 1 || K == N - 1)) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    return 0;\n}", "reasoning": "The problem involves two players, Alice and Bob, coloring points on a circle symmetrically. The key observation is that for all points to be colored black, the number of points must be even and the starting point K must be such that it allows both players to symmetrically color all points. The solution involves checking if N is even and if K is such that the points can be symmetrically colored starting from both ends.", "question_id": "arc188_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    GArray *seq;\n    GArray *rev;\n} Sequence;\n\nbool is_valid_sequence(Sequence *seq, int *A, int *B, int N) {\n    GArray *sorted_seq = g_array_copy(seq->seq);\n    g_array_sort(sorted_seq, (GCompareFunc)g_int_compare);\n    GArray *sorted_rev = g_array_copy(seq->rev);\n    g_array_sort(sorted_rev, (GCompareFunc)g_int_compare);\n\n    int a = 1, b = 1;\n    for (int i = 0; i < N; i++) {\n        if (g_array_index(sorted_seq, int, i) == A[i]) {\n            a++;\n        }\n        if (B[i] != -1 && g_array_index(sorted_rev, int, i) == B[i]) {\n            b++;\n        }\n    }\n\n    return a == N + 1 && b == N + 1;\n}\n\nint count_valid_pairs(int *A, int *B, int N) {\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                int seq[3] = {i + 1, j + 1, k + 1};\n                int rev_seq[3] = {k + 1, j + 1, i + 1};\n\n                Sequence seq_a, seq_b;\n                seq_a.seq = g_array_new(FALSE, FALSE, sizeof(int));\n                seq_a.rev = g_array_new(FALSE, FALSE, sizeof(int));\n                seq_b.seq = g_array_new(FALSE, FALSE, sizeof(int));\n                seq_b.rev = g_array_new(FALSE, FALSE, sizeof(int));\n\n                for (int m = 0; m < 3; m++) {\n                    g_array_append_val(seq_a.seq, seq[m]);\n                    g_array_append_val(seq_a.rev, rev_seq[m]);\n                }\n\n                if (is_valid_sequence(&seq_a, A, B, N)) {\n                    count++;\n                }\n\n                g_array_free(seq_a.seq, TRUE);\n                g_array_free(seq_a.rev, TRUE);\n                g_array_free(seq_b.seq, TRUE);\n                g_array_free(seq_b.rev, TRUE);\n            }\n        }\n    }\n\n    return count % MOD;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int A[N], B[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n\n    int result = count_valid_pairs(A, B, N);\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate sequences a and b that satisfy the given conditions. Here's a step-by-step approach to solving it:\n\n1. **Understand the Constraints**: We need to create sequences a and b such that each integer from 1 to 2N appears exactly once in the concatenation of a and b. Additionally, for each i from 1 to N, a_i must equal A_i and b_i must equal B_i if B_i is not -1.\n\n2. **Generate Sequences**: We need to generate all possible sequences a and b that satisfy the conditions. This involves generating permutations of the numbers from 1 to N and checking if they can form valid sequences a and b.\n\n3. **Check Validity**: For each generated sequence, we need to check if it forms valid sequences a and b. This involves sorting the sequences and checking if the sorted sequences can be uniquely identified as s_i and t_i.\n\n4. **Count Valid Pairs**: We need to count the number of valid pairs of sequences a and b that satisfy the conditions. We also need to return the count modulo 998244353.\n\n5. **Efficiency**: Given the constraints, we need to optimize our solution to handle large values of N efficiently. This involves using efficient data structures and algorithms, such as hash tables and sorting.\n\n6. **Edge Cases**: We need to handle edge cases, such as when there are identical sequences among the 2N sequences, in which case a and b are not defined.\n\n7. **Implementation**: We will implement the solution using C and the GLib library, which provides efficient data structures and algorithms for handling large datasets.", "question_id": "arc188_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    char S[N + 1];\n    scanf(\"%s\", S);\n\n    GHashTable *dp[N + 1][N + 1];\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            dp[i][j] = g_hash_table_new(g_str_hash, g_str_equal);\n        }\n    }\n\n    // Initialize base cases\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            g_hash_table_insert(dp[i][j], \"0\", GINT_TO_POINTER(1));\n        }\n    }\n\n    // Fill DP table\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= N; j++) {\n            for (int k = 0; k <= N; k++) {\n                char *key = g_strdup_printf(\"%d,%d\", j, k);\n                int value = GPOINTER_TO_INT(g_hash_table_lookup(dp[i][j], key));\n                if (value == 0) continue;\n\n                if (S[i] != '?' && S[i] == S[i + 1]) {\n                    char *new_key = g_strdup_printf(\"%d,%d\", j + 2, k);\n                    g_hash_table_insert(dp[i + 2][k], new_key, GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(dp[i + 2][k], new_key)) + value) % MOD));\n                }\n\n                if (S[i] != '?' && S[i] == 'A' && S[i + 1] == 'B' && S[i + 2] == 'C') {\n                    char *new_key = g_strdup_printf(\"%d,%d\", j, k + 3);\n                    g_hash_table_insert(dp[i + 3][k + 3], new_key, GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(dp[i + 3][k + 3], new_key)) + value) % MOD));\n                }\n\n                if (S[i] == '?') {\n                    for (char c = 'A'; c <= 'C'; c++) {\n                        if (S[i + 1] != '?' && S[i + 1] == c) {\n                            char *new_key = g_strdup_printf(\"%d,%d\", j + 2, k);\n                            g_hash_table_insert(dp[i + 2][k], new_key, GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(dp[i + 2][k], new_key)) + value) % MOD));\n                        }\n\n                        if (S[i + 1] == '?' && S[i + 2] == '?' && (c == 'A' || c == 'B' || c == 'C')) {\n                            char *new_key = g_strdup_printf(\"%d,%d\", j, k + 3);\n                            g_hash_table_insert(dp[i + 3][k + 3], new_key, GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(dp[i + 3][k + 3], new_key)) + value) % MOD));\n                        }\n                    }\n                }\n\n                g_free(key);\n            }\n        }\n    }\n\n    // Count the number of ways to replace '?' to get at least K good substrings\n    int result = 0;\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            char *key = g_strdup_printf(\"%d,%d\", i, j);\n            int value = GPOINTER_TO_INT(g_hash_table_lookup(dp[N][j], key));\n            if (value >= K) {\n                result = (result + value) % MOD;\n            }\n            g_free(key);\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    // Clean up\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            g_hash_table_destroy(dp[i][j]);\n        }\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the number of ways to replace each '?' in the string S with 'A', 'B', or 'C' such that the resulting string contains at least K good substrings. A good string can be formed by deleting pairs of identical characters or triplets of 'A', 'B', and 'C'. We can use dynamic programming to count the number of good substrings and then use combinatorial methods to count the number of valid replacements.", "question_id": "arc188_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(long long));\n    g_array_append_val(dp, 1);\n\n    for (int i = 1; i < n; i++) {\n        long long prev = g_array_index(dp, long long, i - 1);\n        if (A[i] != A[i - 1]) {\n            g_array_append_val(dp, prev * 2 % MOD);\n        } else {\n            g_array_append_val(dp, prev);\n        }\n    }\n\n    long long result = g_array_index(dp, long long, n - 1);\n\n    printf(\"%lld\\n\", result);\n\n    free(A);\n    g_array_free(dp, TRUE);\n\n    return 0;\n}", "reasoning": "The problem involves transforming a grid of cells such that each cell's value matches a given target sequence. The operations allowed are limited, and we need to count the number of valid sequences of operations modulo 998244353. The key insight is that each cell can only be updated if the value to its left matches the target value, and the values in between must be different from the left value. This problem can be approached using dynamic programming and combinatorial counting.", "question_id": "arc189_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, x;\n    scanf(\"%d %d\", &n, &x);\n\n    GArray *red = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *blue = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *P = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *Q = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        g_array_append_val(red, a);\n        g_array_append_val(blue, b);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int p, q;\n        scanf(\"%d %d\", &p, &q);\n        g_array_append_val(P, p - 1);\n        g_array_append_val(Q, q - 1);\n    }\n\n    int operations = 0;\n    for (int i = 0; i < n; i++) {\n        if (i == x - 1) continue;\n\n        int r = g_array_index(red, int, i);\n        int b = g_array_index(blue, int, i);\n\n        if (r > 0) {\n            int p = g_array_index(P, int, i);\n            if (g_array_index(blue, int, p) > 0) {\n                operations++;\n            } else {\n                printf(\"-1\n\");\n                g_array_free(red, TRUE);\n                g_array_free(blue, TRUE);\n                g_array_free(P, TRUE);\n                g_array_free(Q, TRUE);\n                return 0;\n            }\n        }\n\n        if (b > 0) {\n            int q = g_array_index(Q, int, i);\n            if (g_array_index(red, int, q) > 0) {\n                operations++;\n            } else {\n                printf(\"-1\n\");\n                g_array_free(red, TRUE);\n                g_array_free(blue, TRUE);\n                g_array_free(P, TRUE);\n                g_array_free(Q, TRUE);\n                return 0;\n            }\n        }\n    }\n\n    printf(\"%d\n\", operations);\n\n    g_array_free(red, TRUE);\n    g_array_free(blue, TRUE);\n    g_array_free(P, TRUE);\n    g_array_free(Q, TRUE);\n\n    return 0;\n}", "reasoning": "The problem involves determining whether Takahashi can achieve a state where all boxes other than the X-th box contain no balls by repeatedly transferring balls between boxes according to given permutations. The solution involves checking if the number of red and blue balls can be transferred to the X-th box while ensuring no other box ends up with any balls. This requires analyzing the input and performing operations accordingly.", "question_id": "arc189_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *sizes = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &sizes[i]);\n    }\n\n    GArray *left_max = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *right_max = g_array_new(FALSE, FALSE, sizeof(int));\n\n    int current_max = 0;\n    for (int i = 0; i < n; i++) {\n        if (sizes[i] > current_max) {\n            current_max = sizes[i];\n        }\n        g_array_append_val(left_max, current_max);\n    }\n\n    current_max = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (sizes[i] > current_max) {\n            current_max = sizes[i];\n        }\n        g_array_prepend_val(right_max, current_max);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int result = sizes[i];\n        if (i > 0) {\n            result += g_array_index(left_max, int, i - 1);\n        }\n        if (i < n - 1) {\n            result += g_array_index(right_max, int, n - i - 2);\n        }\n        printf(\"%d \", result);\n    }\n\n    free(sizes);\n    g_array_free(left_max, TRUE);\n    g_array_free(right_max, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum size Takahashi can have after performing the allowed actions for each position K. The key insight is that Takahashi can only absorb slimes that are strictly smaller than him, and he can perform these actions any number of times. This means that for each position K, we need to find the largest possible size Takahashi can achieve by absorbing smaller slimes to his left and right, up to the point where no smaller slimes are available on either side.", "question_id": "arc189_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *coords = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &coords[i]);\n    }\n\n    qsort(coords, n, sizeof(int), compare);\n\n    int min_sum = 0;\n    for (int i = 0; i < n; i++) {\n        min_sum += coords[i];\n    }\n\n    printf(\"%d\n\", min_sum);\n\n    free(coords);\n\n    return 0;\n}", "reasoning": "To minimize the sum of the coordinates of the N pieces, we need to understand the effect of the operation on the coordinates. The operation moves the (i+1)-th and (i+2)-th pieces to symmetric positions with respect to the midpoint M between the i-th and (i+3)-th pieces. By analyzing this operation, we can deduce that the optimal strategy is to always move the middle two pieces towards the center of the remaining pieces. This ensures that the sum of the coordinates is minimized. To implement this, we can sort the coordinates and then repeatedly apply the operation to the middle two pieces until no more operations can be performed.", "question_id": "arc189_b"}
