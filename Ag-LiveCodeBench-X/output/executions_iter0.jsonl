{"question_id": "1873_A", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        char str[4];\n        scanf(\"%s\", str);\n\n        // Check if the string is already 'abc'\n        if (strcmp(str, \"abc\") == 0) {\n            printf(\"YES\\n\");\n            continue;\n        }\n\n        // Find the positions of 'a', 'b', and 'c'\n        int pos_a, pos_b, pos_c;\n        for (int i = 0; i < 3; i++) {\n            if (str[i] == 'a') pos_a = i;\n            if (str[i] == 'b') pos_b = i;\n            if (str[i] == 'c') pos_c = i;\n        }\n\n        // Check if swapping 'a' and 'b' makes 'abc'\n        if (pos_a != 0 || pos_b != 1) {\n            char temp = str[0];\n            str[0] = str[1];\n            str[1] = temp;\n            if (strcmp(str, \"abc\") == 0) {\n                printf(\"YES\\n\");\n                continue;\n            }\n            // Swap back\n            temp = str[0];\n            str[0] = str[1];\n            str[1] = temp;\n        }\n\n        // Check if swapping 'a' and 'c' makes 'abc'\n        if (pos_a != 0 || pos_c != 2) {\n            char temp = str[0];\n            str[0] = str[2];\n            str[2] = temp;\n            if (strcmp(str, \"abc\") == 0) {\n                printf(\"YES\\n\");\n                continue;\n            }\n            // Swap back\n            temp = str[0];\n            str[0] = str[2];\n            str[2] = temp;\n        }\n\n        // Check if swapping 'b' and 'c' makes 'abc'\n        if (pos_b != 1 || pos_c != 2) {\n            char temp = str[1];\n            str[1] = str[2];\n            str[2] = temp;\n            if (strcmp(str, \"abc\") == 0) {\n                printf(\"YES\\n\");\n                continue;\n            }\n            // Swap back\n            temp = str[1];\n            str[1] = str[2];\n            str[2] = temp;\n        }\n\n        // If none of the above swaps work, it's not possible\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_6c8wij_i/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_6c8wij_i/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1873_B", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *digits = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &digits[i]);\n        }\n\n        int maxProduct = 1;\n        int maxIndex = -1;\n\n        for (int i = 0; i < n; i++) {\n            int product = 1;\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    product *= (digits[j] + 1);\n                } else {\n                    product *= digits[j];\n                }\n            }\n            if (product > maxProduct) {\n                maxProduct = product;\n                maxIndex = i;\n            }\n        }\n\n        printf(\"%d\n\", maxProduct);\n\n        free(digits);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0lgbqaft/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0lgbqaft/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1873_D", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n        char s[n + 1];\n        scanf(\"%s\", s);\n\n        int operations = 0;\n        int i = 0;\n\n        while (i < n) {\n            if (s[i] == 'B') {\n                operations++;\n                while (i < n && s[i] == 'B' && (i - i % k) % k == 0) {\n                    i++;\n                }\n            } else {\n                i++;\n            }\n        }\n\n        printf(\"%d\\n\", operations);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_w5jh1gjs/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_w5jh1gjs/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1883_B", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        char s[100001];\n        scanf(\"%s\", s);\n\n        // Count the frequency of each character\n        GHashTable *count = g_hash_table_new(g_str_hash, g_str_equal);\n        for (int i = 0; i < n; i++) {\n            char *ch = g_strdup(&s[i]);\n            int val = GPOINTER_TO_INT(g_hash_table_lookup(count, ch)) + 1;\n            g_hash_table_insert(count, ch, GINT_TO_POINTER(val));\n        }\n\n        int odd_count = 0;\n        GHashTableIter iter;\n        gpointer key, value;\n        g_hash_table_iter_init(&iter, count);\n        while (g_hash_table_iter_next(&iter, &key, &value)) {\n            if (GPOINTER_TO_INT(value) % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        // Check if it's possible to form a palindrome\n        if (odd_count <= 1 && n - k >= 0 && (n - k) % 2 == 0) {\n            printf(\"YES\n\");\n        } else {\n            printf(\"NO\n\");\n        }\n\n        // Clean up\n        g_hash_table_destroy(count);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_mxscjkya/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_mxscjkya/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1883_C", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (int i = 0; i < n; i++) {\n            int num;\n            scanf(\"%d\", &num);\n            int remainder = num % k;\n            if (remainder != 0) {\n                g_hash_table_insert(count, GINT_TO_POINTER(remainder), GINT_TO_POINTER(1));\n            }\n        }\n\n        int operations = 0;\n        if (k == 2) {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(1))) {\n                operations = 1;\n            }\n        } else if (k == 3) {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(1))) {\n                operations = 1;\n            } else if (g_hash_table_lookup(count, GINT_TO_POINTER(2))) {\n                operations = 2;\n            }\n        } else if (k == 4) {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(2))) {\n                operations = 1;\n            }\n        } else if (k == 5) {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(1))) {\n                operations = 1;\n            } else if (g_hash_table_lookup(count, GINT_TO_POINTER(2))) {\n                operations = 2;\n            } else if (g_hash_table_lookup(count, GINT_TO_POINTER(3))) {\n                operations = 3;\n            } else if (g_hash_table_lookup(count, GINT_TO_POINTER(4))) {\n                operations = 4;\n            }\n        }\n\n        printf(\"%d\n\", operations);\n\n        g_hash_table_destroy(count);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_lw4klwam/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_lw4klwam/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1899_A", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        if (n % 3 == 0) {\n            printf(\"First\\n\");\n        } else {\n            printf(\"Second\\n\");\n        }\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"First\", \"got\": \"Second\", \"stderr\": \"Test case 0 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "First", "got": "Second", "stderr": "Test case 0 produced wrong output\n"}
{"question_id": "1899_B", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *weights = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &weights[i]);\n        }\n\n        qsort(weights, n, sizeof(int), compare);\n\n        long long sum1 = 0, sum2 = 0;\n        for (int i = 0; i < n / 2; i++) {\n            sum1 += weights[i];\n        }\n        for (int i = n / 2; i < n; i++) {\n            sum2 += weights[i];\n        }\n\n        printf(\"%lld\n\", llabs(sum1 - sum2));\n\n        free(weights);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_lx_oobge/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_lx_oobge/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1899_C", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *arr = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &arr[i]);\n        }\n\n        int max_sum = INT_MIN;\n        int current_sum = 0;\n        int last_parity = -1; // -1 for unknown, 0 for even, 1 for odd\n\n        for (int i = 0; i < n; i++) {\n            int current_parity = arr[i] % 2;\n\n            if (last_parity == -1 || last_parity != current_parity) {\n                current_sum += arr[i];\n                last_parity = current_parity;\n            } else {\n                current_sum = arr[i];\n                last_parity = current_parity;\n            }\n\n            max_sum = fmax(max_sum, current_sum);\n        }\n\n        printf(\"%d\n\", max_sum);\n\n        free(arr);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__47hwmkv/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__47hwmkv/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1899_D", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n        long long count = 0;\n\n        for (int i = 0; i < n; i++) {\n            int a;\n            scanf(\"%d\", &a);\n\n            long long key = (long long)a * (1LL << a);\n            gpointer value = g_hash_table_lookup(map, GINT_TO_POINTER(key));\n\n            if (value != NULL) {\n                count += GPOINTER_TO_LONG(value);\n            }\n\n            g_hash_table_insert(map, GINT_TO_POINTER(key), GINT_TO_LONG(value ? GPOINTER_TO_LONG(value) + 1 : 1));\n        }\n\n        printf(\"%lld\n\", count);\n\n        g_hash_table_destroy(map);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_mitykrmf/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_mitykrmf/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc301_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char s[1000];\n    scanf(\"%s\", s);\n\n    int takahashi_wins = 0;\n    int aoki_wins = 0;\n    int takahashi_last_win = -1;\n    int aoki_last_win = -1;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'T') {\n            takahashi_wins++;\n            takahashi_last_win = i;\n        } else if (s[i] == 'A') {\n            aoki_wins++;\n            aoki_last_win = i;\n        }\n    }\n\n    if (takahashi_wins > aoki_wins) {\n        printf(\"T\\n\");\n    } else if (aoki_wins > takahashi_wins) {\n        printf(\"A\\n\");\n    } else {\n        if (takahashi_last_win < aoki_last_win) {\n            printf(\"T\\n\");\n        } else {\n            printf(\"A\\n\");\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tfcixlct/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_tfcixlct/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc301_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Read the input sequence\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    // Perform the insertion process\n    bool inserted;\n    do {\n        inserted = false;\n        for (int i = 0; i < arr->len - 1; i++) {\n            int diff = abs(g_array_index(arr, int, i) - g_array_index(arr, int, i + 1));\n            if (diff != 1) {\n                int start = (g_array_index(arr, int, i) < g_array_index(arr, int, i + 1)) ? g_array_index(arr, int, i) + 1 : g_array_index(arr, int, i + 1) - 1;\n                int end = (g_array_index(arr, int, i) < g_array_index(arr, int, i + 1)) ? g_array_index(arr, int, i + 1) - 1 : g_array_index(arr, int, i);\n                for (int j = start; j <= end; j++) {\n                    g_array_insert_val(arr, i + 1, j);\n                }\n                inserted = true;\n                break;\n            }\n        }\n    } while (inserted);\n\n    // Print the final sequence\n    for (int i = 0; i < arr->len; i++) {\n        printf(\"%d \", g_array_index(arr, int, i));\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0v3mvbji/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0v3mvbji/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc301_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[200001], T[200001];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int len = strlen(S);\n    GHashTable *countS = g_hash_table_new(g_str_hash, g_str_equal);\n    GHashTable *countT = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Count characters in S and T\n    for (int i = 0; i < len; i++) {\n        if (S[i] != '@') {\n            int *count = g_hash_table_lookup(countS, &S[i]);\n            if (count == NULL) {\n                g_hash_table_insert(countS, &S[i], GINT_TO_POINTER(1));\n            } else {\n                *count += 1;\n            }\n        }\n        if (T[i] != '@') {\n            int *count = g_hash_table_lookup(countT, &T[i]);\n            if (count == NULL) {\n                g_hash_table_insert(countT, &T[i], GINT_TO_POINTER(1));\n            } else {\n                *count += 1;\n            }\n        }\n    }\n\n    // Check if we can balance the counts\n    int wildcardCountS = 0;\n    int wildcardCountT = 0;\n    int mismatch = 0;\n\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, countS);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int count = GPOINTER_TO_INT(value);\n        if (count > 0) {\n            int *Tcount = g_hash_table_lookup(countT, key);\n            if (Tcount != NULL) {\n                if (*Tcount < count) {\n                    mismatch += count - *Tcount;\n                }\n            } else {\n                mismatch += count;\n            }\n        }\n    }\n\n    g_hash_table_iter_init(&iter, countT);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int count = GPOINTER_TO_INT(value);\n        if (count > 0) {\n            int *Scount = g_hash_table_lookup(countS, key);\n            if (Scount != NULL) {\n                if (*Scount < count) {\n                    mismatch += count - *Scount;\n                }\n            } else {\n                mismatch += count;\n            }\n        }\n    }\n\n    // Check if we have enough wildcards to balance the mismatch\n    for (int i = 0; i < len; i++) {\n        if (S[i] == '@') {\n            wildcardCountS++;\n        }\n        if (T[i] == '@') {\n            wildcardCountT++;\n        }\n    }\n\n    if (wildcardCountS >= mismatch && wildcardCountT >= mismatch) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(countS);\n    g_hash_table_destroy(countT);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ypofq309/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ypofq309/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc301_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[61];\n    long long N;\n    scanf(\"%s %lld\", S, &N);\n\n    int len = strlen(S);\n    GArray *numbers = g_array_new(FALSE, FALSE, sizeof(long long));\n\n    void generate_numbers(char *str, int index, long long current) {\n        if (index == len) {\n            g_array_append_val(numbers, current);\n            return;\n        }\n        if (str[index] == '?') {\n            generate_numbers(str, index + 1, current * 2);\n            generate_numbers(str, index + 1, current * 2 + 1);\n        } else {\n            generate_numbers(str, index + 1, current * 2 + (str[index] - '0')));\n        }\n    }\n\n    generate_numbers(S, 0, 0);\n\n    long long result = -1;\n    for (int i = 0; i < numbers->len; i++) {\n        long long num = g_array_index(numbers, long long, i);\n        if (num <= N && num > result) {\n            result = num;\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n\n    g_array_free(numbers, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_k7ubk4rg/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_k7ubk4rg/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc301_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 301\n\n// Directions for moving up, down, left, and right\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\n// Function to check if a position is within the grid boundaries\nbool isValid(int x, int y, int H, int W) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nint main() {\n    int H, W, T;\n    scanf(\"%d %d %d\", &H, &W, &T);\n\n    char grid[MAX][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    // Find the start and goal positions\n    int startX, startY, goalX, goalY;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                startX = i;\n                startY = j;\n            } else if (grid[i][j] == 'G') {\n                goalX = i;\n                goalY = j;\n            }\n        }\n    }\n\n    // BFS to find the maximum number of candy squares that can be visited\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(startX * W + startY));\n    g_hash_table_insert(visited, GINT_TO_POINTER(startX * W + startY), GINT_TO_POINTER(0));\n\n    int maxCandies = 0;\n\n    while (!g_queue_is_empty(queue) && T > 0) {\n        int size = g_queue_get_length(queue);\n        for (int i = 0; i < size; i++) {\n            int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n            int x = current / W;\n            int y = current % W;\n\n            for (int d = 0; d < 4; d++) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n\n                if (isValid(nx, ny, H, W) && grid[nx][ny] != '#') {\n                    int newCandies = g_hash_table_lookup(visited, GINT_TO_POINTER(nx * W + ny)) ? g_hash_table_lookup(visited, GINT_TO_POINTER(nx * W + ny)) : 0;\n\n                    if (grid[nx][ny] == 'o') {\n                        newCandies++;\n                    }\n\n                    if (newCandies > maxCandies) {\n                        maxCandies = newCandies;\n                    }\n\n                    int key = nx * W + ny;\n                    if (!g_hash_table_contains(visited, GINT_TO_POINTER(key)) || newCandies > g_hash_table_lookup(visited, GINT_TO_POINTER(key))) {\n                        g_hash_table_insert(visited, GINT_TO_POINTER(key), GINT_TO_POINTER(newCandies));\n                        g_queue_push_tail(queue, GINT_TO_POINTER(key));\n                    }\n                }\n            }\n        }\n        T--;\n    }\n\n    printf(\"%d\n\", maxCandies);\n\n    g_hash_table_destroy(visited);\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_w7ee8qx1/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_w7ee8qx1/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc301_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int first;\n    int second;\n    int third;\n    int fourth;\n} State;\n\ntypedef struct {\n    GHashTable *table;\n} Memo;\n\nint countValidStrings(const char *s, int index, int prev, Memo *memo) {\n    if (index == strlen(s)) {\n        return 1;\n    }\n\n    State key = {prev, prev, 0, 0};\n    gpointer value = g_hash_table_lookup(memo->table, &key);\n    if (value) {\n        return GPOINTER_TO_INT(value);\n    }\n\n    int count = 0;\n\n    if (s[index] == '?') {\n        for (char c = 'A'; c <= 'Z'; c++) {\n            count = (count + countValidStrings(s, index + 1, c, memo)) % MOD;\n        }\n    } else {\n        count = countValidStrings(s, index + 1, s[index], memo);\n    }\n\n    g_hash_table_insert(memo->table, &key, GINT_TO_POINTER(count));\n\n    return count;\n}\n\nint main() {\n    char s[300005];\n    scanf(\"%s\", s);\n\n    Memo memo = {g_hash_table_new(g_direct_hash, g_direct_equal)};\n\n    int result = countValidStrings(s, 0, 0, &memo);\n\n    printf(\"%d\n\", result);\n\n    g_hash_table_destroy(memo.table);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_6it_3gzk/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_6it_3gzk/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc302_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint main() {\n    // Read input\n    long long A, B;\n    scanf(\"%lld %lld\", &A, &B);\n\n    // Calculate the minimum number of attacks needed\n    long long attacks = (A + B - 1) / B;\n\n    // Output the result\n    printf(\"%lld\n\", attacks);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_msry4710/program.c: In function 'main':\\n/tmp/agnostics_c_msry4710/program.c:14:12: warning: missing terminating \\\" character\\n   14 |     printf(\\\"%lld\\n      |            ^\\n/tmp/agnostics_c_msry4710/program.c:14:12: error: missing terminating \\\" character\\n   14 |     printf(\\\"%lld\\n      |            ^~~~~\\n/tmp/agnostics_c_msry4710/program.c:15:1: warning: missing terminating \\\" character\\n   15 | \\\", attacks);\\n      | ^\\n/tmp/agnostics_c_msry4710/program.c:15:1: error: missing terminating \\\" character\\n   15 | \\\", attacks);\\n      | ^~~~~~~~~~~~\\n/tmp/agnostics_c_msry4710/program.c:17:5: error: expected expression before 'return'\\n   17 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_msry4710/program.c:17:14: error: expected ';' before '}' token\\n   17 |     return 0;\\n      |              ^\\n      |              ;\\n   18 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_msry4710/program.c: In function 'main':\n/tmp/agnostics_c_msry4710/program.c:14:12: warning: missing terminating \" character\n   14 |     printf(\"%lld\n      |            ^\n/tmp/agnostics_c_msry4710/program.c:14:12: error: missing terminating \" character\n   14 |     printf(\"%lld\n      |            ^~~~~\n/tmp/agnostics_c_msry4710/program.c:15:1: warning: missing terminating \" character\n   15 | \", attacks);\n      | ^\n/tmp/agnostics_c_msry4710/program.c:15:1: error: missing terminating \" character\n   15 | \", attacks);\n      | ^~~~~~~~~~~~\n/tmp/agnostics_c_msry4710/program.c:17:5: error: expected expression before 'return'\n   17 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_msry4710/program.c:17:14: error: expected ';' before '}' token\n   17 |     return 0;\n      |              ^\n      |              ;\n   18 | }\n      | ~             \n"}
{"question_id": "abc302_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define H 100\n#define W 100\n\nbool is_collinear(int x1, int y1, int x2, int y2, int x3, int y3) {\n    return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0;\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    char grid[H][W + 1];\n\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 's') {\n                for (int di = -1; di <= 1; di++) {\n                    for (int dj = -1; dj <= 1; dj++) {\n                        if (di == 0 && dj == 0) continue;\n                        int ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < H && nj >= 0 && nj < W && grid[ni][nj] == 'n') {\n                            int ni2 = ni + di, nj2 = nj + dj;\n                            if (ni2 >= 0 && ni2 < H && nj2 >= 0 && nj2 < W && grid[ni2][nj2] == 'u') {\n                                int ni3 = ni2 + di, nj3 = nj2 + dj;\n                                if (ni3 >= 0 && ni3 < H && nj3 >= 0 && nj3 < W && grid[ni3][nj3] == 'k') {\n                                    int ni4 = ni3 + di, nj4 = nj3 + dj;\n                                    if (ni4 >= 0 && ni4 < H && nj4 >= 0 && nj4 < W && grid[ni4][nj4] == 'e') {\n                                        if (is_collinear(i, j, ni, nj, ni2, nj2) &&\n                                            is_collinear(ni, nj, ni2, nj2, ni3, nj3) &&\n                                            is_collinear(ni2, nj2, ni3, nj3, ni4, nj4)) {\n                                            printf(\"%d %d\n\", i + 1, j + 1);\n                                            printf(\"%d %d\n\", ni + 1, nj + 1);\n                                            printf(\"%d %d\n\", ni2 + 1, nj2 + 1);\n                                            printf(\"%d %d\n\", ni3 + 1, nj3 + 1);\n                                            printf(\"%d %d\n\", ni4 + 1, nj4 + 1);\n                                            return 0;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"No solution found\n\");\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_k_0nn3bf/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_k_0nn3bf/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc302_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 8\n#define MAX_M 5\n\nbool canTransform(const char *s1, const char *s2) {\n    int diff = 0;\n    for (int i = 0; i < strlen(s1); i++) {\n        if (s1[i] != s2[i]) {\n            diff++;\n            if (diff > 1) {\n                return false;\n            }\n        }\n    }\n    return diff == 1;\n}\n\nbool dfs(const char *target, GHashTable *visited, GHashTable *graph, int *path, int pathLength) {\n    if (strcmp(target, path[pathLength - 1]) == 0) {\n        return true;\n    }\n\n    GList *neighbors = g_hash_table_lookup(graph, (gpointer)target);\n    if (neighbors) {\n        GList *node = neighbors;\n        while (node) {\n            const char *neighbor = (const char *)node->data;\n            if (!g_hash_table_contains(visited, (gpointer)neighbor)) {\n                g_hash_table_insert(visited, (gpointer)neighbor, (gpointer)true);\n                path[pathLength] = neighbor;\n                if (dfs(neighbor, visited, graph, path, pathLength + 1)) {\n                    return true;\n                }\n                g_hash_table_remove(visited, (gpointer)neighbor);\n            }\n            node = node->next;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashTable *graph = g_hash_table_new(g_str_hash, g_str_equal);\n    char **strings = (char **)malloc(N * sizeof(char *));\n\n    for (int i = 0; i < N; i++) {\n        strings[i] = (char *)malloc((M + 1) * sizeof(char));\n        scanf(\"%s\", strings[i]);\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i != j && canTransform(strings[i], strings[j])) {\n                g_hash_table_insert(graph, (gpointer)strings[i], (gpointer)strings[j]);\n                g_hash_table_insert(graph, (gpointer)strings[j], (gpointer)strings[i]);\n            }\n        }\n    }\n\n    char *path[N];\n    bool found = false;\n\n    for (int i = 0; i < N; i++) {\n        GHashTable *visited = g_hash_table_new(g_str_hash, g_str_equal);\n        path[0] = strings[i];\n        if (dfs(strings[i], visited, graph, path, 1)) {\n            found = true;\n            break;\n        }\n        g_hash_table_destroy(visited);\n    }\n\n    if (found) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    for (int i = 0; i < N; i++) {\n        free(strings[i]);\n    }\n    free(strings);\n    g_hash_table_destroy(graph);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_svgvisty/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_svgvisty/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc302_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m, d;\n    scanf(\"%d %d %d\", &n, &m, &d);\n\n    GArray *aoki = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(aoki, value);\n    }\n\n    GArray *snuke = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < m; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(snuke, value);\n    }\n\n    g_array_sort(aoki, compare);\n    g_array_sort(snuke, compare);\n\n    int max_sum = -1;\n    int i = 0, j = 0;\n\n    while (i < n && j < m) {\n        if (g_array_index(aoki, int, i) + d >= g_array_index(snuke, int, j)) {\n            max_sum = g_array_index(aoki, int, i) + g_array_index(snuke, int, j);\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    printf(\"%d\n\", max_sum);\n\n    g_array_free(aoki, TRUE);\n    g_array_free(snuke, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_q0lfljgz/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_q0lfljgz/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc302_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MAX_N 300005\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize data structures\n    GHashTable *graph = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GQueue *queue = g_queue_new();\n    int *degree = (int *)calloc(N + 1, sizeof(int));\n\n    // Initialize the queue with all vertices\n    for (int i = 1; i <= N; i++) {\n        g_queue_push_tail(queue, GINT_TO_POINTER(i));\n    }\n\n    for (int i = 0; i < Q; i++) {\n        int type, u, v;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            scanf(\"%d %d\", &u, &v);\n            // Add edge between u and v\n            if (!g_hash_table_contains(graph, GINT_TO_POINTER(u))) {\n                g_hash_table_insert(graph, GINT_TO_POINTER(u), g_array_new(FALSE, FALSE, sizeof(int)));\n            }\n            if (!g_hash_table_contains(graph, GINT_TO_POINTER(v))) {\n                g_hash_table_insert(graph, GINT_TO_POINTER(v), g_array_new(FALSE, FALSE, sizeof(int)));\n            }\n            g_array_append_val(g_hash_table_lookup(graph, GINT_TO_POINTER(u)), v);\n            g_array_append_val(g_hash_table_lookup(graph, GINT_TO_POINTER(v)), u);\n\n            // Update degrees\n            degree[u]++;\n            degree[v]++;\n\n            // If either vertex was previously disconnected, remove it from the queue\n            if (degree[u] == 1) {\n                g_queue_remove(queue, GINT_TO_POINTER(u));\n            }\n            if (degree[v] == 1) {\n                g_queue_remove(queue, GINT_TO_POINTER(v));\n            }\n        } else if (type == 2) {\n            scanf(\"%d\", &v);\n            // Remove all edges connected to v\n            if (g_hash_table_contains(graph, GINT_TO_POINTER(v))) {\n                GArray *neighbors = g_hash_table_lookup(graph, GINT_TO_POINTER(v));\n                for (int j = 0; j < neighbors->len; j++) {\n                    int neighbor = g_array_index(neighbors, int, j);\n                    g_array_remove_range(g_hash_table_lookup(graph, GINT_TO_POINTER(neighbor)), j, 1);\n                    degree[neighbor]--;\n                    if (degree[neighbor] == 1) {\n                        g_queue_push_tail(queue, GINT_TO_POINTER(neighbor));\n                    }\n                    j--;\n                }\n                g_hash_table_remove(graph, GINT_TO_POINTER(v));\n                degree[v] = 0;\n            }\n        }\n\n        // Print the number of disconnected vertices\n        printf(\"%d\\n\", g_queue_get_length(queue));\n    }\n\n    // Clean up\n    g_hash_table_destroy(graph);\n    g_queue_free(queue);\n    free(degree);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_olzhavcw/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_olzhavcw/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc302_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Create a hash table to keep track of sets containing 1 and M\n    GHashTable *sets_with_1 = g_hash_table_new(g_int_hash, g_int_equal);\n    GHashTable *sets_with_m = g_hash_table_new(g_int_hash, g_int_equal);\n\n    // Read the sets and update the hash tables\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        int *set = (int *)malloc(a * sizeof(int));\n        for (int j = 0; j < a; j++) {\n            scanf(\"%d\", &set[j]);\n            if (set[j] == 1) {\n                g_hash_table_insert(sets_with_1, set, set);\n            }\n            if (set[j] == m) {\n                g_hash_table_insert(sets_with_m, set, set);\n            }\n        }\n        // Free the allocated memory for the set\n        free(set);\n    }\n\n    // Check if both 1 and M are already in the same set\n    if (g_hash_table_lookup(sets_with_1, g_hash_table_lookup(sets_with_m, NULL)) != NULL) {\n        printf(\"0\n\");\n        g_hash_table_destroy(sets_with_1);\n        g_hash_table_destroy(sets_with_m);\n        return 0;\n    }\n\n    // Initialize the minimum operations counter\n    int min_operations = -1;\n\n    // Try merging sets with 1 and sets with M\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, sets_with_1);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        g_hash_table_iter_init(&iter, sets_with_m);\n        while (g_hash_table_iter_next(&iter, &key, &value)) {\n            int *set1 = (int *)key;\n            int *set2 = (int *)value;\n\n            // Check if there is a common element between set1 and set2\n            for (int i = 0; i < a; i++) {\n                for (int j = 0; j < a; j++) {\n                    if (set1[i] == set2[j]) {\n                        // Merge set1 and set2\n                        int *merged_set = (int *)malloc((a + a) * sizeof(int));\n                        int merged_size = 0;\n                        for (int k = 0; k < a; k++) {\n                            merged_set[merged_size++] = set1[k];\n                        }\n                        for (int k = 0; k < a; k++) {\n                            merged_set[merged_size++] = set2[k];\n                        }\n\n                        // Check if the merged set contains both 1 and M\n                        bool contains_1 = false;\n                        bool contains_m = false;\n                        for (int k = 0; k < merged_size; k++) {\n                            if (merged_set[k] == 1) {\n                                contains_1 = true;\n                            }\n                            if (merged_set[k] == m) {\n                                contains_m = true;\n                            }\n                        }\n\n                        if (contains_1 && contains_m) {\n                            // Update the minimum operations counter\n                            if (min_operations == -1 || min_operations > 1) {\n                                min_operations = 1;\n                            }\n                        }\n\n                        // Free the allocated memory for the merged set\n                        free(merged_set);\n                    }\n                }\n            }\n        }\n    }\n\n    // Print the result\n    printf(\"%d\n\", min_operations);\n\n    // Clean up\n    g_hash_table_destroy(sets_with_1);\n    g_hash_table_destroy(sets_with_m);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_uelagviz/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_uelagviz/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc303_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[101], t[101];\n    scanf(\"%s\", s);\n    scanf(\"%s\", t);\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] != t[i] && !(s[i] == '1' && t[i] == 'l') && !(s[i] == 'l' && t[i] == '1') && !(s[i] == '0' && t[i] == 'o') && !(s[i] == 'o' && t[i] == '0')) {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_l2a4492o/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_l2a4492o/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc303_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Create a 2D array to store the positions of each person in each photo\n    int **positions = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        positions[i] = (int *)malloc(M * sizeof(int));\n    }\n\n    // Populate the positions array\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &positions[j][i]);\n        }\n    }\n\n    // Initialize a hash table to keep track of pairs of people who have been next to each other\n    GHashTable *next_to_each_other = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Check each photo for pairs of people who have been next to each other\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N - 1; j++) {\n            int person1 = positions[j][i];\n            int person2 = positions[j + 1][i];\n            GList *key = g_list_prepend(NULL, GINT_TO_POINTER(person1));\n            key = g_list_prepend(key, GINT_TO_POINTER(person2));\n            g_hash_table_insert(next_to_each_other, key, GINT_TO_POINTER(1));\n        }\n    }\n\n    // Count the number of pairs of people who did not stand next to each other\n    int count = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            GList *key = g_list_prepend(NULL, GINT_TO_POINTER(i));\n            key = g_list_prepend(key, GINT_TO_POINTER(j));\n            if (!g_hash_table_lookup_extended(next_to_each_other, key, NULL, NULL)) {\n                count++;\n            }\n            g_list_free(key);\n        }\n    }\n\n    // Print the result\n    printf(\"%d\n\", count);\n\n    // Free memory\n    for (int i = 0; i < N; i++) {\n        free(positions[i]);\n    }\n    free(positions);\n    g_hash_table_destroy(next_to_each_other);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_6nemq30q/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_6nemq30q/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc303_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M, H, K;\n    scanf(\"%d %d %d %d\", &N, &M, &H, &K);\n\n    char S[N + 1];\n    scanf(\"%s\", S);\n\n    GHashTable *items = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < M; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        g_hash_table_insert(items, GINT_TO_POINTER(x * 200001 + y), GINT_TO_POINTER(K));\n    }\n\n    int x = 0, y = 0;\n    for (int i = 0; i < N; i++) {\n        H--;\n        if (H < 0) {\n            printf(\"No\\n\");\n            g_hash_table_destroy(items);\n            return 0;\n        }\n\n        if (S[i] == 'R') x++;\n        else if (S[i] == 'L') x--;\n        else if (S[i] == 'U') y++;\n        else if (S[i] == 'D') y--;\n\n        int key = x * 200001 + y;\n        if (g_hash_table_contains(items, GINT_TO_POINTER(key))) {\n            H = K;\n            g_hash_table_remove(items, GINT_TO_POINTER(key));\n        }\n    }\n\n    printf(\"Yes\\n\");\n\n    g_hash_table_destroy(items);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0f5tlu8r/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0f5tlu8r/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc303_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int X, Y, Z;\n    scanf(\"%d %d %d\", &X, &Y, &Z);\n\n    char S[300001];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n    int time = 0;\n    bool caps_lock = false;\n\n    for (int i = 0; i < n; i++) {\n        if (S[i] == 'A') {\n            if (caps_lock) {\n                time += X;\n            } else {\n                time += Y;\n            }\n        } else {\n            if (caps_lock) {\n                time += Y;\n            } else {\n                time += X;\n            }\n        }\n\n        if (S[i] == 'A' || S[i] == 'a') {\n            if (i + 1 < n && (S[i + 1] == 'A' || S[i + 1] == 'a')) {\n                time += Z;\n                caps_lock = !caps_lock;\n                i++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", time);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tfzwuedk/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_tfzwuedk/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc303_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Create adjacency list for the graph\n    GHashTable *adj = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        g_hash_table_insert(adj, GINT_TO_POINTER(i), g_array_new(FALSE, FALSE, sizeof(int)));\n    }\n\n    // Read edges and build the adjacency list\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        GArray *list_u = (GArray *)g_hash_table_lookup(adj, GINT_TO_POINTER(u));\n        g_array_append_val(list_u, v);\n        GArray *list_v = (GArray *)g_hash_table_lookup(adj, GINT_TO_POINTER(v));\n        g_array_append_val(list_v, u);\n    }\n\n    // Function to check if a node is a leaf\n    bool is_leaf(GHashTable *adj, int node) {\n        GArray *list = (GArray *)g_hash_table_lookup(adj, GINT_TO_POINTER(node));\n        return g_array_get_length(list) == 1;\n    }\n\n    // Function to find the level of a star\n    int find_star_level(GHashTable *adj, int root) {\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(root));\n        int level = 0;\n        while (!g_queue_is_empty(queue)) {\n            int size = g_queue_get_length(queue);\n            for (int i = 0; i < size; i++) {\n                int node = GPOINTER_TO_INT(g_queue_pop_head(queue));\n                GArray *list = (GArray *)g_hash_table_lookup(adj, GINT_TO_POINTER(node));\n                for (int j = 0; j < g_array_get_length(list); j++) {\n                    int neighbor = g_array_index(list, int, j);\n                    if (is_leaf(adj, neighbor)) {\n                        g_queue_push_tail(queue, GINT_TO_POINTER(neighbor));\n                    }\n                }\n            }\n            level++;\n        }\n        return level;\n    }\n\n    // Find all leaves and determine the stars\n    GArray *leaves = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        if (is_leaf(adj, i)) {\n            g_array_append_val(leaves, i);\n        }\n    }\n\n    // Determine the number of stars and their levels\n    GHashTable *stars = g_hash_table_new(g_direct_hash, g_direct_equal);\n    while (g_array_get_length(leaves) > 0) {\n        int root = g_array_index(leaves, int, 0);\n        g_array_remove_index(leaves, 0);\n        int level = find_star_level(adj, root);\n        g_hash_table_insert(stars, GINT_TO_POINTER(level), GINT_TO_POINTER(1));\n    }\n\n    // Print the levels of the stars sorted in ascending order\n    GList *keys = g_hash_table_get_keys(stars);\n    keys = g_list_sort(keys, (GCompareFunc)g_int_compare);\n    for (GList *key = keys; key != NULL; key = key->next) {\n        int level = GPOINTER_TO_INT(key->data);\n        int count = GPOINTER_TO_INT(g_hash_table_lookup(stars, key->data));\n        for (int i = 0; i < count; i++) {\n            printf(\"%d \", level);\n        }\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_hash_table_destroy(adj);\n    g_hash_table_destroy(stars);\n    g_list_free(keys);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_p0ky8tc_/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_p0ky8tc_/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc304_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_NAME_LENGTH 11\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int age;\n} Person;\n\n// Comparison function for qsort to sort by age\nint compare_by_age(const void *a, const void *b) {\n    Person *personA = (Person *)a;\n    Person *personB = (Person *)b;\n    return personA->age - personB->age;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create an array of Person structures\n    Person people[n];\n\n    // Read input and store in the array\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s %d\", people[i].name, &people[i].age);\n    }\n\n    // Sort the array by age using qsort\n    qsort(people, n, sizeof(Person), compare_by_age);\n\n    // Find the index of the youngest person\n    int youngest_index = 0;\n    for (int i = 1; i < n; i++) {\n        if (people[i].age < people[youngest_index].age) {\n            youngest_index = i;\n        }\n    }\n\n    // Print the names in clockwise order starting from the youngest person\n    for (int i = 0; i < n; i++) {\n        int index = (youngest_index + i) % n;\n        printf(\"%s\n\", people[index].name);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_kxeosx73/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_kxeosx73/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc304_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    if (n <= 999) {\n        printf(\"%d\n\", n);\n    } else if (n <= 9999) {\n        printf(\"%d\n\", n / 10 * 10);\n    } else if (n <= 99999) {\n        printf(\"%d\n\", n / 100 * 100);\n    } else if (n <= 999999) {\n        printf(\"%d\n\", n / 1000 * 1000);\n    } else if (n <= 9999999) {\n        printf(\"%d\n\", n / 10000 * 10000);\n    } else if (n <= 99999999) {\n        printf(\"%d\n\", n / 100000 * 100000);\n    } else {\n        printf(\"%d\n\", n / 1000000 * 1000000);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_o8i2wv2r/program.c: In function 'main':\\n/tmp/agnostics_c_o8i2wv2r/program.c:9:16: warning: missing terminating \\\" character\\n    9 |         printf(\\\"%d\\n      |                ^\\n/tmp/agnostics_c_o8i2wv2r/program.c:9:16: error: missing terminating \\\" character\\n    9 |         printf(\\\"%d\\n      |                ^~~\\n/tmp/agnostics_c_o8i2wv2r/program.c:10:1: warning: missing terminating \\\" character\\n   10 | \\\", n);\\n      | ^\\n/tmp/agnostics_c_o8i2wv2r/program.c:10:1: error: missing terminating \\\" character\\n   10 | \\\", n);\\n      | ^~~~~~\\n/tmp/agnostics_c_o8i2wv2r/program.c:11:5: error: expected expression before '}' token\\n   11 |     } else if (n <= 9999) {\\n      |     ^\\n/tmp/agnostics_c_o8i2wv2r/program.c:9:16: error: expected ';' before '}' token\\n    9 |         printf(\\\"%d\\n      |                ^\\n      |                ;\\n   10 | \\\", n);\\n   11 |     } else if (n <= 9999) {\\n      |     ~           \\n/tmp/agnostics_c_o8i2wv2r/program.c:12:16: warning: missing terminating \\\" character\\n   12 |         printf(\\\"%d\\n      |                ^\\n/tmp/agnostics_c_o8i2wv2r/program.c:12:16: error: missing terminating \\\" character\\n   12 |         printf(\\\"%d\\n      |                ^~~\\n/tmp/agnostics_c_o8i2wv2r/program.c:13:1: warning: missing terminating \\\" character\\n   13 | \\\", n / 10 * 10);\\n      | ^\\n/tmp/agnostics_c_o8i2wv2r/program.c:13:1: error: missing terminating \\\" character\\n   13 | \\\", n / 10 * 10);\\n      | ^~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_o8i2wv2r/program.c:14:5: error: expected expression before '}' token\\n   14 |     } else if (n <= 99999) {\\n      |     ^\\n/tmp/agnostics_c_o8i2wv2r/program.c:12:16: error: expected ';' before '}' token\\n   12 |         printf(\\\"%d\\n      |                ^\\n      |                ;\\n   13 | \\\", n / 10 * 10);\\n   14 |     } else if (n <= 99999) {\\n      |     ~           \\n/tmp/agnostics_c_o8i2wv2r/program.c:15:16: warning: missing terminating \\\" chara", "raw_stderr": "", "result": "fail"}
{"question_id": "abc304_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_N 2000\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n\n    double X[MAX_N], Y[MAX_N];\n\n    // Read coordinates of each person\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf\", &X[i], &Y[i]);\n    }\n\n    // Check if person 1 is infected\n    bool person1_infected = false;\n    for (int i = 0; i < N; i++) {\n        double distance = sqrt(pow(X[i] - X[0], 2) + pow(Y[i] - Y[0], 2));\n        if (distance <= D) {\n            person1_infected = true;\n            break;\n        }\n    }\n\n    // Check if each person is infected\n    for (int i = 0; i < N; i++) {\n        if (person1_infected) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_af50ro93/program.c: In function 'main':\\n/tmp/agnostics_c_af50ro93/program.c:19:5: error: unknown type name 'bool'\\n   19 |     bool person1_infected = false;\\n      |     ^~~~\\n/tmp/agnostics_c_af50ro93/program.c:4:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n    3 | #include <math.h>\\n  +++ |+#include <stdbool.h>\\n    4 | \\n/tmp/agnostics_c_af50ro93/program.c:19:29: error: 'false' undeclared (first use in this function)\\n   19 |     bool person1_infected = false;\\n      |                             ^~~~~\\n/tmp/agnostics_c_af50ro93/program.c:19:29: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_af50ro93/program.c:19:29: note: each undeclared identifier is reported only once for each function it appears in\\n/tmp/agnostics_c_af50ro93/program.c:23:32: error: 'true' undeclared (first use in this function)\\n   23 |             person1_infected = true;\\n      |                                ^~~~\\n/tmp/agnostics_c_af50ro93/program.c:23:32: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_af50ro93/program.c:31:20: warning: missing terminating \\\" character\\n   31 |             printf(\\\"Yes\\n      |                    ^\\n/tmp/agnostics_c_af50ro93/program.c:31:20: error: missing terminating \\\" character\\n   31 |             printf(\\\"Yes\\n      |                    ^~~~\\n/tmp/agnostics_c_af50ro93/program.c:32:1: warning: missing terminating \\\" character\\n   32 | \\\");\\n      | ^\\n/tmp/agnostics_c_af50ro93/program.c:32:1: error: missing terminating \\\" character\\n   32 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_af50ro93/program.c:33:9: error: expected expression before '}' token\\n   33 |         } else {\\n      |         ^\\n/tmp/agnostics_c_af50ro93/program.c:31:20: error: expected ';' before '}' token\\n   31 |             printf(\\\"Yes\\n      |              ", "raw_stderr": "", "result": "fail"}
{"question_id": "abc304_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n\nint main() {\n    int W, H;\n    scanf(\"%d %d\", &W, &H);\n\n    int N;\n    scanf(\"%d\", &N);\n    int strawberries[N][2];\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &strawberries[i][0], &strawberries[i][1]);\n    }\n\n    int A;\n    scanf(\"%d\", &A);\n    int a[A];\n\n    for (int i = 0; i < A; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int B;\n    scanf(\"%d\", &B);\n    int b[B];\n\n    for (int i = 0; i < B; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    // Sort the strawberry coordinates\n    qsort(strawberries, N, sizeof(strawberries[0]), (int (*)(const void *, const void *))compare);\n\n    // Sort the cutting lines\n    qsort(a, A, sizeof(a[0]), (int (*)(const void *, const void *))compare);\n    qsort(b, B, sizeof(b[0]), (int (*)(const void *, const void *))compare);\n\n    // Initialize the minimum and maximum number of strawberries\n    int min_strawberries = INT_MAX;\n    int max_strawberries = 0;\n\n    // Iterate through all possible pieces\n    for (int i = 0; i <= A; i++) {\n        for (int j = 0; j <= B; j++) {\n            int x1 = (i == 0) ? 0 : a[i - 1];\n            int y1 = (j == 0) ? 0 : b[j - 1];\n            int x2 = (i == A) ? W : a[i];\n            int y2 = (j == B) ? H : b[j];\n\n            int count = 0;\n\n            // Count the strawberries in the current piece\n            for (int k = 0; k < N; k++) {\n                if (strawberries[k][0] > x1 && strawberries[k][0] < x2 && strawberries[k][1] > y1 && strawberries[k][1] < y2) {\n                    count++;\n                }\n            }\n\n            // Update the minimum and maximum number of strawberries\n            min_strawberries = (count < min_strawberries) ? count : min_strawberries;\n            max_strawberries = (count > max_strawberries) ? count : max_strawberries;\n        }\n    }\n\n    // Print the result\n    printf(\"%d %d\n\", min_strawberries, max_strawberries);\n\n    return 0;\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_m1wx7qo3/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_m1wx7qo3/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc304_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n#define MAXM 200005\n#define MAXQ 200005\n\nGArray *adj[MAXN];\nbool visited[MAXN];\n\nvoid dfs(int u, int target) {\n    if (u == target) return;\n    visited[u] = true;\n    for (int i = 0; i < g_array_get_length(adj[u]); i++) {\n        int v = g_array_index(adj[u], int, i);\n        if (!visited[v]) {\n            dfs(v, target);\n        }\n    }\n}\n\nbool isGoodAfterAddingEdge(int u, int v, int pairs[][2], int K) {\n    visited[u] = true;\n    for (int i = 0; i < K; i++) {\n        if (pairs[i][0] == u || pairs[i][1] == u || pairs[i][0] == v || pairs[i][1] == v) {\n            dfs(pairs[i][0], pairs[i][1]);\n            if (visited[pairs[i][0]] || visited[pairs[i][1]]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M, K, Q, u, v, p, q;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 0; i < N; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        g_array_append_val(adj[u], v);\n        g_array_append_val(adj[v], u);\n    }\n\n    scanf(\"%d\", &K);\n    int pairs[K][2];\n    for (int i = 0; i < K; i++) {\n        scanf(\"%d %d\", &pairs[i][0], &pairs[i][1]);\n        pairs[i][0]--; pairs[i][1]--;\n    }\n\n    scanf(\"%d\", &Q);\n\n    for (int i = 0; i < Q; i++) {\n        scanf(\"%d %d\", &p, &q);\n        p--; q--;\n        if (isGoodAfterAddingEdge(p, q, pairs, K)) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_3lksd3a0/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_3lksd3a0/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc305_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Calculate the nearest water station\n    int nearest_station = ((N + 2) / 5) * 5;\n\n    // Output the result\n    printf(\"%d\n\", nearest_station);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_cc3vupez/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_cc3vupez/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc305_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char p, q;\n    scanf(\"%c %c\", &p, &q);\n\n    // Initialize cumulative distances\n    int distances[8] = {0};  // Array to store distances from A to each point\n    distances[1] = 3;  // Distance from A to B\n    distances[2] = distances[1] + 1;  // Distance from A to C\n    distances[3] = distances[2] + 4;  // Distance from A to D\n    distances[4] = distances[3] + 1;  // Distance from A to E\n    distances[5] = distances[4] + 5;  // Distance from A to F\n    distances[6] = distances[5] + 9;  // Distance from A to G\n\n    // Calculate the distance between p and q\n    int dist_p = distances[p - 'A' + 1];\n    int dist_q = distances[q - 'A' + 1];\n    int distance = abs(dist_p - dist_q);\n\n    // Output the result\n    printf(\"%d\n\", distance);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_abptb_bb/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_abptb_bb/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc305_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    char grid[H][W + 1];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '#') {\n                bool has_adjacent = false;\n                if (i > 0 && grid[i - 1][j] == '#') has_adjacent = true;\n                if (i < H - 1 && grid[i + 1][j] == '#') has_adjacent = true;\n                if (j > 0 && grid[i][j - 1] == '#') has_adjacent = true;\n                if (j < W - 1 && grid[i][j + 1] == '#') has_adjacent = true;\n\n                if (!has_adjacent) {\n                    printf(\"%d %d\n\", i + 1, j + 1);\n                    return 0;\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_u5cl3qj9/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_u5cl3qj9/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc305_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *sleep_log = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int time;\n        scanf(\"%d\", &time);\n        g_array_append_val(sleep_log, time);\n    }\n\n    qsort(sleep_log->data, sleep_log->len, sizeof(int), compare);\n\n    int q;\n    scanf(\"%d\", &q);\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n\n        int total_sleep_time = 0;\n        for (int j = 1; j < sleep_log->len; j += 2) {\n            if (l <= sleep_log->data[j] && sleep_log->data[j] <= r) {\n                total_sleep_time += sleep_log->data[j + 1] - sleep_log->data[j];\n            }\n        }\n\n        printf(\"%d\n\", total_sleep_time);\n    }\n\n    g_array_free(sleep_log, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_9fgx_nng/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_9fgx_nng/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc305_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    // Adjacency list for the graph\n    GArray *adj[MAXN];\n    for (int i = 0; i < N; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read edges\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        g_array_append_val(adj[a], b);\n        g_array_append_val(adj[b], a);\n    }\n\n    // Read guards\n    GHashTable *guards = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < K; i++) {\n        int p, h;\n        scanf(\"%d %d\", &p, &h);\n        p--;\n        g_hash_table_insert(guards, GINT_TO_POINTER(p), GINT_TO_POINTER(h));\n    }\n\n    // BFS to find guarded vertices\n    bool guarded[MAXN];\n    memset(guarded, false, sizeof(guarded));\n\n    for (int i = 0; i < K; i++) {\n        int p = GPOINTER_TO_INT(g_hash_table_lookup(guards, GINT_TO_POINTER(i)));\n        int h = GPOINTER_TO_INT(g_hash_table_lookup(guards, GINT_TO_POINTER(i)));\n\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(p));\n\n        bool visited[MAXN];\n        memset(visited, false, sizeof(visited));\n        visited[p] = true;\n\n        while (!g_queue_is_empty(queue)) {\n            int u = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n            for (int j = 0; j < g_array_get_length(adj[u]); j++) {\n                int v = g_array_index(adj[u], int, j);\n\n                if (!visited[v] && g_array_get_length(adj[u]) <= h) {\n                    visited[v] = true;\n                    guarded[v] = true;\n                    g_queue_push_tail(queue, GINT_TO_POINTER(v));\n                }\n            }\n        }\n\n        g_queue_free(queue);\n    }\n\n    // Count and print guarded vertices\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        if (guarded[i]) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    for (int i = 0; i < N; i++) {\n        if (guarded[i]) {\n            printf(\"%d \", i + 1);\n        }\n    }\n\n    printf(\"\\n\");\n\n    // Clean up\n    for (int i = 0; i < N; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n    g_hash_table_destroy(guards);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_50phijmp/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_50phijmp/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc306_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[51];\n    scanf(\"%s\", s);\n\n    char result[101];\n    result[0] = '\\0';\n\n    for (int i = 0; i < n; i++) {\n        strncat(result, &s[i], 1);\n        strncat(result, &s[i], 1);\n    }\n\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc306_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char binary[65];\n    scanf(\"%64s\", binary);\n\n    long long decimal = 0;\n    for (int i = 0; i < 64; i++) {\n        if (binary[i] == '1') {\n            decimal += (1LL << (63 - i));\n        }\n    }\n\n    printf(\"%lld\\n\", decimal);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"8196788687340504235\", \"got\": \"-9223372036854775808\", \"stderr\": \"Test case 1 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "8196788687340504235", "got": "-9223372036854775808", "stderr": "Test case 1 produced wrong output\n"}
{"question_id": "abc306_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int *A = (int *)malloc(3 * N * sizeof(int));\n    for (int i = 0; i < 3 * N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GHashTable *index_map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < 3 * N; i++) {\n        int num = A[i];\n        if (g_hash_table_contains(index_map, GINT_TO_POINTER(num))) {\n            GArray *indices = g_hash_table_lookup(index_map, GINT_TO_POINTER(num));\n            g_array_append_val(indices, i);\n        } else {\n            GArray *indices = g_array_new(FALSE, FALSE, sizeof(int));\n            g_array_append_val(indices, i);\n            g_hash_table_insert(index_map, GINT_TO_POINTER(num), indices);\n        }\n    }\n\n    int *middle_indices = (int *)malloc(N * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        GArray *indices = g_hash_table_lookup(index_map, GINT_TO_POINTER(i));\n        middle_indices[i - 1] = g_array_index(indices, int, 1);\n    }\n\n    qsort(middle_indices, N, sizeof(int), compare);\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", middle_indices[i]);\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    for (int i = 1; i <= N; i++) {\n        GArray *indices = g_hash_table_lookup(index_map, GINT_TO_POINTER(i));\n        g_array_free(indices, TRUE);\n    }\n    g_hash_table_destroy(index_map);\n    free(A);\n    free(middle_indices);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tm8iv5n0/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_tm8iv5n0/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc306_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 300000\n\ntypedef struct {\n    int healthy;\n    int unhealthy;\n} State;\n\ntypedef struct {\n    int tastiness;\n    int type;\n} Course;\n\nGHashTable *dp;\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint solve(int index, State state, Course *courses, int N) {\n    if (index == N) {\n        return 0;\n    }\n\n    State next_state;\n    if (state.healthy) {\n        next_state.healthy = 1;\n        next_state.unhealthy = 0;\n    } else {\n        next_state.healthy = 0;\n        next_state.unhealthy = 1;\n    }\n\n    gpointer result = g_hash_table_lookup(dp, &(State){state.healthy, state.unhealthy});\n    if (result != NULL) {\n        return GPOINTER_TO_INT(result);\n    }\n\n    int eat = 0;\n    if (state.healthy && courses[index].type == 0) {\n        eat = courses[index].tastiness + solve(index + 1, next_state, courses, N);\n    } else if (state.unhealthy && courses[index].type == 1) {\n        eat = courses[index].tastiness + solve(index + 1, next_state, courses, N);\n    }\n\n    int skip = solve(index + 1, state, courses, N);\n\n    int max_tastiness = max(eat, skip);\n    g_hash_table_insert(dp, &(State){state.healthy, state.unhealthy}, GINT_TO_POINTER(max_tastiness));\n\n    return max_tastiness;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    Course courses[MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &courses[i].type, &courses[i].tastiness);\n    }\n\n    dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int result = solve(0, (State){1, 0}, courses, N);\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__39z2t6a/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__39z2t6a/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc306_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int N, K, Q;\n    scanf(\"%d %d %d\", &N, &K, &Q);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    memset(A, 0, N * sizeof(int));\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(arr, A[i]);\n    }\n\n    for (int i = 0; i < Q; i++) {\n        int X, Y;\n        scanf(\"%d %d\", &X, &Y);\n\n        // Update the sequence\n        A[X - 1] = Y;\n        g_array_set_val(arr, X - 1, Y);\n\n        // Sort the array in descending order\n        qsort(arr->data, arr->len, sizeof(int), compare);\n\n        // Calculate the sum of the largest K elements\n        long long sum = 0;\n        for (int j = 0; j < K; j++) {\n            sum += g_array_index(arr, int, j);\n        }\n\n        // Print the result\n        printf(\"%lld\n\", sum);\n    }\n\n    // Clean up\n    free(A);\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_9c81pdyr/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_9c81pdyr/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc307_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int *steps = (int *)malloc(7 * N * sizeof(int));\n    for (int i = 0; i < 7 * N; i++) {\n        scanf(\"%d\", &steps[i]);\n    }\n\n    for (int week = 0; week < N; week++) {\n        int weekly_steps = 0;\n        for (int day = 0; day < 7; day++) {\n            weekly_steps += steps[week * 7 + day];\n        }\n        printf(\"%d \", weekly_steps);\n    }\n\n    free(steps);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc307_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nbool is_palindrome(const char *str, int len) {\n    for (int i = 0, j = len - 1; i < j; i++, j--) {\n        if (str[i] != str[j]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(char *));\n\n    for (int i = 0; i < n; i++) {\n        char str[1000];\n        scanf(\"%s\", str);\n        arr = g_array_append_val(arr, strdup(str));\n    }\n\n    bool found = false;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i != j) {\n                char concatenated[2000];\n                snprintf(concatenated, sizeof(concatenated), \"%s%s\", arr->pdata[i], arr->pdata[j]);\n                if (is_palindrome(concatenated, strlen(concatenated))) {\n                    found = true;\n                    goto end;\n                }\n            }\n        }\n    }\n\nend:\n    if (found) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    for (gsize i = 0; i < arr->len; i++) {\n        free(g_array_index(arr, char *, i));\n    }\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_eie_gwx8/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_eie_gwx8/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc307_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int HA, WA, HB, WB, HX, WX;\n    scanf(\"%d %d\", &HA, &WA);\n    char A[HA][WA + 1];\n    for (int i = 0; i < HA; i++) {\n        scanf(\"%s\", A[i]);\n    }\n    scanf(\"%d %d\", &HB, &WB);\n    char B[HB][WB + 1];\n    for (int i = 0; i < HB; i++) {\n        scanf(\"%s\", B[i]);\n    }\n    scanf(\"%d %d\", &HX, &WX);\n    char X[HX][WX + 1];\n    for (int i = 0; i < HX; i++) {\n        scanf(\"%s\", X[i]);\n    }\n\n    // Combine A and B\n    char combined[HA + HB][WA + WB + 1];\n    for (int i = 0; i < HA; i++) {\n        strcpy(combined[i], A[i]);\n    }\n    for (int i = 0; i < HB; i++) {\n        strcpy(combined[HA + i], B[i]);\n    }\n\n    // Check if combined contains all black squares of X\n    bool contains_all = true;\n    for (int i = 0; i < HX; i++) {\n        for (int j = 0; j < WX; j++) {\n            if (X[i][j] == '#' && combined[i][j] != '#') {\n                contains_all = false;\n                break;\n            }\n        }\n        if (!contains_all) break;\n    }\n    if (!contains_all) {\n        printf(\"No\");\n        return 0;\n    }\n\n    // Check if any HX x WX area matches X\n    for (int i = 0; i <= HA + HB - HX; i++) {\n        for (int j = 0; j <= WA + WB - WX; j++) {\n            bool matches = true;\n            for (int k = 0; k < HX; k++) {\n                for (int l = 0; l < WX; l++) {\n                    if (X[k][l] == '#' && combined[i + k][j + l] != '#') {\n                        matches = false;\n                        break;\n                    }\n                }\n                if (!matches) break;\n            }\n            if (matches) {\n                printf(\"Yes\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"No\");\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ju8_p0ie/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ju8_p0ie/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc307_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    char str[n + 1];\n    scanf(\"%s\", str);\n\n    // Initialize stack\n    GQueue *stack = g_queue_new();\n\n    // Process each character in the string\n    for (int i = 0; i < n; i++) {\n        if (str[i] == '(') {\n            // Push '(' onto the stack\n            g_queue_push_tail(stack, GINT_TO_POINTER(str[i]));\n        } else if (str[i] == ')') {\n            if (!g_queue_is_empty(stack) && GPOINTER_TO_INT(g_queue_peek_tail(stack)) == '(') {\n                // Pop the matching '(' from the stack\n                g_queue_pop_tail(stack);\n            } else {\n                // If no matching '(', push ')' onto the stack\n                g_queue_push_tail(stack, GINT_TO_POINTER(str[i]));\n            }\n        } else {\n            // Push other characters onto the stack\n            g_queue_push_tail(stack, GINT_TO_POINTER(str[i]));\n        }\n    }\n\n    // Build the result string from the stack\n    char result[n + 1];\n    int index = 0;\n    while (!g_queue_is_empty(stack)) {\n        result[index++] = GPOINTER_TO_INT(g_queue_pop_tail(stack));\n    }\n    result[index] = '\\0';\n\n    // Reverse the result string to get the correct order\n    for (int i = 0; i < index / 2; i++) {\n        char temp = result[i];\n        result[i] = result[index - i - 1];\n        result[index - i - 1] = temp;\n    }\n\n    // Print the result\n    printf(\"%s\\n\", result);\n\n    // Clean up\n    g_queue_free(stack);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_5fhpv8xn/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_5fhpv8xn/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc307_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint dp[1000001][1000001];\n\nint countWays(int n, int m) {\n    if (dp[n][m] != -1) return dp[n][m];\n    if (n == 1) return m;\n    if (n == 2) return m * (m - 1) % MOD;\n\n    int result = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (i != j) {\n                result = (result + countWays(n - 1, m)) % MOD;\n            }\n        }\n    }\n    dp[n][m] = result;\n    return result;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    memset(dp, -1, sizeof(dp));\n\n    int result = countWays(n, m);\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_altjy04r/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_altjy04r/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc308_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int numbers[8];\n\n    // Read input\n    for (int i = 0; i < 8; i++) {\n        scanf(\"%d\", &numbers[i]);\n    }\n\n    // Check the conditions\n    bool isMonotonic = true;\n    bool inRange = true;\n    bool isMultipleOf25 = true;\n\n    for (int i = 1; i < 8; i++) {\n        if (numbers[i] < numbers[i - 1]) {\n            isMonotonic = false;\n        }\n        if (numbers[i] < 100 || numbers[i] > 675) {\n            inRange = false;\n        }\n        if (numbers[i] % 25 != 0) {\n            isMultipleOf25 = false;\n        }\n    }\n\n    // Print the result\n    if (isMonotonic && inRange && isMultipleOf25) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_q7kxq2y7/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_q7kxq2y7/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc308_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Read the colors of the plates Takahashi ate\n    char *C[N];\n    for (int i = 0; i < N; i++) {\n        C[i] = (char *)malloc(21 * sizeof(char));\n        scanf(\" %s\", C[i]);\n    }\n\n    // Read the distinct colors and their corresponding prices\n    char *D[M];\n    int *P = (int *)malloc((M + 1) * sizeof(int));\n    for (int i = 0; i < M; i++) {\n        D[i] = (char *)malloc(21 * sizeof(char));\n        scanf(\" %s\", D[i]);\n        scanf(\" %d\", &P[i]);\n    }\n\n    // Initialize the price for unknown colors\n    P[0] = 0;\n\n    // Create a hash table to store the prices of each color\n    GHashTable *price_map = g_hash_table_new(g_str_hash, g_str_equal);\n    for (int i = 0; i <= M; i++) {\n        g_hash_table_insert(price_map, D[i], GINT_TO_POINTER(P[i]));\n    }\n\n    // Calculate the total price\n    int total_price = 0;\n    for (int i = 0; i < N; i++) {\n        char *color = C[i];\n        gpointer price_ptr = g_hash_table_lookup(price_map, color);\n        if (price_ptr != NULL) {\n            int price = GPOINTER_TO_INT(price_ptr);\n            total_price += price;\n        }\n    }\n\n    // Output the total price\n    printf(\"%d\n\", total_price);\n\n    // Free allocated memory\n    for (int i = 0; i < N; i++) {\n        free(C[i]);\n    }\n    for (int i = 0; i < M; i++) {\n        free(D[i]);\n    }\n    free(P);\n    g_hash_table_destroy(price_map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_x9fvccvb/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_x9fvccvb/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc308_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\ntypedef struct {\n    int person;\n    double success_rate;\n} Person;\n\nint compare(const void *a, const void *b) {\n    Person *p1 = (Person *)a;\n    Person *p2 = (Person *)b;\n    if (p1->success_rate != p2->success_rate) {\n        return p2->success_rate > p1->success_rate ? 1 : -1;\n    } else {\n        return p1->person - p2->person;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Person people[n];\n    for (int i = 0; i < n; i++) {\n        people[i].person = i + 1;\n        scanf(\"%d %d\", &people[i].success_rate, &people[i].success_rate);\n        people[i].success_rate = (double)people[i].success_rate / (people[i].success_rate + people[i].success_rate);\n    }\n\n    qsort(people, n, sizeof(Person), compare);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", people[i].person);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4jpfamr4/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_4jpfamr4/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc308_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define H_MAX 500\n#define W_MAX 500\n\ntypedef struct {\n    int x, y;\n} Point;\n\nbool is_valid(int x, int y, int H, int W) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nbool dfs(int H, int W, char grid[H_MAX][W_MAX], Point current, int sequence_index, GHashTable *visited) {\n    if (sequence_index >= 5) {\n        sequence_index %= 5;\n    }\n\n    char expected_char = \"sneku\"[sequence_index];\n    if (grid[current.x][current.y] != expected_char) {\n        return false;\n    }\n\n    if (current.x == H - 1 && current.y == W - 1) {\n        return true;\n    }\n\n    Point directions[4] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for (int i = 0; i < 4; i++) {\n        Point next = {current.x + directions[i].x, current.y + directions[i].y};\n        if (is_valid(next.x, next.y, H, W) && !g_hash_table_contains(visited, &next)) {\n            g_hash_table_insert(visited, &next, GINT_TO_POINTER(1));\n            if (dfs(H, W, grid, next, sequence_index + 1, visited)) {\n                return true;\n            }\n            g_hash_table_remove(visited, &next);\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    char grid[H_MAX][W_MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    Point start = {0, 0};\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n    g_hash_table_insert(visited, &start, GINT_TO_POINTER(1));\n\n    if (dfs(H, W, grid, start, 0, visited)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_nd8ssscx/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_nd8ssscx/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc308_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int A[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    char S[MAXN];\n    scanf(\"%s\", S);\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int result = 0;\n\n    for (int i = 0; i < N - 2; i++) {\n        if (S[i] == 'M' && S[i + 1] == 'E' && S[i + 2] == 'X') {\n            int mex = 0;\n            bool found[3] = {false, false, false};\n\n            for (int j = i; j <= i + 2; j++) {\n                if (A[j] == 0) {\n                    found[0] = true;\n                } else if (A[j] == 1) {\n                    found[1] = true;\n                } else if (A[j] == 2) {\n                    found[2] = true;\n                }\n            }\n\n            for (int j = 0; j < 3; j++) {\n                if (!found[j]) {\n                    mex = j;\n                    break;\n                }\n            }\n\n            result += mex;\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_c3svsz30/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_c3svsz30/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc308_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare_int(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *prices = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &prices[i]);\n    }\n\n    int *min_prices = (int *)malloc(m * sizeof(int));\n    int *discounts = (int *)malloc(m * sizeof(int));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &min_prices[i], &discounts[i]);\n    }\n\n    qsort(prices, n, sizeof(int), compare_int);\n    qsort(min_prices, m, sizeof(int), compare_int);\n    qsort(discounts, m, sizeof(int), compare_int);\n\n    int total_cost = 0;\n    int coupon_index = m - 1;\n\n    for (int i = 0; i < n; i++) {\n        while (coupon_index >= 0 && min_prices[coupon_index] > prices[i]) {\n            coupon_index--;\n        }\n\n        if (coupon_index >= 0 && prices[i] >= min_prices[coupon_index]) {\n            total_cost += prices[i] - discounts[coupon_index];\n            coupon_index--;\n        } else {\n            total_cost += prices[i];\n        }\n    }\n\n    printf(\"%d\\n\", total_cost);\n\n    free(prices);\n    free(min_prices);\n    free(discounts);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_wv5a3hnc/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_wv5a3hnc/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc309_a", "solution": "#include <stdio.h>\n\nint main() {\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n\n    // Determine the row of A and B\n    int rowA = (A - 1) / 3;\n    int rowB = (B - 1) / 3;\n\n    // Check if A and B are in the same row and adjacent horizontally\n    if (rowA == rowB && abs(A - B) == 1) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_wqrhsbk4/program.c: In function 'main':\\n/tmp/agnostics_c_wqrhsbk4/program.c:12:25: warning: implicit declaration of function 'abs' [-Wimplicit-function-declaration]\\n   12 |     if (rowA == rowB && abs(A - B) == 1) {\\n      |                         ^~~\\n/tmp/agnostics_c_wqrhsbk4/program.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'abs'\\n    1 | #include <stdio.h>\\n  +++ |+#include <stdlib.h>\\n    2 | \\n/tmp/agnostics_c_wqrhsbk4/program.c:13:16: warning: missing terminating \\\" character\\n   13 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_wqrhsbk4/program.c:13:16: error: missing terminating \\\" character\\n   13 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_wqrhsbk4/program.c:14:1: warning: missing terminating \\\" character\\n   14 | \\\");\\n      | ^\\n/tmp/agnostics_c_wqrhsbk4/program.c:14:1: error: missing terminating \\\" character\\n   14 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_wqrhsbk4/program.c:15:5: error: expected expression before '}' token\\n   15 |     } else {\\n      |     ^\\n/tmp/agnostics_c_wqrhsbk4/program.c:13:16: error: expected ';' before '}' token\\n   13 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   14 | \\\");\\n   15 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_wqrhsbk4/program.c:16:16: warning: missing terminating \\\" character\\n   16 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_wqrhsbk4/program.c:16:16: error: missing terminating \\\" character\\n   16 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_wqrhsbk4/program.c:17:1: warning: missing terminating \\\" character\\n   17 | \\\");\\n      | ^\\n/tmp/agnostics_c_wqrhsbk4/program.c:17:1: error: missing terminating \\\" character\\n   17 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_wqrhsbk4/program.c:18:5: error: expected expression before '}' token\\n   18 |     }\\n      |     ^\\n/tmp/agnostics_c_wqrhsbk4/program.c:16:16: er", "raw_stderr": "", "result": "fail"}
{"question_id": "abc309_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Read the grid into a 2D array\n    char grid[n][n + 1];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    // Initialize variables to store the outer squares\n    GQueue *top = g_queue_new();\n    GQueue *bottom = g_queue_new();\n    GQueue *left = g_queue_new();\n    GQueue *right = g_queue_new();\n\n    // Extract the outer squares\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || i == n - 1) {\n            for (int j = 0; j < n; j++) {\n                g_queue_push_tail(top, GINT_TO_POINTER(grid[i][j] - '0'));\n                g_queue_push_tail(bottom, GINT_TO_POINTER(grid[n - 1 - i][j] - '0'));\n            }\n        } else {\n            g_queue_push_tail(left, GINT_TO_POINTER(grid[i][0] - '0'));\n            g_queue_push_tail(right, GINT_TO_POINTER(grid[i][n - 1] - '0'));\n        }\n    }\n\n    // Shift the outer squares clockwise by one position\n    GQueue *temp = g_queue_new();\n    g_queue_push_tail(temp, g_queue_pop_head(top));\n    g_queue_free(top);\n    top = temp;\n\n    temp = g_queue_new();\n    g_queue_push_tail(temp, g_queue_pop_head(right));\n    g_queue_free(right);\n    right = temp;\n\n    temp = g_queue_new();\n    g_queue_push_tail(temp, g_queue_pop_head(bottom));\n    g_queue_free(bottom);\n    bottom = temp;\n\n    temp = g_queue_new();\n    g_queue_push_tail(temp, g_queue_pop_head(left));\n    g_queue_free(left);\n    left = temp;\n\n    // Update the grid with the shifted outer squares\n    for (int i = 0; i < n; i++) {\n        if (i == 0 || i == n - 1) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = '0' + g_queue_pop_head(top);\n                grid[n - 1 - i][j] = '0' + g_queue_pop_head(bottom);\n            }\n        } else {\n            grid[i][0] = '0' + g_queue_pop_head(left);\n            grid[i][n - 1] = '0' + g_queue_pop_head(right);\n        }\n    }\n\n    // Print the resulting grid\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\n\", grid[i]);\n    }\n\n    // Free the queues\n    g_queue_free(top);\n    g_queue_free(bottom);\n    g_queue_free(left);\n    g_queue_free(right);\n    g_queue_free(temp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_xov_jr7o/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_xov_jr7o/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc309_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    int days[N], pills[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &days[i], &pills[i]);\n    }\n\n    int current_day = 0;\n    int total_pills = 0;\n\n    while (total_pills <= K) {\n        current_day++;\n        for (int i = 0; i < N; i++) {\n            if (current_day % days[i] == 1) {\n                total_pills += pills[i];\n            }\n        }\n    }\n\n    printf(\"%d\n\", current_day);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_lax66m82/program.c: In function 'main':\\n/tmp/agnostics_c_lax66m82/program.c:25:12: warning: missing terminating \\\" character\\n   25 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_lax66m82/program.c:25:12: error: missing terminating \\\" character\\n   25 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_lax66m82/program.c:26:1: warning: missing terminating \\\" character\\n   26 | \\\", current_day);\\n      | ^\\n/tmp/agnostics_c_lax66m82/program.c:26:1: error: missing terminating \\\" character\\n   26 | \\\", current_day);\\n      | ^~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_lax66m82/program.c:28:5: error: expected expression before 'return'\\n   28 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_lax66m82/program.c:28:14: error: expected ';' before '}' token\\n   28 |     return 0;\\n      |              ^\\n      |              ;\\n   29 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_lax66m82/program.c: In function 'main':\n/tmp/agnostics_c_lax66m82/program.c:25:12: warning: missing terminating \" character\n   25 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c_lax66m82/program.c:25:12: error: missing terminating \" character\n   25 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c_lax66m82/program.c:26:1: warning: missing terminating \" character\n   26 | \", current_day);\n      | ^\n/tmp/agnostics_c_lax66m82/program.c:26:1: error: missing terminating \" character\n   26 | \", current_day);\n      | ^~~~~~~~~~~~~~~~\n/tmp/agnostics_c_lax66m82/program.c:28:5: error: expected expression before 'return'\n   28 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_lax66m82/program.c:28:14: error: expected ';' before '}' token\n   28 |     return 0;\n      |              ^\n      |              ;\n   29 | }\n      | ~             \n"}
{"question_id": "abc309_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N1, N2, M;\n    scanf(\"%d %d %d\", &N1, &N2, &M);\n\n    GHashTable *graph[N1 + N2 + 1];\n    for (int i = 0; i <= N1 + N2; i++) {\n        graph[i] = g_hash_table_new(g_direct_hash, g_direct_equal);\n    }\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        g_hash_table_insert(graph[a], GINT_TO_POINTER(b), NULL);\n        g_hash_table_insert(graph[b], GINT_TO_POINTER(a), NULL);\n    }\n\n    int max_dist = 0;\n    for (int i = 1; i <= N1; i++) {\n        for (int j = N1 + 1; j <= N1 + N2; j++) {\n            if (g_hash_table_lookup(graph[i], GINT_TO_POINTER(j)) == NULL) {\n                int dist = 0;\n                GQueue *queue = g_queue_new();\n                GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n                g_queue_push_tail(queue, GINT_TO_POINTER(i));\n                g_hash_table_insert(visited, GINT_TO_POINTER(i), NULL);\n\n                while (!g_queue_is_empty(queue)) {\n                    int node = GPOINTER_TO_INT(g_queue_pop_head(queue));\n                    if (node == j) {\n                        dist = 1;\n                        break;\n                    }\n                    GHashTable *neighbors = graph[node];\n                    GHashTableIter iter;\n                    gpointer key;\n                    g_hash_table_iter_init(&iter, neighbors);\n                    while (g_hash_table_iter_next(&iter, &key, NULL)) {\n                        int neighbor = GPOINTER_TO_INT(key);\n                        if (g_hash_table_lookup(visited, GINT_TO_POINTER(neighbor)) == NULL) {\n                            g_queue_push_tail(queue, GINT_TO_POINTER(neighbor));\n                            g_hash_table_insert(visited, GINT_TO_POINTER(neighbor), NULL);\n                        }\n                    }\n                }\n\n                g_queue_free(queue);\n                g_hash_table_destroy(visited);\n                max_dist = (dist > max_dist) ? dist : max_dist;\n            }\n        }\n    }\n\n    printf(\"%d\n\", max_dist);\n\n    for (int i = 0; i <= N1 + N2; i++) {\n        g_hash_table_destroy(graph[i]);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8lhn2ap7/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_8lhn2ap7/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc309_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Read parent information\n    int *parents = (int *)malloc(n * sizeof(int));\n    for (int i = 1; i < n; i++) {\n        scanf(\"%d\", &parents[i]);\n    }\n\n    // Read insurance policies\n    GArray *insurance = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        g_array_append_val(insurance, x);\n        g_array_append_val(insurance, y);\n    }\n\n    // Initialize coverage array\n    bool *covered = (bool *)calloc(n + 1, sizeof(bool));\n\n    // Process each insurance policy\n    for (int i = 0; i < m * 2; i += 2) {\n        int x = g_array_index(insurance, int, i);\n        int y = g_array_index(insurance, int, i + 1);\n\n        // Traverse the family tree to mark descendants as covered\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(x));\n\n        while (!g_queue_is_empty(queue)) {\n            int person = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n            if (!covered[person]) {\n                covered[person] = true;\n\n                // Add descendants to the queue\n                for (int i = 0; i < n; i++) {\n                    if (parents[i] == person) {\n                        g_queue_push_tail(queue, GINT_TO_POINTER(i + 1));\n                    }\n                }\n\n                // Add current person's descendants up to y generations\n                for (int j = 1; j <= y; j++) {\n                    GQueue *temp_queue = g_queue_new();\n                    while (!g_queue_is_empty(queue)) {\n                        int descendant = GPOINTER_TO_INT(g_queue_pop_head(queue));\n                        for (int k = 0; k < n; k++) {\n                            if (parents[k] == descendant) {\n                                g_queue_push_tail(temp_queue, GINT_TO_POINTER(k + 1));\n                            }\n                        }\n                    }\n                    g_queue_free(queue);\n                    queue = temp_queue;\n                }\n            }\n        }\n\n        g_queue_free(queue);\n    }\n\n    // Count the number of people covered by at least one insurance policy\n    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (covered[i]) {\n            count++;\n        }\n    }\n\n    // Print the result\n    printf(\"%d\\n\", count);\n\n    // Clean up\n    free(parents);\n    free(covered);\n    g_array_free(insurance, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_c3p2npkg/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_c3p2npkg/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc310_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, p, q;\n    scanf(\"%d %d %d\", &n, &p, &q);\n\n    GArray *dishes = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int dish_price;\n        scanf(\"%d\", &dish_price);\n        g_array_append_val(dishes, dish_price);\n    }\n\n    qsort(dishes->data, dishes->len, sizeof(int), compare);\n\n    int min_cost = p;\n    for (int i = 0; i < n; i++) {\n        int total_cost = q + g_array_index(dishes, int, i);\n        if (total_cost < min_cost) {\n            min_cost = total_cost;\n        }\n    }\n\n    printf(\"%d\\n\", min_cost);\n\n    g_array_free(dishes, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_uapon1c2/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_uapon1c2/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc310_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 100\n#define MAX_M 100\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashTable *products = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < N; i++) {\n        int P, C;\n        scanf(\"%d %d\", &P, &C);\n        int *functions = (int *)malloc(C * sizeof(int));\n        for (int j = 0; j < C; j++) {\n            scanf(\"%d\", &functions[j]);\n        }\n\n        qsort(functions, C, sizeof(int), compare);\n\n        g_hash_table_insert(products, GINT_TO_POINTER(P), functions);\n    }\n\n    bool found = false;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i != j) {\n                int *functions_i = (int *)g_hash_table_lookup(products, GINT_TO_POINTER(i + 1));\n                int *functions_j = (int *)g_hash_table_lookup(products, GINT_TO_POINTER(j + 1));\n\n                int C_i = 0, C_j = 0;\n                for (int k = 0; k < MAX_M; k++) {\n                    if (functions_i[k] != 0) C_i++;\n                    if (functions_j[k] != 0) C_j++;\n                }\n\n                if (C_i >= C_j) {\n                    int k = 0;\n                    while (k < C_i && functions_i[k] <= functions_j[k]) k++;\n                    if (k == C_i && (C_i > C_j || functions_i[k - 1] < functions_j[k - 1])) {\n                        found = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (found) break;\n    }\n\n    if (found) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    g_hash_table_destroy(products);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_lspg_1ma/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_lspg_1ma/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc310_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Use a hash table to store the canonical form of each stick\n    GHashTable *map = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < n; i++) {\n        char str[1000];\n        scanf(\"%s\", str);\n\n        // Create a reversed copy of the string\n        char reversed[1000];\n        strcpy(reversed, str);\n        strrev(reversed);\n\n        // Use the lexicographically smaller version as the key\n        char *key = (strcmp(str, reversed) < 0) ? str : reversed;\n\n        // Insert the key into the hash table\n        g_hash_table_insert(map, key, GINT_TO_POINTER(1));\n    }\n\n    // The number of distinct sticks is the size of the hash table\n    int result = g_hash_table_size(map);\n\n    // Output the result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8wp2e8la/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_8wp2e8la/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc310_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MAX_N 10\n#define MAX_T 10\n#define MAX_M 50\n\nint N, T, M;\nint A[MAX_M], B[MAX_M];\nGArray *team[MAX_N];\n\nvoid dfs(int player, int team_id) {\n    if (player > N) {\n        for (int i = 1; i <= N; i++) {\n            if (g_array_length(team[i]) > 0) {\n                printf(\"Team %d: \", i);\n                for (int j = 0; j < g_array_length(team[i]); j++) {\n                    printf(\"%d \", g_array_index(team[i], int, j));\n                }\n                printf(\"\\n\");\n            }\n        }\n        return;\n    }\n    if (g_array_length(team[player]) > 0) {\n        dfs(player + 1, team_id);\n        return;\n    }\n    for (int i = 1; i <= T; i++) {\n        bool valid = true;\n        for (int j = 0; j < g_array_length(team[i]); j++) {\n            int other = g_array_index(team[i], int, j);\n            if (other == A[player] || other == B[player]) {\n                valid = false;\n                break;\n            }\n        }\n        if (valid) {\n            g_array_append_val(team[i], player);\n            dfs(player + 1, team_id);\n            g_array_remove_range(team[i], g_array_length(team[i]) - 1, 1);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &T, &M);\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n    }\n    for (int i = 1; i <= N; i++) {\n        team[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n    dfs(1, 0);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tueer4m7/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_tueer4m7/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc310_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    // Initialize a GArray to store the intermediate results\n    GArray *results = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Iterate over all possible starting points i\n    for (int i = 0; i < n; i++) {\n        int result = 0;\n        // Iterate over all possible ending points j starting from i\n        for (int j = i; j < n; j++) {\n            // Compute f(i, j) using the NAND operator\n            result = !(s[j] == '1' && (i == j || result == 0));\n            // Add the result to the total sum\n            g_array_append_val(results, result);\n        }\n    }\n\n    // Calculate the sum of all results\n    int sum = 0;\n    for (int i = 0; i < results->len; i++) {\n        sum += g_array_index(results, int, i);\n    }\n\n    // Print the result\n    printf(\"%d\\n\", sum);\n\n    // Free the GArray\n    g_array_free(results, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_5xpcst88/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_5xpcst88/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc310_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        g_array_append_val(A, a);\n    }\n\n    int max_val = 10;\n    for (int i = 0; i < N; i++) {\n        max_val += g_array_index(A, int, i);\n    }\n\n    int *dp = (int *)malloc((max_val + 1) * sizeof(int));\n    memset(dp, 0, (max_val + 1) * sizeof(int));\n    dp[0] = 1;\n\n    for (int i = 0; i < N; i++) {\n        int a = g_array_index(A, int, i);\n        for (int j = max_val; j >= 0; j--) {\n            for (int k = 1; k <= a; k++) {\n                if (j - k >= 0) {\n                    dp[j] = (dp[j] + dp[j - k]) % MOD;\n                }\n            }\n        }\n    }\n\n    int total_ways = dp[10];\n    int total_outcomes = 1;\n\n    for (int i = 0; i < N; i++) {\n        total_outcomes = (total_outcomes * g_array_index(A, int, i)) % MOD;\n    }\n\n    int result = 0;\n    for (int i = 1; i < MOD; i++) {\n        if ((i * total_outcomes) % MOD == 1) {\n            result = (result * total_ways) % MOD;\n            break;\n        }\n    }\n\n    printf(\"%d\n\", result);\n\n    free(dp);\n    g_array_free(A, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0z7infol/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0z7infol/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc311_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char str[1000];\n    scanf(\"%s\", str);\n\n    int lastA = -1, lastB = -1, lastC = -1;\n\n    for (int i = 0; i < n; i++) {\n        if (str[i] == 'A') {\n            lastA = i;\n        } else if (str[i] == 'B') {\n            lastB = i;\n        } else if (str[i] == 'C') {\n            lastC = i;\n        }\n        if (lastA != -1 && lastB != -1 && lastC != -1) {\n            break;\n        }\n    }\n\n    int result = 1 + fmax(fmax(lastA, lastB), lastC);\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8s4svb7o/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_8s4svb7o/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc311_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n\n    // Read the schedules into a GArray of strings\n    GArray *schedules = g_array_new(FALSE, FALSE, sizeof(char*));\n    for (int i = 0; i < N; i++) {\n        char *schedule = malloc(D + 1);\n        scanf(\"%s\", schedule);\n        g_array_append_val(schedules, schedule);\n    }\n\n    int max_consecutive_days = 0;\n\n    // Check each day for the maximum consecutive free days\n    for (int day = 0; day < D; day++) {\n        int consecutive_free = 0;\n        bool all_free = true;\n\n        for (int person = 0; person < N; person++) {\n            if (g_array_index(schedules, char*, person)[day] == 'x') {\n                all_free = false;\n                break;\n            }\n        }\n\n        if (all_free) {\n            consecutive_free++;\n        }\n\n        for (int i = day + 1; i < D; i++) {\n            bool all_free_in_range = true;\n\n            for (int person = 0; person < N; person++) {\n                if (g_array_index(schedules, char*, person)[i] == 'x') {\n                    all_free_in_range = false;\n                    break;\n                }\n            }\n\n            if (all_free_in_range) {\n                consecutive_free++;\n            } else {\n                break;\n            }\n        }\n\n        max_consecutive_days = fmax(max_consecutive_days, consecutive_free);\n    }\n\n    // Free the allocated memory for schedules\n    for (int i = 0; i < N; i++) {\n        free(g_array_index(schedules, char*, i));\n    }\n    g_array_free(schedules, TRUE);\n\n    // Output the result\n    printf(\"%d\n\", max_consecutive_days);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_14modbh7/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_14modbh7/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc311_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GQueue *queue = g_queue_new();\n\n    for (int i = 0; i < n; i++) {\n        if (!g_hash_table_contains(visited, GINT_TO_POINTER(i))) {\n            GQueue *path = g_queue_new();\n            g_queue_push_tail(path, GINT_TO_POINTER(i));\n            g_hash_table_insert(visited, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n\n            while (!g_queue_is_empty(path)) {\n                int current = GPOINTER_TO_INT(g_queue_peek_head(path));\n                int next = A[current - 1] - 1;\n\n                if (next == current) {\n                    int cycle_length = g_queue_get_length(path);\n                    printf(\"%d\\n\", cycle_length);\n                    GList *node = g_queue_peek_head_link(path);\n                    for (int j = 0; j < cycle_length; j++) {\n                        printf(\"%d \", GPOINTER_TO_INT(node->data) + 1);\n                        node = node->next;\n                    }\n                    printf(\"\\n\");\n                    goto end;\n                }\n\n                if (!g_hash_table_contains(visited, GINT_TO_POINTER(next))) {\n                    g_queue_push_tail(path, GINT_TO_POINTER(next));\n                    g_hash_table_insert(visited, GINT_TO_POINTER(next), GINT_TO_POINTER(1));\n                } else {\n                    g_queue_push_tail(path, GINT_TO_POINTER(next));\n                    break;\n                }\n            }\n\n            g_queue_free(path);\n        }\n    }\n\nend:\n    g_hash_table_destroy(visited);\n    g_queue_free(queue);\n    free(A);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_h15kqdb3/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_h15kqdb3/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc311_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200\n#define MAX_M 200\n\ntypedef struct {\n    int x, y;\n} Position;\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    char grid[MAX_N][MAX_M];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    GQueue *queue = g_queue_new();\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    Position start = {2, 2};\n    g_queue_push_tail(queue, GINT_TO_POINTER(start.x * MAX_M + start.y));\n    g_hash_table_insert(visited, GINT_TO_POINTER(start.x * MAX_M + start.y), GINT_TO_POINTER(1));\n\n    int count = 0;\n\n    while (!g_queue_is_empty(queue)) {\n        Position current = *(Position*)g_queue_pop_head(queue);\n        int x = current.x;\n        int y = current.y;\n\n        count++;\n\n        // Up\n        if (x > 1 && grid[x-1][y] == \".\" && !g_hash_table_contains(visited, GINT_TO_POINTER((x-1) * MAX_M + y))) {\n            Position next = {x-1, y};\n            g_queue_push_tail(queue, GINT_TO_POINTER(next.x * MAX_M + next.y));\n            g_hash_table_insert(visited, GINT_TO_POINTER(next.x * MAX_M + next.y), GINT_TO_POINTER(1));\n        }\n\n        // Down\n        if (x < N-1 && grid[x+1][y] == \".\" && !g_hash_table_contains(visited, GINT_TO_POINTER((x+1) * MAX_M + y))) {\n            Position next = {x+1, y};\n            g_queue_push_tail(queue, GINT_TO_POINTER(next.x * MAX_M + next.y));\n            g_hash_table_insert(visited, GINT_TO_POINTER(next.x * MAX_M + next.y), GINT_TO_POINTER(1));\n        }\n\n        // Left\n        if (y > 1 && grid[x][y-1] == \".\" && !g_hash_table_contains(visited, GINT_TO_POINTER(x * MAX_M + (y-1)))) {\n            Position next = {x, y-1};\n            g_queue_push_tail(queue, GINT_TO_POINTER(next.x * MAX_M + next.y));\n            g_hash_table_insert(visited, GINT_TO_POINTER(next.x * MAX_M + next.y), GINT_TO_POINTER(1));\n        }\n\n        // Right\n        if (y < M-1 && grid[x][y+1] == \".\" && !g_hash_table_contains(visited, GINT_TO_POINTER(x * MAX_M + (y+1)))) {\n            Position next = {x, y+1};\n            g_queue_push_tail(queue, GINT_TO_POINTER(next.x * MAX_M + next.y));\n            g_hash_table_insert(visited, GINT_TO_POINTER(next.x * MAX_M + next.y), GINT_TO_POINTER(1));\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    g_queue_free(queue);\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_3ef6dsdw/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_3ef6dsdw/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc311_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    GHashTable *holed_squares = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < N; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        g_hash_table_insert(holed_squares, GINT_TO_POINTER(a), GINT_TO_POINTER(b));\n    }\n\n    long long holeless_count = 0;\n\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            int can_be_holeless = 1;\n            for (int n = 1; n <= H - i + 1 && n <= W - j + 1; n++) {\n                if (g_hash_table_lookup(holed_squares, GINT_TO_POINTER(i + n - 1)) == GINT_TO_POINTER(j + n - 1)) {\n                    can_be_holeless = 0;\n                    break;\n                }\n            }\n            if (can_be_holeless) {\n                holeless_count++;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", holeless_count);\n\n    g_hash_table_destroy(holed_squares);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_icuumoqh/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_icuumoqh/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc312_a", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[4];  // Array to store the input string\n    scanf(\"%s\", S);  // Read the input string\n\n    // Define the target strings\n    char targets[8][4] = {\"ACE\", \"BDF\", \"CEG\", \"DFA\", \"EGB\", \"FAC\", \"GBD\"};\n\n    // Check each target string\n    for (int i = 0; i < 8; i++) {\n        if (strcmp(S, targets[i]) == 0) {\n            printf(\"Yes\n\");\n            return 0;\n        }\n    }\n\n    // If no match is found, print 'No'\n    printf(\"No\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_q37aidou/program.c: In function 'main':\\n/tmp/agnostics_c_q37aidou/program.c:14:20: warning: missing terminating \\\" character\\n   14 |             printf(\\\"Yes\\n      |                    ^\\n/tmp/agnostics_c_q37aidou/program.c:14:20: error: missing terminating \\\" character\\n   14 |             printf(\\\"Yes\\n      |                    ^~~~\\n/tmp/agnostics_c_q37aidou/program.c:15:1: warning: missing terminating \\\" character\\n   15 | \\\");\\n      | ^\\n/tmp/agnostics_c_q37aidou/program.c:15:1: error: missing terminating \\\" character\\n   15 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_q37aidou/program.c:16:13: error: expected expression before 'return'\\n   16 |             return 0;\\n      |             ^~~~~~\\n/tmp/agnostics_c_q37aidou/program.c:16:22: error: expected ';' before '}' token\\n   16 |             return 0;\\n      |                      ^\\n      |                      ;\\n   17 |         }\\n      |         ~             \\n/tmp/agnostics_c_q37aidou/program.c:21:12: warning: missing terminating \\\" character\\n   21 |     printf(\\\"No\\n      |            ^\\n/tmp/agnostics_c_q37aidou/program.c:21:12: error: missing terminating \\\" character\\n   21 |     printf(\\\"No\\n      |            ^~~\\n/tmp/agnostics_c_q37aidou/program.c:22:1: warning: missing terminating \\\" character\\n   22 | \\\");\\n      | ^\\n/tmp/agnostics_c_q37aidou/program.c:22:1: error: missing terminating \\\" character\\n   22 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_q37aidou/program.c:24:5: error: expected expression before 'return'\\n   24 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_q37aidou/program.c:24:14: error: expected ';' before '}' token\\n   24 |     return 0;\\n      |              ^\\n      |              ;\\n   25 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_q37aidou/program.c: In function 'main':\n/tmp/agnostics_c_q37aidou/program.c:14:20: warning: missing terminating \" character\n   14 |             printf(\"Yes\n      |                    ^\n/tmp/agnostics_c_q37aidou/program.c:14:20: error: missing terminating \" character\n   14 |             printf(\"Yes\n      |                    ^~~~\n/tmp/agnostics_c_q37aidou/program.c:15:1: warning: missing terminating \" character\n   15 | \");\n      | ^\n/tmp/agnostics_c_q37aidou/program.c:15:1: error: missing terminating \" character\n   15 | \");\n      | ^~~\n/tmp/agnostics_c_q37aidou/program.c:16:13: error: expected expression before 'return'\n   16 |             return 0;\n      |             ^~~~~~\n/tmp/agnostics_c_q37aidou/program.c:16:22: error: expected ';' before '}' token\n   16 |             return 0;\n      |                      ^\n      |                      ;\n   17 |         }\n      |         ~             \n/tmp/agnostics_c_q37aidou/program.c:21:12: warning: missing terminating \" character\n   21 |     printf(\"No\n      |            ^\n/tmp/agnostics_c_q37aidou/program.c:21:12: error: missing terminating \" character\n   21 |     printf(\"No\n      |            ^~~\n/tmp/agnostics_c_q37aidou/program.c:22:1: warning: missing terminating \" character\n   22 | \");\n      | ^\n/tmp/agnostics_c_q37aidou/program.c:22:1: error: missing terminating \" character\n   22 | \");\n      | ^~~\n/tmp/agnostics_c_q37aidou/program.c:24:5: error: expected expression before 'return'\n   24 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_q37aidou/program.c:24:14: error: expected ';' before '}' token\n   24 |     return 0;\n      |              ^\n      |              ;\n   25 | }\n      | ~             \n"}
{"question_id": "abc312_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define N 9\n\nbool isTakCode(const char *grid[N], int startRow, int startCol) {\n    // Check top-left 3x3 region\n    if (grid[startRow][startCol] != '#' || grid[startRow][startCol + 1] != '#' || grid[startRow][startCol + 2] != '#') return false;\n    if (grid[startRow + 1][startCol] != '#' || grid[startRow + 1][startCol + 1] != '.' || grid[startRow + 1][startCol + 2] != '#') return false;\n    if (grid[startRow + 2][startCol] != '#' || grid[startRow + 2][startCol + 1] != '#' || grid[startRow + 2][startCol + 2] != '#') return false;\n\n    // Check bottom-right 3x3 region\n    if (grid[startRow + 6][startCol + 6] != '#' || grid[startRow + 6][startCol + 7] != '#' || grid[startRow + 6][startCol + 8] != '#') return false;\n    if (grid[startRow + 7][startCol + 6] != '#' || grid[startRow + 7][startCol + 7] != '.' || grid[startRow + 7][startCol + 8] != '#') return false;\n    if (grid[startRow + 8][startCol + 6] != '#' || grid[startRow + 8][startCol + 7] != '#' || grid[startRow + 8][startCol + 8] != '#') return false;\n\n    // Check adjacent cells\n    for (int i = startRow; i < startRow + 9; i++) {\n        for (int j = startCol; j < startCol + 9; j++) {\n            if (i == startRow || i == startRow + 8 || j == startCol || j == startCol + 8) {\n                if (grid[i][j] != '.') return false;\n            } else {\n                if (grid[i][j] != '#') return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    char grid[N][M + 1];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i <= N - 9; i++) {\n        for (int j = 0; j <= M - 9; j++) {\n            if (isTakCode(grid, i, j)) {\n                printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_gpo15feq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_gpo15feq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc312_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *sellers = (int *)malloc(n * sizeof(int));\n    int *buyers = (int *)malloc(m * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &sellers[i]);\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &buyers[i]);\n    }\n\n    qsort(sellers, n, sizeof(int), compare);\n    qsort(buyers, m, sizeof(int), compare);\n\n    int i = 0, j = 0;\n    int result = -1;\n\n    while (i < n && j < m) {\n        if (sellers[i] >= buyers[j]) {\n            result = buyers[j];\n            break;\n        }\n        i++;\n    }\n\n    if (result == -1) {\n        result = buyers[m - 1];\n    }\n\n    printf(\"%d\n\", result);\n\n    free(sellers);\n    free(buyers);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ecs0j1tp/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ecs0j1tp/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc312_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    char S[3001];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n    GHashTable *dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initialize dp for empty string\n    g_hash_table_insert(dp, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n\n    for (int i = 0; i < n; i++) {\n        GHashTable *new_dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n        if (S[i] == '(' || S[i] == ')') {\n            GHashTableIter iter;\n            gpointer key, value;\n            g_hash_table_iter_init(&iter, dp);\n            while (g_hash_table_iter_next(&iter, &key, &value)) {\n                int count = GPOINTER_TO_INT(value);\n                int left = S[i] == '(' ? count : 0;\n                int right = S[i] == ')' ? count : 0;\n                g_hash_table_insert(new_dp, GINT_TO_POINTER(left), GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(new_dp, GINT_TO_POINTER(left))) + count) % MOD));\n                g_hash_table_insert(new_dp, GINT_TO_POINTER(right), GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(new_dp, GINT_TO_POINTER(right))) + count) % MOD));\n            }\n        } else {\n            GHashTableIter iter;\n            gpointer key, value;\n            g_hash_table_iter_init(&iter, dp);\n            while (g_hash_table_iter_next(&iter, &key, &value)) {\n                int count = GPOINTER_TO_INT(value);\n                int left = count;\n                int right = count;\n                g_hash_table_insert(new_dp, GINT_TO_POINTER(left), GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(new_dp, GINT_TO_POINTER(left))) + count) % MOD));\n                g_hash_table_insert(new_dp, GINT_TO_POINTER(right), GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(new_dp, GINT_TO_POINTER(right))) + count) % MOD));\n            }\n        }\n        g_hash_table_destroy(dp);\n        dp = new_dp;\n    }\n\n    int result = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, dp);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        result = (result + GPOINTER_TO_INT(value)) % MOD;\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_h839ruz0/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_h839ruz0/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc312_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Array to store cuboids\n    int cuboids[n][6];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 6; j++) {\n            scanf(\"%d\", &cuboids[i][j]);\n        }\n    }\n\n    // Array to store the result\n    int result[n];\n\n    // Process each cuboid\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n\n        // Check for shared faces with other cuboids\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n\n            // Check XY plane\n            if (cuboids[i][0] == cuboids[j][0] && cuboids[i][1] == cuboids[j][1] &&\n                (cuboids[i][2] == cuboids[j][2] || cuboids[i][2] == cuboids[j][5] ||\n                 cuboids[i][5] == cuboids[j][2])) {\n                count++;\n            }\n\n            // Check XZ plane\n            if (cuboids[i][0] == cuboids[j][0] && cuboids[i][2] == cuboids[j][2] &&\n                (cuboids[i][1] == cuboids[j][1] || cuboids[i][1] == cuboids[j][4] ||\n                 cuboids[i][4] == cuboids[j][1])) {\n                count++;\n            }\n\n            // Check YZ plane\n            if (cuboids[i][1] == cuboids[j][1] && cuboids[i][2] == cuboids[j][2] &&\n                (cuboids[i][0] == cuboids[j][0] || cuboids[i][0] == cuboids[j][3] ||\n                 cuboids[i][3] == cuboids[j][0])) {\n                count++;\n            }\n        }\n\n        result[i] = count;\n    }\n\n    // Output the results\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\\n\", result[i]);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_d6iny1sr/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_d6iny1sr/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc312_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n#define MAXM 200000\n\ntypedef struct {\n    int type;\n    int value;\n} Item;\n\nint compare(const void *a, const void *b) {\n    return ((Item *)b)->value - ((Item *)a)->value;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Item items[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &items[i].type, &items[i].value);\n    }\n\n    qsort(items, N, sizeof(Item), compare);\n\n    int total_happiness = 0;\n    int can_openers = 0;\n\n    for (int i = 0; i < M; i++) {\n        if (items[i].type == 2) {\n            can_openers += items[i].value;\n        } else if (items[i].type == 1) {\n            if (can_openers > 0) {\n                can_openers--;\n                total_happiness += items[i].value;\n            }\n        } else if (items[i].type == 0) {\n            total_happiness += items[i].value;\n        }\n    }\n\n    printf(\"%d\\n\", total_happiness);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_xglyld2e/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_xglyld2e/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc313_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *abilities = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &abilities[i]);\n    }\n\n    int max_ability = 0;\n    for (int i = 1; i < n; i++) {\n        if (abilities[i] > max_ability) {\n            max_ability = abilities[i];\n        }\n    }\n\n    int x = 0;\n    if (max_ability > abilities[0]) {\n        x = max_ability - abilities[0] + 1;\n    }\n\n    printf(\"%d\n\", x);\n\n    free(abilities);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0ua68buc/program.c: In function 'main':\\n/tmp/agnostics_c_0ua68buc/program.c:25:12: warning: missing terminating \\\" character\\n   25 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_0ua68buc/program.c:25:12: error: missing terminating \\\" character\\n   25 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_0ua68buc/program.c:26:1: warning: missing terminating \\\" character\\n   26 | \\\", x);\\n      | ^\\n/tmp/agnostics_c_0ua68buc/program.c:26:1: error: missing terminating \\\" character\\n   26 | \\\", x);\\n      | ^~~~~~\\n/tmp/agnostics_c_0ua68buc/program.c:28:20: error: expected ')' before ';' token\\n   28 |     free(abilities);\\n      |                    ^\\n      |                    )\\n/tmp/agnostics_c_0ua68buc/program.c:25:11: note: to match this '('\\n   25 |     printf(\\\"%d\\n      |           ^\\n/tmp/agnostics_c_0ua68buc/program.c:28:5: error: invalid use of void expression\\n   28 |     free(abilities);\\n      |     ^~~~~~~~~~~~~~~\\n/tmp/agnostics_c_0ua68buc/program.c:30:14: error: expected ';' before '}' token\\n   30 |     return 0;\\n      |              ^\\n      |              ;\\n   31 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0ua68buc/program.c: In function 'main':\n/tmp/agnostics_c_0ua68buc/program.c:25:12: warning: missing terminating \" character\n   25 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c_0ua68buc/program.c:25:12: error: missing terminating \" character\n   25 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c_0ua68buc/program.c:26:1: warning: missing terminating \" character\n   26 | \", x);\n      | ^\n/tmp/agnostics_c_0ua68buc/program.c:26:1: error: missing terminating \" character\n   26 | \", x);\n      | ^~~~~~\n/tmp/agnostics_c_0ua68buc/program.c:28:20: error: expected ')' before ';' token\n   28 |     free(abilities);\n      |                    ^\n      |                    )\n/tmp/agnostics_c_0ua68buc/program.c:25:11: note: to match this '('\n   25 |     printf(\"%d\n      |           ^\n/tmp/agnostics_c_0ua68buc/program.c:28:5: error: invalid use of void expression\n   28 |     free(abilities);\n      |     ^~~~~~~~~~~~~~~\n/tmp/agnostics_c_0ua68buc/program.c:30:14: error: expected ';' before '}' token\n   30 |     return 0;\n      |              ^\n      |              ;\n   31 | }\n      | ~             \n"}
{"question_id": "abc313_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 50\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Initialize adjacency list\n    GArray *adj[N + 1];\n    for (int i = 1; i <= N; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read input and build adjacency list\n    for (int i = 0; i < M; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n        g_array_append_val(adj[A], B);\n    }\n\n    // Initialize in-degree and out-degree arrays\n    int in_degree[N + 1] = {0};\n    int out_degree[N + 1] = {0};\n\n    // Calculate in-degree and out-degree\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j < g_array_index(adj[i], int, j); j++) {\n            int neighbor = g_array_index(adj[i], int, j);\n            in_degree[neighbor]++;\n            out_degree[i]++;\n        }\n    }\n\n    // Find nodes with in-degree 0 and out-degree N-1\n    int strongest = -1;\n    for (int i = 1; i <= N; i++) {\n        if (in_degree[i] == 0 && out_degree[i] == N - 1) {\n            if (strongest != -1) {\n                strongest = -1;\n                break;\n            }\n            strongest = i;\n        }\n    }\n\n    // Output the result\n    printf(\"%d\n\", strongest);\n\n    // Clean up\n    for (int i = 1; i <= N; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_36hrek02/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_36hrek02/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc313_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    qsort(arr, n, sizeof(int), compare);\n\n    int min = arr[0];\n    int max = arr[n-1];\n    int operations = 0;\n\n    while (max - min > 1) {\n        if (max - min == 2) {\n            if (arr[1] - min > max - arr[n-2]) {\n                operations += arr[1] - min;\n                arr[1] -= arr[1] - min;\n                max = arr[n-1];\n            } else {\n                operations += max - arr[n-2];\n                arr[n-2] += max - arr[n-2];\n                min = arr[0];\n            }\n        } else {\n            operations += (max - min - 1) / 2;\n            max -= (max - min - 1) / 2;\n            min += (max - min - 1) / 2;\n        }\n    }\n\n    printf(\"%d\n\", operations);\n\n    free(arr);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_5i6634m4/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_5i6634m4/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc314_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <gmp.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    mpz_t pi;\n    mpz_init(pi);\n\n    // Calculate pi to the n-th decimal place\n    mpz_set_ui(pi, 0);\n    mpz_ui_pow_ui(pi, 10, n);\n    mpz_mul_ui(pi, pi, 4);\n\n    // Print pi with n decimal places\n    gmp_printf(\"%.%Ff\\n\", n, pi);\n\n    mpz_clear(pi);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_lufxtig6/program.c:3:10: fatal error: gmp.h: No such file or directory\\n    3 | #include <gmp.h>\\n      |          ^~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_lufxtig6/program.c:3:10: fatal error: gmp.h: No such file or directory\n    3 | #include <gmp.h>\n      |          ^~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc314_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, X;\n    scanf(\"%d\", &N);\n\n    GHashTable *bets = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 1; i <= N; i++) {\n        int C;\n        scanf(\"%d\", &C);\n\n        for (int j = 0; j < C; j++) {\n            int A;\n            scanf(\"%d\", &A);\n\n            if (A == X) {\n                if (g_hash_table_contains(bets, GINT_TO_POINTER(i))) {\n                    int *current_bets = g_hash_table_lookup(bets, GINT_TO_POINTER(i));\n                    (*current_bets)++;\n                } else {\n                    int *new_bets = malloc(sizeof(int));\n                    *new_bets = 1;\n                    g_hash_table_insert(bets, GINT_TO_POINTER(i), new_bets);\n                }\n            }\n        }\n    }\n\n    int min_bets = INT_MAX;\n    GList *keys = g_hash_table_get_keys(bets);\n    for (GList *key = keys; key != NULL; key = key->next) {\n        int *bets_count = g_hash_table_lookup(bets, key);\n        if (*bets_count < min_bets) {\n            min_bets = *bets_count;\n        }\n    }\n\n    int count = 0;\n    for (GList *key = keys; key != NULL; key = key->next) {\n        int *bets_count = g_hash_table_lookup(bets, key);\n        if (*bets_count == min_bets) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    for (GList *key = keys; key != NULL; key = key->next) {\n        int *bets_count = g_hash_table_lookup(bets, key);\n        if (*bets_count == min_bets) {\n            printf(\"%d \", GPOINTER_TO_INT(key));\n        }\n    }\n\n    printf(\"\\n\");\n\n    g_hash_table_destroy(bets);\n    g_list_free(keys);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_h4dt_aus/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_h4dt_aus/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc314_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    int *color_indices = (int *)malloc(m * sizeof(int));\n    memset(color_indices, 0, m * sizeof(int));\n\n    // Store the starting indices of each color group\n    for (int i = 0; i < n; i++) {\n        color_indices[s[i] - 'a'] = i;\n    }\n\n    // Perform the right circular shifts for each color\n    for (int i = 0; i < m; i++) {\n        int start = color_indices[i];\n        int end = n - 1;\n        char temp = s[end];\n\n        // Perform the shift\n        while (end > start) {\n            s[end] = s[end - 1];\n            end--;\n        }\n        s[start] = temp;\n    }\n\n    // Print the final string\n    printf(\"%s\n\", s);\n\n    // Free allocated memory\n    free(color_indices);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_u763bgbj/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_u763bgbj/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc314_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n    int q;\n    scanf(\"%d\", &q);\n\n    // Initialize flags\n    bool to_upper = false;\n    bool to_lower = false;\n\n    // Process operations\n    for (int i = 0; i < q; i++) {\n        int t, x;\n        char c;\n        scanf(\"%d %d %c\", &t, &x, &c);\n\n        if (t == 1) {\n            // Change character at position x-1 to c\n            s[x - 1] = c;\n        } else if (t == 2) {\n            // Convert all characters to lowercase\n            to_upper = false;\n            to_lower = true;\n        } else if (t == 3) {\n            // Convert all characters to uppercase\n            to_upper = true;\n            to_lower = false;\n        }\n    }\n\n    // Apply flags to the string\n    if (to_upper) {\n        for (int i = 0; i < n; i++) {\n            if (isalpha(s[i])) {\n                s[i] = toupper(s[i]);\n            }\n        }\n    } else if (to_lower) {\n        for (int i = 0; i < n; i++) {\n            if (isalpha(s[i])) {\n                s[i] = tolower(s[i]);\n            }\n        }\n    }\n\n    // Print the result\n    printf(\"%s\\n\", s);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_mxxtvf9x/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_mxxtvf9x/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc314_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 100\n#define MAX_M 100\n#define MAX_C 10000\n#define MAX_P 100\n#define EPS 1e-5\n\ntypedef struct {\n    int C;\n    int P;\n    int S[MAX_P];\n} Wheel;\n\nWheel wheels[MAX_N];\nint N, M;\n\nGHashTable *dp[MAX_N][MAX_M];\n\ndouble expected_cost(int points, int wheel_index) {\n    if (points >= M) {\n        return 0.0;\n    }\n    if (wheel_index == N) {\n        return INT_MAX;\n    }\n\n    GHashTable *hash = dp[wheel_index][points];\n    if (hash == NULL) {\n        hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n        dp[wheel_index][points] = hash;\n    }\n\n    gpointer value = g_hash_table_lookup(hash, GINT_TO_POINTER(wheel_index));\n    if (value != NULL) {\n        return GPOINTER_TO_DOUBLE(value);\n    }\n\n    double min_cost = INT_MAX;\n    for (int i = 0; i < wheels[wheel_index].P; i++) {\n        double cost = wheels[wheel_index].C + expected_cost(points + wheels[wheel_index].S[i], wheel_index + 1);\n        min_cost = fmin(min_cost, cost);\n    }\n\n    g_hash_table_insert(hash, GINT_TO_POINTER(wheel_index), GINT_TO_DOUBLE(min_cost));\n\n    return min_cost;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &wheels[i].C, &wheels[i].P);\n        for (int j = 0; j < wheels[i].P; j++) {\n            scanf(\"%d\", &wheels[i].S[j]);\n        }\n    }\n\n    double total_cost = 0.0;\n    for (int i = 0; i < N; i++) {\n        total_cost += expected_cost(0, i);\n    }\n\n    printf(\"%.10f\n\", total_cost);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            g_hash_table_destroy(dp[i][j]);\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_o0_yt4yl/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_o0_yt4yl/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc314_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int wins;\n    int total;\n} PlayerStats;\n\nvoid dfs(int player, GHashTable *graph, GHashTable *stats, int *visited) {\n    if (visited[player]) return;\n    visited[player] = 1;\n\n    GList *edges = g_hash_table_lookup(graph, GINT_TO_POINTER(player));\n    if (edges) {\n        PlayerStats sum = {0, 0};\n        GList *edge;\n        for (edge = edges; edge != NULL; edge = edge->next) {\n            int neighbor = GPOINTER_TO_INT(edge->data);\n            dfs(neighbor, graph, stats, visited);\n            sum.wins += ((PlayerStats *)g_hash_table_lookup(stats, GINT_TO_POINTER(neighbor)))->wins;\n            sum.total += ((PlayerStats *)g_hash_table_lookup(stats, GINT_TO_POINTER(neighbor)))->total;\n        }\n        PlayerStats *current = g_hash_table_lookup(stats, GINT_TO_POINTER(player));\n        current->wins = (sum.wins + 1) % MOD;\n        current->total = sum.total + 1;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *graph = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *stats = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 1; i <= n; i++) {\n        PlayerStats *new_stats = g_new(PlayerStats, 1);\n        new_stats->wins = 0;\n        new_stats->total = 0;\n        g_hash_table_insert(stats, GINT_TO_POINTER(i), new_stats);\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        int p, q;\n        scanf(\"%d %d\", &p, &q);\n\n        GList *edges_p = g_hash_table_lookup(graph, GINT_TO_POINTER(p));\n        if (!edges_p) {\n            edges_p = g_list_append(NULL, GINT_TO_POINTER(q));\n            g_hash_table_insert(graph, GINT_TO_POINTER(p), edges_p);\n        } else {\n            edges_p = g_list_append(edges_p, GINT_TO_POINTER(q));\n            g_hash_table_insert(graph, GINT_TO_POINTER(p), edges_p);\n        }\n\n        GList *edges_q = g_hash_table_lookup(graph, GINT_TO_POINTER(q));\n        if (!edges_q) {\n            edges_q = g_list_append(NULL, GINT_TO_POINTER(p));\n            g_hash_table_insert(graph, GINT_TO_POINTER(q), edges_q);\n        } else {\n            edges_q = g_list_append(edges_q, GINT_TO_POINTER(p));\n            g_hash_table_insert(graph, GINT_TO_POINTER(q), edges_q);\n        }\n    }\n\n    int *visited = g_new(int, n + 1);\n    memset(visited, 0, sizeof(int) * (n + 1));\n\n    for (int i = 1; i <= n; i++) {\n        dfs(i, graph, stats, visited);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        PlayerStats *player_stats = g_hash_table_lookup(stats, GINT_TO_POINTER(i));\n        printf(\"%d \", player_stats->wins);\n    }\n\n    printf(\"\\n\");\n\n    g_hash_table_destroy(graph);\n    g_hash_table_destroy(stats);\n    g_free(visited);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_gelslcua/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_gelslcua/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc315_a", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[101];\n    scanf(\"%s\", S);\n\n    char result[101];\n    int j = 0;\n\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (S[i] != 'a' && S[i] != 'e' && S[i] != 'i' && S[i] != 'o' && S[i] != 'u') {\n            result[j++] = S[i];\n        }\n    }\n    result[j] = '\\0';\n\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc315_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int M;\n    scanf(\"%d\", &M);\n\n    int *days = (int *)malloc(M * sizeof(int));\n    int total_days = 0;\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &days[i]);\n        total_days += days[i];\n    }\n\n    int middle_day = (total_days + 1) / 2;\n    int current_day = 0;\n\n    for (int i = 0; i < M; i++) {\n        current_day += days[i];\n        if (current_day >= middle_day) {\n            printf(\"%d %d\\n\", i + 1, middle_day - (current_day - days[i]) + 1);\n            break;\n        }\n    }\n\n    free(days);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"1 1\", \"got\": \"1 2\", \"stderr\": \"Test case 0 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "1 1", "got": "1 2", "stderr": "Test case 0 produced wrong output\n"}
{"question_id": "abc315_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create a hash table to store the maximum deliciousness for each flavor\n    GHashTable *flavor_max = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        int flavor, deliciousness;\n        scanf(\"%d %d\", &flavor, &deliciousness);\n\n        // Update the maximum deliciousness for the current flavor\n        gpointer existing_max = g_hash_table_lookup(flavor_max, GINT_TO_POINTER(flavor));\n        if (existing_max == NULL || GPOINTER_TO_INT(existing_max) < deliciousness) {\n            g_hash_table_insert(flavor_max, GINT_TO_POINTER(flavor), GINT_TO_POINTER(deliciousness));\n        }\n    }\n\n    // Initialize variables to store the maximum satisfaction\n    int max_satisfaction = 0;\n\n    // Iterate through all pairs of cups\n    for (int i = 0; i < n; i++) {\n        int flavor1, deliciousness1;\n        scanf(\"%d %d\", &flavor1, &deliciousness1);\n\n        for (int j = i + 1; j < n; j++) {\n            int flavor2, deliciousness2;\n            scanf(\"%d %d\", &flavor2, &deliciousness2);\n\n            // Calculate satisfaction for different flavors\n            if (flavor1 != flavor2) {\n                int satisfaction = deliciousness1 + deliciousness2;\n                if (satisfaction > max_satisfaction) {\n                    max_satisfaction = satisfaction;\n                }\n            } else {\n                // Calculate satisfaction for same flavor\n                int satisfaction = deliciousness2 + deliciousness1 / 2;\n                if (satisfaction > max_satisfaction) {\n                    max_satisfaction = satisfaction;\n                }\n            }\n        }\n    }\n\n    // Output the maximum satisfaction\n    printf(\"%d\\n\", max_satisfaction);\n\n    // Clean up\n    g_hash_table_destroy(flavor_max);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jzaqtiwd/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jzaqtiwd/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc315_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 2001\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    char grid[MAX][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    bool marked[MAX][MAX];\n    memset(marked, false, sizeof(marked));\n\n    bool changed;\n    do {\n        changed = false;\n\n        // Mark cookies in rows\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W - 1; j++) {\n                if (grid[i][j] == grid[i][j + 1] && grid[i][j] != '.') {\n                    marked[i][j] = true;\n                    marked[i][j + 1] = true;\n                    changed = true;\n                }\n            }\n        }\n\n        // Mark cookies in columns\n        for (int j = 0; j < W; j++) {\n            for (int i = 0; i < H - 1; i++) {\n                if (grid[i][j] == grid[i + 1][j] && grid[i][j] != '.') {\n                    marked[i][j] = true;\n                    marked[i + 1][j] = true;\n                    changed = true;\n                }\n            }\n        }\n\n        // Remove marked cookies\n        if (changed) {\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (marked[i][j]) {\n                        grid[i][j] = '.';\n                    }\n                }\n            }\n        }\n\n        // Reset marked array for the next iteration\n        memset(marked, false, sizeof(marked));\n    } while (changed);\n\n    // Count remaining cookies\n    int count = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] != '.') {\n                count++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_koh9gev_/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_koh9gev_/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc315_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_BOOKS 200000\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GArray *in_degree = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_set_size(in_degree, N + 1);\n\n    GArray *adj_list[N + 1];\n    for (int i = 1; i <= N; i++) {\n        adj_list[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    for (int i = 1; i <= N; i++) {\n        int C;\n        scanf(\"%d\", &C);\n        for (int j = 0; j < C; j++) {\n            int P;\n            scanf(\"%d\", &P);\n            g_array_append_val(adj_list[P], i);\n            g_array_index(in_degree, int, i)++;\n        }\n    }\n\n    GQueue *queue = g_queue_new();\n    for (int i = 1; i <= N; i++) {\n        if (g_array_index(in_degree, int, i) == 0) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(i));\n        }\n    }\n\n    GArray *result = g_array_new(FALSE, FALSE, sizeof(int));\n\n    while (!g_queue_is_empty(queue)) {\n        int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        g_array_append_val(result, current);\n\n        for (guint j = 0; j < adj_list[current]->len; j++) {\n            int neighbor = g_array_index(adj_list[current], int, j);\n            g_array_index(in_degree, int, neighbor)--;\n            if (g_array_index(in_degree, int, neighbor) == 0) {\n                g_queue_push_tail(queue, GINT_TO_POINTER(neighbor));\n            }\n        }\n    }\n\n    for (int i = 2; i <= N; i++) {\n        printf(\"%d \", g_array_index(result, int, i));\n    }\n    printf(\"\\n\");\n\n    g_array_free(in_degree, TRUE);\n    for (int i = 1; i <= N; i++) {\n        g_array_free(adj_list[i], TRUE);\n    }\n    g_queue_free(queue);\n    g_array_free(result, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_eq9m8ej2/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_eq9m8ej2/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc315_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 10000\n#define EPS 1e-5\n\n// Function to calculate Euclidean distance between two points\ndouble distance(int x1, int y1, int x2, int y2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\n// Function to calculate minimum distance with penalty\ndouble min_distance(int n, int *x, int *y, int pos, int skip) {\n    // Base case: if at the last checkpoint\n    if (pos == n - 1) {\n        return distance(x[pos], y[pos], x[0], y[0]) + (skip > 0 ? pow(2, skip - 1) : 0);\n    }\n\n    // Check if result is already computed\n    if (dp[pos][skip] != -1) {\n        return dp[pos][skip];\n    }\n\n    double min_dist = INT_MAX;\n\n    // Try skipping the current checkpoint\n    min_dist = fmin(min_dist, min_distance(n, x, y, pos + 1, skip + 1));\n\n    // Try not skipping the current checkpoint\n    for (int i = pos + 1; i < n; i++) {\n        min_dist = fmin(min_dist, min_distance(n, x, y, i, 0) + distance(x[pos], y[pos], x[i], y[i]));\n    }\n\n    // Store the result in dp array\n    dp[pos][skip] = min_dist;\n    return min_dist;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int x[MAX_N], y[MAX_N];\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &x[i], &y[i]);\n    }\n\n    // Initialize dp array with -1\n    double dp[MAX_N][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = -1;\n        }\n    }\n\n    // Calculate minimum distance\n    double result = min_distance(n, x, y, 0, 0);\n\n    // Print the result\n    printf(\"%.15f\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_wsozx0x6/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_wsozx0x6/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc318_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, M, P;\n    scanf(\"%d %d %d\", &N, &M, &P);\n\n    // Calculate the number of full moon days\n    int full_moon_count = 0;\n    if (M <= N) {\n        full_moon_count = (N - M + 1) / P;\n    }\n\n    // Output the result\n    printf(\"%d\n\", full_moon_count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_u4nz679m/program.c: In function 'main':\\n/tmp/agnostics_c_u4nz679m/program.c:15:12: warning: missing terminating \\\" character\\n   15 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_u4nz679m/program.c:15:12: error: missing terminating \\\" character\\n   15 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_u4nz679m/program.c:16:1: warning: missing terminating \\\" character\\n   16 | \\\", full_moon_count);\\n      | ^\\n/tmp/agnostics_c_u4nz679m/program.c:16:1: error: missing terminating \\\" character\\n   16 | \\\", full_moon_count);\\n      | ^~~~~~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_u4nz679m/program.c:18:5: error: expected expression before 'return'\\n   18 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_u4nz679m/program.c:18:14: error: expected ';' before '}' token\\n   18 |     return 0;\\n      |              ^\\n      |              ;\\n   19 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_u4nz679m/program.c: In function 'main':\n/tmp/agnostics_c_u4nz679m/program.c:15:12: warning: missing terminating \" character\n   15 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c_u4nz679m/program.c:15:12: error: missing terminating \" character\n   15 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c_u4nz679m/program.c:16:1: warning: missing terminating \" character\n   16 | \", full_moon_count);\n      | ^\n/tmp/agnostics_c_u4nz679m/program.c:16:1: error: missing terminating \" character\n   16 | \", full_moon_count);\n      | ^~~~~~~~~~~~~~~~~~~~\n/tmp/agnostics_c_u4nz679m/program.c:18:5: error: expected expression before 'return'\n   18 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_u4nz679m/program.c:18:14: error: expected ';' before '}' token\n   18 |     return 0;\n      |              ^\n      |              ;\n   19 | }\n      | ~             \n"}
{"question_id": "abc318_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 101\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    bool grid[MAX][MAX] = {false};\n\n    for (int i = 0; i < N; i++) {\n        int A, B, C, D;\n        scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n\n        for (int x = A; x < B; x++) {\n            for (int y = C; y < D; y++) {\n                grid[x][y] = true;\n            }\n        }\n    }\n\n    int area = 0;\n    for (int x = 0; x < MAX; x++) {\n        for (int y = 0; y < MAX; y++) {\n            if (grid[x][y]) {\n                area++;\n            }\n        }\n    }\n\n    printf(\"%d\n\", area);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_asqxvnql/program.c: In function 'main':\\n/tmp/agnostics_c_asqxvnql/program.c:10:5: error: unknown type name 'bool'\\n   10 |     bool grid[MAX][MAX] = {false};\\n      |     ^~~~\\n/tmp/agnostics_c_asqxvnql/program.c:3:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n    2 | #include <stdlib.h>\\n  +++ |+#include <stdbool.h>\\n    3 | \\n/tmp/agnostics_c_asqxvnql/program.c:10:28: error: 'false' undeclared (first use in this function)\\n   10 |     bool grid[MAX][MAX] = {false};\\n      |                            ^~~~~\\n/tmp/agnostics_c_asqxvnql/program.c:10:28: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_asqxvnql/program.c:10:28: note: each undeclared identifier is reported only once for each function it appears in\\n/tmp/agnostics_c_asqxvnql/program.c:18:30: error: 'true' undeclared (first use in this function)\\n   18 |                 grid[x][y] = true;\\n      |                              ^~~~\\n/tmp/agnostics_c_asqxvnql/program.c:18:30: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_asqxvnql/program.c:32:12: warning: missing terminating \\\" character\\n   32 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_asqxvnql/program.c:32:12: error: missing terminating \\\" character\\n   32 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_asqxvnql/program.c:33:1: warning: missing terminating \\\" character\\n   33 | \\\", area);\\n      | ^\\n/tmp/agnostics_c_asqxvnql/program.c:33:1: error: missing terminating \\\" character\\n   33 | \\\", area);\\n      | ^~~~~~~~~\\n/tmp/agnostics_c_asqxvnql/program.c:35:5: error: expected expression before 'return'\\n   35 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_asqxvnql/program.c:35:14: error: expected ';' before '}' token\\n   35 |     return 0;\\n      |              ^\\n      |              ;\\n   36 |", "raw_stderr": "", "result": "fail"}
{"question_id": "abc318_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, D, P;\n    scanf(\"%d %d %d\", &N, &D, &P);\n\n    GArray *F = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        int fare;\n        scanf(\"%d\", &fare);\n        g_array_append_val(F, fare);\n    }\n\n    // Sort the fares in descending order\n    qsort(F->data, F->len, sizeof(int), (int (*)(const void *, const void *))strcmp);\n\n    int total_cost = 0;\n    int i = 0;\n\n    while (i < N) {\n        int pass_cost = 0;\n        int pass_days = 0;\n\n        // Calculate the cost and number of days for the current batch of passes\n        while (i < N && pass_cost + F->data[i] <= P) {\n            pass_cost += F->data[i];\n            pass_days++;\n            i++;\n        }\n\n        // If we can buy a full batch of passes, add the cost to total_cost\n        if (pass_days == D) {\n            total_cost += P;\n        } else {\n            // Otherwise, add the cost of the remaining days\n            total_cost += pass_cost;\n        }\n    }\n\n    printf(\"%d\\n\", total_cost);\n\n    g_array_free(F, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_t48xlgnn/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_t48xlgnn/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc318_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 16\n#define MAX_VALUE 1000000000\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int graph[MAX_N][MAX_N];\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            scanf(\"%d\", &graph[i][j]);\n        }\n    }\n\n    int max_weight = 0;\n\n    for (int mask = 0; mask < (1 << (n * (n - 1) / 2)); mask++) {\n        int weight = 0;\n        int edge_count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (mask & (1 << edge_count)) {\n                    weight += graph[i][j];\n                }\n                edge_count++;\n            }\n        }\n        if (weight > max_weight) {\n            max_weight = weight;\n        }\n    }\n\n    printf(\"%d\n\", max_weight);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_9enkhnhd/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_9enkhnhd/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc318_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Use a hash table to store the count of each element and its last occurrence index\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *last_index = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    long long result = 0;\n\n    for (int i = 0; i < n; i++) {\n        // Get the count of the current element and its last occurrence index\n        int *c = (int *)g_hash_table_lookup(count, GINT_TO_POINTER(A[i]));\n        int *l = (int *)g_hash_table_lookup(last_index, GINT_TO_POINTER(A[i]));\n\n        if (c == NULL) {\n            c = (int *)malloc(sizeof(int));\n            *c = 0;\n            l = (int *)malloc(sizeof(int));\n            *l = -1;\n        }\n\n        // If the element has been seen before, add the number of valid triples to the result\n        if (*l != -1) {\n            result += *l;\n        }\n\n        // Update the count and last occurrence index of the current element\n        (*c)++;\n        *l = i;\n\n        // Insert the updated count and last occurrence index back into the hash tables\n        g_hash_table_insert(count, GINT_TO_POINTER(A[i]), c);\n        g_hash_table_insert(last_index, GINT_TO_POINTER(A[i]), l);\n    }\n\n    // Output the result\n    printf(\"%lld\n\", result);\n\n    // Clean up\n    for (int i = 0; i < n; i++) {\n        free((int *)g_hash_table_lookup(count, GINT_TO_POINTER(A[i])));\n        free((int *)g_hash_table_lookup(last_index, GINT_TO_POINTER(A[i])));\n    }\n    g_hash_table_destroy(count);\n    g_hash_table_destroy(last_index);\n    free(A);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_6tv4xhp6/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_6tv4xhp6/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc319_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char result[n + 1];\n    memset(result, '-', sizeof(result));\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 1; j <= 9; j++) {\n            if (n % j == 0 && i % (n / j) == 0) {\n                result[i] = '0' + j;\n                break;\n            }\n        }\n    }\n\n    result[n] = '\\0';\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_c5ve_v6q/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_c5ve_v6q/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc319_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define N 3\n\nint is_valid_sequence(int *grid, int *sequence, int length) {\n    for (int i = 0; i < N; i++) {\n        if (sequence[i * 3] == sequence[i * 3 + 1] && sequence[i * 3 + 1] != sequence[i * 3 + 2]) return 0;\n        if (sequence[i] == sequence[i + N] && sequence[i + N] != sequence[i + 2 * N]) return 0;\n    }\n    if (sequence[0] == sequence[4] && sequence[4] != sequence[8]) return 0;\n    if (sequence[2] == sequence[4] && sequence[4] != sequence[6]) return 0;\n    return 1;\n}\n\nint main() {\n    int grid[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    int count = 0;\n    int total = 0;\n\n    int *sequence = (int *)malloc(N * N * sizeof(int));\n    for (int i = 0; i < N * N; i++) {\n        sequence[i] = i;\n    }\n\n    do {\n        int valid = 1;\n        for (int i = 0; i < N * N; i++) {\n            int row = sequence[i] / N;\n            int col = sequence[i] % N;\n            int value = grid[row][col];\n            if (i > 0 && value == grid[sequence[i - 1] / N][sequence[i - 1] % N]) {\n                valid = 0;\n                break;\n            }\n        }\n        if (valid) {\n            total++;\n            if (is_valid_sequence(grid, sequence, N * N)) {\n                count++;\n            }\n        }\n    } while (next_permutation(sequence, sequence + N * N));\n\n    double probability = (double)count / total;\n    printf(\"%.15f\n\", probability);\n\n    free(sequence);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_uxn89jx1/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_uxn89jx1/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc319_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint canFit(int *words, int n, int m, int width) {\n    int lines = 1;\n    int currentWidth = 0;\n    for (int i = 0; i < n; i++) {\n        if (words[i] > width) return 0; // Word is too long to fit in any line\n        if (currentWidth + words[i] + (i > 0 ? 1 : 0) > width) {\n            lines++;\n            currentWidth = words[i];\n        } else {\n            currentWidth += words[i] + (i > 0 ? 1 : 0);\n        }\n    }\n    return lines <= m;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int *words = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &words[i]);\n    }\n\n    int left = 0, right = 1000000000000000000, result = 0;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (canFit(words, n, m, mid)) {\n            result = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    printf(\"%d\n\", result);\n\n    free(words);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_kdqrsten/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_kdqrsten/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc319_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Define a structure to represent the state of Takahashi\ntypedef struct {\n    int stop;\n    long long time;\n} State;\n\n// Define a comparison function for the priority queue\nstatic gint compare_states(gconstpointer a, gconstpointer b) {\n    State *state1 = (State *)a;\n    State *state2 = (State *)b;\n    return state1->time - state2->time;\n}\n\nint main() {\n    int n, x, y;\n    scanf(\"%d %d %d\", &n, &x, &y);\n\n    // Read bus stop times and intervals\n    GArray *bus_times = g_array_new(FALSE, FALSE, sizeof(State));\n    for (int i = 0; i < n - 1; i++) {\n        int p, t;\n        scanf(\"%d %d\", &p, &t);\n        g_array_append_val(bus_times, (State){i + 1, t});\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n\n    // Process each query\n    for (int i = 0; i < q; i++) {\n        long long q_i;\n        scanf(\"%lld\", &q_i);\n\n        // Initialize the priority queue with the starting time at bus stop 1\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(q_i + x));\n\n        // Process the priority queue until we reach bus stop N\n        while (g_queue_get_length(queue) > 0) {\n            State current = *(State *)g_queue_pop_head(queue);\n            if (current.stop == n) {\n                printf(\"%lld\\n\", current.time);\n                break;\n            }\n\n            // Check the next bus departure time\n            State next = bus_times->data[current.stop - 1];\n            if (current.time % next.time == 0) {\n                g_queue_push_tail(queue, GINT_TO_POINTER(current.time + next.time));\n            } else {\n                g_queue_push_tail(queue, GINT_TO_POINTER((current.time / next.time + 1) * next.time));\n            }\n        }\n\n        // Clean up the priority queue\n        g_queue_free(queue);\n    }\n\n    // Clean up the bus times array\n    g_array_free(bus_times, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jzyr1gj6/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jzyr1gj6/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc320_a", "solution": "#include <stdio.h>\n\nint main() {\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n\n    long long result = (long long)pow(A, B) + (long long)pow(B, A);\n\n    printf(\"%lld\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"/tmp/agnostics_c_a228f_k7/program.c: In function 'main':\\n/tmp/agnostics_c_a228f_k7/program.c:7:35: warning: implicit declaration of function 'pow' [-Wimplicit-function-declaration]\\n    7 |     long long result = (long long)pow(A, B) + (long long)pow(B, A);\\n      |                                   ^~~\\n/tmp/agnostics_c_a228f_k7/program.c:2:1: note: include '<math.h>' or provide a declaration of 'pow'\\n    1 | #include <stdio.h>\\n  +++ |+#include <math.h>\\n    2 | \\n/tmp/agnostics_c_a228f_k7/program.c:7:35: warning: incompatible implicit declaration of built-in function 'pow' [-Wbuiltin-declaration-mismatch]\\n    7 |     long long result = (long long)pow(A, B) + (long long)pow(B, A);\\n      |                                   ^~~\\n/tmp/agnostics_c_a228f_k7/program.c:7:35: note: include '<math.h>' or provide a declaration of 'pow'\\n\"}\n", "raw_stderr": "", "result": "success", "stderr": "/tmp/agnostics_c_a228f_k7/program.c: In function 'main':\n/tmp/agnostics_c_a228f_k7/program.c:7:35: warning: implicit declaration of function 'pow' [-Wimplicit-function-declaration]\n    7 |     long long result = (long long)pow(A, B) + (long long)pow(B, A);\n      |                                   ^~~\n/tmp/agnostics_c_a228f_k7/program.c:2:1: note: include '<math.h>' or provide a declaration of 'pow'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \n/tmp/agnostics_c_a228f_k7/program.c:7:35: warning: incompatible implicit declaration of built-in function 'pow' [-Wbuiltin-declaration-mismatch]\n    7 |     long long result = (long long)pow(A, B) + (long long)pow(B, A);\n      |                                   ^~~\n/tmp/agnostics_c_a228f_k7/program.c:7:35: note: include '<math.h>' or provide a declaration of 'pow'\n"}
{"question_id": "abc320_b", "solution": "#include <stdio.h>\n#include <string.h>\n\n// Function to check if a substring is a palindrome\nbool is_palindrome(char *str, int start, int end) {\n    while (start < end) {\n        if (str[start] != str[end]) {\n            return false;\n        }\n        start++;\n        end--;\n    }\n    return true;\n}\n\nint main() {\n    char S[101];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n    int max_length = 1;\n\n    // Iterate through all possible substrings\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            if (is_palindrome(S, i, j)) {\n                int length = j - i + 1;\n                if (length > max_length) {\n                    max_length = length;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\n\", max_length);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_zdxgr7d7/program.c:5:1: error: unknown type name 'bool'\\n    5 | bool is_palindrome(char *str, int start, int end) {\\n      | ^~~~\\n/tmp/agnostics_c_zdxgr7d7/program.c:3:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n    2 | #include <string.h>\\n  +++ |+#include <stdbool.h>\\n    3 | \\n/tmp/agnostics_c_zdxgr7d7/program.c: In function 'is_palindrome':\\n/tmp/agnostics_c_zdxgr7d7/program.c:8:20: error: 'false' undeclared (first use in this function)\\n    8 |             return false;\\n      |                    ^~~~~\\n/tmp/agnostics_c_zdxgr7d7/program.c:8:20: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_zdxgr7d7/program.c:8:20: note: each undeclared identifier is reported only once for each function it appears in\\n/tmp/agnostics_c_zdxgr7d7/program.c:13:12: error: 'true' undeclared (first use in this function)\\n   13 |     return true;\\n      |            ^~~~\\n/tmp/agnostics_c_zdxgr7d7/program.c:13:12: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_zdxgr7d7/program.c: In function 'main':\\n/tmp/agnostics_c_zdxgr7d7/program.c:35:12: warning: missing terminating \\\" character\\n   35 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_zdxgr7d7/program.c:35:12: error: missing terminating \\\" character\\n   35 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_zdxgr7d7/program.c:36:1: warning: missing terminating \\\" character\\n   36 | \\\", max_length);\\n      | ^\\n/tmp/agnostics_c_zdxgr7d7/program.c:36:1: error: missing terminating \\\" character\\n   36 | \\\", max_length);\\n      | ^~~~~~~~~~~~~~~\\n/tmp/agnostics_c_zdxgr7d7/program.c:38:5: error: expected expression before 'return'\\n   38 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_zdxgr7d7/program.c:38:14: error: expected ';' before '}' token\\n   38 |     return 0;\\n      |       ", "raw_stderr": "", "result": "fail"}
{"question_id": "abc320_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int M;\n    scanf(\"%d\", &M);\n\n    char S1[M+1], S2[M+1], S3[M+1];\n    scanf(\"%s\", S1);\n    scanf(\"%s\", S2);\n    scanf(\"%s\", S3);\n\n    int result = -1;\n\n    // Iterate through all possible characters\n    for (int i = 0; i < M; i++) {\n        int t1 = (i + 1) % M;\n        int t2 = (i + 1) % M;\n        int t3 = (i + 1) % M;\n\n        // Check if all three characters match at the same time\n        if (S1[t1] == S2[t2] && S2[t2] == S3[t3]) {\n            if (result == -1 || t1 > result) {\n                result = t1;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_oi6fjt32/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_oi6fjt32/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc320_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n#define MAXM 200005\n\ntypedef struct {\n    int x, y;\n    bool determined;\n} Person;\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Person people[MAXN];\n    for (int i = 0; i < N; i++) {\n        people[i].x = 0;\n        people[i].y = 0;\n        people[i].determined = false;\n    }\n\n    GHashTable *constraints = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < M; i++) {\n        int A, B, X, Y;\n        scanf(\"%d %d %d %d\", &A, &B, &X, &Y);\n\n        GArray *constraint = g_array_new(FALSE, FALSE, sizeof(int));\n        g_array_append_val(constraint, A);\n        g_array_append_val(constraint, B);\n        g_array_append_val(constraint, X);\n        g_array_append_val(constraint, Y);\n\n        g_hash_table_insert(constraints, GINT_TO_POINTER(A), constraint);\n        g_hash_table_insert(constraints, GINT_TO_POINTER(B), constraint);\n    }\n\n    for (int i = 1; i <= N; i++) {\n        if (!people[i - 1].determined) {\n            GArray *constraint = g_hash_table_lookup(constraints, GINT_TO_POINTER(i));\n            if (constraint != NULL) {\n                int A = g_array_index(constraint, int, 0);\n                int B = g_array_index(constraint, int, 1);\n                int X = g_array_index(constraint, int, 2);\n                int Y = g_array_index(constraint, int, 3);\n\n                if (!people[A - 1].determined) {\n                    people[A - 1].x = people[B - 1].x + X;\n                    people[A - 1].y = people[B - 1].y + Y;\n                    people[A - 1].determined = true;\n                } else {\n                    people[B - 1].x = people[A - 1].x - X;\n                    people[B - 1].y = people[A - 1].y - Y;\n                    people[B - 1].determined = true;\n                }\n            } else {\n                printf(\"undecidable\n\");\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (people[i].determined) {\n            printf(\"%d %d\n\", people[i].x, people[i].y);\n        } else {\n            printf(\"undecidable\n\");\n        }\n    }\n\n    g_hash_table_destroy(constraints);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__6tmomhh/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__6tmomhh/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc320_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MAX_N 200000\n#define MAX_M 200000\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashTable *people = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GQueue *events = g_queue_new();\n\n    for (int i = 0; i < M; i++) {\n        int T, W, S;\n        scanf(\"%d %d %d\", &T, &W, &S);\n\n        g_queue_push_tail(events, GINT_TO_POINTER(T));\n        g_queue_push_tail(events, GINT_TO_POINTER(T + S));\n        g_queue_push_tail(events, GINT_TO_POINTER(W));\n    }\n\n    int *noodles = (int *)calloc(N + 1, sizeof(int));\n\n    int time = 0;\n    while (!g_queue_is_empty(events)) {\n        int current_time = GPOINTER_TO_INT(g_queue_pop_head(events));\n\n        while (time < current_time) {\n            int *person = g_hash_table_lookup(people, GINT_TO_POINTER(time % N + 1));\n            if (person != NULL) {\n                noodles[*person] += 1;\n            }\n            time++;\n        }\n\n        int W = GPOINTER_TO_INT(g_queue_pop_head(events));\n        int person = GPOINTER_TO_INT(g_queue_pop_head(events));\n\n        if (person != 0) {\n            g_hash_table_insert(people, GINT_TO_POINTER(person), GINT_TO_POINTER(person));\n        }\n    }\n\n    for (int i = 1; i <= N; i++) {\n        printf(\"%d\n\", noodles[i]);\n    }\n\n    g_hash_table_destroy(people);\n    g_queue_free(events);\n    free(noodles);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_7nr8bqvu/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_7nr8bqvu/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc321_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    char num[6];  // To store the number as a string, ensuring space for up to 5 digits and a null terminator\n    sprintf(num, \"%d\", N);\n\n    int length = strlen(num);\n\n    // Check if the number is a 321-like Number\n    bool is321Like = true;\n    for (int i = 0; i < length - 1; i++) {\n        if (num[i] <= num[i + 1]) {\n            is321Like = false;\n            break;\n        }\n    }\n\n    // Output the result\n    if (is321Like) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_gg4jd4it/program.c: In function 'main':\\n/tmp/agnostics_c_gg4jd4it/program.c:15:5: error: unknown type name 'bool'\\n   15 |     bool is321Like = true;\\n      |     ^~~~\\n/tmp/agnostics_c_gg4jd4it/program.c:4:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n    3 | #include <string.h>\\n  +++ |+#include <stdbool.h>\\n    4 | \\n/tmp/agnostics_c_gg4jd4it/program.c:15:22: error: 'true' undeclared (first use in this function)\\n   15 |     bool is321Like = true;\\n      |                      ^~~~\\n/tmp/agnostics_c_gg4jd4it/program.c:15:22: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_gg4jd4it/program.c:15:22: note: each undeclared identifier is reported only once for each function it appears in\\n/tmp/agnostics_c_gg4jd4it/program.c:18:25: error: 'false' undeclared (first use in this function)\\n   18 |             is321Like = false;\\n      |                         ^~~~~\\n/tmp/agnostics_c_gg4jd4it/program.c:18:25: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_gg4jd4it/program.c:25:16: warning: missing terminating \\\" character\\n   25 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_gg4jd4it/program.c:25:16: error: missing terminating \\\" character\\n   25 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_gg4jd4it/program.c:26:1: warning: missing terminating \\\" character\\n   26 | \\\");\\n      | ^\\n/tmp/agnostics_c_gg4jd4it/program.c:26:1: error: missing terminating \\\" character\\n   26 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_gg4jd4it/program.c:27:5: error: expected expression before '}' token\\n   27 |     } else {\\n      |     ^\\n/tmp/agnostics_c_gg4jd4it/program.c:25:16: error: expected ';' before '}' token\\n   25 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   26 | \\\");\\n   27 |     } els", "raw_stderr": "", "result": "fail"}
{"question_id": "abc321_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, X;\n    scanf(\"%d %d\", &N, &X);\n\n    int scores[N-1];\n    for (int i = 0; i < N-1; i++) {\n        scanf(\"%d\", &scores[i]);\n    }\n\n    g_array_sort(G_ARRAY_FROM_POINTER(scores, int, N-1), (GCompareFunc)g_int_compare);\n\n    int sum = 0;\n    for (int i = 1; i < N-1; i++) {\n        sum += scores[i];\n    }\n\n    int min_score_needed = X - sum;\n    if (min_score_needed < 0) {\n        printf(\"-1\n\");\n    } else if (min_score_needed > 100) {\n        printf(\"-1\n\");\n    } else {\n        printf(\"%d\n\", min_score_needed);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_6ffm4i36/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_6ffm4i36/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc321_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 1000000\n\nGQueue *queue;\n\nvoid generate(int n, int last_digit) {\n    if (n == 0) {\n        char str[MAX];\n        sprintf(str, \"%d\", last_digit);\n        g_queue_push_tail(queue, g_strdup(str));\n        return;\n    }\n    for (int i = last_digit - 1; i >= 0; i--) {\n        char str[MAX];\n        sprintf(str, \"%d%d\", last_digit, i);\n        g_queue_push_tail(queue, g_strdup(str));\n        generate(n - 1, i);\n    }\n}\n\nint main() {\n    int K;\n    scanf(\"%d\", &K);\n\n    queue = g_queue_new();\n\n    for (int i = 9; i >= 1; i--) {\n        generate(1, i);\n    }\n\n    GList *node = g_list_nth(g_queue_get_elements(queue), K - 1);\n    printf(\"%s\n\", (char *)node->data);\n\n    g_queue_free_full(queue, g_free);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_v0hffg4k/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_v0hffg4k/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc321_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m, p;\n    scanf(\"%d %d %d\", &n, &m, &p);\n\n    int *main_dishes = (int *)malloc(n * sizeof(int));\n    int *side_dishes = (int *)malloc(m * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &main_dishes[i]);\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &side_dishes[i]);\n    }\n\n    qsort(main_dishes, n, sizeof(int), compare);\n    qsort(side_dishes, m, sizeof(int), compare);\n\n    int total_price = 0;\n    int i = 0, j = 0;\n\n    while (i < n && j < m) {\n        int sum = main_dishes[i] + side_dishes[j];\n        total_price += (sum <= p) ? sum : p;\n\n        if (sum <= p) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    printf(\"%d\n\", total_price);\n\n    free(main_dishes);\n    free(side_dishes);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_edic0dxu/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_edic0dxu/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc321_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int N, X, K;\n        scanf(\"%d %d %d\", &N, &X, &K);\n\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(X));\n\n        int level = 0;\n        int count = 0;\n        bool found = false;\n\n        while (!g_queue_is_empty(queue)) {\n            int size = g_queue_get_length(queue);\n\n            if (level == K) {\n                count = size;\n                found = true;\n                break;\n            }\n\n            for (int i = 0; i < size; i++) {\n                int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n                int left = 2 * current;\n                int right = 2 * current + 1;\n\n                if (left <= N) {\n                    g_queue_push_tail(queue, GINT_TO_POINTER(left));\n                }\n\n                if (right <= N) {\n                    g_queue_push_tail(queue, GINT_TO_POINTER(right));\n                }\n            }\n\n            level++;\n        }\n\n        if (!found) {\n            count = 0;\n        }\n\n        printf(\"%d\\n\", count);\n\n        g_queue_free(queue);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2liy9g8p/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2liy9g8p/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc322_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    // Iterate through the string to find the first occurrence of 'ABC'\n    for (int i = 0; i <= n - 3; i++) {\n        if (s[i] == 'A' && s[i + 1] == 'B' && s[i + 2] == 'C') {\n            printf(\"%d\n\", i + 1);  // +1 because positions are 1-based\n            return 0;\n        }\n    }\n\n    // If 'ABC' is not found, print -1\n    printf(\"-1\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ybixvfpc/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ybixvfpc/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc322_b", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    char S[N+1], T[M+1];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int is_prefix = 1, is_suffix = 1;\n\n    // Check if S is a prefix of T\n    for (int i = 0; i < N; i++) {\n        if (T[i] != S[i]) {\n            is_prefix = 0;\n            break;\n        }\n    }\n\n    // Check if S is a suffix of T\n    for (int i = 0; i < N; i++) {\n        if (T[M - N + i] != S[i]) {\n            is_suffix = 0;\n            break;\n        }\n    }\n\n    // Determine the result based on the conditions\n    int result = 0;\n    if (is_prefix && is_suffix) {\n        result = 0;\n    } else if (is_prefix) {\n        result = 1;\n    } else if (is_suffix) {\n        result = 2;\n    } else {\n        result = 3;\n    }\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc322_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Read the days on which fireworks are launched\n    GArray *fireworks_days = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < m; i++) {\n        int day;\n        scanf(\"%d\", &day);\n        g_array_append_val(fireworks_days, day);\n    }\n\n    // Create a hash table to store the days on which fireworks are launched\n    GHashTable *fireworks_map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < m; i++) {\n        int day = g_array_index(fireworks_days, int, i);\n        g_hash_table_insert(fireworks_map, GINT_TO_POINTER(day), GINT_TO_POINTER(1));\n    }\n\n    // For each day of the festival, find the next day on which fireworks are launched\n    for (int i = 1; i <= n; i++) {\n        if (g_hash_table_lookup(fireworks_map, GINT_TO_POINTER(i))) {\n            printf(\"0\\n\");\n        } else {\n            int next_day = i + 1;\n            while (g_hash_table_lookup(fireworks_map, GINT_TO_POINTER(next_day)) == NULL) {\n                next_day++;\n            }\n            printf(\"%d\\n\", next_day - i);\n        }\n    }\n\n    // Clean up\n    g_array_free(fireworks_days, TRUE);\n    g_hash_table_destroy(fireworks_map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ilt2njkk/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ilt2njkk/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc322_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define GRID_SIZE 4\n\n// Function to check if a polyomino can be placed at a given position\nbool can_place_polyomino(char grid[GRID_SIZE][GRID_SIZE], char polyomino[GRID_SIZE][GRID_SIZE], int x, int y, int rotation) {\n    // Placeholder for polyomino rotation logic\n    // For simplicity, assume rotation is handled elsewhere\n    // Check if the polyomino fits within the grid boundaries\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            if (polyomino[i][j] == '#' && (x + i >= GRID_SIZE || y + j >= GRID_SIZE || grid[x + i][y + j] != '.')) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n// Function to place a polyomino on the grid\nvoid place_polyomino(char grid[GRID_SIZE][GRID_SIZE], char polyomino[GRID_SIZE][GRID_SIZE], int x, int y) {\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            if (polyomino[i][j] == '#') {\n                grid[x + i][y + j] = '#';\n            }\n        }\n    }\n}\n\n// Function to remove a polyomino from the grid\nvoid remove_polyomino(char grid[GRID_SIZE][GRID_SIZE], char polyomino[GRID_SIZE][GRID_SIZE], int x, int y) {\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            if (polyomino[i][j] == '#') {\n                grid[x + i][y + j] = '.';\n            }\n        }\n    }\n}\n\n// Function to solve the puzzle\nbool solve_puzzle(char grid[GRID_SIZE][GRID_SIZE], char polyominoes[3][GRID_SIZE][GRID_SIZE], int index) {\n    if (index == 3) {\n        return true; // All polyominoes placed successfully\n    }\n\n    for (int x = 0; x <= GRID_SIZE - 1; x++) {\n        for (int y = 0; y <= GRID_SIZE - 1; y++) {\n            if (can_place_polyomino(grid, polyominoes[index], x, y, 0)) {\n                place_polyomino(grid, polyominoes[index], x, y);\n                if (solve_puzzle(grid, polyominoes, index + 1)) {\n                    return true;\n                }\n                remove_polyomino(grid, polyominoes[index], x, y);\n            }\n        }\n    }\n\n    return false; // No valid placement found\n}\n\nint main() {\n    char grid[GRID_SIZE][GRID_SIZE];\n    char polyominoes[3][GRID_SIZE][GRID_SIZE];\n\n    // Read the grid\n    for (int i = 0; i < GRID_SIZE; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            scanf(\"%c\", &grid[i][j]);\n        }\n    }\n\n    // Read the polyominoes\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < GRID_SIZE; j++) {\n            for (int k = 0; k < GRID_SIZE; k++) {\n                scanf(\"%c\", &polyominoes[i][j][k]);\n            }\n        }\n    }\n\n    // Solve the puzzle\n    if (solve_puzzle(grid, polyominoes, 0)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_xl4ggn0z/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_xl4ggn0z/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc322_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 100\n#define MAX_K 5\n#define MAX_C 1000000000\n\ntypedef struct {\n    int cost;\n    int effects[MAX_K];\n} Plan;\n\nint compare(const void *a, const void *b) {\n    Plan *p1 = (Plan *)a;\n    Plan *p2 = (Plan *)b;\n    int diff = 0;\n    for (int i = 0; i < MAX_K; i++) {\n        diff += p1->effects[i] - p2->effects[i];\n    }\n    return (diff * MAX_C + p2->cost) - (diff * MAX_C + p1->cost);\n}\n\nint main() {\n    int N, K, P;\n    scanf(\"%d %d %d\", &N, &K, &P);\n\n    Plan plans[MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &plans[i].cost);\n        for (int j = 0; j < K; j++) {\n            scanf(\"%d\", &plans[i].effects[j]);\n        }\n    }\n\n    int current_values[MAX_K] = {0};\n    int total_cost = 0;\n\n    GArray *queue = g_array_new(FALSE, FALSE, sizeof(Plan));\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(queue, plans[i]);\n    }\n\n    g_array_sort(queue, compare);\n\n    while (g_array_get_length(queue) > 0) {\n        Plan plan = g_array_index(queue, Plan, 0);\n        g_array_remove_range(queue, 0, 1);\n\n        bool can_apply = true;\n        for (int j = 0; j < K; j++) {\n            if (current_values[j] + plan.effects[j] < P) {\n                can_apply = false;\n                break;\n            }\n        }\n\n        if (can_apply) {\n            for (int j = 0; j < K; j++) {\n                current_values[j] += plan.effects[j];\n            }\n            total_cost += plan.cost;\n        }\n\n        if (current_values[0] >= P && current_values[1] >= P && current_values[2] >= P) {\n            break;\n        }\n    }\n\n    if (current_values[0] >= P && current_values[1] >= P && current_values[2] >= P) {\n        printf(\"%d\\n\", total_cost);\n    } else {\n        printf(\"-1\\n\");\n    }\n\n    g_array_free(queue, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_7czra8xn/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_7czra8xn/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc323_a", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[17];  // String of length 16 + 1 for the null terminator\n    scanf(\"%s\", S);\n\n    bool all_zeros = true;\n\n    // Check characters at even positions (indices 1, 3, 5, ..., 15)\n    for (int i = 1; i < 16; i += 2) {\n        if (S[i] != '0') {\n            all_zeros = false;\n            break;\n        }\n    }\n\n    // Print the result\n    if (all_zeros) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0z0olfnx/program.c: In function 'main':\\n/tmp/agnostics_c_0z0olfnx/program.c:8:5: error: unknown type name 'bool'\\n    8 |     bool all_zeros = true;\\n      |     ^~~~\\n/tmp/agnostics_c_0z0olfnx/program.c:3:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n    2 | #include <string.h>\\n  +++ |+#include <stdbool.h>\\n    3 | \\n/tmp/agnostics_c_0z0olfnx/program.c:8:22: error: 'true' undeclared (first use in this function)\\n    8 |     bool all_zeros = true;\\n      |                      ^~~~\\n/tmp/agnostics_c_0z0olfnx/program.c:8:22: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_0z0olfnx/program.c:8:22: note: each undeclared identifier is reported only once for each function it appears in\\n/tmp/agnostics_c_0z0olfnx/program.c:13:25: error: 'false' undeclared (first use in this function)\\n   13 |             all_zeros = false;\\n      |                         ^~~~~\\n/tmp/agnostics_c_0z0olfnx/program.c:13:25: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_0z0olfnx/program.c:20:16: warning: missing terminating \\\" character\\n   20 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_0z0olfnx/program.c:20:16: error: missing terminating \\\" character\\n   20 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_0z0olfnx/program.c:21:1: warning: missing terminating \\\" character\\n   21 | \\\");\\n      | ^\\n/tmp/agnostics_c_0z0olfnx/program.c:21:1: error: missing terminating \\\" character\\n   21 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_0z0olfnx/program.c:22:5: error: expected expression before '}' token\\n   22 |     } else {\\n      |     ^\\n/tmp/agnostics_c_0z0olfnx/program.c:20:16: error: expected ';' before '}' token\\n   20 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   21 | \\\");\\n   22 |     } else {\\", "raw_stderr": "", "result": "fail"}
{"question_id": "abc323_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    int player1 = GPOINTER_TO_INT(*(int *)a);\n    int player2 = GPOINTER_TO_INT(*(int *)b);\n    int wins1 = GPOINTER_TO_INT(g_hash_table_lookup(wins, GINT_TO_POINTER(player1)));\n    int wins2 = GPOINTER_TO_INT(g_hash_table_lookup(wins, GINT_TO_POINTER(player2)));\n    if (wins1 != wins2) {\n        return wins2 - wins1;\n    } else {\n        return player1 - player2;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *wins = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 1; i <= n; i++) {\n        g_hash_table_insert(wins, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n    }\n\n    char **results = (char **)malloc(n * sizeof(char *));\n    for (int i = 0; i < n; i++) {\n        results[i] = (char *)malloc(n + 1);\n        scanf(\"%s\", results[i]);\n        for (int j = 0; j < n; j++) {\n            if (results[i][j] == 'o') {\n                int *w = (int *)g_hash_table_lookup(wins, GINT_TO_POINTER(j + 1));\n                (*w)++;\n            }\n        }\n    }\n\n    int *players = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        players[i] = i + 1;\n    }\n\n    qsort(players, n, sizeof(int), compare);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", players[i]);\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < n; i++) {\n        free(results[i]);\n    }\n    free(results);\n    free(players);\n    g_hash_table_destroy(wins);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_sz1jqd1d/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_sz1jqd1d/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc323_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Read problem scores\n    int *scores = (int *)malloc(m * sizeof(int));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &scores[i]);\n    }\n\n    // Read player solved problems status\n    char **status = (char **)malloc(n * sizeof(char *));\n    for (int i = 0; i < n; i++) {\n        status[i] = (char *)malloc(m * sizeof(char));\n        scanf(\" %s\", status[i]);\n    }\n\n    // Calculate current total scores for each player\n    int *current_scores = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        current_scores[i] = 0;\n        for (int j = 0; j < m; j++) {\n            if (status[i][j] == 'o') {\n                current_scores[i] += scores[j] + (i + 1);\n            }\n        }\n    }\n\n    // Calculate the minimum number of problems each player needs to solve to exceed all others\n    for (int i = 0; i < n; i++) {\n        int max_needed = 0;\n        for (int j = 0; j < n; j++) {\n            if (current_scores[j] > current_scores[i]) {\n                int needed = (current_scores[j] - current_scores[i] + 99) / 100; // Round up\n                if (needed > max_needed) {\n                    max_needed = needed;\n                }\n            }\n        }\n        printf(\"%d\\n\", max_needed);\n    }\n\n    // Free allocated memory\n    free(scores);\n    for (int i = 0; i < n; i++) {\n        free(status[i]);\n    }\n    free(status);\n    free(current_scores);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_z2plyelv/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_z2plyelv/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc323_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *sizes = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *counts = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int size, count;\n        scanf(\"%d %d\", &size, &count);\n        g_array_append_val(sizes, size);\n        g_array_append_val(counts, count);\n    }\n\n    qsort(sizes->data, sizes->len, sizeof(int), compare);\n\n    int result = 0;\n\n    for (int i = 0; i < sizes->len; i++) {\n        int size = g_array_index(sizes, int, i);\n        int count = g_array_index(counts, int, i);\n\n        while (count > 1) {\n            count -= 2;\n            result++;\n        }\n\n        if (count == 1) {\n            result++;\n        }\n    }\n\n    printf(\"%d\n\", result);\n\n    g_array_free(sizes, TRUE);\n    g_array_free(counts, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jp4f3yx2/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jp4f3yx2/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc323_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, X;\n    scanf(\"%d %d\", &N, &X);\n\n    GArray *times = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        int T;\n        scanf(\"%d\", &T);\n        g_array_append_val(times, T);\n    }\n\n    int total_time = 0;\n    for (int i = 0; i < N; i++) {\n        total_time += g_array_index(times, int, i);\n    }\n\n    int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    int x = total_time;\n    int y = N;\n    int g = gcd(x, y);\n    x /= g;\n    y /= g;\n\n    int result = 0;\n    for (int i = 0; i < N; i++) {\n        int T = g_array_index(times, int, i);\n        if ((X + 0.5) % T == 0) {\n            result = (result + y * (x * T / 2)) % MOD;\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_array_free(times, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2pkbxqo8/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2pkbxqo8/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc324_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    bool allEqual = true;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] != arr[0]) {\n            allEqual = false;\n            break;\n        }\n    }\n\n    if (allEqual) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    free(arr);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0hizsdyy/program.c: In function 'main':\\n/tmp/agnostics_c_0hizsdyy/program.c:13:5: error: unknown type name 'bool'\\n   13 |     bool allEqual = true;\\n      |     ^~~~\\n/tmp/agnostics_c_0hizsdyy/program.c:3:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n    2 | #include <stdlib.h>\\n  +++ |+#include <stdbool.h>\\n    3 | \\n/tmp/agnostics_c_0hizsdyy/program.c:13:21: error: 'true' undeclared (first use in this function)\\n   13 |     bool allEqual = true;\\n      |                     ^~~~\\n/tmp/agnostics_c_0hizsdyy/program.c:13:21: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_0hizsdyy/program.c:13:21: note: each undeclared identifier is reported only once for each function it appears in\\n/tmp/agnostics_c_0hizsdyy/program.c:16:24: error: 'false' undeclared (first use in this function)\\n   16 |             allEqual = false;\\n      |                        ^~~~~\\n/tmp/agnostics_c_0hizsdyy/program.c:16:24: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_0hizsdyy/program.c:22:16: warning: missing terminating \\\" character\\n   22 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_0hizsdyy/program.c:22:16: error: missing terminating \\\" character\\n   22 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_0hizsdyy/program.c:23:1: warning: missing terminating \\\" character\\n   23 | \\\");\\n      | ^\\n/tmp/agnostics_c_0hizsdyy/program.c:23:1: error: missing terminating \\\" character\\n   23 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_0hizsdyy/program.c:24:5: error: expected expression before '}' token\\n   24 |     } else {\\n      |     ^\\n/tmp/agnostics_c_0hizsdyy/program.c:22:16: error: expected ';' before '}' token\\n   22 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   23 | \\\");\\n   24 |     } else {\\n", "raw_stderr": "", "result": "fail"}
{"question_id": "abc324_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long long N;\n    scanf(\"%lld\", &N);\n\n    while (N % 2 == 0) {\n        N /= 2;\n    }\n\n    while (N % 3 == 0) {\n        N /= 3;\n    }\n\n    if (N == 1) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc324_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to check if two strings are equal\nbool are_equal(const char *s1, const char *s2) {\n    return strcmp(s1, s2) == 0;\n}\n\n// Function to check if s2 is obtained by inserting one character into s1\nbool is_insertion(const char *s1, const char *s2) {\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    if (len2 != len1 + 1) return false;\n    for (int i = 0; i < len2; i++) {\n        if (i == len1) return true;\n        if (s1[i] != s2[i]) return false;\n    }\n    return true;\n}\n\n// Function to check if s2 is obtained by deleting one character from s1\nbool is_deletion(const char *s1, const char *s2) {\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    if (len1 != len2 + 1) return false;\n    for (int i = 0, j = 0; i < len1; i++, j++) {\n        if (s1[i] != s2[j]) {\n            i++;\n        }\n        if (i == len1 && j == len2) return true;\n    }\n    return false;\n}\n\n// Function to check if s2 is obtained by substituting one character in s1\nbool is_substitution(const char *s1, const char *s2) {\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    if (len1 != len2) return false;\n    int diff = 0;\n    for (int i = 0; i < len1; i++) {\n        if (s1[i] != s2[i]) {\n            diff++;\n            if (diff > 1) return false;\n        }\n    }\n    return diff == 1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char T_prime[500001];\n    scanf(\"%s\", T_prime);\n\n    GArray *indices = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        char S[500001];\n        scanf(\"%s\", S);\n\n        if (are_equal(S, T_prime) || is_insertion(S, T_prime) || is_deletion(S, T_prime) || is_substitution(S, T_prime)) {\n            g_array_append_val(indices, i + 1);\n        }\n    }\n\n    printf(\"%d\n\", indices->len);\n    for (int i = 0; i < indices->len; i++) {\n        printf(\"%d\", g_array_index(indices, int, i));\n        if (i < indices->len - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    g_array_free(indices, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__826xdcm/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__826xdcm/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc324_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nbool is_perfect_square(long long num) {\n    long long root = (long long)sqrt(num);\n    return root * root == num;\n}\n\nvoid permute(char *str, int l, int r, GHashTable *set) {\n    if (l == r) {\n        long long num = atoll(str);\n        if (is_perfect_square(num)) {\n            g_hash_table_add(set, GINT_TO_POINTER(num), GINT_TO_POINTER(1));\n        }\n    } else {\n        for (int i = l; i <= r; i++) {\n            char temp = str[l];\n            str[l] = str[i];\n            str[i] = temp;\n\n            permute(str, l + 1, r, set);\n\n            temp = str[l];\n            str[l] = str[i];\n            str[i] = temp;\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char str[13];\n    scanf(\"%s\", str);\n\n    GHashTable *set = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    permute(str, 0, n - 1, set);\n\n    int result = g_hash_table_size(set);\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(set);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_k6s36bst/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_k6s36bst/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc324_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_LEN 500000\n\nint main() {\n    int n;\n    char t[MAX_LEN + 1];\n    scanf(\"%d %s\", &n, t);\n\n    GArray *strings = g_array_new(FALSE, FALSE, sizeof(char *));\n    for (int i = 0; i < n; i++) {\n        char s[MAX_LEN + 1];\n        scanf(\"%s\", s);\n        g_array_append_val(strings, s);\n    }\n\n    long long count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            char *s1 = g_array_index(strings, char *, i);\n            char *s2 = g_array_index(strings, char *, j);\n            char *concat = malloc((strlen(s1) + strlen(s2) + 1) * sizeof(char));\n            strcpy(concat, s1);\n            strcat(concat, s2);\n\n            char *pos = concat;\n            for (int k = 0; t[k] != '\\0'; k++) {\n                pos = strchr(pos, t[k]);\n                if (pos == NULL) {\n                    break;\n                }\n                pos++;\n            }\n\n            if (t[strlen(t)] == '\\0') {\n                count++;\n            }\n\n            free(concat);\n        }\n    }\n\n    printf(\"%lld\\n\", count);\n\n    g_array_free(strings, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2ujt0_yn/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2ujt0_yn/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc324_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    int to, beauty, cost;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    Edge *e1 = (Edge *)a, *e2 = (Edge *)b;\n    return (e2->beauty * e1->cost - e1->beauty * e2->cost);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    Edge edges[m];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &edges[i].to, &edges[i].beauty, &edges[i].cost);\n    }\n\n    qsort(edges, m, sizeof(Edge), compare);\n\n    double max_ratio = 0.0;\n    for (int i = 0; i < m; i++) {\n        if (edges[i].to == n) {\n            max_ratio = (double)edges[i].beauty / edges[i].cost;\n            break;\n        }\n    }\n\n    printf(\"%.15f\\n\", max_ratio);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_onj_vhrp/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_onj_vhrp/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc325_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    // Read input\n    char S[11], T[11];  // 10 characters for the name + 1 for the null terminator\n    scanf(\"%s %s\", S, T);\n\n    // Print the formatted string\n    printf(\"%s san\n\", S);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_zamy58le/program.c: In function 'main':\\n/tmp/agnostics_c_zamy58le/program.c:11:12: warning: missing terminating \\\" character\\n   11 |     printf(\\\"%s san\\n      |            ^\\n/tmp/agnostics_c_zamy58le/program.c:11:12: error: missing terminating \\\" character\\n   11 |     printf(\\\"%s san\\n      |            ^~~~~~~\\n/tmp/agnostics_c_zamy58le/program.c:12:1: warning: missing terminating \\\" character\\n   12 | \\\", S);\\n      | ^\\n/tmp/agnostics_c_zamy58le/program.c:12:1: error: missing terminating \\\" character\\n   12 | \\\", S);\\n      | ^~~~~~\\n/tmp/agnostics_c_zamy58le/program.c:14:5: error: expected expression before 'return'\\n   14 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_zamy58le/program.c:14:14: error: expected ';' before '}' token\\n   14 |     return 0;\\n      |              ^\\n      |              ;\\n   15 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_zamy58le/program.c: In function 'main':\n/tmp/agnostics_c_zamy58le/program.c:11:12: warning: missing terminating \" character\n   11 |     printf(\"%s san\n      |            ^\n/tmp/agnostics_c_zamy58le/program.c:11:12: error: missing terminating \" character\n   11 |     printf(\"%s san\n      |            ^~~~~~~\n/tmp/agnostics_c_zamy58le/program.c:12:1: warning: missing terminating \" character\n   12 | \", S);\n      | ^\n/tmp/agnostics_c_zamy58le/program.c:12:1: error: missing terminating \" character\n   12 | \", S);\n      | ^~~~~~\n/tmp/agnostics_c_zamy58le/program.c:14:5: error: expected expression before 'return'\n   14 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_zamy58le/program.c:14:14: error: expected ';' before '}' token\n   14 |     return 0;\n      |              ^\n      |              ;\n   15 | }\n      | ~             \n"}
{"question_id": "abc325_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GArray *employees = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        int W, X;\n        scanf(\"%d %d\", &W, &X);\n\n        for (int j = 0; j < W; j++) {\n            int meeting_time = (X + 9) % 24;\n            if (meeting_time < 9 || meeting_time > 18) {\n                meeting_time += 24;\n            }\n            g_array_append_val(employees, meeting_time);\n        }\n    }\n\n    qsort(employees->data, employees->len, sizeof(int), compare);\n\n    int max_employees = 0;\n    int current_count = 0;\n    int i = 0;\n\n    while (i < employees->len) {\n        int current_time = g_array_index(employees, int, i);\n        int end_time = current_time + 1;\n\n        while (i < employees->len && g_array_index(employees, int, i) < end_time) {\n            current_count++;\n            i++;\n        }\n\n        if (current_count > max_employees) {\n            max_employees = current_count;\n        }\n    }\n\n    printf(\"%d\n\", max_employees);\n\n    g_array_free(employees, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_23qamnhq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_23qamnhq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc325_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 1000\n\nvoid flood_fill(char grid[MAX][MAX], int visited[MAX][MAX], int x, int y, int H, int W) {\n    if (x < 0 || x >= H || y < 0 || y >= W || visited[x][y] || grid[x][y] == '.')\n        return;\n    visited[x][y] = 1;\n    flood_fill(grid, visited, x + 1, y, H, W);\n    flood_fill(grid, visited, x - 1, y, H, W);\n    flood_fill(grid, visited, x, y + 1, H, W);\n    flood_fill(grid, visited, x, y - 1, H, W);\n    flood_fill(grid, visited, x + 1, y + 1, H, W);\n    flood_fill(grid, visited, x - 1, y - 1, H, W);\n    flood_fill(grid, visited, x + 1, y - 1, H, W);\n    flood_fill(grid, visited, x - 1, y + 1, H, W);\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    char grid[MAX][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int visited[MAX][MAX] = {0};\n    int sensor_count = 0;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '#' && !visited[i][j]) {\n                sensor_count++;\n                flood_fill(grid, visited, i, j, H, W);\n            }\n        }\n    }\n\n    printf(\"%d\\n\", sensor_count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_g1f5q6sj/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_g1f5q6sj/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc325_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *products = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int t, d;\n        scanf(\"%d %d\", &t, &d);\n        g_array_append_val(products, t);\n        g_array_append_val(products, d);\n    }\n\n    g_array_sort(products, compare);\n\n    int count = 0;\n    int last_print_time = 0;\n\n    for (int i = 0; i < products->len; i += 2) {\n        int start_time = g_array_index(products, int, i);\n        int end_time = g_array_index(products, int, i + 1);\n\n        if (start_time >= last_print_time) {\n            count++;\n            last_print_time = end_time + 1;\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    g_array_free(products, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_7c546tks/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_7c546tks/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc325_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_CITIES 1000\n#define INF 1000000000\n\nint main() {\n    int n, a, b, c;\n    scanf(\"%d %d %d %d\", &n, &a, &b, &c);\n\n    int D[MAX_CITIES][MAX_CITIES];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &D[i][j]);\n        }\n    }\n\n    GHashTable *dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        g_hash_table_insert(dp, GINT_TO_POINTER(i), GINT_TO_POINTER(INF));\n    }\n\n    g_hash_table_insert(dp, GINT_TO_POINTER(0), GINT_TO_POINTER(0));\n\n    for (int i = 0; i < n; i++) {\n        int *current = g_hash_table_lookup(dp, GINT_TO_POINTER(i));\n        int current_time = GPOINTER_TO_INT(current);\n\n        for (int j = 0; j < n; j++) {\n            int car_time = current_time + D[i][j] * a;\n            int train_time = current_time + D[i][j] * b + c;\n\n            int *min_time = g_hash_table_lookup(dp, GINT_TO_POINTER(j));\n            int current_min_time = GPOINTER_TO_INT(min_time);\n\n            if (car_time < current_min_time) {\n                g_hash_table_insert(dp, GINT_TO_POINTER(j), GINT_TO_POINTER(car_time));\n            }\n\n            if (train_time < current_min_time) {\n                g_hash_table_insert(dp, GINT_TO_POINTER(j), GINT_TO_POINTER(train_time));\n            }\n        }\n    }\n\n    int *result = g_hash_table_lookup(dp, GINT_TO_POINTER(n - 1));\n    int min_time = GPOINTER_TO_INT(result);\n\n    printf(\"%d\n\", min_time);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_abgbmob7/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_abgbmob7/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc325_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Read section lengths\n    int *D = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &D[i]);\n    }\n\n    // Read sensor details\n    int L[2], C[2], K[2];\n    for (int i = 0; i < 2; i++) {\n        scanf(\"%d %d %d\", &L[i], &C[i], &K[i]);\n    }\n\n    // Initialize DP array\n    long long *dp = (long long *)calloc(100001, sizeof(long long));\n\n    // Fill DP array\n    for (int i = 1; i <= 100000; i++) {\n        dp[i] = LLONG_MAX;\n        for (int j = 0; j < 2; j++) {\n            if (i >= L[j] && K[j] > 0) {\n                dp[i] = MIN(dp[i], dp[i - L[j]] + C[j]);\n            }\n        }\n    }\n\n    // Calculate minimum cost to monitor all sections\n    long long total_cost = 0;\n    for (int i = 0; i < n; i++) {\n        if (dp[D[i]] == LLONG_MAX) {\n            printf(\"-1\n\");\n            free(D);\n            free(dp);\n            return 0;\n        }\n        total_cost += dp[D[i]];\n    }\n\n    // Output result\n    printf(\"%lld\n\", total_cost);\n\n    // Clean up\n    free(D);\n    free(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_004nacv3/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_004nacv3/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc326_a", "solution": "#include <stdio.h>\n\nint main() {\n    int X, Y;\n    scanf(\"%d %d\", &X, &Y);\n\n    int diff = abs(X - Y);\n\n    if (diff <= 2) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_oca24r6t/program.c: In function 'main':\\n/tmp/agnostics_c_oca24r6t/program.c:7:16: warning: implicit declaration of function 'abs' [-Wimplicit-function-declaration]\\n    7 |     int diff = abs(X - Y);\\n      |                ^~~\\n/tmp/agnostics_c_oca24r6t/program.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'abs'\\n    1 | #include <stdio.h>\\n  +++ |+#include <stdlib.h>\\n    2 | \\n/tmp/agnostics_c_oca24r6t/program.c:10:16: warning: missing terminating \\\" character\\n   10 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_oca24r6t/program.c:10:16: error: missing terminating \\\" character\\n   10 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_oca24r6t/program.c:11:1: warning: missing terminating \\\" character\\n   11 | \\\");\\n      | ^\\n/tmp/agnostics_c_oca24r6t/program.c:11:1: error: missing terminating \\\" character\\n   11 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_oca24r6t/program.c:12:5: error: expected expression before '}' token\\n   12 |     } else {\\n      |     ^\\n/tmp/agnostics_c_oca24r6t/program.c:10:16: error: expected ';' before '}' token\\n   10 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   11 | \\\");\\n   12 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_oca24r6t/program.c:13:16: warning: missing terminating \\\" character\\n   13 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_oca24r6t/program.c:13:16: error: missing terminating \\\" character\\n   13 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_oca24r6t/program.c:14:1: warning: missing terminating \\\" character\\n   14 | \\\");\\n      | ^\\n/tmp/agnostics_c_oca24r6t/program.c:14:1: error: missing terminating \\\" character\\n   14 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_oca24r6t/program.c:15:5: error: expected expression before '}' token\\n   15 |     }\\n      |     ^\\n/tmp/agnostics_c_oca24r6t/program.c:13:16: error: expected ';' before '", "raw_stderr": "", "result": "fail"}
{"question_id": "abc326_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nbool is_326_like(int num) {\n    int hundreds = num / 100;\n    int tens = (num / 10) % 10;\n    int ones = num % 10;\n    return (hundreds * tens == ones);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    while (!is_326_like(N)) {\n        N++;\n    }\n\n    printf(\"%d\n\", N);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_v06blttq/program.c:4:1: error: unknown type name 'bool'\\n    4 | bool is_326_like(int num) {\\n      | ^~~~\\n/tmp/agnostics_c_v06blttq/program.c:3:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n    2 | #include <stdlib.h>\\n  +++ |+#include <stdbool.h>\\n    3 | \\n/tmp/agnostics_c_v06blttq/program.c: In function 'main':\\n/tmp/agnostics_c_v06blttq/program.c:19:12: warning: missing terminating \\\" character\\n   19 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_v06blttq/program.c:19:12: error: missing terminating \\\" character\\n   19 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_v06blttq/program.c:20:1: warning: missing terminating \\\" character\\n   20 | \\\", N);\\n      | ^\\n/tmp/agnostics_c_v06blttq/program.c:20:1: error: missing terminating \\\" character\\n   20 | \\\", N);\\n      | ^~~~~~\\n/tmp/agnostics_c_v06blttq/program.c:22:5: error: expected expression before 'return'\\n   22 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_v06blttq/program.c:22:14: error: expected ';' before '}' token\\n   22 |     return 0;\\n      |              ^\\n      |              ;\\n   23 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_v06blttq/program.c:4:1: error: unknown type name 'bool'\n    4 | bool is_326_like(int num) {\n      | ^~~~\n/tmp/agnostics_c_v06blttq/program.c:3:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n    2 | #include <stdlib.h>\n  +++ |+#include <stdbool.h>\n    3 | \n/tmp/agnostics_c_v06blttq/program.c: In function 'main':\n/tmp/agnostics_c_v06blttq/program.c:19:12: warning: missing terminating \" character\n   19 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c_v06blttq/program.c:19:12: error: missing terminating \" character\n   19 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c_v06blttq/program.c:20:1: warning: missing terminating \" character\n   20 | \", N);\n      | ^\n/tmp/agnostics_c_v06blttq/program.c:20:1: error: missing terminating \" character\n   20 | \", N);\n      | ^~~~~~\n/tmp/agnostics_c_v06blttq/program.c:22:5: error: expected expression before 'return'\n   22 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_v06blttq/program.c:22:14: error: expected ';' before '}' token\n   22 |     return 0;\n      |              ^\n      |              ;\n   23 | }\n      | ~             \n"}
{"question_id": "abc326_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    qsort(a, n, sizeof(int), compare);\n\n    int max_gifts = 0;\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n        for (int j = i; j < n; j++) {\n            if (a[j] - a[i] < m) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        max_gifts = (max_gifts > count) ? max_gifts : count;\n    }\n\n    printf(\"%d\n\", max_gifts);\n\n    free(a);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_fa7zfyx3/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_fa7zfyx3/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc326_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define N 5\n\ntypedef struct {\n    char grid[N][N];\n    int n;\n    char *R;\n    char *C;\n} Grid;\n\nbool is_valid(Grid *grid, int row, int col, char ch) {\n    for (int i = 0; i < grid->n; i++) {\n        if (grid->grid[row][i] == ch || grid->grid[i][col] == ch) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool solve(Grid *grid, int row, int col) {\n    if (row == grid->n) {\n        return true;\n    }\n\n    if (col == grid->n) {\n        return solve(grid, row + 1, 0);\n    }\n\n    if (grid->grid[row][col] != '.') {\n        return solve(grid, row, col + 1);\n    }\n\n    for (char ch = 'A'; ch <= 'C'; ch++) {\n        if (is_valid(grid, row, col, ch)) {\n            grid->grid[row][col] = ch;\n            if (solve(grid, row, col + 1)) {\n                return true;\n            }\n            grid->grid[row][col] = '.';\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Grid grid = {0};\n    grid.n = n;\n    scanf(\"%s\", grid.R);\n    scanf(\"%s\", grid.C);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            grid.grid[i][j] = '.';\n        }\n    }\n\n    if (!solve(&grid, 0, 0)) {\n        printf(\"No\n\");\n        return 0;\n    }\n\n    printf(\"Yes\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%c\", grid.grid[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_phmiktbc/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_phmiktbc/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc326_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Initialize the DP array\n    int *dp = (int *)calloc(n, sizeof(int));\n    dp[0] = A[0];\n\n    // Fill the DP array\n    for (int i = 1; i < n; i++) {\n        dp[i] = (dp[i - 1] * 2 + A[i]) % MOD;\n    }\n\n    // Calculate the expected value\n    int expected_value = 0;\n    for (int i = 0; i < n; i++) {\n        expected_value = (expected_value + dp[i]) % MOD;\n    }\n\n    // Print the result\n    printf(\"%d\\n\", expected_value);\n\n    // Free the allocated memory\n    free(A);\n    free(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_91veolig/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_91veolig/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc327_a", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[100];\n    scanf(\"%s\", s);\n\n    for (int i = 0; i < n - 1; i++) {\n        if ((s[i] == 'a' && s[i + 1] == 'b') || (s[i] == 'b' && s[i + 1] == 'a')) {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"No\\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc327_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    long long B;\n    scanf(\"%lld\", &B);\n\n    // Initialize binary search bounds\n    long long low = 1;\n    long long high = B;\n\n    // Perform binary search\n    while (low <= high) {\n        long long mid = low + (high - low) / 2;\n        long long mid_pow_mid = mid * mid;\n\n        if (mid_pow_mid == B) {\n            // Found the solution\n            printf(\"%lld\n\", mid);\n            return 0;\n        } else if (mid_pow_mid < B) {\n            // Search in the right half\n            low = mid + 1;\n        } else {\n            // Search in the left half\n            high = mid - 1;\n        }\n    }\n\n    // If no solution is found\n    printf(\"-1\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_zkk9olwl/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_zkk9olwl/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc327_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Initialize a 9x9 grid\n    int grid[9][9];\n\n    // Read the grid from input\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    // Function to check if a set of 9 numbers contains each number from 1 to 9 exactly once\n    bool isValidSet(int *set) {\n        GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (int i = 0; i < 9; i++) {\n            int num = set[i];\n            if (num < 1 || num > 9) return false;\n            int *existing = g_hash_table_lookup(count, GINT_TO_POINTER(num));\n            if (existing) return false;\n            g_hash_table_insert(count, GINT_TO_POINTER(num), GINT_TO_POINTER(1));\n        }\n        g_hash_table_destroy(count);\n        return true;\n    }\n\n    // Check rows\n    for (int i = 0; i < 9; i++) {\n        if (!isValidSet(grid[i])) {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    // Check columns\n    for (int j = 0; j < 9; j++) {\n        int column[9];\n        for (int i = 0; i < 9; i++) {\n            column[i] = grid[i][j];\n        }\n        if (!isValidSet(column)) {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    // Check 3x3 subgrids\n    for (int block = 0; block < 9; block++) {\n        int subgrid[9];\n        int k = 0;\n        for (int i = block / 3 * 3; i < block / 3 * 3 + 3; i++) {\n            for (int j = block % 3 * 3; j < block % 3 * 3 + 3; j++) {\n                subgrid[k++] = grid[i][j];\n            }\n        }\n        if (!isValidSet(subgrid)) {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_m3n0pdgj/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_m3n0pdgj/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc327_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Initialize a hash table to track the parity of positions in sequence A\n    GHashTable *parity = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Process each pair (A_i, B_i)\n    for (int i = 0; i < M; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n\n        // Check if both A_i and B_i have the same parity\n        if (g_hash_table_contains(parity, GINT_TO_POINTER(A)) &&\n            g_hash_table_contains(parity, GINT_TO_POINTER(B)) &&\n            GPOINTER_TO_INT(g_hash_table_lookup(parity, GINT_TO_POINTER(A))) == GPOINTER_TO_INT(g_hash_table_lookup(parity, GINT_TO_POINTER(B)))) {\n            printf(\"No\n\");\n            g_hash_table_destroy(parity);\n            return 0;\n        }\n\n        // Update the parity of A_i in the hash table\n        if (g_hash_table_contains(parity, GINT_TO_POINTER(A))) {\n            int current_parity = GPOINTER_TO_INT(g_hash_table_lookup(parity, GINT_TO_POINTER(A)));\n            g_hash_table_insert(parity, GINT_TO_POINTER(A), GINT_TO_POINTER(1 - current_parity));\n        } else {\n            g_hash_table_insert(parity, GINT_TO_POINTER(A), GINT_TO_POINTER(0));\n        }\n    }\n\n    // If we reach here, (A, B) is a good pair of sequences\n    printf(\"Yes\n\");\n\n    // Clean up\n    g_hash_table_destroy(parity);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8yjm2e0m/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_8yjm2e0m/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc327_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    int *P = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n\n    // Initialize DP table\n    double **dp = (double **)malloc((n + 1) * sizeof(double *));\n    for (int i = 0; i <= n; i++) {\n        dp[i] = (double *)malloc((n + 1) * sizeof(double));\n        memset(dp[i], 0, (n + 1) * sizeof(double));\n    }\n\n    // Fill DP table\n    for (int i = 1; i <= n; i++) {\n        for (int k = 1; k <= i; k++) {\n            double sum = 0.0;\n            double denominator = 0.0;\n            for (int j = 0; j < k; j++) {\n                sum += pow(0.9, k - j - 1) * P[i - j - 1];\n                denominator += pow(0.9, k - j - 1);\n            }\n            double rating = (sum / denominator) - (1200 / sqrt(k));\n            dp[i][k] = rating;\n        }\n    }\n\n    // Find maximum rating\n    double max_rating = -1.0;\n    for (int k = 1; k <= n; k++) {\n        if (dp[n][k] > max_rating) {\n            max_rating = dp[n][k];\n        }\n    }\n\n    // Output result\n    printf(\"%.15f\n\", max_rating);\n\n    // Free memory\n    for (int i = 0; i <= n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    free(P);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_emco0gze/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_emco0gze/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc328_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, x;\n    scanf(\"%d %d\", &n, &x);\n\n    int total_score = 0;\n    for (int i = 0; i < n; i++) {\n        int score;\n        scanf(\"%d\", &score);\n        if (score <= x) {\n            total_score += score;\n        }\n    }\n\n    printf(\"%d\\n\", total_score);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc328_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *days = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int di;\n        scanf(\"%d\", &di);\n        for (int j = 1; j <= di; j++) {\n            int month = i + 1;\n            int day = j;\n            int month_digit = month % 10;\n            int day_digit = day % 10;\n            if (month_digit == day_digit) {\n                g_array_append_val(days, j);\n            }\n        }\n    }\n\n    int result = days->len;\n\n    printf(\"%d\\n\", result);\n\n    g_array_free(days, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_vqt4u8tv/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_vqt4u8tv/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc328_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        int count = 0;\n        for (int j = l - 1; j < r - 1; j++) {\n            if (s[j] == s[j + 1]) {\n                count++;\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_5eyzaxhp/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_5eyzaxhp/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc328_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char s[200001];\n    scanf(\"%s\", s);\n\n    int len = strlen(s);\n    int i = 0;\n\n    while (i < len - 2) {\n        if (s[i] == 'A' && s[i + 1] == 'B' && s[i + 2] == 'C') {\n            // Remove the 'ABC' substring\n            for (int j = i; j < len - 2; j++) {\n                s[j] = s[j + 3];\n            }\n            len -= 3;\n            i = 0; // Reset index to check from the beginning again\n        } else {\n            i++;\n        }\n    }\n\n    printf(\"%s\\n\", s);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc328_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 8\n#define MAX_M (MAX_N * (MAX_N - 1) / 2)\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    return ((Edge *)a)->w - ((Edge *)b)->w;\n}\n\nint find(int *parent, int i) {\n    if (parent[i] != i)\n        parent[i] = find(parent, parent[i]);\n    return parent[i];\n}\n\nvoid unionSet(int *parent, int x, int y) {\n    int rootX = find(parent, x);\n    int rootY = find(parent, y);\n    if (rootX != rootY)\n        parent[rootX] = rootY;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %lld\", &N, &M, &K);\n\n    Edge edges[MAX_M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n    }\n\n    qsort(edges, M, sizeof(Edge), compare);\n\n    int parent[N + 1];\n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n    }\n\n    long long cost = 0;\n    for (int i = 0; i < M; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int w = edges[i].w;\n\n        if (find(parent, u) != find(parent, v)) {\n            unionSet(parent, u, v);\n            cost = (cost + w) % K;\n        }\n    }\n\n    printf(\"%lld\\n\", cost);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_z8g1c5zq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_z8g1c5zq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc329_a", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    // Read input string\n    char S[101];  // Maximum length of S is 100\n    scanf(\"%s\", S);\n\n    // Get the length of the string\n    int len = strlen(S);\n\n    // Iterate through each character of the string\n    for (int i = 0; i < len; i++) {\n        // Print the character\n        printf(\"%c \", S[i]);\n    }\n\n    // Remove the extra space at the end\n    printf(\"\\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc329_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize a GArray to store the integers\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Read the integers into the array\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    // Sort the array in ascending order\n    qsort(arr->data, arr->len, sizeof(int), compare);\n\n    // Find the second largest element\n    int second_largest = arr->data[0];\n    for (int i = 1; i < arr->len; i++) {\n        if (arr->data[i] > second_largest) {\n            second_largest = arr->data[i];\n            break;\n        }\n    }\n\n    // Output the second largest element\n    printf(\"%d\n\", second_largest);\n\n    // Clean up\n    g_array_free(arr, TRUE);\n\n    return 0;\n}\n\n// Comparison function for qsort\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_vjnbdjiy/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_vjnbdjiy/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc329_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    int count = 0;\n    int length = 1;\n\n    for (int i = 1; i <= n; i++) {\n        if (s[i] == s[i - 1]) {\n            length++;\n        } else {\n            count += (length * (length + 1)) / 2;\n            length = 1;\n        }\n    }\n\n    count += (length * (length + 1)) / 2;\n\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_db_7f0ol/program.c: In function 'main':\\n/tmp/agnostics_c_db_7f0ol/program.c:25:12: warning: missing terminating \\\" character\\n   25 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_db_7f0ol/program.c:25:12: error: missing terminating \\\" character\\n   25 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_db_7f0ol/program.c:26:1: warning: missing terminating \\\" character\\n   26 | \\\", count);\\n      | ^\\n/tmp/agnostics_c_db_7f0ol/program.c:26:1: error: missing terminating \\\" character\\n   26 | \\\", count);\\n      | ^~~~~~~~~~\\n/tmp/agnostics_c_db_7f0ol/program.c:28:5: error: expected expression before 'return'\\n   28 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_db_7f0ol/program.c:28:14: error: expected ';' before '}' token\\n   28 |     return 0;\\n      |              ^\\n      |              ;\\n   29 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_db_7f0ol/program.c: In function 'main':\n/tmp/agnostics_c_db_7f0ol/program.c:25:12: warning: missing terminating \" character\n   25 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c_db_7f0ol/program.c:25:12: error: missing terminating \" character\n   25 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c_db_7f0ol/program.c:26:1: warning: missing terminating \" character\n   26 | \", count);\n      | ^\n/tmp/agnostics_c_db_7f0ol/program.c:26:1: error: missing terminating \" character\n   26 | \", count);\n      | ^~~~~~~~~~\n/tmp/agnostics_c_db_7f0ol/program.c:28:5: error: expected expression before 'return'\n   28 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_db_7f0ol/program.c:28:14: error: expected ';' before '}' token\n   28 |     return 0;\n      |              ^\n      |              ;\n   29 | }\n      | ~             \n"}
{"question_id": "abc329_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GHashTable *votes = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int max_votes = 0;\n    int current_winner = 0;\n\n    for (int i = 0; i < m; i++) {\n        int candidate;\n        scanf(\"%d\", &candidate);\n\n        // Update vote count for the candidate\n        int *count = (int *)g_hash_table_lookup(votes, GINT_TO_POINTER(candidate));\n        if (count == NULL) {\n            count = (int *)malloc(sizeof(int));\n            *count = 1;\n            g_hash_table_insert(votes, GINT_TO_POINTER(candidate), count);\n        } else {\n            (*count)++;\n        }\n\n        // Check if the current candidate has more votes than the current winner\n        if (*count > max_votes || (*count == max_votes && candidate < current_winner)) {\n            max_votes = *count;\n            current_winner = candidate;\n        }\n\n        // Print the current winner\n        printf(\"%d\n\", current_winner);\n    }\n\n    // Clean up\n    g_hash_table_destroy(votes);\n    for (GHashTableIter iter = {0}; g_hash_table_iter_init(&iter, votes);) {\n        int *count;\n        g_hash_table_iter_next(&iter, NULL, (gpointer *)&count);\n        free(count);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_x261werl/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_x261werl/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc329_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    char s[n + 1], t[m + 1];\n    scanf(\"%s\", s);\n    scanf(\"%s\", t);\n\n    GHashTable *count = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Count characters in T\n    for (int i = 0; i < m; i++) {\n        char ch = t[i];\n        int *val = (int *)g_hash_table_lookup(count, &ch);\n        if (val) {\n            *val += 1;\n        } else {\n            g_hash_table_insert(count, &ch, GINT_TO_POINTER(1));\n        }\n    }\n\n    // Count characters in S that are not part of the replacement\n    int unmatched = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] != '#') {\n            char ch = s[i];\n            int *val = (int *)g_hash_table_lookup(count, &ch);\n            if (val) {\n                *val -= 1;\n                if (*val == 0) {\n                    g_hash_table_remove(count, &ch);\n                }\n            } else {\n                unmatched++;\n            }\n        }\n    }\n\n    // If there are unmatched characters, it is not possible to transform X into S\n    if (unmatched > 0) {\n        printf(\"No\n\");\n    } else {\n        printf(\"Yes\n\");\n    }\n\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_nyj6azfq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_nyj6azfq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc329_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize a GArray to store the colors of balls in each box\n    GArray *boxes[N + 1];\n    for (int i = 1; i <= N; i++) {\n        boxes[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read initial colors of balls in each box\n    int colors[N + 1];\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &colors[i]);\n        g_array_append_val(boxes[i], colors[i]);\n    }\n\n    // Process each query\n    for (int i = 0; i < Q; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n\n        // Move all balls from box a to box b\n        for (int j = 0; j < boxes[a]->len; j++) {\n            int color = g_array_index(boxes[a], int, j);\n            g_array_append_val(boxes[b], color);\n        }\n        g_array_free(boxes[a], TRUE);\n        boxes[a] = g_array_new(FALSE, FALSE, sizeof(int));\n\n        // Print the number of different colors in box b\n        GHashTable *color_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (int j = 0; j < boxes[b]->len; j++) {\n            int color = g_array_index(boxes[b], int, j);\n            g_hash_table_insert(color_count, GINT_TO_POINTER(color), GINT_TO_POINTER(1));\n        }\n        int unique_colors = g_hash_table_size(color_count);\n        printf(\"%d\n\", unique_colors);\n\n        // Clean up\n        g_hash_table_destroy(color_count);\n    }\n\n    // Clean up for boxes\n    for (int i = 1; i <= N; i++) {\n        g_array_free(boxes[i], TRUE);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_6e7gp46m/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_6e7gp46m/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc330_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n, l;\n    scanf(\"%d %d\", &n, &l);\n\n    // Read scores into a GArray\n    GArray *scores = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int score;\n        scanf(\"%d\", &score);\n        g_array_append_val(scores, score);\n    }\n\n    // Initialize a counter for passed students\n    int passed = 0;\n\n    // Iterate through scores and count those that pass\n    for (int i = 0; i < scores->len; i++) {\n        int score = g_array_index(scores, int, i);\n        if (score >= l) {\n            passed++;\n        }\n    }\n\n    // Output the number of passed students\n    printf(\"%d\n\", passed);\n\n    // Clean up\n    g_array_free(scores, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_wneh0aac/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_wneh0aac/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc330_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, l, r;\n    scanf(\"%d %d %d\", &n, &l, &r);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int *range = (int *)malloc((r - l + 1) * sizeof(int));\n    for (int i = 0; i < r - l + 1; i++) {\n        range[i] = l + i;\n    }\n\n    qsort(range, r - l + 1, sizeof(int), compare);\n\n    for (int i = 0; i < n; i++) {\n        int *pos = (int *)bsearch(&a[i], range, r - l + 1, sizeof(int), compare);\n        if (pos == NULL) {\n            printf(\"Error: bsearch failed\n\");\n            return 1;\n        }\n        int index = pos - range;\n        int median = range[index];\n        printf(\"%d \", median);\n    }\n\n    free(a);\n    free(range);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_3or2e7_4/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_3or2e7_4/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc330_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    long long D;\n    scanf(\"%lld\", &D);\n\n    // Initialize variables\n    long long min_diff = D;\n    long long x = 0;\n\n    // Iterate through possible values of x\n    while (x * x <= D) {\n        long long target = D - x * x;\n        long long y = (long long)sqrt(target);\n\n        // Calculate the difference\n        long long diff = abs(x * x + y * y - D);\n        if (diff < min_diff) {\n            min_diff = diff;\n        }\n\n        // Move to the next x\n        x++;\n    }\n\n    // Output the result\n    printf(\"%lld\\n\", min_diff);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_lxl1qcbb/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_lxl1qcbb/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc330_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    char **grid = (char **)malloc(N * sizeof(char *));\n    for (int i = 0; i < N; i++) {\n        grid[i] = (char *)malloc(N * sizeof(char));\n        scanf(\" %s\", grid[i]);\n    }\n\n    int count = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 'o') {\n                for (int k = 0; k < N; k++) {\n                    if (k != i && grid[k][j] == 'o') {\n                        for (int l = 0; l < N; l++) {\n                            if (l != i && l != k && grid[i][l] == 'o' && grid[k][l] == 'o') {\n                                count++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    for (int i = 0; i < N; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_iqet9v3m/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_iqet9v3m/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc330_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize the array and hash table\n    int *A = (int *)malloc(N * sizeof(int));\n    GHashTable *hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the initial sequence\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n        g_hash_table_insert(hash, GINT_TO_POINTER(A[i]), GINT_TO_POINTER(1));\n    }\n\n    // Process each query\n    for (int q = 0; q < Q; q++) {\n        int i, x;\n        scanf(\"%d %d\", &i, &x);\n\n        // Update the sequence\n        if (g_hash_table_contains(hash, GINT_TO_POINTER(A[i - 1]))) {\n            g_hash_table_remove(hash, GINT_TO_POINTER(A[i - 1]));\n        }\n        A[i - 1] = x;\n        g_hash_table_insert(hash, GINT_TO_POINTER(A[i - 1]), GINT_TO_POINTER(1));\n\n        // Find and print the mex\n        int mex = 0;\n        while (g_hash_table_contains(hash, GINT_TO_POINTER(mex))) {\n            mex++;\n        }\n        printf(\"%d\\n\", mex);\n    }\n\n    // Clean up\n    free(A);\n    g_hash_table_destroy(hash);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_074pldvb/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_074pldvb/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc331_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int M, D, y, m, d;\n    scanf(\"%d %d\", &M, &D);\n    scanf(\"%d %d %d\", &y, &m, &d);\n\n    // Determine the next day\n    if (d == D) {\n        m++;\n        d = 1;\n        if (m > M) {\n            y++;\n            m = 1;\n        }\n    } else {\n        d++;\n    }\n\n    // Output the result\n    printf(\"%d %d %d\n\", y, m, d);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_s30ie5tq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_s30ie5tq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc331_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, S, M, L;\n    scanf(\"%d %d %d %d\", &N, &S, &M, &L);\n\n    int min_cost = INT_MAX;\n\n    // Iterate through possible numbers of 12-egg packs\n    for (int x = 0; x * 12 <= N; x++) {\n        // Iterate through possible numbers of 8-egg packs\n        for (int y = 0; x * 12 + y * 8 <= N; y++) {\n            // Calculate the remaining eggs needed after buying x 12-egg and y 8-egg packs\n            int remaining = N - (x * 12 + y * 8);\n            // Calculate the number of 6-egg packs needed for the remaining eggs\n            int z = remaining / 6;\n            // Calculate the total cost for this combination\n            int cost = x * L + y * M + z * S;\n            // Update the minimum cost if the current cost is lower\n            if (cost < min_cost) {\n                min_cost = cost;\n            }\n        }\n    }\n\n    // Print the minimum cost\n    printf(\"%d\\n\", min_cost);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tdnca96n/program.c: In function 'main':\\n/tmp/agnostics_c_tdnca96n/program.c:8:20: error: 'INT_MAX' undeclared (first use in this function)\\n    8 |     int min_cost = INT_MAX;\\n      |                    ^~~~~~~\\n/tmp/agnostics_c_tdnca96n/program.c:3:1: note: 'INT_MAX' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\\n    2 | #include <stdlib.h>\\n  +++ |+#include <limits.h>\\n    3 | \\n/tmp/agnostics_c_tdnca96n/program.c:8:20: note: each undeclared identifier is reported only once for each function it appears in\\n    8 |     int min_cost = INT_MAX;\\n      |                    ^~~~~~~\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_tdnca96n/program.c: In function 'main':\n/tmp/agnostics_c_tdnca96n/program.c:8:20: error: 'INT_MAX' undeclared (first use in this function)\n    8 |     int min_cost = INT_MAX;\n      |                    ^~~~~~~\n/tmp/agnostics_c_tdnca96n/program.c:3:1: note: 'INT_MAX' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\n    2 | #include <stdlib.h>\n  +++ |+#include <limits.h>\n    3 | \n/tmp/agnostics_c_tdnca96n/program.c:8:20: note: each undeclared identifier is reported only once for each function it appears in\n    8 |     int min_cost = INT_MAX;\n      |                    ^~~~~~~\n"}
{"question_id": "abc331_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Read the array elements\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    // Initialize result array\n    GArray *result = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Process each element in the array\n    for (int i = 0; i < n; i++) {\n        int current = g_array_index(arr, int, i);\n        int sum = 0;\n\n        // Calculate the sum of elements greater than current element\n        for (int j = 0; j < n; j++) {\n            if (j != i && g_array_index(arr, int, j) > current) {\n                sum += g_array_index(arr, int, j);\n            }\n        }\n\n        // Append the result to the result array\n        g_array_append_val(result, sum);\n    }\n\n    // Print the result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", g_array_index(result, int, i));\n        if (i < n - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_array_free(arr, TRUE);\n    g_array_free(result, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_swpkm0tp/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_swpkm0tp/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc331_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 1000\n#define MAXQ 200000\n\ntypedef struct {\n    int blackCount;\n} GridCell;\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Read the grid pattern\n    char pattern[N][N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", pattern[i]);\n    }\n\n    // Initialize prefix sum grid\n    GridCell prefixSum[MAXN][MAXN] = {0};\n\n    // Fill the prefix sum grid\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            int color = (pattern[i][j] == 'B') ? 1 : 0;\n            prefixSum[i][j].blackCount = color;\n            if (i > 0) prefixSum[i][j].blackCount += prefixSum[i - 1][j].blackCount;\n            if (j > 0) prefixSum[i][j].blackCount += prefixSum[i][j - 1].blackCount;\n            if (i > 0 && j > 0) prefixSum[i][j].blackCount -= prefixSum[i - 1][j - 1].blackCount;\n        }\n    }\n\n    // Process each query\n    for (int q = 0; q < Q; q++) {\n        int A, B, C, D;\n        scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n\n        // Adjust coordinates to be 0-based\n        A--; B--; C--; D--;\n\n        // Calculate the number of black squares in the query area\n        int blackCount = prefixSum[C][D].blackCount;\n        if (B > 0) blackCount -= prefixSum[C][B - 1].blackCount;\n        if (A > 0) blackCount -= prefixSum[A - 1][D].blackCount;\n        if (A > 0 && B > 0) blackCount += prefixSum[A - 1][B - 1].blackCount;\n\n        printf(\"%d\\n\", blackCount);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0wfaskw6/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0wfaskw6/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc331_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m, l;\n    scanf(\"%d %d %d\", &n, &m, &l);\n\n    GArray *main_dishes = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *side_dishes = g_array_new(FALSE, FALSE, sizeof(int));\n    GHashTable *unavailable_pairs = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        g_array_append_val(main_dishes, a);\n    }\n\n    for (int i = 0; i < m; i++) {\n        int b;\n        scanf(\"%d\", &b);\n        g_array_append_val(side_dishes, b);\n    }\n\n    for (int i = 0; i < l; i++) {\n        int c, d;\n        scanf(\"%d %d\", &c, &d);\n        g_hash_table_insert(unavailable_pairs, GINT_TO_POINTER(c), GINT_TO_POINTER(d));\n    }\n\n    int max_price = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int price = g_array_index(main_dishes, int, i) + g_array_index(side_dishes, int, j);\n            if (!g_hash_table_lookup(unavailable_pairs, GINT_TO_POINTER(i + 1)) || !g_hash_table_lookup(unavailable_pairs, GINT_TO_POINTER(j + 1))) {\n                max_price = (price > max_price) ? price : max_price;\n            }\n        }\n    }\n\n    printf(\"%d\n\", max_price);\n\n    g_array_free(main_dishes, TRUE);\n    g_array_free(side_dishes, TRUE);\n    g_hash_table_destroy(unavailable_pairs);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_dvo0x7le/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_dvo0x7le/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc332_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, S, K;\n    scanf(\"%d %d %d\", &N, &S, &K);\n\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < N; i++) {\n        int P, Q;\n        scanf(\"%d %d\", &P, &Q);\n\n        int total_cost = P * Q;\n        g_hash_table_insert(map, GINT_TO_POINTER(P), GINT_TO_POINTER(total_cost));\n    }\n\n    int total_price = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, map);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        total_price += GPOINTER_TO_INT(value);\n    }\n\n    int shipping_fee = (total_price >= S) ? 0 : K;\n    int total_amount = total_price + shipping_fee;\n\n    printf(\"%d\n\", total_amount);\n\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_cq333tni/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_cq333tni/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc332_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int K, G, M;\n    scanf(\"%d %d %d\", &K, &G, &M);\n\n    // Initialize the glass and mug\n    int glass = 0;\n    int mug = 0;\n\n    // Perform the operations K times\n    for (int i = 0; i < K; i++) {\n        if (glass == G) {\n            // Discard all the water from the glass\n            glass = 0;\n        } else if (mug == 0) {\n            // Fill the mug with water\n            mug = M;\n        } else {\n            // Transfer water from the mug to the glass until the mug is empty or the glass is filled with water\n            while (mug > 0 && glass < G) {\n                glass++;\n                mug--;\n            }\n        }\n    }\n\n    // Output the amounts of water in the glass and the mug\n    printf(\"%d %d\n\", glass, mug);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_r3uajvjk/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_r3uajvjk/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc332_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    char schedule[n + 1];\n    scanf(\"%s\", schedule);\n\n    GHashTable *plain_tshirts = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *logo_tshirts = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int plain_count = 0;\n    int logo_count = 0;\n    int min_logo_needed = 0;\n\n    for (int i = 0; i < n; i++) {\n        char day = schedule[i];\n\n        if (day == '0') {\n            if (plain_count > 0) {\n                plain_count--;\n            } else {\n                logo_count--;\n            }\n        } else if (day == '1') {\n            if (plain_count > 0) {\n                plain_count--;\n            } else {\n                logo_count--;\n            }\n            logo_count++;\n        } else if (day == '2') {\n            logo_count++;\n        }\n\n        if (logo_count < 0) {\n            logo_count = 0;\n        }\n\n        if (day == '1' || day == '2') {\n            min_logo_needed = (logo_count > min_logo_needed) ? logo_count : min_logo_needed;\n        }\n    }\n\n    printf(\"%d\n\", min_logo_needed);\n\n    g_hash_table_destroy(plain_tshirts);\n    g_hash_table_destroy(logo_tshirts);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_6rbf5qhn/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_6rbf5qhn/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc332_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    // Read grid A\n    int **A = (int **)malloc(H * sizeof(int *));\n    for (int i = 0; i < H; i++) {\n        A[i] = (int *)malloc(W * sizeof(int));\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n\n    // Read grid B\n    int **B = (int **)malloc(H * sizeof(int *));\n    for (int i = 0; i < H; i++) {\n        B[i] = (int *)malloc(W * sizeof(int));\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &B[i][j]);\n        }\n    }\n\n    // Check if it is possible to make A identical to B\n    int operations = 0;\n    for (int i = 0; i < H; i++) {\n        int *rowA = A[i];\n        int *rowB = B[i];\n        for (int j = 0; j < W; j++) {\n            if (rowA[j] != rowB[j]) {\n                operations++;\n            }\n        }\n    }\n\n    for (int j = 0; j < W; j++) {\n        int *colA = (int *)malloc(H * sizeof(int));\n        int *colB = (int *)malloc(H * sizeof(int));\n        for (int i = 0; i < H; i++) {\n            colA[i] = A[i][j];\n            colB[i] = B[i][j];\n        }\n        for (int i = 0; i < H; i++) {\n            if (colA[i] != colB[i]) {\n                operations++;\n            }\n        }\n        free(colA);\n        free(colB);\n    }\n\n    // Output the result\n    if (operations == 0) {\n        printf(\"0\n\");\n    } else {\n        printf(\"%d\n\", operations);\n    }\n\n    // Free allocated memory\n    for (int i = 0; i < H; i++) {\n        free(A[i]);\n        free(B[i]);\n    }\n    free(A);\n    free(B);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_nraf0lge/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_nraf0lge/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc333_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize a buffer to store the result string\n    char result[10];\n    result[0] = '\n';\n\n    // Loop to concatenate N copies of the digit N\n    for (int i = 0; i < n; i++) {\n        char digit = '0' + n;\n        strcat(result, &digit);\n    }\n\n    // Print the result\n    printf(\"%s\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_e2atp6t_/program.c: In function 'main':\\n/tmp/agnostics_c_e2atp6t_/program.c:11:17: warning: missing terminating ' character\\n   11 |     result[0] = '\\n      |                 ^\\n/tmp/agnostics_c_e2atp6t_/program.c:11:17: error: missing terminating ' character\\n/tmp/agnostics_c_e2atp6t_/program.c:12:1: warning: missing terminating ' character\\n   12 | ';\\n      | ^\\n/tmp/agnostics_c_e2atp6t_/program.c:12:1: error: missing terminating ' character\\n   12 | ';\\n      | ^~\\n/tmp/agnostics_c_e2atp6t_/program.c:15:5: error: expected expression before 'for'\\n   15 |     for (int i = 0; i < n; i++) {\\n      |     ^~~\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_e2atp6t_/program.c: In function 'main':\n/tmp/agnostics_c_e2atp6t_/program.c:11:17: warning: missing terminating ' character\n   11 |     result[0] = '\n      |                 ^\n/tmp/agnostics_c_e2atp6t_/program.c:11:17: error: missing terminating ' character\n/tmp/agnostics_c_e2atp6t_/program.c:12:1: warning: missing terminating ' character\n   12 | ';\n      | ^\n/tmp/agnostics_c_e2atp6t_/program.c:12:1: error: missing terminating ' character\n   12 | ';\n      | ^~\n/tmp/agnostics_c_e2atp6t_/program.c:15:5: error: expected expression before 'for'\n   15 |     for (int i = 0; i < n; i++) {\n      |     ^~~\n"}
{"question_id": "abc333_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S1, S2, T1, T2;\n    scanf(\"%c%c%c%c\", &S1, &S2, &T1, &T2);\n\n    // Define a mapping for the lengths of segments in a regular pentagon\n    GHashTable *lengths = g_hash_table_new(g_str_hash, g_str_equal);\n    g_hash_table_insert(lengths, \"AB\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"BC\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"CD\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"DE\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"EA\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"AC\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"BD\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"CE\", GINT_TO_POINTER(1));\n    g_hash_table_insert(lengths, \"AD\", GINT_TO_POINTER(1));\n\n    // Check if the lengths of the segments are equal\n    int len1 = GPOINTER_TO_INT(g_hash_table_lookup(lengths, g_strconcat(S1, S2, NULL)));\n    int len2 = GPOINTER_TO_INT(g_hash_table_lookup(lengths, g_strconcat(T1, T2, NULL)));\n\n    // Output the result\n    if (len1 == len2) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(lengths);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_9x3dgfjz/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_9x3dgfjz/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc333_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to generate repunits\nGArray* generate_repunits(int max_length) {\n    GArray *repunits = g_array_new(FALSE, FALSE, sizeof(char*));\n    char *repunit = (char*)malloc(1000 * sizeof(char));\n    repunit[0] = '1';\n    repunit[1] = '\\0';\n    g_array_append_val(repunits, repunit);\n\n    for (int i = 1; i < max_length; i++) {\n        int len = strlen(repunit);\n        for (int j = 0; j < len; j++) {\n            repunit[j] = repunit[j] == '9' ? '0' : repunit[j] + 1;\n        }\n        if (repunit[len - 1] == '0') {\n            repunit[len - 1] = '1';\n            repunit[len] = '1';\n            repunit[len + 1] = '\\0';\n        }\n        g_array_append_val(repunits, repunit);\n    }\n\n    return repunits;\n}\n\n// Function to find the N-th smallest integer that can be expressed as the sum of exactly three repunits\nint find_nth_repunit_sum(int n) {\n    int max_length = 1000; // Maximum length of repunit to consider\n    GArray *repunits = generate_repunits(max_length);\n    GHashTable *sum_counts = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < repunits->len; i++) {\n        for (int j = 0; j < repunits->len; j++) {\n            for (int k = 0; k < repunits->len; k++) {\n                char *repunit1 = g_array_index(repunits, char*, i);\n                char *repunit2 = g_array_index(repunits, char*, j);\n                char *repunit3 = g_array_index(repunits, char*, k);\n\n                int sum = atoi(repunit1) + atoi(repunit2) + atoi(repunit3);\n                int count = GPOINTER_TO_INT(g_hash_table_lookup(sum_counts, GINT_TO_POINTER(sum))) + 1;\n                g_hash_table_insert(sum_counts, GINT_TO_POINTER(sum), GINT_TO_POINTER(count));\n            }\n        }\n    }\n\n    int result = 0;\n    int count = 0;\n\n    for (int sum = 3; sum < INT_MAX; sum++) {\n        int sum_count = GPOINTER_TO_INT(g_hash_table_lookup(sum_counts, GINT_TO_POINTER(sum)));\n        if (sum_count > 0) {\n            count += sum_count;\n            if (count >= n) {\n                result = sum;\n                break;\n            }\n        }\n    }\n\n    g_array_free(repunits, TRUE);\n    g_hash_table_destroy(sum_counts);\n\n    return result;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int result = find_nth_repunit_sum(n);\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_eexl5wkh/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_eexl5wkh/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc333_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create an adjacency list to represent the tree\n    GArray **adj = g_new(GArray *, n + 1);\n    for (int i = 0; i <= n; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read the edges and build the adjacency list\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        g_array_append_val(adj[u], v);\n        g_array_append_val(adj[v], u);\n    }\n\n    // Initialize a queue for BFS\n    GQueue *queue = g_queue_new();\n\n    // Initialize a visited array to keep track of visited nodes\n    bool *visited = g_new(bool, n + 1);\n    for (int i = 0; i <= n; i++) {\n        visited[i] = false;\n    }\n\n    // Initialize the degree array to store the degree of each node\n    int *degree = g_new(int, n + 1);\n    for (int i = 0; i <= n; i++) {\n        degree[i] = 0;\n    }\n\n    // Calculate the degree of each node\n    for (int i = 1; i <= n; i++) {\n        degree[i] = g_array_get_length(adj[i]);\n    }\n\n    // Add all leaf nodes (nodes with degree 1) to the queue\n    for (int i = 1; i <= n; i++) {\n        if (degree[i] == 1) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(i));\n            visited[i] = true;\n        }\n    }\n\n    int operations = 0;\n\n    // Perform BFS to delete leaf nodes\n    while (!g_queue_is_empty(queue)) {\n        operations++;\n        int size = g_queue_get_length(queue);\n\n        for (int i = 0; i < size; i++) {\n            int u = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n            for (int j = 0; j < g_array_get_length(adj[u]); j++) {\n                int v = g_array_index(adj[u], int, j);\n\n                // Decrease the degree of the neighbor\n                degree[v]--;\n\n                // If the neighbor becomes a leaf, add it to the queue\n                if (degree[v] == 1) {\n                    g_queue_push_tail(queue, GINT_TO_POINTER(v));\n                    visited[v] = true;\n                }\n            }\n\n            // Remove the node from the adjacency list\n            g_array_remove_index(adj[u], 0);\n        }\n    }\n\n    // Clean up\n    for (int i = 0; i <= n; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n    g_free(adj);\n    g_queue_free(queue);\n    g_free(visited);\n    g_free(degree);\n\n    // Print the result\n    printf(\"%d\n\", operations);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_1pzt4rqt/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_1pzt4rqt/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc333_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GHashTable *potions = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int K_min = 0;\n    int *actions = (int *)malloc(N * sizeof(int));\n    int action_index = 0;\n\n    for (int i = 0; i < N; i++) {\n        int t, x;\n        scanf(\"%d %d\", &t, &x);\n\n        if (t == 1) {\n            // Pick up the potion\n            actions[action_index++] = 1;\n            int *count = (int *)g_hash_table_lookup(potions, GINT_TO_POINTER(x));\n            if (count == NULL) {\n                count = (int *)malloc(sizeof(int));\n                *count = 1;\n                g_hash_table_insert(potions, GINT_TO_POINTER(x), count);\n            } else {\n                (*count)++;\n            }\n            K_min = g_max(K_min, *count);\n        } else {\n            // Encounter a monster\n            int *count = (int *)g_hash_table_lookup(potions, GINT_TO_POINTER(x));\n            if (count == NULL || *count == 0) {\n                printf(\"-1\n\");\n                for (int j = 0; j < action_index; j++) {\n                    free(actions);\n                }\n                g_hash_table_destroy(potions);\n                return 0;\n            } else {\n                actions[action_index++] = 0;\n                (*count)--;\n            }\n        }\n    }\n\n    printf(\"%d\n\", K_min);\n    for (int i = 0; i < action_index; i++) {\n        printf(\"%d \", actions[i]);\n    }\n    printf(\"\\n\");\n\n    for (int j = 0; j < action_index; j++) {\n        free(actions);\n    }\n    g_hash_table_destroy(potions);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_wlkzic3j/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_wlkzic3j/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc334_a", "solution": "#include <stdio.h>\n\nint main() {\n    int B, G;\n    scanf(\"%d %d\", &B, &G);\n\n    if (B > G) {\n        printf(\"Bat\n\");\n    } else {\n        printf(\"Glove\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_pv6ye8qj/program.c: In function 'main':\\n/tmp/agnostics_c_pv6ye8qj/program.c:8:16: warning: missing terminating \\\" character\\n    8 |         printf(\\\"Bat\\n      |                ^\\n/tmp/agnostics_c_pv6ye8qj/program.c:8:16: error: missing terminating \\\" character\\n    8 |         printf(\\\"Bat\\n      |                ^~~~\\n/tmp/agnostics_c_pv6ye8qj/program.c:9:1: warning: missing terminating \\\" character\\n    9 | \\\");\\n      | ^\\n/tmp/agnostics_c_pv6ye8qj/program.c:9:1: error: missing terminating \\\" character\\n    9 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_pv6ye8qj/program.c:10:5: error: expected expression before '}' token\\n   10 |     } else {\\n      |     ^\\n/tmp/agnostics_c_pv6ye8qj/program.c:8:16: error: expected ';' before '}' token\\n    8 |         printf(\\\"Bat\\n      |                ^\\n      |                ;\\n    9 | \\\");\\n   10 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_pv6ye8qj/program.c:11:16: warning: missing terminating \\\" character\\n   11 |         printf(\\\"Glove\\n      |                ^\\n/tmp/agnostics_c_pv6ye8qj/program.c:11:16: error: missing terminating \\\" character\\n   11 |         printf(\\\"Glove\\n      |                ^~~~~~\\n/tmp/agnostics_c_pv6ye8qj/program.c:12:1: warning: missing terminating \\\" character\\n   12 | \\\");\\n      | ^\\n/tmp/agnostics_c_pv6ye8qj/program.c:12:1: error: missing terminating \\\" character\\n   12 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_pv6ye8qj/program.c:13:5: error: expected expression before '}' token\\n   13 |     }\\n      |     ^\\n/tmp/agnostics_c_pv6ye8qj/program.c:11:16: error: expected ';' before '}' token\\n   11 |         printf(\\\"Glove\\n      |                ^\\n      |                ;\\n   12 | \\\");\\n   13 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_pv6ye8qj/program.c: In function 'main':\n/tmp/agnostics_c_pv6ye8qj/program.c:8:16: warning: missing terminating \" character\n    8 |         printf(\"Bat\n      |                ^\n/tmp/agnostics_c_pv6ye8qj/program.c:8:16: error: missing terminating \" character\n    8 |         printf(\"Bat\n      |                ^~~~\n/tmp/agnostics_c_pv6ye8qj/program.c:9:1: warning: missing terminating \" character\n    9 | \");\n      | ^\n/tmp/agnostics_c_pv6ye8qj/program.c:9:1: error: missing terminating \" character\n    9 | \");\n      | ^~~\n/tmp/agnostics_c_pv6ye8qj/program.c:10:5: error: expected expression before '}' token\n   10 |     } else {\n      |     ^\n/tmp/agnostics_c_pv6ye8qj/program.c:8:16: error: expected ';' before '}' token\n    8 |         printf(\"Bat\n      |                ^\n      |                ;\n    9 | \");\n   10 |     } else {\n      |     ~           \n/tmp/agnostics_c_pv6ye8qj/program.c:11:16: warning: missing terminating \" character\n   11 |         printf(\"Glove\n      |                ^\n/tmp/agnostics_c_pv6ye8qj/program.c:11:16: error: missing terminating \" character\n   11 |         printf(\"Glove\n      |                ^~~~~~\n/tmp/agnostics_c_pv6ye8qj/program.c:12:1: warning: missing terminating \" character\n   12 | \");\n      | ^\n/tmp/agnostics_c_pv6ye8qj/program.c:12:1: error: missing terminating \" character\n   12 | \");\n      | ^~~\n/tmp/agnostics_c_pv6ye8qj/program.c:13:5: error: expected expression before '}' token\n   13 |     }\n      |     ^\n/tmp/agnostics_c_pv6ye8qj/program.c:11:16: error: expected ';' before '}' token\n   11 |         printf(\"Glove\n      |                ^\n      |                ;\n   12 | \");\n   13 |     }\n      |     ~           \n"}
{"question_id": "abc334_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int A, M, L, R;\n    scanf(\"%d %d %d %d\", &A, &M, &L, &R);\n\n    // Calculate the number of Christmas trees\n    int count = 0;\n    for (int x = A; x <= R; x += M) {\n        if (x >= L) {\n            count++;\n        }\n    }\n\n    // Output result\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_6k47q1v3/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_6k47q1v3/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc334_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    int *socks = (int *)malloc((2 * N - K) * sizeof(int));\n    int *colors = (int *)malloc(K * sizeof(int));\n\n    for (int i = 0; i < K; i++) {\n        scanf(\"%d\", &colors[i]);\n    }\n\n    int index = 0;\n    for (int i = 1; i <= N; i++) {\n        if (i != colors[index]) {\n            socks[index] = i;\n            index++;\n        }\n    }\n\n    qsort(socks, 2 * N - K, sizeof(int), compare);\n\n    int total_weirdness = 0;\n    for (int i = 0; i < 2 * N - K; i += 2) {\n        total_weirdness += abs(socks[i] - socks[i + 1]);\n    }\n\n    printf(\"%d\\n\", total_weirdness);\n\n    free(socks);\n    free(colors);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_a649id3z/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_a649id3z/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc334_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    int *R = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &R[i]);\n    }\n\n    g_array_sort(G_ARRAY_FROM_POINTER(R, int, N), compare);\n\n    for (int q = 0; q < Q; q++) {\n        int X;\n        scanf(\"%d\", &X);\n\n        int count = 0;\n        for (int i = 0; i < N; i++) {\n            if (X >= R[i]) {\n                X -= R[i];\n                count++;\n            } else {\n                break;\n            }\n        }\n\n        printf(\"%d\\n\", count);\n    }\n\n    free(R);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_m2t1opel/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_m2t1opel/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc334_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint H, W;\nchar grid[1001][1001];\nGHashTable *dp[1001][1001];\n\nint dfs(int x, int y) {\n    if (x < 0 || x >= H || y < 0 || y >= W || grid[x][y] == '.')\n        return 0;\n    grid[x][y] = 'X';\n    return 1 + dfs(x-1, y) + dfs(x+1, y) + dfs(x, y-1) + dfs(x, y+1);\n}\n\nint count_components() {\n    int components = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '#') {\n                components++;\n                dfs(i, j);\n            }\n        }\n    }\n    return components;\n}\n\nint expected_components() {\n    int total_red = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.') {\n                total_red++;\n                grid[i][j] = '#';\n                int components = count_components();\n                grid[i][j] = '.';\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        if (grid[k][l] == '#') {\n                            int new_components = components + dfs(k, l);\n                            int *count = (int *)g_hash_table_lookup(dp[k][l], GINT_TO_POINTER(components));\n                            if (count == NULL) {\n                                count = (int *)malloc(sizeof(int));\n                                *count = 0;\n                                g_hash_table_insert(dp[k][l], GINT_TO_POINTER(components), count);\n                            }\n                            (*count)++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int total_components = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '#') {\n                int *count = (int *)g_hash_table_lookup(dp[i][j], GINT_TO_POINTER(count_components()));\n                if (count != NULL) {\n                    total_components += (*count);\n                }\n            }\n        }\n    }\n    return (total_components + total_red - 1) / total_red;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            dp[i][j] = g_hash_table_new(g_direct_hash, g_direct_equal);\n        }\n    }\n    int result = expected_components();\n    printf(\"%d\\n\", result);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            g_hash_table_destroy(dp[i][j]);\n        }\n    }\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_t4cvztj5/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_t4cvztj5/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc335_a", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[101];\n    scanf(\"%s\", S);\n    int len = strlen(S);\n    if (len >= 4 && S[len - 1] == '3') {\n        S[len - 1] = '4';\n    }\n    printf(\"%s\n\", S);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_rsyva6em/program.c: In function 'main':\\n/tmp/agnostics_c_rsyva6em/program.c:11:12: warning: missing terminating \\\" character\\n   11 |     printf(\\\"%s\\n      |            ^\\n/tmp/agnostics_c_rsyva6em/program.c:11:12: error: missing terminating \\\" character\\n   11 |     printf(\\\"%s\\n      |            ^~~\\n/tmp/agnostics_c_rsyva6em/program.c:12:1: warning: missing terminating \\\" character\\n   12 | \\\", S);\\n      | ^\\n/tmp/agnostics_c_rsyva6em/program.c:12:1: error: missing terminating \\\" character\\n   12 | \\\", S);\\n      | ^~~~~~\\n/tmp/agnostics_c_rsyva6em/program.c:13:5: error: expected expression before 'return'\\n   13 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_rsyva6em/program.c:13:14: error: expected ';' before '}' token\\n   13 |     return 0;\\n      |              ^\\n      |              ;\\n   14 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_rsyva6em/program.c: In function 'main':\n/tmp/agnostics_c_rsyva6em/program.c:11:12: warning: missing terminating \" character\n   11 |     printf(\"%s\n      |            ^\n/tmp/agnostics_c_rsyva6em/program.c:11:12: error: missing terminating \" character\n   11 |     printf(\"%s\n      |            ^~~\n/tmp/agnostics_c_rsyva6em/program.c:12:1: warning: missing terminating \" character\n   12 | \", S);\n      | ^\n/tmp/agnostics_c_rsyva6em/program.c:12:1: error: missing terminating \" character\n   12 | \", S);\n      | ^~~~~~\n/tmp/agnostics_c_rsyva6em/program.c:13:5: error: expected expression before 'return'\n   13 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_rsyva6em/program.c:13:14: error: expected ';' before '}' token\n   13 |     return 0;\n      |              ^\n      |              ;\n   14 | }\n      | ~             \n"}
{"question_id": "abc335_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Use a hash table to keep track of printed triples\n    GHashTable *printed = g_hash_table_new(g_int_hash, g_int_equal);\n\n    // Iterate through all possible values of x, y, and z\n    for (int x = 0; x <= n; x++) {\n        for (int y = 0; y <= n - x; y++) {\n            int z = n - x - y;\n\n            // Create a key for the hash table\n            int key = (x << 16) | (y << 8) | z;\n\n            // Check if the triple has already been printed\n            if (!g_hash_table_contains(printed, GINT_TO_POINTER(key))) {\n                // Print the triple\n                printf(\"%d %d %d\n\", x, y, z);\n\n                // Insert the key into the hash table\n                g_hash_table_insert(printed, GINT_TO_POINTER(key), GINT_TO_POINTER(1));\n            }\n        }\n    }\n\n    // Free the hash table\n    g_hash_table_destroy(printed);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4f4jvcgk/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_4f4jvcgk/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc335_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 1000000\n#define MAX_Q 200000\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize the dragon's parts\n    GArray *parts = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(parts, i);\n    }\n\n    // Initialize the head's position\n    int head_x = 0, head_y = 0;\n\n    // Process each query\n    for (int i = 0; i < Q; i++) {\n        char query[2];\n        scanf(\"%s\", query);\n\n        if (query[0] == '1') {\n            char direction;\n            scanf(\" %c\", &direction);\n\n            // Move the head\n            switch (direction) {\n                case 'R':\n                    head_x++;\n                    break;\n                case 'L':\n                    head_x--;\n                    break;\n                case 'U':\n                    head_y++;\n                    break;\n                case 'D':\n                    head_y--;\n                    break;\n            }\n\n            // Move the parts\n            for (int j = 1; j < N; j++) {\n                int prev_x = head_x, prev_y = head_y;\n                scanf(\" %c\", &direction);\n\n                switch (direction) {\n                    case 'R':\n                        prev_x++;\n                        break;\n                    case 'L':\n                        prev_x--;\n                        break;\n                    case 'U':\n                        prev_y++;\n                        break;\n                    case 'D':\n                        prev_y--;\n                        break;\n                }\n\n                // Update the part's position\n                g_array_index(parts, int, j) = prev_x * 1000 + prev_y;\n            }\n        } else if (query[0] == '2') {\n            int p;\n            scanf(\" %d\", &p);\n\n            // Find the coordinates of part p\n            int x = g_array_index(parts, int, p - 1) / 1000;\n            int y = g_array_index(parts, int, p - 1) % 1000;\n\n            // Print the coordinates\n            printf(\"%d %d\n\", x, y);\n        }\n    }\n\n    // Free the allocated memory\n    g_array_free(parts, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_fi60e8pw/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_fi60e8pw/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc335_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char grid[N][N];\n    memset(grid, '0', sizeof(grid));\n\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n\n    int x = n / 2, y = n / 2;\n    int dir = 0;\n    int count = 1;\n\n    while (count <= n * n - 1) {\n        grid[x][y] = '0' + count;\n        count++;\n\n        int nx = x + dx[dir % 4];\n        int ny = y + dy[dir % 4];\n\n        if (nx < 0 || nx >= n || ny < 0 || ny >= n || grid[nx][ny] != '0') {\n            dir++;\n            nx = x + dx[dir % 4];\n            ny = y + dy[dir % 4];\n        }\n\n        x = nx;\n        y = ny;\n    }\n\n    grid[n / 2][n / 2] = 'T';\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%c \", grid[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_66ai5uxe/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_66ai5uxe/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc336_a", "solution": "#include <stdio.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Buffer to store the Dragon String\n    char dragonString[2028];\n    int index = 0;\n\n    // Append 'L' to the string\n    dragonString[index++] = 'L';\n\n    // Append N 'o's to the string\n    for (int i = 0; i < N; i++) {\n        dragonString[index++] = 'o';\n    }\n\n    // Append 'n' to the string\n    dragonString[index++] = 'n';\n\n    // Append 'g' to the string\n    dragonString[index++] = 'g';\n\n    // Null-terminate the string\n    dragonString[index] = '\\0';\n\n    // Print the Dragon String\n    printf(\"%s\n\", dragonString);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_z5asmxc_/program.c: In function 'main':\\n/tmp/agnostics_c_z5asmxc_/program.c:29:12: warning: missing terminating \\\" character\\n   29 |     printf(\\\"%s\\n      |            ^\\n/tmp/agnostics_c_z5asmxc_/program.c:29:12: error: missing terminating \\\" character\\n   29 |     printf(\\\"%s\\n      |            ^~~\\n/tmp/agnostics_c_z5asmxc_/program.c:30:1: warning: missing terminating \\\" character\\n   30 | \\\", dragonString);\\n      | ^\\n/tmp/agnostics_c_z5asmxc_/program.c:30:1: error: missing terminating \\\" character\\n   30 | \\\", dragonString);\\n      | ^~~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_z5asmxc_/program.c:32:5: error: expected expression before 'return'\\n   32 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_z5asmxc_/program.c:32:14: error: expected ';' before '}' token\\n   32 |     return 0;\\n      |              ^\\n      |              ;\\n   33 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_z5asmxc_/program.c: In function 'main':\n/tmp/agnostics_c_z5asmxc_/program.c:29:12: warning: missing terminating \" character\n   29 |     printf(\"%s\n      |            ^\n/tmp/agnostics_c_z5asmxc_/program.c:29:12: error: missing terminating \" character\n   29 |     printf(\"%s\n      |            ^~~\n/tmp/agnostics_c_z5asmxc_/program.c:30:1: warning: missing terminating \" character\n   30 | \", dragonString);\n      | ^\n/tmp/agnostics_c_z5asmxc_/program.c:30:1: error: missing terminating \" character\n   30 | \", dragonString);\n      | ^~~~~~~~~~~~~~~~~\n/tmp/agnostics_c_z5asmxc_/program.c:32:5: error: expected expression before 'return'\n   32 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_z5asmxc_/program.c:32:14: error: expected ';' before '}' token\n   32 |     return 0;\n      |              ^\n      |              ;\n   33 | }\n      | ~             \n"}
{"question_id": "abc336_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N;\n    scanf(\"%d\", &N);\n\n    // Initialize a counter for trailing zeros\n    int ctz = 0;\n\n    // Loop until N becomes 0 or has no trailing zeros\n    while (N > 0 && (N & 1) == 0) {\n        N >>= 1;\n        ctz++;\n    }\n\n    // Output the result\n    printf(\"%d\n\", ctz);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_nnunyddz/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_nnunyddz/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc336_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nvoid generateGoodIntegers(char *result, int N, int index) {\n    if (index == 0) {\n        result[index] = '0';\n        generateGoodIntegers(result, N, index + 1);\n        return;\n    }\n\n    if (N == 1) {\n        result[index] = '0';\n        return;\n    }\n\n    int count = 0;\n    for (int i = 0; i < 5; i++) {\n        if (N - count > 0) {\n            result[index] = '0' + 2 * i;\n            generateGoodIntegers(result, N - count, index + 1);\n            count++;\n        }\n    }\n}\n\nint main() {\n    long long N;\n    scanf(\"%lld\", &N);\n\n    char result[20];\n    result[0] = '\\0';\n\n    generateGoodIntegers(result, N, 0);\n\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_12zrxzus/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_12zrxzus/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc336_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int left = 0, right = n - 1;\n    int max_size = 0;\n\n    while (left <= right) {\n        if (A[left] == A[right]) {\n            max_size += 2;\n            left++;\n            right--;\n        } else if (A[left] < A[right]) {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(A[left] + 1))) {\n                max_size += 2;\n                left++;\n                right--;\n            } else {\n                right--;\n            }\n        } else {\n            if (g_hash_table_lookup(count, GINT_TO_POINTER(A[right] + 1))) {\n                max_size += 2;\n                left++;\n                right--;\n            } else {\n                left++;\n            }\n        }\n    }\n\n    max_size = (max_size + 1) / 2;\n    printf(\"%d\n\", max_size);\n\n    free(A);\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4ep59eb4/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_4ep59eb4/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc337_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int takahashi_total = 0, aoki_total = 0;\n\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        takahashi_total += x;\n        aoki_total += y;\n    }\n\n    if (takahashi_total > aoki_total) {\n        printf(\"Takahashi\\n\");\n    } else if (aoki_total > takahashi_total) {\n        printf(\"Aoki\\n\");\n    } else {\n        printf(\"Draw\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc337_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool isExtendedABC(char *S) {\n    int len = strlen(S);\n    int i = 0;\n\n    // Check for Extended A string at the beginning\n    while (i < len && S[i] == 'A') {\n        i++;\n    }\n\n    // Check for Extended B string next\n    while (i < len && S[i] == 'B') {\n        i++;\n    }\n\n    // Check for Extended C string at the end\n    while (i < len && S[i] == 'C') {\n        i++;\n    }\n\n    // If we have processed the entire string, it is an Extended ABC string\n    return i == len;\n}\n\nint main() {\n    char S[101];\n    scanf(\"%s\", S);\n\n    if (isExtendedABC(S)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc337_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *stack = g_array_new(FALSE, FALSE, sizeof(int));\n    int *result = (int *)malloc(n * sizeof(int));\n\n    for (int i = n - 1; i >= 0; i--) {\n        int person;\n        scanf(\"%d\", &person);\n\n        if (person == -1) {\n            g_array_append_val(stack, i + 1);\n        } else {\n            while (g_array_index(stack, int, 0) != person) {\n                g_array_remove_index(stack, 0);\n            }\n            g_array_append_val(stack, i + 1);\n        }\n    }\n\n    int index = 0;\n    while (g_array_get_length(stack) > 0) {\n        result[index++] = g_array_pop_index(stack, int);\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", result[i]);\n    }\n    printf(\"\\n\");\n\n    free(result);\n    g_array_free(stack, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_r90h1jsp/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_r90h1jsp/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc337_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W, K;\n    scanf(\"%d %d %d\", &H, &W, &K);\n\n    char **grid = (char **)g_malloc(H * sizeof(char *));\n    for (int i = 0; i < H; i++) {\n        grid[i] = (char *)g_malloc(W * sizeof(char));\n        scanf(\"%s\", grid[i]);\n    }\n\n    int result = INT_MAX;\n\n    // Check horizontal sequences\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j <= W - K; j++) {\n            int changes = 0;\n            for (int k = 0; k < K; k++) {\n                if (grid[i][j + k] == \".\") {\n                    changes++;\n                }\n            }\n            if (changes < result) {\n                result = changes;\n            }\n        }\n    }\n\n    // Check vertical sequences\n    for (int j = 0; j < W; j++) {\n        for (int i = 0; i <= H - K; i++) {\n            int changes = 0;\n            for (int k = 0; k < K; k++) {\n                if (grid[i + k][j] == \".\") {\n                    changes++;\n                }\n            }\n            if (changes < result) {\n                result = changes;\n            }\n        }\n    }\n\n    if (result == INT_MAX) {\n        printf(\"-1\n\");\n    } else {\n        printf(\"%d\n\", result);\n    }\n\n    for (int i = 0; i < H; i++) {\n        g_free(grid[i]);\n    }\n    g_free(grid);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_fo_3tbdw/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_fo_3tbdw/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc337_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Binary search approach\n    int left = 1, right = N;\n    int M = 0;\n\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        M++;\n\n        // Serve the first half of the bottles to the current friend\n        printf(\"1 %d\n\", mid);\n\n        char S[100];\n        scanf(\"%s\", S);\n\n        if (S[0] == '1') {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    // The last served bottle is the spoiled one\n    printf(\"1 %d\n\", left);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_7i4t3gwy/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_7i4t3gwy/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc338_a", "solution": "#include <stdio.h>\n#include <ctype.h>\n\nint main() {\n    char S[100];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n\n    // Check if the first character is uppercase\n    if (isupper(S[0])) {\n        // Check if all other characters are lowercase\n        for (int i = 1; i < n; i++) {\n            if (!islower(S[i])) {\n                printf(\"No\");\n                return 0;\n            }\n        }\n        printf(\"Yes\");\n    } else {\n        printf(\"No\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"/tmp/agnostics_c_axzqk32_/program.c: In function 'main':\\n/tmp/agnostics_c_axzqk32_/program.c:8:13: warning: implicit declaration of function 'strlen' [-Wimplicit-function-declaration]\\n    8 |     int n = strlen(S);\\n      |             ^~~~~~\\n/tmp/agnostics_c_axzqk32_/program.c:3:1: note: include '<string.h>' or provide a declaration of 'strlen'\\n    2 | #include <ctype.h>\\n  +++ |+#include <string.h>\\n    3 | \\n/tmp/agnostics_c_axzqk32_/program.c:8:13: warning: incompatible implicit declaration of built-in function 'strlen' [-Wbuiltin-declaration-mismatch]\\n    8 |     int n = strlen(S);\\n      |             ^~~~~~\\n/tmp/agnostics_c_axzqk32_/program.c:8:13: note: include '<string.h>' or provide a declaration of 'strlen'\\n\"}\n", "raw_stderr": "", "result": "success", "stderr": "/tmp/agnostics_c_axzqk32_/program.c: In function 'main':\n/tmp/agnostics_c_axzqk32_/program.c:8:13: warning: implicit declaration of function 'strlen' [-Wimplicit-function-declaration]\n    8 |     int n = strlen(S);\n      |             ^~~~~~\n/tmp/agnostics_c_axzqk32_/program.c:3:1: note: include '<string.h>' or provide a declaration of 'strlen'\n    2 | #include <ctype.h>\n  +++ |+#include <string.h>\n    3 | \n/tmp/agnostics_c_axzqk32_/program.c:8:13: warning: incompatible implicit declaration of built-in function 'strlen' [-Wbuiltin-declaration-mismatch]\n    8 |     int n = strlen(S);\n      |             ^~~~~~\n/tmp/agnostics_c_axzqk32_/program.c:8:13: note: include '<string.h>' or provide a declaration of 'strlen'\n"}
{"question_id": "abc338_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input string\n    char str[1001];\n    scanf(\"%s\", str);\n\n    // Initialize a hash table to store character frequencies\n    GHashTable *freq = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Count the frequency of each character in the string\n    for (int i = 0; str[i] != '\\0'; i++) {\n        char *key = &str[i];\n        int *count = (int *)g_hash_table_lookup(freq, key);\n        if (count) {\n            (*count)++;\n        } else {\n            g_hash_table_insert(freq, key, GINT_TO_POINTER(1));\n        }\n    }\n\n    // Find the character with the highest frequency\n    char most_freq_char = '\\0';\n    int max_count = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, freq);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int count = GPOINTER_TO_INT(value);\n        if (count > max_count || (count == max_count && strcmp(key, &most_freq_char) < 0)) {\n            max_count = count;\n            most_freq_char = *(char *)key;\n        }\n    }\n\n    // Print the character with the highest frequency\n    printf(\"%c\\n\", most_freq_char);\n\n    // Clean up\n    g_hash_table_destroy(freq);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_vl1uxci_/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_vl1uxci_/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc338_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Read ingredient quantities\n    GArray *quantities = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int q;\n        scanf(\"%d\", &q);\n        g_array_append_val(quantities, q);\n    }\n\n    // Read dish A requirements\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        g_array_append_val(A, a);\n    }\n\n    // Read dish B requirements\n    GArray *B = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int b;\n        scanf(\"%d\", &b);\n        g_array_append_val(B, b);\n    }\n\n    // Calculate maximum servings for dish A\n    int max_servings_A = 0;\n    for (int i = 0; i < n; i++) {\n        int q = g_array_index(quantities, int, i);\n        int a = g_array_index(A, int, i);\n        if (a > 0) {\n            max_servings_A += q / a;\n        }\n    }\n\n    // Calculate maximum servings for dish B\n    int max_servings_B = 0;\n    for (int i = 0; i < n; i++) {\n        int q = g_array_index(quantities, int, i);\n        int b = g_array_index(B, int, i);\n        if (b > 0) {\n            max_servings_B += q / b;\n        }\n    }\n\n    // The result is the minimum of the two maximum servings\n    int result = (max_servings_A < max_servings_B) ? max_servings_A : max_servings_B;\n\n    // Output the result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_array_free(quantities, TRUE);\n    g_array_free(A, TRUE);\n    g_array_free(B, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_oq9b9s6n/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_oq9b9s6n/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc338_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *x = (int *)malloc(m * sizeof(int));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &x[i]);\n    }\n\n    GHashTable *bridge_to_cost = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < m - 1; i++) {\n        int cost = abs(x[i] - x[i + 1]);\n        g_hash_table_insert(bridge_to_cost, GINT_TO_POINTER(i), GINT_TO_POINTER(cost));\n    }\n\n    int total_cost = 0;\n    for (int i = 0; i < m - 1; i++) {\n        total_cost += abs(x[i] - x[i + 1]);\n    }\n\n    int min_cost = total_cost;\n\n    for (int i = 0; i < m - 1; i++) {\n        int cost = abs(x[i] - x[i + 1]);\n        int new_cost = total_cost - cost;\n        if (i > 0) {\n            new_cost += abs(x[i - 1] - x[i]);\n        }\n        if (i < m - 2) {\n            new_cost += abs(x[i + 1] - x[i + 2]);\n        }\n        if (new_cost < min_cost) {\n            min_cost = new_cost;\n        }\n    }\n\n    printf(\"%d\n\", min_cost);\n\n    free(x);\n    g_hash_table_destroy(bridge_to_cost);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_qckhj8xe/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_qckhj8xe/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc338_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *points = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < 2 * n; i++) {\n        int point;\n        scanf(\"%d\", &point);\n        g_array_append_val(points, point);\n    }\n\n    qsort(points->data, points->len, sizeof(int), compare);\n\n    for (int i = 0; i < n; i++) {\n        int a1 = g_array_index(points, int, 2 * i);\n        int b1 = g_array_index(points, int, 2 * i + 1);\n        int a2 = g_array_index(points, int, 2 * i + 2);\n        int b2 = g_array_index(points, int, 2 * i + 3);\n\n        if ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) {\n            printf(\"Yes\\n\");\n            g_array_free(points, TRUE);\n            return 0;\n        }\n    }\n\n    printf(\"No\\n\");\n\n    g_array_free(points, TRUE);\n    return 0;\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8a9y2h_6/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_8a9y2h_6/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc338_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 20\n#define MAX_M (MAX_N * (MAX_N - 1))\n#define INF 1e9\n\ntypedef struct {\n    int to, weight;\n} Edge;\n\nGArray *graph[MAX_N];\nint dp[MAX_N][1 << MAX_N];\nint n, m;\n\nint dfs(int node, int visited) {\n    if (visited == (1 << n) - 1) {\n        return 0;\n    }\n    if (dp[node][visited] != -1) {\n        return dp[node][visited];\n    }\n    int min_cost = INF;\n    for (int i = 0; i < graph[node]->len; i++) {\n        Edge *edge = &g_array_index(graph[node], Edge, i);\n        if (!(visited & (1 << (edge->to - 1)))) {\n            int new_cost = dfs(edge->to, visited | (1 << (edge->to - 1))) + edge->weight;\n            if (new_cost < min_cost) {\n                min_cost = new_cost;\n            }\n        }\n    }\n    dp[node][visited] = min_cost;\n    return min_cost;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        graph[i] = g_array_new(FALSE, FALSE, sizeof(Edge));\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        u--; v--;\n        Edge edge = {v, w};\n        g_array_append_val(graph[u], edge);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < (1 << n); j++) {\n            dp[i][j] = -1;\n        }\n    }\n\n    int min_cost = INF;\n    for (int i = 0; i < n; i++) {\n        int cost = dfs(i, 1 << i);\n        if (cost != INF) {\n            min_cost = cost;\n        }\n    }\n\n    if (min_cost == INF) {\n        printf(\"No\n\");\n    } else {\n        printf(\"%d\n\", min_cost);\n    }\n\n    for (int i = 0; i < n; i++) {\n        g_array_free(graph[i], TRUE);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2pej15xj/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2pej15xj/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc339_a", "solution": "#include <stdio.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S[101];\n    scanf(\"%s\", S);\n\n    // Initialize variables\n    int len = strlen(S);\n    int start = len;\n\n    // Find the last occurrence of '..'\n    for (int i = len - 1; i >= 0; i--) {\n        if (S[i] == '.' && i > 0 && S[i - 1] == '.') {\n            start = i + 1;\n            break;\n        }\n    }\n\n    // Print the last substring\n    printf(\"%s\n\", S + start);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__60opv1g/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__60opv1g/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc339_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    char grid[H][W];\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            grid[i][j] = '.';\n        }\n    }\n\n    int x = 0, y = 0, dx = -1, dy = 0;\n    bool isWhite = true;\n\n    for (int i = 0; i < N; i++) {\n        if (grid[x][y] == '.') {\n            grid[x][y] = '#';\n            dx = 0;\n            dy = 1;\n        } else {\n            grid[x][y] = '.';\n            dx = 0;\n            dy = -1;\n        }\n\n        int nx = (x + dx + H) % H;\n        int ny = (y + dy + W) % W;\n        x = nx;\n        y = ny;\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            printf(\"%c\", grid[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_zw0fq0p2/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_zw0fq0p2/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc339_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize the minimum number of passengers to a large positive value\n    long long min_passengers = LLONG_MAX;\n    long long current_passengers = 0;\n\n    // Process each stop\n    for (int i = 0; i < n; i++) {\n        int change;\n        scanf(\"%d\", &change);\n\n        // Update the current number of passengers\n        current_passengers += change;\n\n        // Update the minimum number of passengers encountered\n        if (current_passengers < min_passengers) {\n            min_passengers = current_passengers;\n        }\n    }\n\n    // The minimum possible current number of passengers is the absolute value of the minimum encountered\n    printf(\"%lld\n\", abs(min_passengers));\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tyv0wn25/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_tyv0wn25/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc339_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 60\n\nint minMovesToSameCell(char grid[MAX_N][MAX_N], int N) {\n    int player1[2], player2[2];\n    bool foundPlayer1 = false, foundPlayer2 = false;\n\n    // Find the positions of the two players\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 'P') {\n                if (!foundPlayer1) {\n                    player1[0] = i;\n                    player1[1] = j;\n                    foundPlayer1 = true;\n                } else {\n                    player2[0] = i;\n                    player2[1] = j;\n                    foundPlayer2 = true;\n                }\n            }\n        }\n        if (foundPlayer1 && foundPlayer2) {\n            break;\n        }\n    }\n\n    if (!foundPlayer1 || !foundPlayer2) {\n        return -1; // Players not found\n    }\n\n    // Calculate the Manhattan distance between the two players\n    int distance = abs(player1[0] - player2[0]) + abs(player1[1] - player2[1]);\n\n    // If the distance is even, they can meet in an even number of moves\n    // If the distance is odd, they can meet in an odd number of moves\n    return distance;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    char grid[MAX_N][MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int result = minMovesToSameCell(grid, N);\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_il0wx4fk/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_il0wx4fk/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc340_a", "solution": "#include <stdio.h>\n\nint main() {\n    // Read input\n    int A, B, D;\n    scanf(\"%d %d %d\", &A, &B, &D);\n\n    // Generate and print the arithmetic sequence\n    for (int i = A; i <= B; i += D) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc340_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int Q;\n    scanf(\"%d\", &Q);\n\n    // Initialize a GQueue to store the sequence\n    GQueue *queue = g_queue_new();\n\n    // Process each query\n    for (int i = 0; i < Q; i++) {\n        int query_type, value, k;\n        scanf(\"%d\", &query_type);\n\n        if (query_type == 1) {\n            // Append x to the end of A\n            scanf(\"%d\", &value);\n            g_queue_push_tail(queue, GINT_TO_POINTER(value));\n        } else if (query_type == 2) {\n            // Find the k-th value from the end of A\n            scanf(\"%d\", &k);\n            // Since g_queue_get_nth_from_end is not available, we reverse the queue, get the k-th element, and then reverse it back\n            GQueue *temp_queue = g_queue_new();\n            while (!g_queue_is_empty(queue)) {\n                g_queue_push_tail(temp_queue, g_queue_pop_head(queue));\n            }\n            gpointer kth_value = g_queue_peek_nth(temp_queue, k - 1);\n            printf(\"%d\\n\", GPOINTER_TO_INT(kth_value));\n\n            // Reverse the queue back to its original order\n            while (!g_queue_is_empty(temp_queue)) {\n                g_queue_push_tail(queue, g_queue_pop_head(temp_queue));\n            }\n            g_queue_free(temp_queue);\n        }\n    }\n\n    // Clean up\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_09czu8gw/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_09czu8gw/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc340_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long long N;\n    scanf(\"%lld\", &N);\n\n    // Calculate the total amount paid\n    long long total = (N * (N + 1)) / 2;\n\n    // Subtract the initial number N from the total\n    total -= N;\n\n    // Print the result\n    printf(\"%lld\n\", total);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_mzk844ji/program.c: In function 'main':\\n/tmp/agnostics_c_mzk844ji/program.c:15:12: warning: missing terminating \\\" character\\n   15 |     printf(\\\"%lld\\n      |            ^\\n/tmp/agnostics_c_mzk844ji/program.c:15:12: error: missing terminating \\\" character\\n   15 |     printf(\\\"%lld\\n      |            ^~~~~\\n/tmp/agnostics_c_mzk844ji/program.c:16:1: warning: missing terminating \\\" character\\n   16 | \\\", total);\\n      | ^\\n/tmp/agnostics_c_mzk844ji/program.c:16:1: error: missing terminating \\\" character\\n   16 | \\\", total);\\n      | ^~~~~~~~~~\\n/tmp/agnostics_c_mzk844ji/program.c:18:5: error: expected expression before 'return'\\n   18 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_mzk844ji/program.c:18:14: error: expected ';' before '}' token\\n   18 |     return 0;\\n      |              ^\\n      |              ;\\n   19 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_mzk844ji/program.c: In function 'main':\n/tmp/agnostics_c_mzk844ji/program.c:15:12: warning: missing terminating \" character\n   15 |     printf(\"%lld\n      |            ^\n/tmp/agnostics_c_mzk844ji/program.c:15:12: error: missing terminating \" character\n   15 |     printf(\"%lld\n      |            ^~~~~\n/tmp/agnostics_c_mzk844ji/program.c:16:1: warning: missing terminating \" character\n   16 | \", total);\n      | ^\n/tmp/agnostics_c_mzk844ji/program.c:16:1: error: missing terminating \" character\n   16 | \", total);\n      | ^~~~~~~~~~\n/tmp/agnostics_c_mzk844ji/program.c:18:5: error: expected expression before 'return'\n   18 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_mzk844ji/program.c:18:14: error: expected ';' before '}' token\n   18 |     return 0;\n      |              ^\n      |              ;\n   19 | }\n      | ~             \n"}
{"question_id": "abc340_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint min_time_to_reach_stage(GHashTable *dp, int stage, int *A, int *B, int *X, int N) {\n    if (stage == N) {\n        return 0;\n    }\n    if (g_hash_table_contains(dp, GINT_TO_POINTER(stage))) {\n        return GPOINTER_TO_INT(g_hash_table_lookup(dp, GINT_TO_POINTER(stage)));\n    }\n    int next_stage_time = min_time_to_reach_stage(dp, stage + 1, A, B, X, N) + A[stage];\n    int jump_stage_time = INT_MAX;\n    if (stage + 1 <= N) {\n        jump_stage_time = min_time_to_reach_stage(dp, X[stage], A, B, X, N) + B[stage];\n    }\n    int min_time = min(next_stage_time, jump_stage_time);\n    g_hash_table_insert(dp, GINT_TO_POINTER(stage), GINT_TO_POINTER(min_time));\n    return min_time;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int *A = (int *)malloc(N * sizeof(int));\n    int *B = (int *)malloc(N * sizeof(int));\n    int *X = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N - 1; i++) {\n        scanf(\"%d %d %d\", &A[i], &B[i], &X[i]);\n    }\n    GHashTable *dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int result = min_time_to_reach_stage(dp, 1, A, B, X, N);\n    printf(\"%d\n\", result);\n    g_hash_table_destroy(dp);\n    free(A);\n    free(B);\n    free(X);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_481s5dg4/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_481s5dg4/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc340_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Initialize the number of balls in each box\n    GHashTable *boxes = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        int balls;\n        scanf(\"%d\", &balls);\n        g_hash_table_insert(boxes, GINT_TO_POINTER(i), GINT_TO_POINTER(balls));\n    }\n\n    // Process each operation\n    for (int i = 0; i < M; i++) {\n        int B;\n        scanf(\"%d\", &B);\n\n        // Take out all balls from box B\n        int balls = GPOINTER_TO_INT(g_hash_table_lookup(boxes, GINT_TO_POINTER(B)));\n        g_hash_table_insert(boxes, GINT_TO_POINTER(B), GINT_TO_POINTER(0));\n\n        // Simulate the process of putting balls back into the boxes\n        int C = 0;\n        while (balls > 0) {\n            C++;\n            int new_box = (B + C) % N;\n            int new_balls = GPOINTER_TO_INT(g_hash_table_lookup(boxes, GINT_TO_POINTER(new_box))) + 1;\n            g_hash_table_insert(boxes, GINT_TO_POINTER(new_box), GINT_TO_POINTER(new_balls));\n            balls--;\n        }\n    }\n\n    // Print the number of balls in each box\n    for (int i = 0; i < N; i++) {\n        printf(\"%d\", GPOINTER_TO_INT(g_hash_table_lookup(boxes, GINT_TO_POINTER(i))));\n        if (i < N - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_hash_table_destroy(boxes);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_d9hl1m3t/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_d9hl1m3t/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc341_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Allocate memory for the result string\n    char *result = (char *)malloc((2 * n + 1) * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\n\");\n        return 1;\n    }\n\n    // Initialize the result string with alternating 1s and 0s\n    for (int i = 0; i < 2 * n + 1; i++) {\n        result[i] = (i % 2 == 0) ? '1' : '0';\n    }\n\n    // Print the result string\n    printf(\"%s\n\", result);\n\n    // Free the allocated memory\n    free(result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_he2somzu/program.c: In function 'main':\\n/tmp/agnostics_c_he2somzu/program.c:12:25: warning: missing terminating \\\" character\\n   12 |         fprintf(stderr, \\\"Memory allocation failed\\n      |                         ^\\n/tmp/agnostics_c_he2somzu/program.c:12:25: error: missing terminating \\\" character\\n   12 |         fprintf(stderr, \\\"Memory allocation failed\\n      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_he2somzu/program.c:13:1: warning: missing terminating \\\" character\\n   13 | \\\");\\n      | ^\\n/tmp/agnostics_c_he2somzu/program.c:13:1: error: missing terminating \\\" character\\n   13 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_he2somzu/program.c:14:9: error: expected expression before 'return'\\n   14 |         return 1;\\n      |         ^~~~~~\\n/tmp/agnostics_c_he2somzu/program.c:14:18: error: expected ';' before '}' token\\n   14 |         return 1;\\n      |                  ^\\n      |                  ;\\n   15 |     }\\n      |     ~             \\n/tmp/agnostics_c_he2somzu/program.c:23:12: warning: missing terminating \\\" character\\n   23 |     printf(\\\"%s\\n      |            ^\\n/tmp/agnostics_c_he2somzu/program.c:23:12: error: missing terminating \\\" character\\n   23 |     printf(\\\"%s\\n      |            ^~~\\n/tmp/agnostics_c_he2somzu/program.c:24:1: warning: missing terminating \\\" character\\n   24 | \\\", result);\\n      | ^\\n/tmp/agnostics_c_he2somzu/program.c:24:1: error: missing terminating \\\" character\\n   24 | \\\", result);\\n      | ^~~~~~~~~~~\\n/tmp/agnostics_c_he2somzu/program.c:27:17: error: expected ')' before ';' token\\n   27 |     free(result);\\n      |                 ^\\n      |                 )\\n/tmp/agnostics_c_he2somzu/program.c:23:11: note: to match this '('\\n   23 |     printf(\\\"%s\\n      |           ^\\n/tmp/agnostics_c_he2somzu/program.c:27:5: error: invalid use of void expression\\n   27 |     free(result);\\n      |     ^~~~~~~~~~~~\\n/tmp/agnostics_c_he2somzu/program.c", "raw_stderr": "", "result": "fail"}
{"question_id": "abc341_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MAXN 200000\n\nint compare(const void *a, const void *b) {\n    double r1 = ((double *)a)[1] / ((double *)a)[2];\n    double r2 = ((double *)b)[1] / ((double *)b)[2];\n    if (r1 > r2) return -1;\n    if (r1 < r2) return 1;\n    return 0;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    long long A[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lld\", &A[i]);\n    }\n\n    double ratios[N-1][3];\n    for (int i = 0; i < N-1; i++) {\n        scanf(\"%lf %lf\", &ratios[i][1], &ratios[i][2]);\n        ratios[i][0] = i;\n    }\n\n    qsort(ratios, N-1, sizeof(ratios[0]), compare);\n\n    long long result = A[N-1];\n\n    for (int i = 0; i < N-1; i++) {\n        int idx = (int)ratios[i][0];\n        if (A[idx] >= ratios[i][1]) {\n            A[idx+1] += A[idx] / ratios[i][1] * ratios[i][2];\n            A[idx] = 0;\n        } else {\n            A[idx+1] += A[idx];\n            A[idx] = 0;\n        }\n    }\n\n    printf(\"%lld\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_oo1e_yd2/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_oo1e_yd2/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc341_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 501\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    char T[MAX];\n    scanf(\"%s\", T);\n\n    char grid[H][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    // Find the initial position (crash-landed position)\n    int initial_x, initial_y;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '#') {\n                initial_x = i;\n                initial_y = j;\n                break;\n            }\n        }\n    }\n\n    // Directions for L, R, U, D\n    int dx[] = {0, 0, -1, 1};\n    int dy[] = {-1, 1, 0, 0};\n\n    // Use a hash set to keep track of visited positions\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Start from the initial position\n    g_hash_table_insert(visited, GINT_TO_POINTER(initial_x * W + initial_y), NULL);\n\n    // Simulate the movements\n    for (int i = 0; i < N; i++) {\n        GHashTable *new_visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (gpointer key = g_hash_table_get_first_key(visited); key != NULL; key = g_hash_table_get_next_key(visited, key)) {\n            int pos = GPOINTER_TO_INT(key);\n            int x = pos / W;\n            int y = pos % W;\n\n            for (int k = 0; k < 4; k++) {\n                int new_x = x + dx[k];\n                int new_y = y + dy[k];\n\n                if (new_x >= 0 && new_x < H && new_y >= 0 && new_y < W && grid[new_x][new_y] == '.') {\n                    int new_pos = new_x * W + new_y;\n                    if (!g_hash_table_contains(visited, GINT_TO_POINTER(new_pos))) {\n                        g_hash_table_insert(new_visited, GINT_TO_POINTER(new_pos), NULL);\n                    }\n                }\n            }\n        }\n        g_hash_table_destroy(visited);\n        visited = new_visited;\n    }\n\n    // Output the number of possible positions\n    printf(\"%d\n\", g_hash_table_size(visited));\n\n    // Clean up\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jjat2lv_/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jjat2lv_/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc341_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    // Initialize variables\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(long long));\n\n    // Find numbers divisible by N but not by M\n    for (long long i = N; arr->len < K; i += N) {\n        if (i % M != 0) {\n            g_array_append_val(arr, i);\n        }\n    }\n\n    // Find numbers divisible by M but not by N\n    for (long long i = M; arr->len < K; i += M) {\n        if (i % N != 0) {\n            g_array_append_val(arr, i);\n        }\n    }\n\n    // Sort the array to get the K-th smallest element\n    qsort(arr->data, arr->len, sizeof(long long), compare);\n\n    // Print the K-th smallest element\n    printf(\"%lld\\n\", g_array_index(arr, long long, K - 1));\n\n    // Clean up\n    g_array_free(arr, TRUE);\n\n    return 0;\n}\n\n// Comparison function for qsort\nint compare(const void *a, const void *b) {\n    return (*(long long*)a - *(long long*)b);\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_h1c62rl4/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_h1c62rl4/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc341_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 500005\n\n// Segment tree node structure\ntypedef struct {\n    int start, end;\n    bool value;\n    bool lazy;\n} Node;\n\n// Segment tree structure\ntypedef struct {\n    Node *nodes;\n    int size;\n} SegmentTree;\n\n// Initialize the segment tree\nvoid initSegmentTree(SegmentTree *tree, int n) {\n    tree->size = 1;\n    while (tree->size < n) {\n        tree->size *= 2;\n    }\n    tree->nodes = (Node *)g_malloc(tree->size * sizeof(Node));\n    for (int i = 0; i < tree->size; i++) {\n        tree->nodes[i].start = -1;\n        tree->nodes[i].end = -1;\n        tree->nodes[i].value = false;\n        tree->nodes[i].lazy = false;\n    }\n}\n\n// Build the segment tree\nvoid buildSegmentTree(SegmentTree *tree, char *s, int index, int start, int end) {\n    if (start == end) {\n        tree->nodes[index].start = start;\n        tree->nodes[index].end = end;\n        tree->nodes[index].value = (s[start] == '1');\n        return;\n    }\n    int mid = (start + end) / 2;\n    buildSegmentTree(tree, s, 2 * index + 1, start, mid);\n    buildSegmentTree(tree, s, 2 * index + 2, mid + 1, end);\n    tree->nodes[index].start = start;\n    tree->nodes[index].end = end;\n    tree->nodes[index].value = tree->nodes[2 * index + 1].value != tree->nodes[2 * index + 2].value;\n}\n\n// Push lazy updates to children\nvoid pushLazy(SegmentTree *tree, int index) {\n    if (tree->nodes[index].lazy) {\n        tree->nodes[2 * index + 1].value = !tree->nodes[2 * index + 1].value;\n        tree->nodes[2 * index + 2].value = !tree->nodes[2 * index + 2].value;\n        tree->nodes[2 * index + 1].lazy = !tree->nodes[2 * index + 1].lazy;\n        tree->nodes[2 * index + 2].lazy = !tree->nodes[2 * index + 2].lazy;\n        tree->nodes[index].lazy = false;\n    }\n}\n\n// Update the segment tree\nvoid updateSegmentTree(SegmentTree *tree, int index, int start, int end, int left, int right) {\n    if (tree->nodes[index].lazy) {\n        pushLazy(tree, index);\n    }\n    if (start > end || start > right || end < left) {\n        return;\n    }\n    if (start >= left && end <= right) {\n        tree->nodes[index].value = !tree->nodes[index].value;\n        if (start != end) {\n            tree->nodes[index].lazy = !tree->nodes[index].lazy;\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    updateSegmentTree(tree, 2 * index + 1, start, mid, left, right);\n    updateSegmentTree(tree, 2 * index + 2, mid + 1, end, left, right);\n    tree->nodes[index].value = tree->nodes[2 * index + 1].value != tree->nodes[2 * index + 2].value;\n}\n\n// Query the segment tree\nbool querySegmentTree(SegmentTree *tree, int index, int start, int end, int left, int right) {\n    if (tree->nodes[index].lazy) {\n        pushLazy(tree, index);\n    }\n    if (start > end || start > right || end < left) {\n        return false;\n    }\n    if (start >= left && end <= right) {\n        return tree->nodes[index].value;\n    }\n    int mid = (start + end) / 2;\n    bool leftValue = querySegmentTree(tree, 2 * index + 1, start, mid, left, right);\n    bool rightValue = querySegmentTree(tree, 2 * index + 2, mid + 1, end, left, right);\n    return leftValue != rightValue;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    char *s = (char *)g_malloc((n + 1) * sizeof(char));\n    scanf(\"%s\", s);\n\n    SegmentTree tree;\n    initSegmentTree(&tree, n);\n    buildSegmentTree(&tree, s, 0, 0, n - 1);\n\n    for (int i = 0; i < q; i++) {\n        int type, l, r;\n        scanf(\"%d %d %d\", &type, &l, &r);\n        l--;\n        r--;\n\n        if (type == 1) {\n            updateSegmentTree(&tree, 0, 0, n - 1, l, r);\n        } else if (type == 2) {\n            bool result = querySegmentTree(&tree, 0, 0, n - 1, l, r);\n            printf(result ? \"Yes\n\" : \"No\n\");\n        }\n    }\n\n    g_free(s);\n    g_free(tree.nodes);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_wpsqsd_c/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_wpsqsd_c/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc341_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Adjacency list to represent the graph\n    GArray *adj[n+1];\n    for (int i = 1; i <= n; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Array to store weights of vertices\n    int weight[n+1];\n\n    // Read edges and build adjacency list\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        g_array_append_val(adj[u], v);\n        g_array_append_val(adj[v], u);\n    }\n\n    // Read weights and pieces on vertices\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &weight[i]);\n    }\n\n    int pieces[n+1];\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &pieces[i]);\n    }\n\n    int operations = 0;\n\n    // While there are pieces to remove\n    while (true) {\n        int min_weight = INT_MAX;\n        int min_vertex = -1;\n\n        // Find the vertex with the minimum weight that has pieces to remove\n        for (int i = 1; i <= n; i++) {\n            if (pieces[i] > 0 && weight[i] < min_weight) {\n                min_weight = weight[i];\n                min_vertex = i;\n            }\n        }\n\n        // If no such vertex is found, break the loop\n        if (min_vertex == -1) {\n            break;\n        }\n\n        // Remove one piece from the selected vertex\n        pieces[min_vertex]--;\n\n        // Place pieces on adjacent vertices if possible\n        for (int i = 0; i < adj[min_vertex]->len; i++) {\n            int neighbor = g_array_index(adj[min_vertex], int, i);\n            if (weight[neighbor] < min_weight && pieces[neighbor] < INT_MAX) {\n                pieces[neighbor]++;\n            }\n        }\n\n        // Increment the number of operations\n        operations++;\n    }\n\n    // Output the maximum number of operations\n    printf(\"%d\n\", operations);\n\n    // Clean up\n    for (int i = 1; i <= n; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_1hh4k5js/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_1hh4k5js/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc342_a", "solution": "#include <stdio.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[101];\n    scanf(\"%s\", S);\n\n    int len = strlen(S);\n    GHashTable *char_count = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Count occurrences of each character\n    for (int i = 0; i < len; i++) {\n        char *key = &S[i];\n        int *count = g_hash_table_lookup(char_count, key);\n        if (count) {\n            (*count)++;\n        } else {\n            g_hash_table_insert(char_count, key, GINT_TO_POINTER(1));\n        }\n    }\n\n    // Find the character that appears only once and its position\n    int result = -1;\n    for (int i = 0; i < len; i++) {\n        char *key = &S[i];\n        int count = GPOINTER_TO_INT(g_hash_table_lookup(char_count, key));\n        if (count == 1) {\n            result = i + 1;\n            break;\n        }\n    }\n\n    // Output the result\n    printf(\"%d\\n\", result);\n\n    // Clean up\n    g_hash_table_destroy(char_count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_j_0vot54/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_j_0vot54/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc342_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int positions[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &positions[i]);\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n\n    for (int i = 0; i < q; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n\n        // Find the indices of A_i and B_i in the positions array\n        int index_a = -1, index_b = -1;\n        for (int j = 0; j < n; j++) {\n            if (positions[j] == a) {\n                index_a = j;\n            }\n            if (positions[j] == b) {\n                index_b = j;\n            }\n        }\n\n        // Determine which person is further to the front\n        int result = (index_a < index_b) ? a : b;\n        printf(\"%d\n\", result);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_m7u217ti/program.c: In function 'main':\\n/tmp/agnostics_c_m7u217ti/program.c:33:16: warning: missing terminating \\\" character\\n   33 |         printf(\\\"%d\\n      |                ^\\n/tmp/agnostics_c_m7u217ti/program.c:33:16: error: missing terminating \\\" character\\n   33 |         printf(\\\"%d\\n      |                ^~~\\n/tmp/agnostics_c_m7u217ti/program.c:34:1: warning: missing terminating \\\" character\\n   34 | \\\", result);\\n      | ^\\n/tmp/agnostics_c_m7u217ti/program.c:34:1: error: missing terminating \\\" character\\n   34 | \\\", result);\\n      | ^~~~~~~~~~~\\n/tmp/agnostics_c_m7u217ti/program.c:35:5: error: expected expression before '}' token\\n   35 |     }\\n      |     ^\\n/tmp/agnostics_c_m7u217ti/program.c:33:16: error: expected ';' before '}' token\\n   33 |         printf(\\\"%d\\n      |                ^\\n      |                ;\\n   34 | \\\", result);\\n   35 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_m7u217ti/program.c: In function 'main':\n/tmp/agnostics_c_m7u217ti/program.c:33:16: warning: missing terminating \" character\n   33 |         printf(\"%d\n      |                ^\n/tmp/agnostics_c_m7u217ti/program.c:33:16: error: missing terminating \" character\n   33 |         printf(\"%d\n      |                ^~~\n/tmp/agnostics_c_m7u217ti/program.c:34:1: warning: missing terminating \" character\n   34 | \", result);\n      | ^\n/tmp/agnostics_c_m7u217ti/program.c:34:1: error: missing terminating \" character\n   34 | \", result);\n      | ^~~~~~~~~~~\n/tmp/agnostics_c_m7u217ti/program.c:35:5: error: expected expression before '}' token\n   35 |     }\n      |     ^\n/tmp/agnostics_c_m7u217ti/program.c:33:16: error: expected ';' before '}' token\n   33 |         printf(\"%d\n      |                ^\n      |                ;\n   34 | \", result);\n   35 |     }\n      |     ~           \n"}
{"question_id": "abc342_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char s[200001];\n    scanf(\"%s\", s);\n\n    int q;\n    scanf(\"%d\", &q);\n\n    GHashTable *map = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < q; i++) {\n        char c[2], d[2];\n        scanf(\"%s %s\", c, d);\n\n        g_hash_table_insert(map, c, d);\n    }\n\n    for (int i = 0; i < n; i++) {\n        char *replacement = g_hash_table_lookup(map, s + i);\n        if (replacement != NULL) {\n            s[i] = replacement[0];\n        }\n    }\n\n    printf(\"%s\n\", s);\n\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_fkqnwxsw/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_fkqnwxsw/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc342_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n#define MAXP 17  // Maximum number of prime factors (2^16)\n\nint prime[MAXP] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53};\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int A[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Preprocess the numbers to count the parity of exponents of their prime factors\n    int parity[MAXN][MAXP];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < MAXP; j++) {\n            parity[i][j] = 0;\n        }\n        int num = A[i];\n        for (int j = 0; j < MAXP; j++) {\n            while (num % prime[j] == 0) {\n                parity[i][j]++;\n                num /= prime[j];\n            }\n        }\n        for (int j = 0; j < MAXP; j++) {\n            parity[i][j] %= 2;\n        }\n    }\n\n    // Use a hash map to count how many numbers have the same parity of exponents as a given number\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        int *key = (int *)g_hash_table_lookup(map, parity[i]);\n        if (key) {\n            count += *key;\n        }\n        int *value = (int *)malloc(sizeof(int));\n        *value = 1;\n        g_hash_table_insert(map, parity[i], value);\n    }\n\n    // Output the result\n    printf(\"%d\\n\", count);\n\n    // Clean up\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_5p676pbq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_5p676pbq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc342_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200005\n#define MAX_M 200005\n#define INF INT_MIN\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashTable *dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 1; i <= N; i++) {\n        g_hash_table_insert(dp, GINT_TO_POINTER(i), GINT_TO_POINTER(INF));\n    }\n\n    for (int i = 0; i < M; i++) {\n        int l, d, k, c, A, B;\n        scanf(\"%d %d %d %d %d %d\", &l, &d, &k, &c, &A, &B);\n\n        for (int j = 0; j < k; j++) {\n            int t = l + j * d;\n            int next_time = t + c;\n            int *latest_arrival = g_hash_table_lookup(dp, GINT_TO_POINTER(A));\n            if (latest_arrival != NULL && *latest_arrival <= t) {\n                int *new_latest_arrival = g_hash_table_lookup(dp, GINT_TO_POINTER(B));\n                if (new_latest_arrival != NULL) {\n                    if (*new_latest_arrival < next_time) {\n                        *new_latest_arrival = next_time;\n                    }\n                } else {\n                    g_hash_table_insert(dp, GINT_TO_POINTER(B), GINT_TO_POINTER(next_time));\n                }\n            }\n        }\n    }\n\n    for (int i = 2; i < N; i++) {\n        int *latest_arrival = g_hash_table_lookup(dp, GINT_TO_POINTER(i));\n        if (latest_arrival != NULL && *latest_arrival != INF) {\n            printf(\"%d\\n\", *latest_arrival);\n        } else {\n            printf(\"Unreachable\\n\");\n        }\n    }\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_kl1c8hb2/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_kl1c8hb2/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc343_a", "solution": "#include <stdio.h>\n\nint main() {\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n    int sum = A + B;\n    int result = (sum == 0) ? 1 : 0;\n    printf(\"%d\n\", result);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_q4e6aq_a/program.c: In function 'main':\\n/tmp/agnostics_c_q4e6aq_a/program.c:8:12: warning: missing terminating \\\" character\\n    8 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_q4e6aq_a/program.c:8:12: error: missing terminating \\\" character\\n    8 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_q4e6aq_a/program.c:9:1: warning: missing terminating \\\" character\\n    9 | \\\", result);\\n      | ^\\n/tmp/agnostics_c_q4e6aq_a/program.c:9:1: error: missing terminating \\\" character\\n    9 | \\\", result);\\n      | ^~~~~~~~~~~\\n/tmp/agnostics_c_q4e6aq_a/program.c:10:5: error: expected expression before 'return'\\n   10 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_q4e6aq_a/program.c:10:14: error: expected ';' before '}' token\\n   10 |     return 0;\\n      |              ^\\n      |              ;\\n   11 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_q4e6aq_a/program.c: In function 'main':\n/tmp/agnostics_c_q4e6aq_a/program.c:8:12: warning: missing terminating \" character\n    8 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c_q4e6aq_a/program.c:8:12: error: missing terminating \" character\n    8 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c_q4e6aq_a/program.c:9:1: warning: missing terminating \" character\n    9 | \", result);\n      | ^\n/tmp/agnostics_c_q4e6aq_a/program.c:9:1: error: missing terminating \" character\n    9 | \", result);\n      | ^~~~~~~~~~~\n/tmp/agnostics_c_q4e6aq_a/program.c:10:5: error: expected expression before 'return'\n   10 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_q4e6aq_a/program.c:10:14: error: expected ';' before '}' token\n   10 |     return 0;\n      |              ^\n      |              ;\n   11 | }\n      | ~             \n"}
{"question_id": "abc343_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create a GArray for each vertex to store its connected vertices\n    GArray *adj_lists[n];\n    for (int i = 0; i < n; i++) {\n        adj_lists[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read the adjacency matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int a;\n            scanf(\"%d\", &a);\n            if (a == 1) {\n                g_array_append_val(adj_lists[i], j + 1);\n            }\n        }\n    }\n\n    // Print the connected vertices for each vertex in ascending order\n    for (int i = 0; i < n; i++) {\n        g_array_sort(adj_lists[i], (GCompareFunc)g_int_compare);\n        for (int j = 0; j < adj_lists[i]->len; j++) {\n            printf(\"%d \", g_array_index(adj_lists[i], int, j));\n        }\n        printf(\"\\n\");\n    }\n\n    // Free the allocated memory\n    for (int i = 0; i < n; i++) {\n        g_array_free(adj_lists[i], TRUE);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_oo3ipm1e/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_oo3ipm1e/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc343_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to check if a number is a palindrome\nbool is_palindrome(long long num) {\n    char str[20];  // Assuming the number will fit in a 20-character string\n    sprintf(str, \"%lld\", num);\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    // Read input\n    long long N;\n    scanf(\"%lld\", &N);\n\n    // Initialize variables\n    long long max_palindromic_cube = 0;\n    for (long long i = 1; i * i * i <= N; i++) {\n        long long cube = i * i * i;\n        if (is_palindrome(cube)) {\n            max_palindromic_cube = cube;\n        }\n    }\n\n    // Output result\n    printf(\"%lld\n\", max_palindromic_cube);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_oqmkfkq_/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_oqmkfkq_/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc343_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N, T;\n    scanf(\"%d %d\", &N, &T);\n\n    // Initialize data structures\n    GArray *scores = g_array_new(FALSE, FALSE, sizeof(int));\n    GHashTable *score_counts = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GArray *result = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Initialize scores to zero\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(scores, 0);\n        g_hash_table_insert(score_counts, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n    }\n\n    // Process each time step\n    for (int i = 0; i < T; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n\n        // Update the score of player A\n        int current_score = g_array_index(scores, int, A - 1);\n        int new_score = current_score + B;\n        g_array_index(scores, int, A - 1) = new_score;\n\n        // Update the count of the new score\n        int *count = (int *)g_hash_table_lookup(score_counts, GINT_TO_POINTER(new_score));\n        if (count) {\n            *count += 1;\n        } else {\n            g_hash_table_insert(score_counts, GINT_TO_POINTER(new_score), GINT_TO_POINTER(1));\n        }\n\n        // Remove the count of the old score\n        count = (int *)g_hash_table_lookup(score_counts, GINT_TO_POINTER(current_score));\n        if (count) {\n            *count -= 1;\n            if (*count == 0) {\n                g_hash_table_remove(score_counts, GINT_TO_POINTER(current_score));\n            }\n        }\n\n        // Get the number of unique scores\n        int unique_scores = g_hash_table_size(score_counts);\n        g_array_append_val(result, unique_scores);\n    }\n\n    // Output the result\n    for (int i = 0; i < T; i++) {\n        printf(\"%d\n\", g_array_index(result, int, i));\n    }\n\n    // Clean up\n    g_array_free(scores, TRUE);\n    g_hash_table_destroy(score_counts);\n    g_array_free(result, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tf8hhff7/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_tf8hhff7/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc343_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int V1, V2, V3;\n    scanf(\"%d %d %d\", &V1, &V2, &V3);\n\n    // Check if the given volumes are possible\n    if (V1 + 2 * V2 + V3 != 3 * 7 * 7 * 7) {\n        printf(\"No\\n\");\n        return 0;\n    }\n\n    // Calculate the coordinates of the cubes\n    int a1 = 0, b1 = 0, c1 = 0;\n    int a2 = 0, b2 = 6, c2 = 0;\n    int a3 = 6, b3 = 0, c3 = 0;\n\n    // Print the coordinates\n    printf(\"Yes\\n\");\n    printf(\"%d %d %d %d %d %d %d %d %d\\n\", a1, b1, c1, a2, b2, c2, a3, b3, c3);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_llysg1mf/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_llysg1mf/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc344_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_LEN 101\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint main() {\n    char T[MAX_LEN];\n    int N;\n    scanf(\"%s\", T);\n    scanf(\"%d\", &N);\n\n    GHashTable *dp = g_hash_table_new(g_str_hash, g_str_equal);\n    g_hash_table_insert(dp, \"\", GINT_TO_POINTER(0));\n\n    for (int i = 0; i < N; i++) {\n        int A;\n        scanf(\"%d\", &A);\n        char bags[A][MAX_LEN];\n        for (int j = 0; j < A; j++) {\n            scanf(\"%s\", bags[j]);\n        }\n\n        GHashTable *new_dp = g_hash_table_new(g_str_hash, g_str_equal);\n\n        for (int j = 0; j < A; j++) {\n            char *bag = bags[j];\n            int len = strlen(bag);\n\n            for (gpointer key = g_hash_table_lookup_extended(dp, \"\", NULL, NULL); key != NULL; key = g_hash_table_lookup_extended(dp, key, NULL, NULL)) {\n                char *prefix = key;\n                char *suffix = g_strconcat(prefix, bag, NULL);\n                int cost = GPOINTER_TO_INT(key) + len;\n\n                if (!g_hash_table_contains(dp, suffix)) {\n                    g_hash_table_insert(new_dp, suffix, GINT_TO_POINTER(cost));\n                } else {\n                    int existing_cost = GPOINTER_TO_INT(g_hash_table_lookup(dp, suffix));\n                    if (cost < existing_cost) {\n                        g_hash_table_insert(new_dp, suffix, GINT_TO_POINTER(cost));\n                    }\n                }\n\n                g_free(suffix);\n            }\n        }\n\n        g_hash_table_destroy(dp);\n        dp = new_dp;\n    }\n\n    int result = -1;\n    if (g_hash_table_contains(dp, T)) {\n        result = GPOINTER_TO_INT(g_hash_table_lookup(dp, T));\n    }\n\n    printf(\"%d\n\", result);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_y1ofjj7h/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_y1ofjj7h/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc344_a", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char s[101];\n    scanf(\"%s\", s);\n\n    int len = strlen(s);\n    int first_pipe = -1;\n    int second_pipe = -1;\n\n    // Find the positions of the two | characters\n    for (int i = 0; i < len; i++) {\n        if (s[i] == '|') {\n            if (first_pipe == -1) {\n                first_pipe = i;\n            } else {\n                second_pipe = i;\n                break;\n            }\n        }\n    }\n\n    // Copy characters before the first | to a new string\n    char result[101];\n    int result_index = 0;\n    for (int i = 0; i < first_pipe; i++) {\n        result[result_index++] = s[i];\n    }\n\n    // Skip characters between the two | characters\n    for (int i = second_pipe + 1; i < len; i++) {\n        result[result_index++] = s[i];\n    }\n\n    // Null-terminate the result string\n    result[result_index] = '\\0';\n\n    // Print the result\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc344_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m, l, q;\n    scanf(\"%d\", &n);\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    scanf(\"%d\", &m);\n    int *b = (int *)malloc(m * sizeof(int));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    scanf(\"%d\", &l);\n    int *c = (int *)malloc(l * sizeof(int));\n    for (int i = 0; i < l; i++) {\n        scanf(\"%d\", &c[i]);\n    }\n\n    scanf(\"%d\", &q);\n    int *x = (int *)malloc(q * sizeof(int));\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d\", &x[i]);\n    }\n\n    GHashTable *bc_sums = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < l; j++) {\n            int sum = b[i] + c[j];\n            g_hash_table_insert(bc_sums, GINT_TO_POINTER(sum), GINT_TO_POINTER(1));\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int target = x[i] - a[i];\n        gpointer found = g_hash_table_lookup(bc_sums, GINT_TO_POINTER(target));\n        if (found) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    g_hash_table_destroy(bc_sums);\n    free(a);\n    free(b);\n    free(c);\n    free(x);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2jv503he/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2jv503he/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc344_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    int num;\n\n    // Read integers until 0 is encountered\n    while (scanf(\"%d\", &num) == 1 && num != 0) {\n        g_array_append_val(arr, num);\n    }\n\n    // Print the integers in reverse order\n    for (int i = arr->len - 1; i >= 0; i--) {\n        printf(\"%d\n\", g_array_index(arr, int, i));\n    }\n\n    // Free the dynamically allocated array\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_hfyti763/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_hfyti763/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc344_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Define a structure for the linked list node\ntypedef struct Node {\n    int value;\n    struct Node *next;\n    struct Node *prev;\n} Node;\n\n// Function to create a new node\nNode* create_node(int value) {\n    Node *new_node = (Node*)malloc(sizeof(Node));\n    new_node->value = value;\n    new_node->next = NULL;\n    new_node->prev = NULL;\n    return new_node;\n}\n\n// Function to insert a node after a given node\nvoid insert_after(Node *prev_node, int value) {\n    if (prev_node == NULL) {\n        return;\n    }\n    Node *new_node = create_node(value);\n    new_node->next = prev_node->next;\n    new_node->prev = prev_node;\n    if (prev_node->next != NULL) {\n        prev_node->next->prev = new_node;\n    }\n    prev_node->next = new_node;\n}\n\n// Function to delete a node\nvoid delete_node(Node *node) {\n    if (node == NULL) {\n        return;\n    }\n    if (node->prev != NULL) {\n        node->prev->next = node->next;\n    }\n    if (node->next != NULL) {\n        node->next->prev = node->prev;\n    }\n    free(node);\n}\n\nint main() {\n    // Read input\n    int N;\n    scanf(\"%d\", &N);\n    int A[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Initialize the linked list and hash table\n    GHashTable *hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n    Node *head = NULL;\n    Node *tail = NULL;\n\n    // Populate the linked list and hash table\n    for (int i = 0; i < N; i++) {\n        Node *new_node = create_node(A[i]);\n        g_hash_table_insert(hash, GINT_TO_POINTER(A[i]), new_node);\n        if (head == NULL) {\n            head = new_node;\n            tail = new_node;\n        } else {\n            tail->next = new_node;\n            new_node->prev = tail;\n            tail = new_node;\n        }\n    }\n\n    // Process queries\n    int Q;\n    scanf(\"%d\", &Q);\n    for (int i = 0; i < Q; i++) {\n        int type, x, y;\n        scanf(\"%d %d\", &type, &x);\n        if (type == 1) {\n            scanf(\"%d\", &y);\n            Node *x_node = (Node*)g_hash_table_lookup(hash, GINT_TO_POINTER(x));\n            insert_after(x_node, y);\n        } else if (type == 2) {\n            Node *x_node = (Node*)g_hash_table_lookup(hash, GINT_TO_POINTER(x));\n            delete_node(x_node);\n            g_hash_table_remove(hash, GINT_TO_POINTER(x));\n        }\n    }\n\n    // Print the final sequence\n    Node *current = head;\n    while (current != NULL) {\n        printf(\"%d \", current->value);\n        current = current->next;\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_hash_table_destroy(hash);\n    Node *current_node = head;\n    while (current_node != NULL) {\n        Node *next_node = current_node->next;\n        free(current_node);\n        current_node = next_node;\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_fb0vjxwz/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_fb0vjxwz/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc345_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 7\n#define MAX_H 10\n#define MAX_W 10\n\ntypedef struct {\n    int A;\n    int B;\n} Tile;\n\nGHashTable *tile_positions;\nGArray *available_tiles;\n\nvoid print_grid(int H, int W) {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            printf(\".\");\n        }\n        printf(\"\\n\");\n    }\n}\n\nbool can_place_tile(int H, int W, int x, int y, Tile tile, int orientation) {\n    int A = tile.A;\n    int B = tile.B;\n    if (orientation == 0) {\n        if (x + A > W || y + B > H) return false;\n        for (int i = x; i < x + A; i++) {\n            for (int j = y; j < y + B; j++) {\n                if (g_hash_table_lookup(tile_positions, GINT_TO_POINTER(j * W + i)) != NULL) return false;\n            }\n        }\n    } else {\n        if (x + B > W || y + A > H) return false;\n        for (int i = x; i < x + B; i++) {\n            for (int j = y; j < y + A; j++) {\n                if (g_hash_table_lookup(tile_positions, GINT_TO_POINTER(j * W + i)) != NULL) return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid place_tile(int H, int W, int x, int y, Tile tile, int orientation) {\n    int A = tile.A;\n    int B = tile.B;\n    if (orientation == 0) {\n        for (int i = x; i < x + A; i++) {\n            for (int j = y; j < y + B; j++) {\n                g_hash_table_insert(tile_positions, GINT_TO_POINTER(j * W + i), GINT_TO_POINTER(1));\n            }\n        }\n    } else {\n        for (int i = x; i < x + B; i++) {\n            for (int j = y; j < y + A; j++) {\n                g_hash_table_insert(tile_positions, GINT_TO_POINTER(j * W + i), GINT_TO_POINTER(1));\n            }\n        }\n    }\n}\n\nvoid remove_tile(int H, int W, int x, int y, Tile tile, int orientation) {\n    int A = tile.A;\n    int B = tile.B;\n    if (orientation == 0) {\n        for (int i = x; i < x + A; i++) {\n            for (int j = y; j < y + B; j++) {\n                g_hash_table_remove(tile_positions, GINT_TO_POINTER(j * W + i));\n            }\n        }\n    } else {\n        for (int i = x; i < x + B; i++) {\n            for (int j = y; j < y + A; j++) {\n                g_hash_table_remove(tile_positions, GINT_TO_POINTER(j * W + i));\n            }\n        }\n    }\n}\n\nbool solve(int H, int W, int index) {\n    if (index == available_tiles->len) return true;\n    Tile tile = g_array_index(available_tiles, Tile, index);\n    for (int x = 0; x <= W - tile.A; x++) {\n        for (int y = 0; y <= H - tile.B; y++) {\n            if (can_place_tile(H, W, x, y, tile, 0)) {\n                place_tile(H, W, x, y, tile, 0);\n                if (solve(H, W, index + 1)) return true;\n                remove_tile(H, W, x, y, tile, 0);\n            }\n            if (can_place_tile(H, W, x, y, tile, 1)) {\n                place_tile(H, W, x, y, tile, 1);\n                if (solve(H, W, index + 1)) return true;\n                remove_tile(H, W, x, y, tile, 1);\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int N, H, W;\n    scanf(\"%d %d %d\", &N, &H, &W);\n\n    tile_positions = g_hash_table_new(g_direct_hash, g_direct_equal);\n    available_tiles = g_array_new(FALSE, FALSE, sizeof(Tile));\n\n    for (int i = 0; i < N; i++) {\n        Tile tile;\n        scanf(\"%d %d\", &tile.A, &tile.B);\n        g_array_append_val(available_tiles, tile);\n    }\n\n    if (solve(H, W, 0)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    g_hash_table_destroy(tile_positions);\n    g_array_free(available_tiles, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_rszgw_ew/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_rszgw_ew/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc345_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint main() {\n    char X[20];\n    scanf(\"%s\", X);\n\n    // Convert string to double\n    double x = atof(X);\n\n    // Compute ceiling of X/10\n    double result = ceil(x / 10);\n\n    // Convert result back to integer and print\n    printf(\"%d\\n\", (int)result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"100000000000000000\", \"got\": \"-2147483648\", \"stderr\": \"Test case 2 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "100000000000000000", "got": "-2147483648", "stderr": "Test case 2 produced wrong output\n"}
{"question_id": "abc346_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    long long costs[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld\", &costs[i]);\n    }\n\n    GHashTable *dp = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < n; i++) {\n        char key[2];\n        key[0] = s[i];\n        key[1] = '\\0';\n\n        long long min_cost = LLONG_MAX;\n\n        if (i > 0) {\n            char prev_key[2];\n            prev_key[0] = s[i - 1];\n            prev_key[1] = '\\0';\n\n            gpointer prev_cost_ptr = g_hash_table_lookup(dp, prev_key);\n            if (prev_cost_ptr != NULL) {\n                long long prev_cost = GPOINTER_TO_INT(prev_cost_ptr);\n                min_cost = prev_cost;\n            }\n        }\n\n        if (i < n - 1) {\n            char next_key[2];\n            next_key[0] = s[i + 1];\n            next_key[1] = '\\0';\n\n            gpointer next_cost_ptr = g_hash_table_lookup(dp, next_key);\n            if (next_cost_ptr != NULL) {\n                long long next_cost = GPOINTER_TO_INT(next_cost_ptr);\n                min_cost = next_cost;\n            }\n        }\n\n        if (min_cost == LLONG_MAX) {\n            min_cost = 0;\n        }\n\n        min_cost += costs[i];\n\n        g_hash_table_insert(dp, key, GINT_TO_POINTER(min_cost));\n    }\n\n    long long min_cost = LLONG_MAX;\n\n    for (int i = 0; i < n; i++) {\n        char key[2];\n        key[0] = s[i];\n        key[1] = '\\0';\n\n        gpointer cost_ptr = g_hash_table_lookup(dp, key);\n        if (cost_ptr != NULL) {\n            long long cost = GPOINTER_TO_INT(cost_ptr);\n            if (cost < min_cost) {\n                min_cost = cost;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", min_cost);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_3we5pzag/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_3we5pzag/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc346_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int W, B;\n    scanf(\"%d %d\", &W, &B);\n\n    // The repeating pattern is 'wbwbwwbwbwbw'\n    char pattern[] = \"wbwbwwbwbwbw\";\n    int pattern_len = strlen(pattern);\n\n    // We need a window of size W + B\n    int window_size = W + B;\n\n    // Iterate through the pattern to find the required window\n    for (int i = 0; i < pattern_len; i++) {\n        int w_count = 0;\n        int b_count = 0;\n\n        // Check the current window of size W + B\n        for (int j = 0; j < window_size; j++) {\n            char current_char = pattern[(i + j) % pattern_len];\n            if (current_char == 'w') {\n                w_count++;\n            } else if (current_char == 'b') {\n                b_count++;\n            }\n\n            // If we find the required counts, return 'Yes'\n            if (w_count == W && b_count == B) {\n                printf(\"Yes\\n\");\n                return 0;\n            }\n        }\n    }\n\n    // If no such window is found, return 'No'\n    printf(\"No\\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__gj58_e8/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__gj58_e8/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc346_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int H, W, M;\n    scanf(\"%d %d %d\", &H, &W, &M);\n\n    GHashTable *color_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < M; i++) {\n        int T, A, X;\n        scanf(\"%d %d %d\", &T, &A, &X);\n\n        if (T == 1) {\n            // Repaint all cells in the A-th row with color X\n            for (int j = 0; j < W; j++) {\n                int current_color = 0; // Assuming initial color is 0\n                gpointer count_ptr = g_hash_table_lookup(color_count, GINT_TO_POINTER(current_color));\n                int count = count_ptr ? GPOINTER_TO_INT(count_ptr) : 0;\n                count -= 1; // Remove the current color count\n                g_hash_table_insert(color_count, GINT_TO_POINTER(current_color), GINT_TO_POINTER(count));\n\n                g_hash_table_insert(color_count, GINT_TO_POINTER(X), GINT_TO_POINTER(count + 1));\n            }\n        } else if (T == 2) {\n            // Repaint all cells in the A-th column with color X\n            for (int j = 0; j < H; j++) {\n                int current_color = 0; // Assuming initial color is 0\n                gpointer count_ptr = g_hash_table_lookup(color_count, GINT_TO_POINTER(current_color));\n                int count = count_ptr ? GPOINTER_TO_INT(count_ptr) : 0;\n                count -= 1; // Remove the current color count\n                g_hash_table_insert(color_count, GINT_TO_POINTER(current_color), GINT_TO_POINTER(count));\n\n                g_hash_table_insert(color_count, GINT_TO_POINTER(X), GINT_TO_POINTER(count + 1));\n            }\n        }\n    }\n\n    // Count distinct colors\n    int distinct_colors = 0;\n    GList *keys = g_hash_table_get_keys(color_count);\n    for (GList *node = keys; node != NULL; node = node->next) {\n        if (GPOINTER_TO_INT(node->data) > 0) {\n            distinct_colors++;\n        }\n    }\n\n    printf(\"%d\n\", distinct_colors);\n\n    // Print distinct colors and their counts\n    GList *sorted_keys = g_list_sort(keys, (GCompareFunc)g_int_compare);\n    for (GList *node = sorted_keys; node != NULL; node = node->next) {\n        int color = GPOINTER_TO_INT(node->data);\n        if (color > 0) {\n            gpointer count_ptr = g_hash_table_lookup(color_count, GINT_TO_POINTER(color));\n            int count = count_ptr ? GPOINTER_TO_INT(count_ptr) : 0;\n            printf(\"%d %d\n\", color, count);\n        }\n    }\n\n    // Clean up\n    g_hash_table_destroy(color_count);\n    g_list_free(sorted_keys);\n    g_list_free(keys);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_s5djkv26/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_s5djkv26/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc346_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    int *a = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // Compute and print B_i\n    for (int i = 0; i < n - 1; i++) {\n        printf(\"%d \", a[i] * a[i + 1]);\n    }\n\n    // Free allocated memory\n    free(a);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc346_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    // Create a hash table to store the elements of A\n    GHashTable *hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the sequence A and insert elements into the hash table\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_hash_table_insert(hash, GINT_TO_POINTER(value), GINT_TO_POINTER(1));\n    }\n\n    // Calculate the sum of integers between 1 and K that do not appear in A\n    long long sum = 0;\n    for (int i = 1; i <= k; i++) {\n        if (!g_hash_table_lookup(hash, GINT_TO_POINTER(i))) {\n            sum += i;\n        }\n    }\n\n    // Print the result\n    printf(\"%lld\\n\", sum);\n\n    // Clean up\n    g_hash_table_destroy(hash);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_i6u_n_6r/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_i6u_n_6r/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc347_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint main() {\n    int N, A, B;\n    scanf(\"%d %d %d\", &N, &A, &B);\n\n    int total_days = A + B;\n    bool possible = true;\n\n    for (int i = 0; i < N; i++) {\n        int D;\n        scanf(\"%d\", &D);\n        if (D % total_days != 0) {\n            possible = false;\n            break;\n        }\n    }\n\n    if (possible) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ymwf1pfu/program.c: In function 'main':\\n/tmp/agnostics_c_ymwf1pfu/program.c:22:16: warning: missing terminating \\\" character\\n   22 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_ymwf1pfu/program.c:22:16: error: missing terminating \\\" character\\n   22 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_ymwf1pfu/program.c:23:1: warning: missing terminating \\\" character\\n   23 | \\\");\\n      | ^\\n/tmp/agnostics_c_ymwf1pfu/program.c:23:1: error: missing terminating \\\" character\\n   23 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_ymwf1pfu/program.c:24:5: error: expected expression before '}' token\\n   24 |     } else {\\n      |     ^\\n/tmp/agnostics_c_ymwf1pfu/program.c:22:16: error: expected ';' before '}' token\\n   22 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   23 | \\\");\\n   24 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_ymwf1pfu/program.c:25:16: warning: missing terminating \\\" character\\n   25 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_ymwf1pfu/program.c:25:16: error: missing terminating \\\" character\\n   25 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_ymwf1pfu/program.c:26:1: warning: missing terminating \\\" character\\n   26 | \\\");\\n      | ^\\n/tmp/agnostics_c_ymwf1pfu/program.c:26:1: error: missing terminating \\\" character\\n   26 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_ymwf1pfu/program.c:27:5: error: expected expression before '}' token\\n   27 |     }\\n      |     ^\\n/tmp/agnostics_c_ymwf1pfu/program.c:25:16: error: expected ';' before '}' token\\n   25 |         printf(\\\"No\\n      |                ^\\n      |                ;\\n   26 | \\\");\\n   27 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ymwf1pfu/program.c: In function 'main':\n/tmp/agnostics_c_ymwf1pfu/program.c:22:16: warning: missing terminating \" character\n   22 |         printf(\"Yes\n      |                ^\n/tmp/agnostics_c_ymwf1pfu/program.c:22:16: error: missing terminating \" character\n   22 |         printf(\"Yes\n      |                ^~~~\n/tmp/agnostics_c_ymwf1pfu/program.c:23:1: warning: missing terminating \" character\n   23 | \");\n      | ^\n/tmp/agnostics_c_ymwf1pfu/program.c:23:1: error: missing terminating \" character\n   23 | \");\n      | ^~~\n/tmp/agnostics_c_ymwf1pfu/program.c:24:5: error: expected expression before '}' token\n   24 |     } else {\n      |     ^\n/tmp/agnostics_c_ymwf1pfu/program.c:22:16: error: expected ';' before '}' token\n   22 |         printf(\"Yes\n      |                ^\n      |                ;\n   23 | \");\n   24 |     } else {\n      |     ~           \n/tmp/agnostics_c_ymwf1pfu/program.c:25:16: warning: missing terminating \" character\n   25 |         printf(\"No\n      |                ^\n/tmp/agnostics_c_ymwf1pfu/program.c:25:16: error: missing terminating \" character\n   25 |         printf(\"No\n      |                ^~~\n/tmp/agnostics_c_ymwf1pfu/program.c:26:1: warning: missing terminating \" character\n   26 | \");\n      | ^\n/tmp/agnostics_c_ymwf1pfu/program.c:26:1: error: missing terminating \" character\n   26 | \");\n      | ^~~\n/tmp/agnostics_c_ymwf1pfu/program.c:27:5: error: expected expression before '}' token\n   27 |     }\n      |     ^\n/tmp/agnostics_c_ymwf1pfu/program.c:25:16: error: expected ';' before '}' token\n   25 |         printf(\"No\n      |                ^\n      |                ;\n   26 | \");\n   27 |     }\n      |     ~           \n"}
{"question_id": "abc347_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    // Create a hash table to store the quotients\n    GHashTable *quotients = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the sequence A and store the multiples of K and their quotients\n    for (int i = 0; i < N; i++) {\n        int A;\n        scanf(\"%d\", &A);\n        if (A % K == 0) {\n            int quotient = A / K;\n            g_hash_table_insert(quotients, GINT_TO_POINTER(quotient), GINT_TO_POINTER(1));\n        }\n    }\n\n    // Sort the keys of the hash table\n    GList *keys = g_hash_table_get_keys(quotients);\n    keys = g_list_sort(keys, (GCompareFunc)g_int_compare);\n\n    // Print the sorted keys\n    GList *node = keys;\n    while (node != NULL) {\n        printf(\"%d \", GPOINTER_TO_INT(node->data));\n        node = node->next;\n    }\n    printf(\"\\n\");\n\n    // Clean up the memory allocated for the hash table and the list\n    g_hash_table_destroy(quotients);\n    g_list_free(keys);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tib1snl2/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_tib1snl2/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc347_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize the array A with all elements set to 0\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(A, 0);\n    }\n\n    // Initialize the set S\n    GHashTable *S = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Process each query\n    for (int i = 0; i < Q; i++) {\n        int x;\n        scanf(\"%d\", &x);\n\n        if (g_hash_table_contains(S, GINT_TO_POINTER(x))) {\n            // Remove x from S\n            g_hash_table_remove(S, GINT_TO_POINTER(x));\n        } else {\n            // Insert x into S\n            g_hash_table_insert(S, GINT_TO_POINTER(x), GINT_TO_POINTER(1));\n        }\n\n        // Update the array A based on the size of S\n        int size_S = g_hash_table_size(S);\n        for (int j = 0; j < N; j++) {\n            if (g_hash_table_contains(S, GINT_TO_POINTER(j + 1))) {\n                g_array_index(A, int, j) += size_S;\n            }\n        }\n    }\n\n    // Print the updated array A\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", g_array_index(A, int, i));\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_array_free(A, TRUE);\n    g_hash_table_destroy(S);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_rwplh63l/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_rwplh63l/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc347_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char str[1001];\n    scanf(\"%s\", str);\n\n    // Set to store unique substrings\n    GHashTable *substr_set = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Length of the input string\n    int len = strlen(str);\n\n    // Generate all substrings and insert into the set\n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j <= len; j++) {\n            char *substring = g_strndup(str + i, j - i);\n            g_hash_table_insert(substr_set, substring, GINT_TO_POINTER(1));\n        }\n    }\n\n    // Count of unique substrings\n    int count = g_hash_table_size(substr_set);\n\n    // Output the result\n    printf(\"%d\n\", count);\n\n    // Clean up\n    g_hash_table_destroy(substr_set);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_rrnu6lc2/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_rrnu6lc2/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc348_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *deliciousness = (int *)malloc(n * sizeof(int));\n    char **colors = (char **)malloc(n * sizeof(char *));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %s\", &deliciousness[i], colors[i] = (char *)malloc(10 * sizeof(char)));\n    }\n\n    qsort(deliciousness, n, sizeof(int), compare);\n\n    int max_min_deliciousness = 0;\n\n    for (int i = 0; i < n; i++) {\n        int current_min = deliciousness[i];\n        int count = 1;\n\n        for (int j = i + 1; j < n; j++) {\n            if (strcmp(colors[i], colors[j]) == 0) {\n                current_min = fmax(current_min, deliciousness[j]);\n                count++;\n            }\n\n            if (count == 2) {\n                break;\n            }\n        }\n\n        max_min_deliciousness = fmax(max_min_deliciousness, current_min);\n    }\n\n    printf(\"%d\\n\", max_min_deliciousness);\n\n    free(deliciousness);\n    for (int i = 0; i < n; i++) {\n        free(colors[i]);\n    }\n    free(colors);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_n06pq6dn/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_n06pq6dn/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc348_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to calculate Euclidean distance\ndouble euclidean_distance(int x1, int y1, int x2, int y2) {\n    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create a GArray to store points\n    GArray *points = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Read points into the array\n    for (int i = 0; i < n * 2; i++) {\n        int coord;\n        scanf(\"%d\", &coord);\n        g_array_append_val(points, coord);\n    }\n\n    // Create a GArray to store the ID of the farthest point for each point\n    GArray *farthest_ids = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Iterate over each point\n    for (int i = 0; i < n; i++) {\n        int x1 = g_array_index(points, int, i * 2);\n        int y1 = g_array_index(points, int, i * 2 + 1);\n        double max_distance = 0;\n        int farthest_id = 1;\n\n        // Iterate over all other points to find the farthest one\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            int x2 = g_array_index(points, int, j * 2);\n            int y2 = g_array_index(points, int, j * 2 + 1);\n            double distance = euclidean_distance(x1, y1, x2, y2);\n\n            // Update the farthest point if a closer one is found\n            if (distance > max_distance || (distance == max_distance && j < farthest_id)) {\n                max_distance = distance;\n                farthest_id = j + 1;\n            }\n        }\n\n        // Store the ID of the farthest point\n        g_array_append_val(farthest_ids, farthest_id);\n    }\n\n    // Print the IDs of the farthest points\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\\n\", g_array_index(farthest_ids, int, i));\n    }\n\n    // Free allocated memory\n    g_array_free(points, TRUE);\n    g_array_free(farthest_ids, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_kmccdvr6/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_kmccdvr6/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc348_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    char result[N + 1];\n    result[N] = '\\0';\n\n    for (int i = 1; i <= N; i++) {\n        if (i % 3 == 0) {\n            result[i - 1] = 'x';\n        } else {\n            result[i - 1] = 'o';\n        }\n    }\n\n    printf(\"%s\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc348_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 201\n\nint H, W;\nchar grid[MAX][MAX];\nGHashTable *medicines;\n\nvoid read_input() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    int N;\n    scanf(\"%d\", &N);\n    medicines = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        int r, c, e;\n        scanf(\"%d %d %d\", &r, &c, &e);\n        g_hash_table_insert(medicines, GINT_TO_POINTER(r * W + c), GINT_TO_POINTER(e));\n    }\n}\n\nbool can_reach_goal(int start_r, int start_c, int energy) {\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(start_r * W + start_c));\n    bool visited[MAX * MAX] = {false};\n    visited[start_r * W + start_c] = true;\n\n    while (!g_queue_is_empty(queue)) {\n        int current = g_queue_pop_head(queue);\n        int r = current / W;\n        int c = current % W;\n\n        if (grid[r][c] == 'T') {\n            g_queue_free(queue);\n            return true;\n        }\n\n        int new_energy = energy + 1;\n        if (new_energy > 0 && r > 0 && grid[r - 1][c] != '#' && !visited[(r - 1) * W + c]) {\n            visited[(r - 1) * W + c] = true;\n            g_queue_push_tail(queue, GINT_TO_POINTER((r - 1) * W + c));\n        }\n        if (new_energy > 0 && r < H - 1 && grid[r + 1][c] != '#' && !visited[(r + 1) * W + c]) {\n            visited[(r + 1) * W + c] = true;\n            g_queue_push_tail(queue, GINT_TO_POINTER((r + 1) * W + c));\n        }\n        if (new_energy > 0 && c > 0 && grid[r][c - 1] != '#' && !visited[r * W + c - 1]) {\n            visited[r * W + c - 1] = true;\n            g_queue_push_tail(queue, GINT_TO_POINTER(r * W + c - 1));\n        }\n        if (new_energy > 0 && c < W - 1 && grid[r][c + 1] != '#' && !visited[r * W + c + 1]) {\n            visited[r * W + c + 1] = true;\n            g_queue_push_tail(queue, GINT_TO_POINTER(r * W + c + 1));\n        }\n\n        if (g_hash_table_contains(medicines, GINT_TO_POINTER(current))) {\n            int med_energy = GPOINTER_TO_INT(g_hash_table_lookup(medicines, GINT_TO_POINTER(current)));\n            if (med_energy > energy) {\n                visited[current] = false;\n                g_queue_push_tail(queue, GINT_TO_POINTER(current));\n            }\n        }\n    }\n\n    g_queue_free(queue);\n    return false;\n}\n\nint main() {\n    read_input();\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                if (can_reach_goal(i, j, 0)) {\n                    printf(\"Yes\n\");\n                    g_hash_table_destroy(medicines);\n                    return 0;\n                }\n            }\n        }\n    }\n\n    printf(\"No\n\");\n    g_hash_table_destroy(medicines);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_viqa05_g/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_viqa05_g/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc348_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 100005\n\ntypedef struct {\n    int *children;\n    int num_children;\n} Node;\n\nNode nodes[MAXN];\nint C[MAXN];\nint N;\n\nvoid dfs(int node, int parent, int depth, int *sum, int *min_value) {\n    *sum += depth * C[node - 1];\n    if (*sum < *min_value) {\n        *min_value = *sum;\n    }\n    for (int i = 0; i < nodes[node].num_children; i++) {\n        int child = nodes[node].children[i];\n        if (child != parent) {\n            dfs(child, node, depth + 1, sum, min_value);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        nodes[i].children = NULL;\n        nodes[i].num_children = 0;\n    }\n    for (int i = 0; i < N - 1; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n        nodes[A].children = realloc(nodes[A].children, (nodes[A].num_children + 1) * sizeof(int));\n        nodes[A].children[nodes[A].num_children++] = B;\n        nodes[B].children = realloc(nodes[B].children, (nodes[B].num_children + 1) * sizeof(int));\n        nodes[B].children[nodes[B].num_children++] = A;\n    }\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &C[i - 1]);\n    }\n    int min_value = INT_MAX;\n    dfs(1, 0, 0, &min_value, &min_value);\n    printf(\"%d\n\", min_value);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4o22yvoj/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_4o22yvoj/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc349_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[100001], T[4];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int lenS = strlen(S);\n    int lenT = strlen(T);\n\n    // Check for subsequence of length 3\n    for (int i = 0; i <= lenS - 3; i++) {\n        char temp[4];\n        temp[0] = toupper(S[i]);\n        temp[1] = toupper(S[i + 1]);\n        temp[2] = toupper(S[i + 2]);\n        temp[3] = '\\0';\n        if (strcmp(temp, T) == 0) {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n\n    // Check for subsequence of length 2 with 'X' appended\n    for (int i = 0; i <= lenS - 2; i++) {\n        char temp[4];\n        temp[0] = toupper(S[i]);\n        temp[1] = toupper(S[i + 1]);\n        temp[2] = 'X';\n        temp[3] = '\\0';\n        if (strcmp(temp, T) == 0) {\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"No\\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_n7gq4obp/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_n7gq4obp/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc349_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *scores = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int sum = 0;\n    for (int i = 1; i < n; i++) {\n        int score;\n        scanf(\"%d\", &score);\n        sum += score;\n        g_hash_table_insert(scores, GINT_TO_POINTER(i), GINT_TO_POINTER(score));\n    }\n\n    int final_score = -sum;\n    printf(\"%d\n\", final_score);\n\n    g_hash_table_destroy(scores);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2bdbe2q_/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2bdbe2q_/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc349_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char str[1000];\n    scanf(\"%s\", str);\n\n    GHashTable *char_freq = g_hash_table_new(g_str_hash, g_str_equal);\n    GHashTable *freq_count = g_hash_table_new(g_int_hash, g_int_equal);\n\n    int len = strlen(str);\n    for (int i = 0; i < len; i++) {\n        char *ch = malloc(sizeof(char) * 2);\n        ch[0] = str[i];\n        ch[1] = '\\0';\n\n        int *count = g_hash_table_lookup(char_freq, ch);\n        if (count) {\n            (*count)++;\n        } else {\n            g_hash_table_insert(char_freq, ch, GINT_TO_POINTER(1));\n        }\n\n        free(ch);\n    }\n\n    int *values = malloc(sizeof(int) * 27);  // Assuming ASCII values for lowercase letters\n    memset(values, 0, sizeof(int) * 27);\n\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, char_freq);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int *char_count = (int*)value;\n        values[*char_count]++;\n    }\n\n    int valid = 1;\n    for (int i = 1; i < 27; i++) {\n        if (values[i] != 0 && values[i] != 2) {\n            valid = 0;\n            break;\n        }\n    }\n\n    if (valid) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    g_hash_table_destroy(char_freq);\n    g_hash_table_destroy(freq_count);\n    free(values);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_a8lq5n8h/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_a8lq5n8h/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc349_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    long long L, R;\n    scanf(\"%lld %lld\", &L, &R);\n\n    // Initialize variables\n    int M = 0;\n    GQueue *queue = g_queue_new();\n\n    // Find the minimum number of good sequences needed\n    for (long long i = 1; i <= R; i *= 2) {\n        if (L <= i && i <= R) {\n            M++;\n            g_queue_push_tail(queue, GINT_TO_POINTER(i));\n        }\n    }\n\n    // Print the number of good sequences\n    printf(\"%d\n\", M);\n\n    // Print the divisions\n    while (!g_queue_is_empty(queue)) {\n        long long l = g_queue_pop_head(queue);\n        long long r = l * 2 - 1;\n        printf(\"%lld %lld\n\", l, r);\n    }\n\n    // Clean up\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_o1dqf36p/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_o1dqf36p/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc349_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int grid[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    int sum = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            sum += grid[i][j];\n        }\n    }\n\n    if (sum % 2 == 1) {\n        printf(\"Takahashi\n\");\n    } else {\n        printf(\"Aoki\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_axddol_i/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_axddol_i/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc350_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char S[7];\n    scanf(\"%s\", S);\n\n    // Extract the digits from the string\n    int digits = atoi(&S[3]);\n\n    // Check if the digits are within the valid range\n    if ((digits >= 1 && digits <= 314) || (digits >= 317 && digits <= 349)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc350_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 1000000000000000000\n#define MAX_A 6\n#define MAX_X 1000000000\n#define MAX_Y 1000000000\n#define EPS 1e-6\n\ntypedef struct {\n    double cost;\n    bool computed;\n} MemoEntry;\n\nMemoEntry memo[MAX_N + 1];\n\ndouble expected_cost(long long n, int a, int x, int y) {\n    if (n == 0)\n        return 0.0;\n    if (memo[n].computed)\n        return memo[n].cost;\n\n    double min_cost = n / a * x;\n    for (int b = 1; b <= 6; b++) {\n        min_cost = fmin(min_cost, y + expected_cost(n / b, a, x, y));\n    }\n\n    memo[n].cost = min_cost;\n    memo[n].computed = true;\n    return min_cost;\n}\n\nint main() {\n    long long n;\n    int a, x, y;\n    scanf(\"%lld %d %d %d\", &n, &a, &x, &y);\n\n    for (int i = 0; i <= MAX_N; i++) {\n        memo[i].computed = false;\n    }\n\n    double result = expected_cost(n, a, x, y);\n    printf(\"%.15f\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_u1ydswlv/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_u1ydswlv/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc350_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    // Initialize a hash table to keep track of tooth presence in each hole\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initially, all holes have teeth, so set all values to 1\n    for (int i = 1; i <= n; i++) {\n        g_hash_table_insert(map, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n    }\n\n    // Process each treatment\n    for (int i = 0; i < q; i++) {\n        int t;\n        scanf(\"%d\", &t);\n\n        // Check if the hole has a tooth\n        gpointer value = g_hash_table_lookup(map, GINT_TO_POINTER(t));\n        int present = GPOINTER_TO_INT(value);\n\n        // If the hole has a tooth, remove it\n        if (present == 1) {\n            g_hash_table_insert(map, GINT_TO_POINTER(t), GINT_TO_POINTER(0));\n        } else {\n            // If the hole is empty, grow a tooth\n            g_hash_table_insert(map, GINT_TO_POINTER(t), GINT_TO_POINTER(1));\n        }\n    }\n\n    // Count the number of teeth remaining\n    int teeth_count = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, map);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int present = GPOINTER_TO_INT(value);\n        if (present == 1) {\n            teeth_count++;\n        }\n    }\n\n    // Output the number of teeth remaining\n    printf(\"%d\n\", teeth_count);\n\n    // Clean up\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_pn6ji9a6/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_pn6ji9a6/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc350_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GHashTable *pos = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < n; i++) {\n        g_hash_table_insert(pos, GINT_TO_POINTER(A[i]), GINT_TO_POINTER(i));\n    }\n\n    int swaps = 0;\n    int *visited = (int *)calloc(n, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        if (visited[i] || A[i] == i + 1) {\n            continue;\n        }\n\n        int cycle_size = 0;\n        int x = i;\n\n        while (!visited[x]) {\n            visited[x] = 1;\n            x = GPOINTER_TO_INT(g_hash_table_lookup(pos, GINT_TO_POINTER(x + 1)));\n            cycle_size++;\n        }\n\n        if (cycle_size > 0) {\n            swaps += (cycle_size - 1);\n        }\n    }\n\n    printf(\"%d\n\", swaps);\n\n    for (int i = 0; i < swaps; i++) {\n        int x = i + 1;\n        int y = GPOINTER_TO_INT(g_hash_table_lookup(pos, GINT_TO_POINTER(x + 1)));\n        printf(\"%d %d\n\", x, y);\n    }\n\n    free(A);\n    free(visited);\n    g_hash_table_destroy(pos);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_7znvhnt2/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_7znvhnt2/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc350_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Initialize adjacency list for the graph\n    GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i <= n; i++) {\n        g_hash_table_insert(adj_list, GINT_TO_POINTER(i), g_array_new(FALSE, FALSE, sizeof(int)));\n    }\n\n    // Build the graph from the input friendships\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        GArray *list_a = g_hash_table_lookup(adj_list, GINT_TO_POINTER(a));\n        GArray *list_b = g_hash_table_lookup(adj_list, GINT_TO_POINTER(b));\n        g_array_append_val(list_a, b);\n        g_array_append_val(list_b, a);\n    }\n\n    long long result = 0;\n\n    // For each user, count the number of triangles they can form\n    for (int i = 1; i <= n; i++) {\n        GArray *list_i = g_hash_table_lookup(adj_list, GINT_TO_POINTER(i));\n        for (int j = 0; j < list_i->len; j++) {\n            int y = g_array_index(list_i, int, j);\n            GArray *list_y = g_hash_table_lookup(adj_list, GINT_TO_POINTER(y));\n            for (int k = 0; k < list_y->len; k++) {\n                int z = g_array_index(list_y, int, k);\n                if (z != i && z != y && g_array_contains(list_i, z)) {\n                    result++;\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\n\", result);\n\n    // Clean up\n    for (int i = 1; i <= n; i++) {\n        GArray *list = g_hash_table_lookup(adj_list, GINT_TO_POINTER(i));\n        g_array_free(list, TRUE);\n    }\n    g_hash_table_destroy(adj_list);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_62rdqu8b/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_62rdqu8b/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc351_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int A[9], B[8];\n    int takahashi_total = 0, aoki_total = 0;\n\n    // Read input for Team Takahashi's scores\n    for (int i = 0; i < 9; i++) {\n        scanf(\"%d\", &A[i]);\n        takahashi_total += A[i];\n    }\n\n    // Read input for Team Aoki's scores\n    for (int i = 0; i < 8; i++) {\n        scanf(\"%d\", &B[i]);\n        aoki_total += B[i];\n    }\n\n    // Calculate the difference in scores at the end of the top of the ninth\n    int difference = takahashi_total - aoki_total;\n\n    // If Team Aoki has already won, print 0\n    if (difference > 0) {\n        printf(\"0\\n\");\n    } else {\n        // Find the minimum number of runs needed to win\n        int min_runs_needed = 1;\n        while (true) {\n            int aoki_ninth = min_runs_needed;\n            int new_aoki_total = aoki_total + aoki_ninth;\n            if (new_aoki_total > takahashi_total) {\n                printf(\"%d\\n\", aoki_ninth);\n                break;\n            }\n            min_runs_needed++;\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_9bbqj6x2/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_9bbqj6x2/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc351_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char A[n][n + 1];\n    char B[n][n + 1];\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", A[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", B[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (A[i][j] != B[i][j]) {\n                printf(\"%d %d\n\", i + 1, j + 1);\n                return 0;\n            }\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_qae1x15q/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_qae1x15q/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc351_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nint compare(const void *a, const void *b) {\n    return ((Point*)a)->x - ((Point*)b)->x;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    Point points[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    qsort(points, N, sizeof(Point), compare);\n\n    long long sum = 0;\n    long long prefix_sum = 0;\n\n    for (int i = 0; i < N; i++) {\n        prefix_sum += points[i].y;\n        for (int j = 0; j < i; j++) {\n            int dx = points[i].x - points[j].x;\n            int dy = points[i].y - points[j].y;\n            int dist = dx > dy ? dx : dy;\n            sum += dist;\n        }\n    }\n\n    printf(\"%lld\\n\", sum);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jlolk3ki/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jlolk3ki/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc351_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    // Create a prefix maximum array\n    GArray *prefix_max = g_array_new(FALSE, FALSE, sizeof(int));\n    int max = G_MININT;\n    for (int i = 0; i < n; i++) {\n        max = g_max(max, g_array_index(arr, int, i));\n        g_array_append_val(prefix_max, max);\n    }\n\n    long long result = 0;\n    for (int i = 0; i < n; i++) {\n        int current = g_array_index(arr, int, i);\n        int prefix = g_array_index(prefix_max, int, i);\n        result += (long long)prefix - current;\n    }\n\n    printf(\"%lld\n\", result);\n\n    g_array_free(arr, TRUE);\n    g_array_free(prefix_max, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_gr4du0rj/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_gr4du0rj/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc351_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize GQueue for the sequence of ball sizes\n    GQueue *queue = g_queue_new();\n\n    // Process each ball\n    for (int i = 0; i < n; i++) {\n        int A_i;\n        scanf(\"%d\", &A_i);\n        int size = 1 << A_i;  // Calculate the size of the ball\n\n        // Add the ball to the sequence\n        g_queue_push_tail(queue, GINT_TO_POINTER(size));\n\n        // Perform the merging operation\n        while (g_queue_get_length(queue) > 1) {\n            int rightmost = GPOINTER_TO_INT(g_queue_peek_tail(queue));\n            int second_rightmost = GPOINTER_TO_INT(g_queue_peek_nth(queue, -2));\n\n            if (rightmost != second_rightmost) {\n                break;  // Stop merging if sizes are different\n            }\n\n            // Remove the two rightmost balls\n            g_queue_pop_tail(queue);\n            g_queue_pop_tail(queue);\n\n            // Add a new ball with the sum of the sizes\n            int new_size = rightmost + second_rightmost;\n            g_queue_push_tail(queue, GINT_TO_POINTER(new_size));\n        }\n    }\n\n    // Output the number of balls remaining in the sequence\n    printf(\"%d\\n\", g_queue_get_length(queue));\n\n    // Clean up\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ruqwgl_2/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ruqwgl_2/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc351_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 1000\n\n// Directions for moving up, down, left, and right\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\n// Function to perform DFS and calculate the degree of freedom\nint dfs(char grid[MAX][MAX], int visited[MAX][MAX], int x, int y, int H, int W) {\n    if (x < 0 || x >= H || y < 0 || y >= W || visited[x][y] || grid[x][y] == '#') {\n        return 0;\n    }\n    visited[x][y] = 1;\n    int degree = 1; // Include the cell itself\n    for (int i = 0; i < 4; i++) {\n        degree += dfs(grid, visited, x + dx[i], y + dy[i], H, W);\n    }\n    return degree;\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    char grid[MAX][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int max_degree = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.') {\n                int visited[MAX][MAX] = {0};\n                int degree = dfs(grid, visited, i, j, H, W);\n                max_degree = (degree > max_degree) ? degree : max_degree;\n            }\n        }\n    }\n\n    printf(\"%d\n\", max_degree);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_riqhpxj8/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_riqhpxj8/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc352_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    return ((Edge *)a)->w - ((Edge *)b)->w;\n}\n\nbool is_connected(int *parent, int n) {\n    for (int i = 1; i <= n; i++) {\n        if (parent[i] != 1)\n            return false;\n    }\n    return true;\n}\n\nint find(int *parent, int i) {\n    if (parent[i] != i)\n        parent[i] = find(parent, parent[i]);\n    return parent[i];\n}\n\nvoid union_set(int *parent, int *rank, int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n\n    if (rank[xroot] < rank[yroot])\n        parent[xroot] = yroot;\n    else if (rank[xroot] > rank[yroot])\n        parent[yroot] = xroot;\n    else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GArray *edges = g_array_new(FALSE, FALSE, sizeof(Edge));\n\n    for (int i = 0; i < m; i++) {\n        int k, c;\n        scanf(\"%d %d\", &k, &c);\n\n        for (int j = 0; j < k; j++) {\n            int u;\n            scanf(\"%d\", &u);\n            if (j > 0) {\n                Edge e = {u, prev, c};\n                g_array_append_val(edges, e);\n            }\n            prev = u;\n        }\n    }\n\n    qsort(edges->data, edges->len, sizeof(Edge), compare);\n\n    int *parent = (int *)malloc((n + 1) * sizeof(int));\n    int *rank = (int *)malloc((n + 1) * sizeof(int));\n\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int total_weight = 0;\n\n    for (int i = 0; i < edges->len; i++) {\n        Edge e = g_array_index(edges, Edge, i);\n\n        int x = find(parent, e.u);\n        int y = find(parent, e.v);\n\n        if (x != y) {\n            union_set(parent, rank, x, y);\n            total_weight += e.w;\n        }\n    }\n\n    g_array_free(edges, TRUE);\n\n    if (!is_connected(parent, n)) {\n        printf(\"-1\n\");\n        free(parent);\n        free(rank);\n        return 0;\n    }\n\n    printf(\"%d\n\", total_weight);\n\n    free(parent);\n    free(rank);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_71ui_qm9/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_71ui_qm9/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc352_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, x, y, z;\n    scanf(\"%d %d %d %d\", &n, &x, &y, &z);\n\n    bool stops_at_z = false;\n\n    if (x < y) {\n        // Inbound train from station 1 to station N\n        stops_at_z = (z >= x && z <= y);\n    } else {\n        // Outbound train from station N to station 1\n        stops_at_z = (z >= y && z <= x);\n    }\n\n    if (stops_at_z) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8y0w7fd1/program.c: In function 'main':\\n/tmp/agnostics_c_8y0w7fd1/program.c:8:5: error: unknown type name 'bool'\\n    8 |     bool stops_at_z = false;\\n      |     ^~~~\\n/tmp/agnostics_c_8y0w7fd1/program.c:3:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n    2 | #include <stdlib.h>\\n  +++ |+#include <stdbool.h>\\n    3 | \\n/tmp/agnostics_c_8y0w7fd1/program.c:8:23: error: 'false' undeclared (first use in this function)\\n    8 |     bool stops_at_z = false;\\n      |                       ^~~~~\\n/tmp/agnostics_c_8y0w7fd1/program.c:8:23: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\\n/tmp/agnostics_c_8y0w7fd1/program.c:8:23: note: each undeclared identifier is reported only once for each function it appears in\\n/tmp/agnostics_c_8y0w7fd1/program.c:19:16: warning: missing terminating \\\" character\\n   19 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_8y0w7fd1/program.c:19:16: error: missing terminating \\\" character\\n   19 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_8y0w7fd1/program.c:20:1: warning: missing terminating \\\" character\\n   20 | \\\");\\n      | ^\\n/tmp/agnostics_c_8y0w7fd1/program.c:20:1: error: missing terminating \\\" character\\n   20 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_8y0w7fd1/program.c:21:5: error: expected expression before '}' token\\n   21 |     } else {\\n      |     ^\\n/tmp/agnostics_c_8y0w7fd1/program.c:19:16: error: expected ';' before '}' token\\n   19 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   20 | \\\");\\n   21 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_8y0w7fd1/program.c:22:16: warning: missing terminating \\\" character\\n   22 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_8y0w7fd1/program.c:22:16: error: missing terminating \\\" character\\n   22 |         printf(\\\"No\\n      |                ^~", "raw_stderr": "", "result": "fail"}
{"question_id": "abc352_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200000\n\ntypedef struct {\n    int a;\n    int b;\n} Giant;\n\nint compare(const void *a, const void *b) {\n    Giant *g1 = (Giant *)a;\n    Giant *g2 = (Giant *)b;\n    int diff1 = g1->b - g1->a;\n    int diff2 = g2->b - g2->a;\n    return diff2 - diff1;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Giant giants[MAX_N];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &giants[i].a, &giants[i].b);\n    }\n\n    qsort(giants, n, sizeof(Giant), compare);\n\n    long long max_height = 0;\n    for (int i = 0; i < n; i++) {\n        max_height += giants[i].b;\n    }\n\n    printf(\"%lld\n\", max_height);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_a3eyvl2a/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_a3eyvl2a/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc352_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[200001], T[200001];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int n = strlen(S);\n    int m = strlen(T);\n\n    GHashTable *map = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < n; i++) {\n        g_hash_table_insert(map, &S[i], GINT_TO_POINTER(1));\n    }\n\n    GQueue *queue = g_queue_new();\n\n    for (int i = 0; i < m; i++) {\n        if (g_hash_table_lookup(map, &T[i])) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(i + 1));\n        }\n    }\n\n    while (!g_queue_is_empty(queue)) {\n        int pos = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        printf(\"%d \", pos);\n    }\n\n    g_hash_table_destroy(map);\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4t_uqwhu/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_4t_uqwhu/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc352_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    // Read the permutation\n    int *P = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n\n    // Create a hash table to store the positions of elements in the permutation\n    GHashTable *pos = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        g_hash_table_insert(pos, GINT_TO_POINTER(P[i]), GINT_TO_POINTER(i));\n    }\n\n    int min_diff = N; // Initialize the minimum difference to a large value\n\n    // Iterate over all possible starting points for the good index sequence\n    for (int i = 0; i <= N - K; i++) {\n        // Find the next consecutive elements in the permutation\n        int next = P[i] + 1;\n        int count = 1;\n        while (count < K) {\n            if (g_hash_table_lookup(pos, GINT_TO_POINTER(next)) != NULL) {\n                next++;\n                count++;\n            } else {\n                break;\n            }\n        }\n\n        // If we found K consecutive elements, calculate the difference\n        if (count == K) {\n            int diff = g_hash_table_lookup(pos, GINT_TO_POINTER(next - 1)) - g_hash_table_lookup(pos, GINT_TO_POINTER(P[i]));\n            if (diff < min_diff) {\n                min_diff = diff;\n            }\n        }\n    }\n\n    // Output the minimum difference\n    printf(\"%d\n\", min_diff);\n\n    // Free the allocated memory\n    free(P);\n    g_hash_table_destroy(pos);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_bsqexo1e/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_bsqexo1e/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc353_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    long long total_sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n\n        // Calculate the remainder of a when divided by 10^8\n        int remainder = a % 100000000;\n\n        // Add the remainder to the total sum\n        total_sum += remainder;\n\n        // Update the count of this remainder in the hash table\n        gpointer count_ptr = g_hash_table_lookup(count, GINT_TO_POINTER(remainder));\n        if (count_ptr != NULL) {\n            int current_count = GPOINTER_TO_INT(count_ptr);\n            total_sum += (long long)remainder * current_count;\n        }\n\n        // Increment the count of this remainder in the hash table\n        g_hash_table_insert(count, GINT_TO_POINTER(remainder), GINT_TO_POINTER(1 + (count_ptr ? GPOINTER_TO_INT(count_ptr) : 0)));\n    }\n\n    // Print the total sum\n    printf(\"%lld\n\", total_sum);\n\n    // Clean up\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_afy51ooh/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_afy51ooh/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc353_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    GQueue *queue = g_queue_new();\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        g_queue_push_tail(queue, GINT_TO_POINTER(a));\n    }\n\n    int empty_seats = k;\n    int start_count = 0;\n\n    while (!g_queue_is_empty(queue)) {\n        int group_size = GPOINTER_TO_INT(g_queue_peek_head(queue));\n\n        if (group_size > empty_seats) {\n            start_count++;\n            empty_seats = k;\n        } else {\n            empty_seats -= group_size;\n            g_queue_pop_head(queue);\n        }\n    }\n\n    printf(\"%d\\n\", start_count);\n\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_uohugac7/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_uohugac7/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc353_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *heights = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n\n    int first_height = heights[0];\n    int position = -1;\n\n    for (int i = 1; i < n; i++) {\n        if (heights[i] > first_height) {\n            position = i + 1;\n            break;\n        }\n    }\n\n    printf(\"%d\n\", position);\n\n    free(heights);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_unp0qqju/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_unp0qqju/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc353_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *strings = g_array_new(FALSE, FALSE, sizeof(char*));\n    for (int i = 0; i < n; i++) {\n        char *str = malloc(1000 * sizeof(char));\n        scanf(\"%s\", str);\n        g_array_append_val(strings, str);\n    }\n\n    int total_length = 0;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            char *s1 = g_array_index(strings, char*, i);\n            char *s2 = g_array_index(strings, char*, j);\n\n            int len1 = strlen(s1);\n            int len2 = strlen(s2);\n\n            int common_length = 0;\n            for (int k = 0; k < len1 && k < len2; k++) {\n                if (s1[k] == s2[k]) {\n                    common_length++;\n                } else {\n                    break;\n                }\n            }\n\n            total_length += common_length;\n        }\n    }\n\n    printf(\"%d\n\", total_length);\n\n    // Clean up\n    for (int i = 0; i < n; i++) {\n        free(g_array_index(strings, char*, i));\n    }\n    g_array_free(strings, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ddy343hj/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ddy343hj/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc353_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        g_array_append_val(A, x);\n    }\n\n    long long sum = 0;\n\n    for (int i = 0; i < N; i++) {\n        int x = g_array_index(A, int, i);\n        long long count = 0;\n        for (int j = i + 1; j < N; j++) {\n            int y = g_array_index(A, int, j);\n            char z[20];\n            sprintf(z, \"%d%d\", x, y);\n            long long val = atoll(z);\n            sum = (sum + val) % MOD;\n        }\n    }\n\n    printf(\"%lld\\n\", sum);\n\n    g_array_free(A, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_qy8md1_9/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_qy8md1_9/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc354_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Define a structure to hold user data\ntypedef struct {\n    char name[17]; // 16 characters + 1 for null terminator\n    int rating;\n} User;\n\n// Comparison function for qsort to sort users by name\nint compare(const void *a, const void *b) {\n    User *user1 = (User *)a;\n    User *user2 = (User *)b;\n    return strcmp(user1->name, user2->name);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Allocate memory for the array of users\n    User *users = (User *)malloc(N * sizeof(User));\n\n    // Read user data\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s %d\", users[i].name, &users[i].rating);\n    }\n\n    // Sort users by name\n    qsort(users, N, sizeof(User), compare);\n\n    // Calculate the sum of ratings\n    int total_rating = 0;\n    for (int i = 0; i < N; i++) {\n        total_rating += users[i].rating;\n    }\n\n    // Determine the winner\n    int winner_index = total_rating % N;\n    printf(\"%s\n\", users[winner_index].name);\n\n    // Free allocated memory\n    free(users);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_3d163g3x/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_3d163g3x/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc354_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int H;\n    scanf(\"%d\", &H);\n\n    // Initialize variables\n    int day = 0;\n    int plant_height = 0;\n\n    // Loop until the plant's height exceeds Takahashi's height\n    while (plant_height <= H) {\n        day++;\n        plant_height += 1 << (day - 1);\n    }\n\n    // Output the result\n    printf(\"%d\n\", day);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_uloovjcg/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_uloovjcg/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc354_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Create a hash table to store the edges of the bipartite graph\n    GHashTable *edges = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the input and build the graph\n    for (int i = 0; i < N; i++) {\n        int A, B;\n        scanf(\"%d %d\", &A, &B);\n\n        // Add edges for both sides of the card\n        GArray *arrayA = g_hash_table_lookup(edges, GINT_TO_POINTER(A));\n        if (!arrayA) {\n            arrayA = g_array_new(FALSE, FALSE, sizeof(int));\n            g_hash_table_insert(edges, GINT_TO_POINTER(A), arrayA);\n        }\n        g_array_append_val(arrayA, B);\n\n        GArray *arrayB = g_hash_table_lookup(edges, GINT_TO_POINTER(B));\n        if (!arrayB) {\n            arrayB = g_array_new(FALSE, FALSE, sizeof(int));\n            g_hash_table_insert(edges, GINT_TO_POINTER(B), arrayB);\n        }\n        g_array_append_val(arrayB, A);\n    }\n\n    // Use a set to keep track of visited vertices\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Function to perform DFS and count connected components\n    int dfs(int vertex, GHashTable *edges, GHashTable *visited) {\n        if (g_hash_table_lookup(visited, GINT_TO_POINTER(vertex))) {\n            return 0;\n        }\n        g_hash_table_insert(visited, GINT_TO_POINTER(vertex), GINT_TO_POINTER(1));\n\n        GArray *neighbors = g_hash_table_lookup(edges, GINT_TO_POINTER(vertex));\n        if (neighbors) {\n            for (guint i = 0; i < neighbors->len; i++) {\n                int neighbor = g_array_index(neighbors, int, i);\n                dfs(neighbor, edges, visited);\n            }\n        }\n\n        return 1;\n    }\n\n    // Count the number of connected components\n    int components = 0;\n    for (int i = 1; i <= 1000000000; i++) { // Assuming the maximum value of A or B\n        if (!g_hash_table_lookup(visited, GINT_TO_POINTER(i))) {\n            components += dfs(i, edges, visited);\n        }\n    }\n\n    // Determine the winner based on the number of connected components\n    if (components % 2 == 1) {\n        printf(\"Takahashi\\n\");\n    } else {\n        printf(\"Aoki\\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(edges);\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_i9qk6cs6/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_i9qk6cs6/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc354_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Read input and store in arrays\n    int *A = (int *)malloc(N * sizeof(int));\n    int *C = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &C[i]);\n    }\n\n    // Sort the cards based on strength A\n    qsort(A, N, sizeof(int), compare);\n\n    // Use a GArray to store the indices of remaining cards\n    GArray *remaining = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Add the first card to the remaining list\n    g_array_append_val(remaining, 0);\n\n    // Iterate through the cards to find and discard cards\n    for (int i = 1; i < N; i++) {\n        int found = 0;\n        for (int j = 0; j < remaining->len; j++) {\n            int idx = g_array_index(remaining, int, j);\n            if (A[i] > A[idx] && C[i] < C[idx]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            g_array_append_val(remaining, i);\n        }\n    }\n\n    // Output the result\n    printf(\"%d\\n\", remaining->len);\n    for (int i = 0; i < remaining->len; i++) {\n        printf(\"%d \", g_array_index(remaining, int, i) + 1);\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    free(A);\n    free(C);\n    g_array_free(remaining, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_9ezs8wwm/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_9ezs8wwm/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc354_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int A, B, C, D;\n    scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n\n    int blackArea = 0;\n\n    for (int x = A; x < C; x++) {\n        for (int y = B; y < D; y++) {\n            if ((x + y) % 2 == 0 && (x % 2 == y % 2)) {\n                blackArea++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", blackArea * 2);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:timeout\", \"stdout\": \"\", \"stderr\": \"Test case 0 timed out after 15 seconds\\n\"}\n", "raw_stderr": "", "result": "fail:timeout", "stdout": "", "stderr": "Test case 0 timed out after 15 seconds\n"}
{"question_id": "abc355_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MOD 100\n\nvoid ask_question(int i, int j) {\n    printf(\"? %d %d\n\", i, j);\n    fflush(stdout);\n}\n\nint main() {\n    int N, L, R;\n    scanf(\"%d %d %d\", &N, &L, &R);\n\n    GHashTable *sums = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int i = 0;\n    int j = 0;\n    int size = 1 << N;\n\n    while (size > 1) {\n        int mid = L + (R - L) / 2;\n        ask_question(i, j);\n        int left_sum = 0;\n        int right_sum = 0;\n\n        for (int k = L; k <= mid; k++) {\n            left_sum += g_hash_table_lookup(sums, GINT_TO_POINTER(k)) ? GPOINTER_TO_INT(g_hash_table_lookup(sums, GINT_TO_POINTER(k))) : 0;\n        }\n\n        for (int k = mid + 1; k <= R; k++) {\n            right_sum += g_hash_table_lookup(sums, GINT_TO_POINTER(k)) ? GPOINTER_TO_INT(g_hash_table_lookup(sums, GINT_TO_POINTER(k))) : 0;\n        }\n\n        int total_sum = (left_sum + right_sum) % MOD;\n        g_hash_table_insert(sums, GINT_TO_POINTER(L), GINT_TO_POINTER(total_sum));\n\n        if (mid == L) {\n            R = mid;\n        } else {\n            L = mid + 1;\n        }\n\n        size /= 2;\n        j++;\n    }\n\n    int result = g_hash_table_lookup(sums, GINT_TO_POINTER(L)) ? GPOINTER_TO_INT(g_hash_table_lookup(sums, GINT_TO_POINTER(L))) : 0;\n    printf(\"! %d\n\", result);\n\n    g_hash_table_destroy(sums);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_5puldy0m/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_5puldy0m/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc355_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(m * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    int *c = (int *)malloc((n + m) * sizeof(int));\n    memcpy(c, a, n * sizeof(int));\n    memcpy(c + n, b, m * sizeof(int));\n\n    qsort(c, n + m, sizeof(int), compare);\n\n    bool found = false;\n\n    for (int i = 0; i < n + m - 1; i++) {\n        if (c[i] == c[i + 1] - 1) {\n            found = true;\n            break;\n        }\n    }\n\n    if (found) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    free(a);\n    free(b);\n    free(c);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0lqf8l8u/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0lqf8l8u/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc355_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, T;\n    scanf(\"%d %d\", &N, &T);\n\n    // Initialize the grid\n    int **grid = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        grid[i] = (int *)malloc(N * sizeof(int));\n        for (int j = 0; j < N; j++) {\n            grid[i][j] = N * (i - 1) + j + 1;\n        }\n    }\n\n    // Initialize hash tables to track marked cells in rows, columns, and diagonals\n    GHashTable *rows = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *cols = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *diag1 = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *diag2 = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initialize counters for marked cells in each row, column, and diagonal\n    for (int i = 0; i < N; i++) {\n        g_hash_table_insert(rows, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n        g_hash_table_insert(cols, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n    }\n    g_hash_table_insert(diag1, GINT_TO_POINTER(0), GINT_TO_POINTER(0));\n    g_hash_table_insert(diag2, GINT_TO_POINTER(0), GINT_TO_POINTER(0));\n\n    // Process each turn\n    for (int turn = 1; turn <= T; turn++) {\n        int A;\n        scanf(\"%d\", &A);\n\n        // Find the cell (i, j) containing A\n        int found = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (grid[i][j] == A) {\n                    // Mark the cell\n                    grid[i][j] = -1;\n\n                    // Increment the counter for the row and column\n                    int *row_count = (int *)g_hash_table_lookup(rows, GINT_TO_POINTER(i));\n                    int *col_count = (int *)g_hash_table_lookup(cols, GINT_TO_POINTER(j));\n                    (*row_count)++;\n                    (*col_count)++;\n\n                    // Check if the diagonal is marked\n                    if (i == j) {\n                        int *diag1_count = (int *)g_hash_table_lookup(diag1, GINT_TO_POINTER(0));\n                        (*diag1_count)++;\n                    }\n                    if (i + j == N - 1) {\n                        int *diag2_count = (int *)g_hash_table_lookup(diag2, GINT_TO_POINTER(0));\n                        (*diag2_count)++;\n                    }\n\n                    // Check for Bingo\n                    if (*row_count == N || *col_count == N || *diag1_count == N || *diag2_count == N) {\n                        printf(\"%d\\n\", turn);\n                        found = 1;\n                        break;\n                    }\n                }\n            }\n            if (found) {\n                break;\n            }\n        }\n\n        if (found) {\n            break;\n        }\n    }\n\n    // If no Bingo is achieved within T turns, print -1\n    if (!found) {\n        printf(\"-1\\n\");\n    }\n\n    // Free allocated memory\n    for (int i = 0; i < N; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n    g_hash_table_destroy(rows);\n    g_hash_table_destroy(cols);\n    g_hash_table_destroy(diag1);\n    g_hash_table_destroy(diag2);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jn6kactd/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jn6kactd/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc355_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n\n    // Check if Ringo and Snuke point to different suspects\n    if (A != B) {\n        // If they point to different suspects, the culprit can be uniquely identified\n        if (A == 1 && B == 2) {\n            printf(\"3\n\");\n        } else if (A == 1 && B == 3) {\n            printf(\"2\n\");\n        } else if (A == 2 && B == 1) {\n            printf(\"3\n\");\n        } else if (A == 2 && B == 3) {\n            printf(\"1\n\");\n        } else if (A == 3 && B == 1) {\n            printf(\"2\n\");\n        } else if (A == 3 && B == 2) {\n            printf(\"1\n\");\n        }\n    } else {\n        // If they point to the same suspect, the culprit cannot be uniquely identified\n        printf(\"-1\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4hlismda/program.c: In function 'main':\\n/tmp/agnostics_c_4hlismda/program.c:12:20: warning: missing terminating \\\" character\\n   12 |             printf(\\\"3\\n      |                    ^\\n/tmp/agnostics_c_4hlismda/program.c:12:20: error: missing terminating \\\" character\\n   12 |             printf(\\\"3\\n      |                    ^~\\n/tmp/agnostics_c_4hlismda/program.c:13:1: warning: missing terminating \\\" character\\n   13 | \\\");\\n      | ^\\n/tmp/agnostics_c_4hlismda/program.c:13:1: error: missing terminating \\\" character\\n   13 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_4hlismda/program.c:14:9: error: expected expression before '}' token\\n   14 |         } else if (A == 1 && B == 3) {\\n      |         ^\\n/tmp/agnostics_c_4hlismda/program.c:12:20: error: expected ';' before '}' token\\n   12 |             printf(\\\"3\\n      |                    ^\\n      |                    ;\\n   13 | \\\");\\n   14 |         } else if (A == 1 && B == 3) {\\n      |         ~           \\n/tmp/agnostics_c_4hlismda/program.c:15:20: warning: missing terminating \\\" character\\n   15 |             printf(\\\"2\\n      |                    ^\\n/tmp/agnostics_c_4hlismda/program.c:15:20: error: missing terminating \\\" character\\n   15 |             printf(\\\"2\\n      |                    ^~\\n/tmp/agnostics_c_4hlismda/program.c:16:1: warning: missing terminating \\\" character\\n   16 | \\\");\\n      | ^\\n/tmp/agnostics_c_4hlismda/program.c:16:1: error: missing terminating \\\" character\\n   16 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_4hlismda/program.c:17:9: error: expected expression before '}' token\\n   17 |         } else if (A == 2 && B == 1) {\\n      |         ^\\n/tmp/agnostics_c_4hlismda/program.c:15:20: error: expected ';' before '}' token\\n   15 |             printf(\\\"2\\n      |                    ^\\n      |                    ;\\n   16 | \\\");\\n   17 |         } else if (A == 2 && B == 1) {\\n      |         ~           \\n/tmp/agnostics_c_4hlismda/program.c", "raw_stderr": "", "result": "fail"}
{"question_id": "abc355_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *intervals = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        g_array_append_val(intervals, l);\n        g_array_append_val(intervals, r);\n    }\n\n    g_array_sort(intervals, compare);\n\n    int count = 0;\n    for (int i = 0; i < n * 2; i += 2) {\n        int l = g_array_index(intervals, int, i);\n        int r = g_array_index(intervals, int, i + 1);\n        int idx = g_array_index(intervals, int, i + 2);\n        if (idx >= n * 2) break;\n        int next_l = g_array_index(intervals, int, idx);\n        if (next_l <= r) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    g_array_free(intervals, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_f0j0poyo/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_f0j0poyo/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc356_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, L, R;\n    scanf(\"%d %d %d\", &N, &L, &R);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        A[i] = i + 1;\n    }\n\n    for (int i = L - 1, j = R - 1; i < j; i++, j--) {\n        int temp = A[i];\n        A[i] = A[j];\n        A[j] = temp;\n    }\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n\n    free(A);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc356_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Precompute the number of 1s in the binary representation of numbers with a given number of bits set to 1\n    int dp[61][61] = {0};\n    for (int i = 0; i <= 60; i++) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= 60; j++) {\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD;\n        }\n    }\n\n    // Compute the sum of the popcount of the bitwise AND of each number from 0 to n with m\n    long long sum = 0;\n    for (int i = 0; i <= n; i++) {\n        int k = 0;\n        for (int j = 0; j <= 60; j++) {\n            if ((i & (1 << j)) != 0) {\n                k++;\n            }\n        }\n        sum = (sum + dp[k][__builtin_popcount(m)]) % MOD;\n    }\n\n    // Print the result\n    printf(\"%lld\\n\", sum);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_gkfafz96/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_gkfafz96/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc356_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    GHashTable *max_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *min_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int max_val = arr[i] > arr[j] ? arr[i] : arr[j];\n            int min_val = arr[i] < arr[j] ? arr[i] : arr[j];\n\n            gpointer max_count_val = g_hash_table_lookup(max_count, GINT_TO_POINTER(max_val));\n            int max_count_int = max_count_val ? GPOINTER_TO_INT(max_count_val) : 0;\n            g_hash_table_insert(max_count, GINT_TO_POINTER(max_val), GINT_TO_POINTER(max_count_int + 1));\n\n            gpointer min_count_val = g_hash_table_lookup(min_count, GINT_TO_POINTER(min_val));\n            int min_count_int = min_count_val ? GPOINTER_TO_INT(min_count_val) : 0;\n            g_hash_table_insert(min_count, GINT_TO_POINTER(min_val), GINT_TO_POINTER(min_count_int + 1));\n        }\n    }\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        int max_val = arr[i];\n        int min_val = arr[i];\n\n        gpointer max_count_val = g_hash_table_lookup(max_count, GINT_TO_POINTER(max_val));\n        int max_count_int = max_count_val ? GPOINTER_TO_INT(max_count_val) : 0;\n\n        gpointer min_count_val = g_hash_table_lookup(min_count, GINT_TO_POINTER(min_val));\n        int min_count_int = min_count_val ? GPOINTER_TO_INT(min_count_val) : 0;\n\n        result += max_count_int - min_count_int;\n    }\n\n    printf(\"%d\\n\", result);\n\n    free(arr);\n    g_hash_table_destroy(max_count);\n    g_hash_table_destroy(min_count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_hzyj4j0g/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_hzyj4j0g/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc356_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 15\n#define MAX_M 100\n\n// Function to check if a combination of real keys satisfies the test results\nbool is_valid_combination(int n, int k, int *tests, char *results, int *combination, GHashTable *test_map) {\n    for (int i = 0; i < n; i++) {\n        if (combination[i] == 1) {\n            // If the key is real, check all tests involving this key\n            for (int j = 0; j < n; j++) {\n                if (combination[j] == 1) {\n                    // If both keys are real, check if they are in the same test\n                    for (int test = 0; test < n; test++) {\n                        if (tests[test * n + j] == 1 && tests[test * n + i] == 1) {\n                            if (results[test] == 'x') {\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    int tests[n * n];\n    char results[n];\n\n    // Read test cases\n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        for (int j = 0; j < c; j++) {\n            int key;\n            scanf(\"%d\", &key);\n            tests[i * n + key - 1] = 1;\n        }\n        scanf(\" %c\", &results[i]);\n    }\n\n    int combination[n];\n    memset(combination, 0, sizeof(combination));\n\n    int count = 0;\n\n    // Generate all combinations of real and dummy keys\n    for (int i = 0; i < (1 << n); i++) {\n        bool valid = true;\n        for (int j = 0; j < n; j++) {\n            combination[j] = (i >> j) & 1;\n        }\n\n        if (is_valid_combination(n, k, tests, results, combination, NULL)) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_qc11wqaf/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_qc11wqaf/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc356_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Array to store the daily goal for each nutrient\n    int goals[M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &goals[i]);\n    }\n\n    // Array to store the total intake for each nutrient\n    int intake[M] = {0};\n\n    // Read the intake from each food and update the total intake\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            int units;\n            scanf(\"%d\", &units);\n            intake[j] += units;\n        }\n    }\n\n    // Check if the intake meets the goal for each nutrient\n    bool met_goal = true;\n    for (int i = 0; i < M; i++) {\n        if (intake[i] < goals[i]) {\n            met_goal = false;\n            break;\n        }\n    }\n\n    // Print the result\n    if (met_goal) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0pd1hy7a/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0pd1hy7a/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc357_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid generateCarpet(char **carpet, int size, int offset) {\n    if (size == 1) {\n        carpet[offset][offset] = '#';\n        return;\n    }\n\n    int newSize = size / 3;\n\n    // Fill the central block with white cells\n    for (int i = offset; i < offset + newSize; i++) {\n        for (int j = offset; j < offset + newSize; j++) {\n            carpet[i][j] = '.';\n        }\n    }\n\n    // Fill the other eight blocks with level-(K-1) carpets\n    generateCarpet(carpet, newSize, offset);\n    generateCarpet(carpet, newSize, offset + newSize);\n    generateCarpet(carpet, newSize, offset + 2 * newSize);\n\n    generateCarpet(carpet, newSize, offset);\n    generateCarpet(carpet, newSize, offset + 2 * newSize);\n\n    generateCarpet(carpet, newSize, offset);\n    generateCarpet(carpet, newSize, offset + newSize);\n    generateCarpet(carpet, newSize, offset + 2 * newSize);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int size = 3 * (1 << N);\n    char **carpet = (char **)malloc(size * sizeof(char *));\n\n    for (int i = 0; i < size; i++) {\n        carpet[i] = (char *)malloc(size * sizeof(char));\n        memset(carpet[i], '.', size * sizeof(char));\n    }\n\n    generateCarpet(carpet, size, 0);\n\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++) {\n            printf(\"%c\", carpet[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    for (int i = 0; i < size; i++) {\n        free(carpet[i]);\n    }\n    free(carpet);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"###################################################################################################################################################################################################################################################\\n#.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.#\\n###################################################################################################################################################################################################################################################\\n###...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...###\\n#.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.##.#...#.#\\n###...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...######...###\\n###################################################################################################################################################################################################################################################\\n#.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.##.#\\n###########################################", "raw_stderr": "", "result": "fail"}
{"question_id": "abc357_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    int hands[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &hands[i]);\n    }\n\n    qsort(hands, N, sizeof(int), compare);\n\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        if (M >= hands[i]) {\n            M -= hands[i];\n            count++;\n        } else {\n            break;\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2s6g_zn0/program.c: In function 'main':\\n/tmp/agnostics_c_2s6g_zn0/program.c:29:12: warning: missing terminating \\\" character\\n   29 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_2s6g_zn0/program.c:29:12: error: missing terminating \\\" character\\n   29 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_2s6g_zn0/program.c:30:1: warning: missing terminating \\\" character\\n   30 | \\\", count);\\n      | ^\\n/tmp/agnostics_c_2s6g_zn0/program.c:30:1: error: missing terminating \\\" character\\n   30 | \\\", count);\\n      | ^~~~~~~~~~\\n/tmp/agnostics_c_2s6g_zn0/program.c:32:5: error: expected expression before 'return'\\n   32 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_2s6g_zn0/program.c:32:14: error: expected ';' before '}' token\\n   32 |     return 0;\\n      |              ^\\n      |              ;\\n   33 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2s6g_zn0/program.c: In function 'main':\n/tmp/agnostics_c_2s6g_zn0/program.c:29:12: warning: missing terminating \" character\n   29 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c_2s6g_zn0/program.c:29:12: error: missing terminating \" character\n   29 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c_2s6g_zn0/program.c:30:1: warning: missing terminating \" character\n   30 | \", count);\n      | ^\n/tmp/agnostics_c_2s6g_zn0/program.c:30:1: error: missing terminating \" character\n   30 | \", count);\n      | ^~~~~~~~~~\n/tmp/agnostics_c_2s6g_zn0/program.c:32:5: error: expected expression before 'return'\n   32 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_2s6g_zn0/program.c:32:14: error: expected ';' before '}' token\n   32 |     return 0;\n      |              ^\n      |              ;\n   33 | }\n      | ~             \n"}
{"question_id": "abc357_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    long long n;\n    scanf(\"%lld\", &n);\n\n    // Convert N to string for easy manipulation\n    char str[20];\n    sprintf(str, \"%lld\", n);\n    int len = strlen(str);\n\n    // Calculate the length of V_N as a string\n    long long len_vn = n * len;\n\n    // Calculate the remainder of V_N when divided by MOD\n    long long remainder = 0;\n    for (int i = 0; i < len_vn; i++) {\n        remainder = (remainder * 10 + (str[i % len] - '0')) % MOD;\n    }\n\n    // Print the result\n    printf(\"%lld\\n\", remainder);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_889ersvy/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_889ersvy/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc357_b", "solution": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    // Read input string\n    char str[1000];\n    scanf(\"%s\", str);\n\n    // Initialize counters for uppercase and lowercase letters\n    int upper_count = 0, lower_count = 0;\n\n    // Count the number of uppercase and lowercase letters\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (isupper(str[i])) {\n            upper_count++;\n        } else if (islower(str[i])) {\n            lower_count++;\n        }\n    }\n\n    // Convert the string based on the counts\n    if (upper_count > lower_count) {\n        // Convert all lowercase letters to uppercase\n        for (int i = 0; str[i] != '\\0'; i++) {\n            if (islower(str[i])) {\n                str[i] = toupper(str[i]);\n            }\n        }\n    } else {\n        // Convert all uppercase letters to lowercase\n        for (int i = 0; str[i] != '\\0'; i++) {\n            if (isupper(str[i])) {\n                str[i] = tolower(str[i]);\n            }\n        }\n    }\n\n    // Output the modified string\n    printf(\"%s\\n\", str);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc357_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int *visited = (int *)calloc(n, sizeof(int));\n    int total_pairs = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (visited[i]) continue;\n\n        GQueue *queue = g_queue_new();\n        g_queue_push_tail(queue, GINT_TO_POINTER(i));\n        int count = 0;\n\n        while (!g_queue_is_empty(queue)) {\n            int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n            if (visited[current]) continue;\n\n            visited[current] = 1;\n            count++;\n\n            int next = a[current] - 1;\n            if (next == current) {\n                break;\n            }\n\n            g_queue_push_tail(queue, GINT_TO_POINTER(next));\n        }\n\n        total_pairs += count * (n - count);\n        g_queue_free(queue);\n    }\n\n    printf(\"%d\n\", total_pairs);\n\n    free(a);\n    free(visited);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_urxsu9va/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_urxsu9va/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc358_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint dp[1001][27];\nGHashTable *memo;\n\nint countStrings(int length, int letter) {\n    if (length == 0) return 1;\n    if (letter == 0) return 0;\n    if (dp[length][letter] != -1) return dp[length][letter];\n\n    int result = 0;\n    for (int i = 0; i <= GPOINTER_TO_INT(g_hash_table_lookup(memo, GINT_TO_POINTER(letter))); i++) {\n        result = (result + countStrings(length - 1, letter - 1)) % MOD;\n    }\n    dp[length][letter] = result;\n    return result;\n}\n\nint main() {\n    int K;\n    scanf(\"%d\", &K);\n\n    memo = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int C[26];\n    for (int i = 0; i < 26; i++) {\n        scanf(\"%d\", &C[i]);\n        g_hash_table_insert(memo, GINT_TO_POINTER(i + 1), GINT_TO_POINTER(C[i]));\n    }\n\n    memset(dp, -1, sizeof(dp));\n\n    int total = 0;\n    for (int i = 1; i <= K; i++) {\n        total = (total + countStrings(i, 26)) % MOD;\n    }\n\n    printf(\"%d\n\", total);\n\n    g_hash_table_destroy(memo);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ke64h8xm/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ke64h8xm/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc358_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 10\n#define MAXM 10\n\nint n, m;\nchar stands[MAXN][MAXM + 1];\n\nbool visited[MAXN];\nbool dfs(int stand, int *match, bool adj[MAXN][MAXM]) {\n    for (int flavor = 0; flavor < m; flavor++) {\n        if (adj[stand][flavor] && !visited[flavor]) {\n            visited[flavor] = true;\n            if (match[flavor] == -1 || dfs(match[flavor], match, adj)) {\n                match[flavor] = stand;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint hungarian(bool adj[MAXN][MAXM]) {\n    int match[MAXM];\n    memset(match, -1, sizeof(match));\n    int result = 0;\n    for (int stand = 0; stand < n; stand++) {\n        memset(visited, false, sizeof(visited));\n        if (dfs(stand, match, adj)) {\n            result++;\n        }\n    }\n    return result;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", stands[i]);\n    }\n\n    bool adj[MAXN][MAXM] = {false};\n    for (int stand = 0; stand < n; stand++) {\n        for (int flavor = 0; flavor < m; flavor++) {\n            if (stands[stand][flavor] == 'o') {\n                adj[stand][flavor] = true;\n            }\n        }\n    }\n\n    int max_match = hungarian(adj);\n    int min_stands = m - max_match;\n    printf(\"%d\\n\", min_stands);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_rhc7o_d_/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_rhc7o_d_/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc358_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, a;\n    scanf(\"%d %d\", &n, &a);\n\n    GQueue *queue = g_queue_new();\n    int *arrival_times = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arrival_times[i]);\n    }\n\n    int current_time = 0;\n    for (int i = 0; i < n; i++) {\n        if (g_queue_is_empty(queue)) {\n            current_time = arrival_times[i];\n        } else {\n            current_time = g_queue_peek_tail(queue) + a;\n        }\n        g_queue_push_tail(queue, GINT_TO_POINTER(current_time + a));\n        printf(\"%d\n\", current_time);\n    }\n\n    g_queue_free(queue);\n    free(arrival_times);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_shscq8wv/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_shscq8wv/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc358_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(m * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    qsort(a, n, sizeof(int), compare);\n\n    int min_cost = 0;\n    int i = 0;\n\n    for (int j = 0; j < m; j++) {\n        while (i < n && a[i] < b[j]) {\n            i++;\n        }\n\n        if (i == n) {\n            min_cost = -1;\n            break;\n        }\n\n        min_cost += a[i];\n        i++;\n    }\n\n    printf(\"%d\\n\", min_cost);\n\n    free(a);\n    free(b);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_l6cekat3/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_l6cekat3/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc358_a", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[11], T[11];\n    scanf(\"%s %s\", S, T);\n\n    if (strcmp(S, \"AtCoder\") == 0 && strcmp(T, \"Land\") == 0) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc359_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long long sx, sy, tx, ty;\n    scanf(\"%lld %lld\", &sx, &sy);\n    scanf(\"%lld %lld\", &tx, &ty);\n\n    // Calculate the Manhattan distance in terms of tiles\n    long long dx = abs(tx - sx);\n    long long dy = abs(ty - sy);\n\n    // The minimum toll is the sum of the distances in the x and y directions\n    long long min_toll = dx + dy;\n\n    printf(\"%lld\n\", min_toll);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_s1extxo1/program.c: In function 'main':\\n/tmp/agnostics_c_s1extxo1/program.c:16:12: warning: missing terminating \\\" character\\n   16 |     printf(\\\"%lld\\n      |            ^\\n/tmp/agnostics_c_s1extxo1/program.c:16:12: error: missing terminating \\\" character\\n   16 |     printf(\\\"%lld\\n      |            ^~~~~\\n/tmp/agnostics_c_s1extxo1/program.c:17:1: warning: missing terminating \\\" character\\n   17 | \\\", min_toll);\\n      | ^\\n/tmp/agnostics_c_s1extxo1/program.c:17:1: error: missing terminating \\\" character\\n   17 | \\\", min_toll);\\n      | ^~~~~~~~~~~~~\\n/tmp/agnostics_c_s1extxo1/program.c:19:5: error: expected expression before 'return'\\n   19 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_s1extxo1/program.c:19:14: error: expected ';' before '}' token\\n   19 |     return 0;\\n      |              ^\\n      |              ;\\n   20 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_s1extxo1/program.c: In function 'main':\n/tmp/agnostics_c_s1extxo1/program.c:16:12: warning: missing terminating \" character\n   16 |     printf(\"%lld\n      |            ^\n/tmp/agnostics_c_s1extxo1/program.c:16:12: error: missing terminating \" character\n   16 |     printf(\"%lld\n      |            ^~~~~\n/tmp/agnostics_c_s1extxo1/program.c:17:1: warning: missing terminating \" character\n   17 | \", min_toll);\n      | ^\n/tmp/agnostics_c_s1extxo1/program.c:17:1: error: missing terminating \" character\n   17 | \", min_toll);\n      | ^~~~~~~~~~~~~\n/tmp/agnostics_c_s1extxo1/program.c:19:5: error: expected expression before 'return'\n   19 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_s1extxo1/program.c:19:14: error: expected ';' before '}' token\n   19 |     return 0;\n      |              ^\n      |              ;\n   20 | }\n      | ~             \n"}
{"question_id": "abc359_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create a hash table to store the positions of each color\n    GHashTable *positions = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the input and store the positions of each color\n    for (int i = 0; i < 2 * n; i++) {\n        int color;\n        scanf(\"%d\", &color);\n\n        // If the color is already in the hash table, store its position\n        if (g_hash_table_contains(positions, GINT_TO_POINTER(color))) {\n            GArray *pos_arr = g_hash_table_lookup(positions, GINT_TO_POINTER(color));\n            g_array_append_val(pos_arr, i);\n        } else {\n            // Otherwise, create a new array for this color and store the position\n            GArray *pos_arr = g_array_new(FALSE, FALSE, sizeof(int));\n            g_array_append_val(pos_arr, i);\n            g_hash_table_insert(positions, GINT_TO_POINTER(color), pos_arr);\n        }\n    }\n\n    // Initialize the result counter\n    int result = 0;\n\n    // Iterate over the colors and check the condition\n    for (int i = 1; i <= n; i++) {\n        // Get the positions of the current color\n        GArray *pos_arr = g_hash_table_lookup(positions, GINT_TO_POINTER(i));\n\n        // Check if there are exactly two positions for this color\n        if (pos_arr && pos_arr->len == 2) {\n            int pos1 = g_array_index(pos_arr, int, 0);\n            int pos2 = g_array_index(pos_arr, int, 1);\n\n            // Check if there is exactly one person between the two positions\n            if (abs(pos1 - pos2) == 3) {\n                result++;\n            }\n        }\n    }\n\n    // Output the result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_hash_table_destroy(positions);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_m5wyh42b/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_m5wyh42b/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc359_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *h = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(h, value);\n    }\n\n    GArray *a = g_array_new(FALSE, FALSE, sizeof(long long));\n    g_array_append_val(a, 0);\n\n    for (int i = 1; i <= n; i++) {\n        g_array_append_val(a, 0);\n    }\n\n    long long operations = 0;\n    for (int i = 1; i <= n; i++) {\n        int h_i = g_array_index(h, int, i - 1);\n        long long a_i = g_array_index(a, long long, i);\n\n        while (a_i <= 0) {\n            a_i++;\n            operations++;\n\n            for (int j = i; j > 0; j--) {\n                long long a_j = g_array_index(a, long long, j);\n                long long a_j_minus_1 = g_array_index(a, long long, j - 1);\n\n                if (a_j_minus_1 > a_j && a_j_minus_1 > h_i) {\n                    a_j_minus_1--;\n                    a_j++;\n                    operations++;\n                }\n            }\n        }\n\n        g_array_index(a, long long, i) = a_i;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        printf(\"%lld \", g_array_index(a, long long, i));\n    }\n    printf(\"\\n\");\n\n    g_array_free(h, TRUE);\n    g_array_free(a, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_1xegq7_t/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_1xegq7_t/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc359_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Use a GHashTable to count occurrences of 'Takahashi'\n    GHashTable *count = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < n; i++) {\n        char str[1000];\n        scanf(\"%s\", str);\n\n        // If the string is 'Takahashi', increment the count\n        if (strcmp(str, \"Takahashi\") == 0) {\n            int current_count = GPOINTER_TO_INT(g_hash_table_lookup(count, \"Takahashi\")) + 1;\n            g_hash_table_insert(count, \"Takahashi\", GINT_TO_POINTER(current_count));\n        }\n    }\n\n    // Get the count of 'Takahashi'\n    int result = GPOINTER_TO_INT(g_hash_table_lookup(count, \"Takahashi\"));\n\n    // Print the result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_yrkddg7f/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_yrkddg7f/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc359_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    // Initialize DP table\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_append_val(dp, 1);\n\n    // Initialize prefix sum array for palindrome checks\n    GArray *prefix_sum = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_append_val(prefix_sum, 0);\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '?') {\n            // Calculate the number of good strings ending with 'A' and 'B'\n            int count_a = 0, count_b = 0;\n            for (int j = 0; j < dp->len; j++) {\n                count_a = (count_a + g_array_index(dp, int, j)) % MOD;\n                count_b = (count_b + g_array_index(dp, int, j)) % MOD;\n            }\n            g_array_append_val(dp, count_a);\n            g_array_append_val(dp, count_b);\n        } else {\n            // Update DP table based on the current character\n            int count = 0;\n            for (int j = 0; j < dp->len; j++) {\n                count = (count + g_array_index(dp, int, j)) % MOD;\n            }\n            g_array_append_val(dp, count);\n        }\n    }\n\n    // Calculate the number of good strings\n    int result = 0;\n    for (int i = 0; i < dp->len; i++) {\n        result = (result + g_array_index(dp, int, i)) % MOD;\n    }\n\n    // Output the result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_array_free(dp, TRUE);\n    g_array_free(prefix_sum, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_vli7f09w/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_vli7f09w/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc360_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    int *W = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &W[i]);\n    }\n\n    int *box_to_item = (int *)calloc(n + 1, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        box_to_item[A[i]] = i;\n    }\n\n    int *item_to_box = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        item_to_box[i] = i + 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        int item = A[i];\n        int box = item_to_box[item];\n        if (box != i + 1) {\n            int target_box = i + 1;\n            int target_item = box_to_item[target_box];\n\n            // Swap items\n            int temp_item = A[item_to_box[target_box]];\n            int temp_weight = W[item_to_box[target_box]];\n\n            A[item_to_box[target_box]] = A[i];\n            W[item_to_box[target_box]] = W[i];\n\n            A[i] = temp_item;\n            W[i] = temp_weight;\n\n            // Update mappings\n            box_to_item[item] = target_box;\n            item_to_box[target_box] = item;\n            box_to_item[target_item] = i + 1;\n            item_to_box[i + 1] = target_item;\n        }\n    }\n\n    int total_cost = 0;\n    for (int i = 0; i < n; i++) {\n        total_cost += W[i];\n    }\n\n    printf(\"%d\\n\", total_cost);\n\n    free(A);\n    free(W);\n    free(box_to_item);\n    free(item_to_box);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_499bu8dq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_499bu8dq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc360_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S[101], T[101];\n    scanf(\"%s %s\", S, T);\n\n    int len_S = strlen(S);\n    int len_T = strlen(T);\n\n    // Iterate over possible values of w\n    for (int w = 1; w < len_S; w++) {\n        // Iterate over possible values of c\n        for (int c = 1; c <= len_T; c++) {\n            // Check if the condition is satisfied\n            char result[len_T + 1];\n            result[len_T] = '\\0';\n\n            for (int i = 0; i < len_S; i += w) {\n                if (i + c < len_S + 1) {\n                    result[i / w] = S[i + c - 1];\n                }\n            }\n\n            if (strcmp(result, T) == 0) {\n                printf(\"Yes\n\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"No\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_hyiqe__c/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_hyiqe__c/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc360_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    // The expected value of the position of the black ball after K operations is 1\n    int expected_value = 1;\n\n    // Output the result modulo 998244353\n    printf(\"%d\n\", expected_value % 998244353);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_c69iannl/program.c: In function 'main':\\n/tmp/agnostics_c_c69iannl/program.c:12:12: warning: missing terminating \\\" character\\n   12 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_c69iannl/program.c:12:12: error: missing terminating \\\" character\\n   12 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_c69iannl/program.c:13:1: warning: missing terminating \\\" character\\n   13 | \\\", expected_value % 998244353);\\n      | ^\\n/tmp/agnostics_c_c69iannl/program.c:13:1: error: missing terminating \\\" character\\n   13 | \\\", expected_value % 998244353);\\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_c69iannl/program.c:15:5: error: expected expression before 'return'\\n   15 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_c69iannl/program.c:15:14: error: expected ';' before '}' token\\n   15 |     return 0;\\n      |              ^\\n      |              ;\\n   16 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_c69iannl/program.c: In function 'main':\n/tmp/agnostics_c_c69iannl/program.c:12:12: warning: missing terminating \" character\n   12 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c_c69iannl/program.c:12:12: error: missing terminating \" character\n   12 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c_c69iannl/program.c:13:1: warning: missing terminating \" character\n   13 | \", expected_value % 998244353);\n      | ^\n/tmp/agnostics_c_c69iannl/program.c:13:1: error: missing terminating \" character\n   13 | \", expected_value % 998244353);\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/agnostics_c_c69iannl/program.c:15:5: error: expected expression before 'return'\n   15 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_c69iannl/program.c:15:14: error: expected ';' before '}' token\n   15 |     return 0;\n      |              ^\n      |              ;\n   16 | }\n      | ~             \n"}
{"question_id": "abc360_a", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    // Read input string S\n    char S[4];  // Array to hold the string (3 characters + null terminator)\n    scanf(\"%s\", S);\n\n    // Initialize variables to store positions of R and M\n    int posR = -1, posM = -1;\n\n    // Iterate through the string to find positions of R and M\n    for (int i = 0; i < 3; i++) {\n        if (S[i] == 'R') {\n            posR = i;\n        } else if (S[i] == 'M') {\n            posM = i;\n        }\n    }\n\n    // Check if R is to the left of M\n    if (posR < posM) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_usbn87c_/program.c: In function 'main':\\n/tmp/agnostics_c_usbn87c_/program.c:23:16: warning: missing terminating \\\" character\\n   23 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_usbn87c_/program.c:23:16: error: missing terminating \\\" character\\n   23 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_usbn87c_/program.c:24:1: warning: missing terminating \\\" character\\n   24 | \\\");\\n      | ^\\n/tmp/agnostics_c_usbn87c_/program.c:24:1: error: missing terminating \\\" character\\n   24 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_usbn87c_/program.c:25:5: error: expected expression before '}' token\\n   25 |     } else {\\n      |     ^\\n/tmp/agnostics_c_usbn87c_/program.c:23:16: error: expected ';' before '}' token\\n   23 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   24 | \\\");\\n   25 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_usbn87c_/program.c:26:16: warning: missing terminating \\\" character\\n   26 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_usbn87c_/program.c:26:16: error: missing terminating \\\" character\\n   26 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_usbn87c_/program.c:27:1: warning: missing terminating \\\" character\\n   27 | \\\");\\n      | ^\\n/tmp/agnostics_c_usbn87c_/program.c:27:1: error: missing terminating \\\" character\\n   27 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_usbn87c_/program.c:28:5: error: expected expression before '}' token\\n   28 |     }\\n      |     ^\\n/tmp/agnostics_c_usbn87c_/program.c:26:16: error: expected ';' before '}' token\\n   26 |         printf(\\\"No\\n      |                ^\\n      |                ;\\n   27 | \\\");\\n   28 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_usbn87c_/program.c: In function 'main':\n/tmp/agnostics_c_usbn87c_/program.c:23:16: warning: missing terminating \" character\n   23 |         printf(\"Yes\n      |                ^\n/tmp/agnostics_c_usbn87c_/program.c:23:16: error: missing terminating \" character\n   23 |         printf(\"Yes\n      |                ^~~~\n/tmp/agnostics_c_usbn87c_/program.c:24:1: warning: missing terminating \" character\n   24 | \");\n      | ^\n/tmp/agnostics_c_usbn87c_/program.c:24:1: error: missing terminating \" character\n   24 | \");\n      | ^~~\n/tmp/agnostics_c_usbn87c_/program.c:25:5: error: expected expression before '}' token\n   25 |     } else {\n      |     ^\n/tmp/agnostics_c_usbn87c_/program.c:23:16: error: expected ';' before '}' token\n   23 |         printf(\"Yes\n      |                ^\n      |                ;\n   24 | \");\n   25 |     } else {\n      |     ~           \n/tmp/agnostics_c_usbn87c_/program.c:26:16: warning: missing terminating \" character\n   26 |         printf(\"No\n      |                ^\n/tmp/agnostics_c_usbn87c_/program.c:26:16: error: missing terminating \" character\n   26 |         printf(\"No\n      |                ^~~\n/tmp/agnostics_c_usbn87c_/program.c:27:1: warning: missing terminating \" character\n   27 | \");\n      | ^\n/tmp/agnostics_c_usbn87c_/program.c:27:1: error: missing terminating \" character\n   27 | \");\n      | ^~~\n/tmp/agnostics_c_usbn87c_/program.c:28:5: error: expected expression before '}' token\n   28 |     }\n      |     ^\n/tmp/agnostics_c_usbn87c_/program.c:26:16: error: expected ';' before '}' token\n   26 |         printf(\"No\n      |                ^\n      |                ;\n   27 | \");\n   28 |     }\n      |     ~           \n"}
{"question_id": "abc360_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, T;\n    scanf(\"%d %d\", &N, &T);\n    char S[N+1];\n    scanf(\"%s\", S);\n    int X[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    GHashTable *hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        g_hash_table_insert(hash, GINT_TO_POINTER(X[i]), GINT_TO_POINTER(i));\n    }\n\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        int x = X[i];\n        int dir = S[i] - '0';\n        for (int j = i + 1; j < N; j++) {\n            int y = X[j];\n            int d = S[j] - '0';\n            if (dir != d) {\n                int time = abs(x - y);\n                if (time <= T) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    g_hash_table_destroy(hash);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_cg_26qcj/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_cg_26qcj/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc361_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 15\n\nint min_operations(int N, char *S, char *T) {\n    int operations = 0;\n    for (int i = 0; i < N; i++) {\n        if (S[i] != T[i]) {\n            int j = i + 1;\n            while (j < N && S[j] != T[i]) {\n                j++;\n            }\n            if (j == N) {\n                return -1;\n            }\n            for (int k = j; k > i; k--) {\n                char temp = S[k];\n                S[k] = S[k - 1];\n                S[k - 1] = temp;\n                operations++;\n            }\n        }\n    }\n    return operations;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char S[MAX_N], T[MAX_N];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n    int result = min_operations(N, S, T);\n    printf(\"%d\n\", result);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_uqnbdwmy/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_uqnbdwmy/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc361_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int a, b, c, d, e, f, g, h, i, j, k, l;\n\n    // Read input\n    scanf(\"%d %d %d %d %d %d\", &a, &b, &c, &d, &e, &f);\n    scanf(\"%d %d %d %d %d %d\", &g, &h, &i, &j, &k, &l);\n\n    // Check if there is overlap in all three dimensions\n    if (d > g && a < j && e > h && b < k && f > i && c < l) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0e6j1fz6/program.c: In function 'main':\\n/tmp/agnostics_c_0e6j1fz6/program.c:13:16: warning: missing terminating \\\" character\\n   13 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_0e6j1fz6/program.c:13:16: error: missing terminating \\\" character\\n   13 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_0e6j1fz6/program.c:14:1: warning: missing terminating \\\" character\\n   14 | \\\");\\n      | ^\\n/tmp/agnostics_c_0e6j1fz6/program.c:14:1: error: missing terminating \\\" character\\n   14 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_0e6j1fz6/program.c:15:5: error: expected expression before '}' token\\n   15 |     } else {\\n      |     ^\\n/tmp/agnostics_c_0e6j1fz6/program.c:13:16: error: expected ';' before '}' token\\n   13 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   14 | \\\");\\n   15 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_0e6j1fz6/program.c:16:16: warning: missing terminating \\\" character\\n   16 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_0e6j1fz6/program.c:16:16: error: missing terminating \\\" character\\n   16 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_0e6j1fz6/program.c:17:1: warning: missing terminating \\\" character\\n   17 | \\\");\\n      | ^\\n/tmp/agnostics_c_0e6j1fz6/program.c:17:1: error: missing terminating \\\" character\\n   17 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_0e6j1fz6/program.c:18:5: error: expected expression before '}' token\\n   18 |     }\\n      |     ^\\n/tmp/agnostics_c_0e6j1fz6/program.c:16:16: error: expected ';' before '}' token\\n   16 |         printf(\\\"No\\n      |                ^\\n      |                ;\\n   17 | \\\");\\n   18 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0e6j1fz6/program.c: In function 'main':\n/tmp/agnostics_c_0e6j1fz6/program.c:13:16: warning: missing terminating \" character\n   13 |         printf(\"Yes\n      |                ^\n/tmp/agnostics_c_0e6j1fz6/program.c:13:16: error: missing terminating \" character\n   13 |         printf(\"Yes\n      |                ^~~~\n/tmp/agnostics_c_0e6j1fz6/program.c:14:1: warning: missing terminating \" character\n   14 | \");\n      | ^\n/tmp/agnostics_c_0e6j1fz6/program.c:14:1: error: missing terminating \" character\n   14 | \");\n      | ^~~\n/tmp/agnostics_c_0e6j1fz6/program.c:15:5: error: expected expression before '}' token\n   15 |     } else {\n      |     ^\n/tmp/agnostics_c_0e6j1fz6/program.c:13:16: error: expected ';' before '}' token\n   13 |         printf(\"Yes\n      |                ^\n      |                ;\n   14 | \");\n   15 |     } else {\n      |     ~           \n/tmp/agnostics_c_0e6j1fz6/program.c:16:16: warning: missing terminating \" character\n   16 |         printf(\"No\n      |                ^\n/tmp/agnostics_c_0e6j1fz6/program.c:16:16: error: missing terminating \" character\n   16 |         printf(\"No\n      |                ^~~\n/tmp/agnostics_c_0e6j1fz6/program.c:17:1: warning: missing terminating \" character\n   17 | \");\n      | ^\n/tmp/agnostics_c_0e6j1fz6/program.c:17:1: error: missing terminating \" character\n   17 | \");\n      | ^~~\n/tmp/agnostics_c_0e6j1fz6/program.c:18:5: error: expected expression before '}' token\n   18 |     }\n      |     ^\n/tmp/agnostics_c_0e6j1fz6/program.c:16:16: error: expected ';' before '}' token\n   16 |         printf(\"No\n      |                ^\n      |                ;\n   17 | \");\n   18 |     }\n      |     ~           \n"}
{"question_id": "abc361_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N, K, X;\n    scanf(\"%d %d %d\", &N, &K, &X);\n\n    // Initialize GArray to store the sequence A\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Read the sequence A\n    for (int i = 0; i < N; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(A, value);\n    }\n\n    // Insert X immediately after the K-th element\n    if (K > 0 && K <= N) {\n        g_array_insert_val(A, K, X);\n    }\n\n    // Print the resulting sequence B\n    for (int i = 0; i < A->len; i++) {\n        printf(\"%d \", g_array_index(A, int, i));\n    }\n    printf(\"\\n\");\n\n    // Free the allocated memory\n    g_array_free(A, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ycqo8pux/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ycqo8pux/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc361_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    long long N;\n    scanf(\"%lld\", &N);\n\n    // Use a hash set to avoid counting duplicates\n    GHashTable *set = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Iterate through possible values of a\n    for (long long a = 2; a * a <= N; a++) {\n        long long power = a * a;\n        // Iterate through possible values of b\n        while (power <= N) {\n            g_hash_table_insert(set, GINT_TO_POINTER(power), GINT_TO_POINTER(1));\n            power *= a;\n        }\n    }\n\n    // Count the number of unique elements in the set\n    int result = g_hash_table_size(set);\n\n    // Output result\n    printf(\"%d\n\", result);\n\n    // Clean up\n    g_hash_table_destroy(set);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_lhmxnwjj/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_lhmxnwjj/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc361_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    qsort(a, n, sizeof(int), compare);\n\n    int min_diff = INT_MAX;\n    for (int i = 0; i <= n - k; i++) {\n        int max_val = a[i + k - 1];\n        int min_val = a[i];\n        int diff = max_val - min_val;\n        if (diff < min_diff) {\n            min_diff = diff;\n        }\n    }\n\n    printf(\"%d\n\", min_diff);\n\n    free(a);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_foh4zge8/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_foh4zge8/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc361_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_CITIES 200000\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int graph[MAX_CITIES][MAX_CITIES] = {0};\n    for (int i = 0; i < n - 1; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        graph[a - 1][b - 1] = c;\n        graph[b - 1][a - 1] = c;\n    }\n\n    int *visited = (int *)calloc(n, sizeof(int));\n    int *path = (int *)malloc(n * sizeof(int));\n    int total_distance = 0;\n\n    visited[0] = 1;\n    path[0] = 1;\n    int current_city = 0;\n\n    for (int i = 1; i < n; i++) {\n        int min_distance = INT_MAX;\n        int next_city = -1;\n\n        for (int j = 0; j < n; j++) {\n            if (!visited[j] && graph[current_city][j] < min_distance) {\n                min_distance = graph[current_city][j];\n                next_city = j;\n            }\n        }\n\n        if (next_city == -1) {\n            // If no unvisited city is found, break the loop\n            break;\n        }\n\n        visited[next_city] = 1;\n        path[i] = next_city + 1;\n        total_distance += min_distance;\n        current_city = next_city;\n    }\n\n    // Add the distance from the last city back to the starting city\n    total_distance += graph[path[n - 1] - 1][path[0] - 1];\n\n    printf(\"%d\n\", total_distance);\n\n    free(visited);\n    free(path);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_dzrtuy_i/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_dzrtuy_i/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc362_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200000\n#define MAX_E 200000\n\ntypedef struct {\n    int to;\n    long long weight;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    return ((Edge*)a)->weight - ((Edge*)b)->weight;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    long long A[MAX_N];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld\", &A[i]);\n    }\n\n    GArray *graph[MAX_N] = { NULL };\n    for (int i = 0; i < n; i++) {\n        graph[i] = g_array_new(FALSE, FALSE, sizeof(Edge));\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        long long b;\n        scanf(\"%d %d %lld\", &u, &v, &b);\n        u--;\n        v--;\n\n        Edge edge1 = { v, b + A[v] };\n        g_array_append_val(graph[u], edge1);\n\n        Edge edge2 = { u, b + A[u] };\n        g_array_append_val(graph[v], edge2);\n    }\n\n    long long *dist = (long long *)calloc(n, sizeof(long long));\n    for (int i = 0; i < n; i++) {\n        dist[i] = LLONG_MAX;\n    }\n\n    dist[0] = A[0];\n\n    GPriorityQueue *pq = g_priority_queue_new((GCompareFunc)compare, NULL);\n    g_priority_queue_push(pq, (gpointer)dist[0], (gpointer)0);\n\n    while (!g_priority_queue_is_empty(pq)) {\n        int u = GPOINTER_TO_INT(g_priority_queue_pop(pq));\n\n        for (int i = 0; i < g_array_get_n_items(graph[u]); i++) {\n            Edge edge = g_array_index(graph[u], Edge, i);\n            int v = edge.to;\n            long long weight = edge.weight;\n\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                g_priority_queue_push(pq, (gpointer)dist[v], (gpointer)v);\n            }\n        }\n    }\n\n    for (int i = 1; i < n; i++) {\n        printf(\"%lld \", dist[i]);\n    }\n\n    printf(\"\\n\");\n\n    for (int i = 0; i < n; i++) {\n        g_array_free(graph[i], TRUE);\n    }\n\n    g_priority_queue_free(pq);\n    free(dist);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_bd1m2fw5/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_bd1m2fw5/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc362_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // dp[i][d] will store the number of arithmetic subsequences ending at index i with difference d\n    GHashTable *dp[n];\n    for (int i = 0; i < n; i++) {\n        dp[i] = g_hash_table_new(g_direct_hash, g_direct_equal);\n    }\n\n    int result = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            long long diff = (long long)A[i] - A[j];\n            if (diff > INT_MAX || diff < INT_MIN) continue;\n\n            int d = (int)diff;\n            gpointer count = g_hash_table_lookup(dp[j], GINT_TO_POINTER(d));\n            int cnt = count ? GPOINTER_TO_INT(count) : 0;\n\n            g_hash_table_insert(dp[i], GINT_TO_POINTER(d), GINT_TO_POINTER((cnt + 1) % MOD));\n\n            result = (result + cnt + 1) % MOD;\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    for (int i = 0; i < n; i++) {\n        g_hash_table_destroy(dp[i]);\n    }\n\n    free(A);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_wzpc8w64/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_wzpc8w64/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc362_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *L = (int *)malloc(n * sizeof(int));\n    int *R = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &L[i], &R[i]);\n    }\n\n    int sum = 0;\n    int *X = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        if (L[i] <= 0 && R[i] >= 0) {\n            X[i] = 0;\n        } else if (L[i] > 0) {\n            X[i] = L[i];\n            sum += X[i];\n        } else {\n            X[i] = R[i];\n            sum += X[i];\n        }\n    }\n\n    if (sum != 0) {\n        printf(\"No\n\");\n        free(L);\n        free(R);\n        free(X);\n        return 0;\n    }\n\n    printf(\"Yes\n\");\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", X[i]);\n    }\n    printf(\"\\n\");\n\n    free(L);\n    free(R);\n    free(X);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jrpg___s/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jrpg___s/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc362_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int R, G, B;\n    char C[10];\n\n    // Read input\n    scanf(\"%d %d %d\", &R, &G, &B);\n    scanf(\"%s\", C);\n\n    // Initialize minimum cost to a large value\n    int min_cost = INT_MAX;\n\n    // Iterate through each pen color\n    if (strcmp(C, \"Red\") != 0) {\n        min_cost = R;\n    }\n    if (strcmp(C, \"Green\") != 0 && G < min_cost) {\n        min_cost = G;\n    }\n    if (strcmp(C, \"Blue\") != 0 && B < min_cost) {\n        min_cost = B;\n    }\n\n    // Print the minimum cost\n    printf(\"%d\\n\", min_cost);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_xd61n1kc/program.c: In function 'main':\\n/tmp/agnostics_c_xd61n1kc/program.c:13:20: error: 'INT_MAX' undeclared (first use in this function)\\n   13 |     int min_cost = INT_MAX;\\n      |                    ^~~~~~~\\n/tmp/agnostics_c_xd61n1kc/program.c:3:1: note: 'INT_MAX' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\\n    2 | #include <stdlib.h>\\n  +++ |+#include <limits.h>\\n    3 | \\n/tmp/agnostics_c_xd61n1kc/program.c:13:20: note: each undeclared identifier is reported only once for each function it appears in\\n   13 |     int min_cost = INT_MAX;\\n      |                    ^~~~~~~\\n/tmp/agnostics_c_xd61n1kc/program.c:16:9: warning: implicit declaration of function 'strcmp' [-Wimplicit-function-declaration]\\n   16 |     if (strcmp(C, \\\"Red\\\") != 0) {\\n      |         ^~~~~~\\n/tmp/agnostics_c_xd61n1kc/program.c:3:1: note: include '<string.h>' or provide a declaration of 'strcmp'\\n    2 | #include <stdlib.h>\\n  +++ |+#include <string.h>\\n    3 | \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_xd61n1kc/program.c: In function 'main':\n/tmp/agnostics_c_xd61n1kc/program.c:13:20: error: 'INT_MAX' undeclared (first use in this function)\n   13 |     int min_cost = INT_MAX;\n      |                    ^~~~~~~\n/tmp/agnostics_c_xd61n1kc/program.c:3:1: note: 'INT_MAX' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\n    2 | #include <stdlib.h>\n  +++ |+#include <limits.h>\n    3 | \n/tmp/agnostics_c_xd61n1kc/program.c:13:20: note: each undeclared identifier is reported only once for each function it appears in\n   13 |     int min_cost = INT_MAX;\n      |                    ^~~~~~~\n/tmp/agnostics_c_xd61n1kc/program.c:16:9: warning: implicit declaration of function 'strcmp' [-Wimplicit-function-declaration]\n   16 |     if (strcmp(C, \"Red\") != 0) {\n      |         ^~~~~~\n/tmp/agnostics_c_xd61n1kc/program.c:3:1: note: include '<string.h>' or provide a declaration of 'strcmp'\n    2 | #include <stdlib.h>\n  +++ |+#include <string.h>\n    3 | \n"}
{"question_id": "abc362_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint main() {\n    int x1, y1, x2, y2, x3, y3;\n    scanf(\"%d %d\", &x1, &y1);\n    scanf(\"%d %d\", &x2, &y2);\n    scanf(\"%d %d\", &x3, &y3);\n\n    double d1 = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n    double d2 = sqrt(pow(x3 - x2, 2) + pow(y3 - y2, 2));\n    double d3 = sqrt(pow(x3 - x1, 2) + pow(y3 - y1, 2));\n\n    if ((d1 * d1 == d2 * d2 + d3 * d3) ||\n        (d2 * d2 == d1 * d1 + d3 * d3) ||\n        (d3 * d3 == d1 * d1 + d2 * d2)) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_azm_ti8w/program.c: In function 'main':\\n/tmp/agnostics_c_azm_ti8w/program.c:18:16: warning: missing terminating \\\" character\\n   18 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_azm_ti8w/program.c:18:16: error: missing terminating \\\" character\\n   18 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_azm_ti8w/program.c:19:1: warning: missing terminating \\\" character\\n   19 | \\\");\\n      | ^\\n/tmp/agnostics_c_azm_ti8w/program.c:19:1: error: missing terminating \\\" character\\n   19 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_azm_ti8w/program.c:20:5: error: expected expression before '}' token\\n   20 |     } else {\\n      |     ^\\n/tmp/agnostics_c_azm_ti8w/program.c:18:16: error: expected ';' before '}' token\\n   18 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   19 | \\\");\\n   20 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_azm_ti8w/program.c:21:16: warning: missing terminating \\\" character\\n   21 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_azm_ti8w/program.c:21:16: error: missing terminating \\\" character\\n   21 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_azm_ti8w/program.c:22:1: warning: missing terminating \\\" character\\n   22 | \\\");\\n      | ^\\n/tmp/agnostics_c_azm_ti8w/program.c:22:1: error: missing terminating \\\" character\\n   22 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_azm_ti8w/program.c:23:5: error: expected expression before '}' token\\n   23 |     }\\n      |     ^\\n/tmp/agnostics_c_azm_ti8w/program.c:21:16: error: expected ';' before '}' token\\n   21 |         printf(\\\"No\\n      |                ^\\n      |                ;\\n   22 | \\\");\\n   23 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_azm_ti8w/program.c: In function 'main':\n/tmp/agnostics_c_azm_ti8w/program.c:18:16: warning: missing terminating \" character\n   18 |         printf(\"Yes\n      |                ^\n/tmp/agnostics_c_azm_ti8w/program.c:18:16: error: missing terminating \" character\n   18 |         printf(\"Yes\n      |                ^~~~\n/tmp/agnostics_c_azm_ti8w/program.c:19:1: warning: missing terminating \" character\n   19 | \");\n      | ^\n/tmp/agnostics_c_azm_ti8w/program.c:19:1: error: missing terminating \" character\n   19 | \");\n      | ^~~\n/tmp/agnostics_c_azm_ti8w/program.c:20:5: error: expected expression before '}' token\n   20 |     } else {\n      |     ^\n/tmp/agnostics_c_azm_ti8w/program.c:18:16: error: expected ';' before '}' token\n   18 |         printf(\"Yes\n      |                ^\n      |                ;\n   19 | \");\n   20 |     } else {\n      |     ~           \n/tmp/agnostics_c_azm_ti8w/program.c:21:16: warning: missing terminating \" character\n   21 |         printf(\"No\n      |                ^\n/tmp/agnostics_c_azm_ti8w/program.c:21:16: error: missing terminating \" character\n   21 |         printf(\"No\n      |                ^~~\n/tmp/agnostics_c_azm_ti8w/program.c:22:1: warning: missing terminating \" character\n   22 | \");\n      | ^\n/tmp/agnostics_c_azm_ti8w/program.c:22:1: error: missing terminating \" character\n   22 | \");\n      | ^~~\n/tmp/agnostics_c_azm_ti8w/program.c:23:5: error: expected expression before '}' token\n   23 |     }\n      |     ^\n/tmp/agnostics_c_azm_ti8w/program.c:21:16: error: expected ';' before '}' token\n   21 |         printf(\"No\n      |                ^\n      |                ;\n   22 | \");\n   23 |     }\n      |     ~           \n"}
{"question_id": "abc363_a", "solution": "#include <stdio.h>\n\nint main() {\n    int R;\n    scanf(\"%d\", &R);\n\n    int increase = 100;\n\n    printf(\"%d\n\", increase);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_xxbityed/program.c: In function 'main':\\n/tmp/agnostics_c_xxbityed/program.c:9:12: warning: missing terminating \\\" character\\n    9 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_xxbityed/program.c:9:12: error: missing terminating \\\" character\\n    9 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_xxbityed/program.c:10:1: warning: missing terminating \\\" character\\n   10 | \\\", increase);\\n      | ^\\n/tmp/agnostics_c_xxbityed/program.c:10:1: error: missing terminating \\\" character\\n   10 | \\\", increase);\\n      | ^~~~~~~~~~~~~\\n/tmp/agnostics_c_xxbityed/program.c:12:5: error: expected expression before 'return'\\n   12 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_xxbityed/program.c:12:14: error: expected ';' before '}' token\\n   12 |     return 0;\\n      |              ^\\n      |              ;\\n   13 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_xxbityed/program.c: In function 'main':\n/tmp/agnostics_c_xxbityed/program.c:9:12: warning: missing terminating \" character\n    9 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c_xxbityed/program.c:9:12: error: missing terminating \" character\n    9 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c_xxbityed/program.c:10:1: warning: missing terminating \" character\n   10 | \", increase);\n      | ^\n/tmp/agnostics_c_xxbityed/program.c:10:1: error: missing terminating \" character\n   10 | \", increase);\n      | ^~~~~~~~~~~~~\n/tmp/agnostics_c_xxbityed/program.c:12:5: error: expected expression before 'return'\n   12 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_xxbityed/program.c:12:14: error: expected ';' before '}' token\n   12 |     return 0;\n      |              ^\n      |              ;\n   13 | }\n      | ~             \n"}
{"question_id": "abc363_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nGHashTable *memo;\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const char *str) {\n    int len = strlen(str);\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Recursive function to find the palindrome string that evaluates to N\nchar *find_palindrome(long long N) {\n    if (N == 0) {\n        return g_strdup(\"0\");\n    }\n\n    char *result = NULL;\n\n    // Try all possible first half values\n    for (long long i = 1; i * i <= N; i++) {\n        long long remainder = N - i * i;\n        char *second_half = find_palindrome(remainder);\n        if (second_half != NULL) {\n            char *first_half = g_strdup_printf(\"%lld\", i);\n            char *palindrome = g_strconcat(first_half, second_half, first_half, NULL);\n            if (is_palindrome(palindrome)) {\n                result = palindrome;\n                break;\n            }\n            g_free(first_half);\n            g_free(second_half);\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    // Read input\n    long long N;\n    scanf(\"%lld\", &N);\n\n    // Initialize memoization table\n    memo = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Find the palindrome string\n    char *result = find_palindrome(N);\n\n    // Output result\n    if (result != NULL) {\n        printf(\"%s\n\", result);\n        g_free(result);\n    } else {\n        printf(\"-1\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(memo);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ek9wq984/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ek9wq984/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc363_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, T, P;\n    scanf(\"%d %d %d\", &N, &T, &P);\n\n    int *hair_lengths = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &hair_lengths[i]);\n    }\n\n    int days = 0;\n    int count = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (hair_lengths[i] >= T) {\n            count++;\n        }\n    }\n\n    if (count >= P) {\n        printf(\"0\\n\");\n        free(hair_lengths);\n        return 0;\n    }\n\n    while (count < P) {\n        days++;\n        for (int i = 0; i < N; i++) {\n            hair_lengths[i]++;\n            if (hair_lengths[i] >= T) {\n                count++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", days);\n\n    free(hair_lengths);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"99\", \"got\": \"1\", \"stderr\": \"Test case 0 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "99", "got": "1", "stderr": "Test case 0 produced wrong output\n"}
{"question_id": "abc363_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <glib.h>\n\n#define MAX_LEN 11\n\n// Function to check if a string contains a palindrome of length K\nbool contains_palindrome(const char *str, int n, int k) {\n    for (int i = 0; i <= n - k; i++) {\n        bool is_palindrome = true;\n        for (int j = 0; j < k / 2; j++) {\n            if (str[i + j] != str[i + k - 1 - j]) {\n                is_palindrome = false;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Recursive function to generate permutations and count valid ones\nvoid permute(char *str, int start, int end, int k, int *count) {\n    if (start == end) {\n        if (!contains_palindrome(str, end, k)) {\n            (*count)++;\n        }\n    } else {\n        for (int i = start; i <= end; i++) {\n            // Swap characters\n            char temp = str[start];\n            str[start] = str[i];\n            str[i] = temp;\n\n            // Recurse\n            permute(str, start + 1, end, k, count);\n\n            // Swap back\n            temp = str[start];\n            str[start] = str[i];\n            str[i] = temp;\n        }\n    }\n}\n\nint main() {\n    int n, k;\n    char s[MAX_LEN];\n\n    // Read input\n    scanf(\"%d %d\", &n, &k);\n    scanf(\"%s\", s);\n\n    int count = 0;\n\n    // Generate all permutations and count valid ones\n    permute(s, 0, n - 1, k, &count);\n\n    // Output result\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_k1g4groq/program.c:5:10: fatal error: glib.h: No such file or directory\\n    5 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_k1g4groq/program.c:5:10: fatal error: glib.h: No such file or directory\n    5 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc363_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to check if a string is a palindrome\nbool is_palindrome(const char *str, int len) {\n    for (int i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    // Read input\n    unsigned long long n;\n    scanf(\"%llu\", &n);\n\n    // Variables to store the current palindrome and its length\n    char palindrome[20];  // 20 is enough to store the largest possible palindrome within the constraints\n    int len = 1;\n\n    // Generate palindromes until we find the N-th one\n    while (true) {\n        // Construct the first half of the palindrome\n        for (int i = 0; i < len; i++) {\n            palindrome[i] = '0' + (i < len / 2 ? i : len - i - 1);\n        }\n        palindrome[len] = '\n0';\n\n        // Form the full palindrome by mirroring the first half\n        for (int i = len; i < 2 * len; i++) {\n            palindrome[i] = palindrome[2 * len - i - 1];\n        }\n\n        // Check if the constructed palindrome is the N-th one\n        if (is_palindrome(palindrome, 2 * len)) {\n            n--;\n            if (n == 0) {\n                printf(\"%s\n\", palindrome);\n                break;\n            }\n        }\n\n        // Move to the next palindrome length\n        if (len == 1) {\n            len = 2;\n        } else {\n            len++;\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_mblzow2s/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_mblzow2s/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc363_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 1000\n\n// Function to perform flood fill and count the number of sections that sink\nint flood_fill(int **grid, int H, int W, int sea_level, int x, int y) {\n    if (x < 0 || x >= H || y < 0 || y >= W || grid[x][y] <= sea_level) {\n        return 0;\n    }\n    grid[x][y] = -1; // Mark the section as visited\n    int count = 1;\n    count += flood_fill(grid, H, W, sea_level, x + 1, y);\n    count += flood_fill(grid, H, W, sea_level, x - 1, y);\n    count += flood_fill(grid, H, W, sea_level, x, y + 1);\n    count += flood_fill(grid, H, W, sea_level, x, y - 1);\n    return count;\n}\n\nint main() {\n    int H, W, Y;\n    scanf(\"%d %d %d\", &H, &W, &Y);\n\n    int **grid = (int **)malloc(H * sizeof(int *));\n    for (int i = 0; i < H; i++) {\n        grid[i] = (int *)malloc(W * sizeof(int));\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    for (int year = 1; year <= Y; year++) {\n        int total_sunk = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] > year) {\n                    total_sunk += flood_fill(grid, H, W, year, i, j);\n                }\n            }\n        }\n        printf(\"%d\n\", H * W - total_sunk);\n    }\n\n    for (int i = 0; i < H; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_90uac3zs/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_90uac3zs/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc364_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    int S_i, S_j;\n    scanf(\"%d %d\", &S_i, &S_j);\n\n    char **grid = (char **)g_malloc(H * sizeof(char *));\n    for (int i = 0; i < H; i++) {\n        grid[i] = (char *)g_malloc(W * sizeof(char));\n        scanf(\" %c\", &grid[i][0]);\n    }\n\n    char X[51];\n    scanf(\"%s\", X);\n\n    int x = S_i - 1;\n    int y = S_j - 1;\n\n    for (int i = 0; i < strlen(X); i++) {\n        if (X[i] == 'L' && y > 0 && grid[x][y - 1] == '.') {\n            y--;\n        } else if (X[i] == 'R' && y < W - 1 && grid[x][y + 1] == '.') {\n            y++;\n        } else if (X[i] == 'U' && x > 0 && grid[x - 1][y] == '.') {\n            x--;\n        } else if (X[i] == 'D' && x < H - 1 && grid[x + 1][y] == '.') {\n            x++;\n        }\n    }\n\n    printf(\"%d %d\n\", x + 1, y + 1);\n\n    for (int i = 0; i < H; i++) {\n        g_free(grid[i]);\n    }\n    g_free(grid);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ien1g9ej/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ien1g9ej/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc364_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 80\n#define MAX_VALUE 10000\n\ntypedef struct {\n    int sweetness;\n    int saltiness;\n} Dish;\n\nint compare(const void *a, const void *b) {\n    return ((Dish *)b)->sweetness - ((Dish *)a)->sweetness;\n}\n\nint maxDishes(int N, int X, int Y, Dish dishes[]) {\n    qsort(dishes, N, sizeof(Dish), compare);\n\n    int maxCount = 0;\n    for (int i = 0; i < N; i++) {\n        int count = 0;\n        int currentSweetness = 0;\n        int currentSaltiness = 0;\n\n        for (int j = i; j < N; j++) {\n            currentSweetness += dishes[j].sweetness;\n            currentSaltiness += dishes[j].saltiness;\n\n            if (currentSweetness <= X && currentSaltiness <= Y) {\n                count++;\n            } else {\n                break;\n            }\n        }\n\n        maxCount = (count > maxCount) ? count : maxCount;\n    }\n\n    return maxCount;\n}\n\nint main() {\n    int N, X, Y;\n    scanf(\"%d %d %d\", &N, &X, &Y);\n\n    Dish dishes[MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &dishes[i].sweetness, &dishes[i].saltiness);\n    }\n\n    int result = maxDishes(N, X, Y, dishes);\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_820q_15s/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_820q_15s/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc364_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200005\n\ntypedef struct {\n    int to;\n    int cost;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    return ((Edge *)a)->cost - ((Edge *)b)->cost;\n}\n\nint find(int *parent, int i) {\n    if (parent[i] == i)\n        return i;\n    return parent[i] = find(parent, parent[i]);\n}\n\nvoid union_sets(int *parent, int *rank, int x, int y) {\n    int rootX = find(parent, x);\n    int rootY = find(parent, y);\n\n    if (rank[rootX] > rank[rootY])\n        parent[rootY] = rootX;\n    else if (rank[rootX] < rank[rootY])\n        parent[rootX] = rootY;\n    else {\n        parent[rootY] = rootX;\n        rank[rootX]++;\n    }\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    GArray *edges = g_array_new(FALSE, FALSE, sizeof(Edge));\n\n    for (int i = 1; i <= Q; i++) {\n        int L, R, C;\n        scanf(\"%d %d %d\", &L, &R, &C);\n\n        for (int j = L; j <= R; j++) {\n            Edge e = {N + i, C};\n            g_array_append_val(edges, e);\n        }\n    }\n\n    g_array_sort(edges, compare);\n\n    int *parent = malloc((N + Q + 1) * sizeof(int));\n    int *rank = malloc((N + Q + 1) * sizeof(int));\n\n    for (int i = 1; i <= N + Q; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    int cost = 0;\n    int edges_used = 0;\n\n    for (int i = 0; i < edges->len; i++) {\n        Edge e = g_array_index(edges, Edge, i);\n\n        int rootX = find(parent, e.to);\n        int rootY = find(parent, e.from);\n\n        if (rootX != rootY) {\n            union_sets(parent, rank, rootX, rootY);\n            cost += e.cost;\n            edges_used++;\n\n            if (edges_used == N - 1)\n                break;\n        }\n    }\n\n    g_array_free(edges, TRUE);\n    free(parent);\n    free(rank);\n\n    if (edges_used != N - 1)\n        printf(\"-1\n\");\n    else\n        printf(\"%d\n\", cost);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_cfku_yr4/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_cfku_yr4/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc364_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    int *B = (int *)malloc(Q * sizeof(int));\n    int *k = (int *)malloc(Q * sizeof(int));\n    for (int i = 0; i < Q; i++) {\n        scanf(\"%d %d\", &B[i], &k[i]);\n    }\n\n    for (int i = 0; i < Q; i++) {\n        int *dist = (int *)malloc(N * sizeof(int));\n        for (int j = 0; j < N; j++) {\n            dist[j] = abs(A[j] - B[i]);\n        }\n\n        qsort(dist, N, sizeof(int), compare);\n\n        printf(\"%d\\n\", dist[k[i] - 1]);\n\n        free(dist);\n    }\n\n    free(A);\n    free(B);\n    free(k);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_28wz53il/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_28wz53il/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc364_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Structure to hold the sweetness and saltiness of a dish\ntypedef struct {\n    int sweetness;\n    int saltiness;\n} Dish;\n\n// Comparison function for qsort\nint compare(const void *a, const void *b) {\n    Dish *d1 = (Dish *)a;\n    Dish *d2 = (Dish *)b;\n    return d1->sweetness - d2->sweetness;\n}\n\nint main() {\n    int N;\n    long long X, Y;\n    scanf(\"%d %lld %lld\", &N, &X, &Y);\n\n    Dish *dishes = (Dish *)malloc(N * sizeof(Dish));\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &dishes[i].sweetness, &dishes[i].saltiness);\n    }\n\n    // Sort dishes by sweetness\n    qsort(dishes, N, sizeof(Dish), compare);\n\n    long long total_sweetness = 0;\n    long long total_saltiness = 0;\n    int count = 0;\n\n    for (int i = 0; i < N; i++) {\n        total_sweetness += dishes[i].sweetness;\n        total_saltiness += dishes[i].saltiness;\n        count++;\n\n        if (total_sweetness > X || total_saltiness > Y) {\n            break;\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    free(dishes);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_g5py83df/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_g5py83df/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc364_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Process using appropriate data structure\n    char *dishes = (char *)malloc(n * sizeof(char));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", &dishes[i]);\n    }\n\n    // Your algorithm here\n    bool canEatAll = true;\n    for (int i = 0; i < n - 1; i++) {\n        if (strcmp(&dishes[i], \"sweet\") == 0 && strcmp(&dishes[i + 1], \"sweet\") == 0) {\n            canEatAll = false;\n            break;\n        }\n    }\n\n    // Output result\n    if (canEatAll) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    // Clean up\n    free(dishes);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_clp1n5w_/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_clp1n5w_/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc365_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    int first = INT_MIN, second = INT_MIN;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > first) {\n            second = first;\n            first = arr[i];\n        } else if (arr[i] > second && arr[i] != first) {\n            second = arr[i];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == second) {\n            printf(\"%d\\n\", i + 1);\n            break;\n        }\n    }\n\n    free(arr);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_iix0un6i/program.c: In function 'main':\\n/tmp/agnostics_c_iix0un6i/program.c:13:17: error: 'INT_MIN' undeclared (first use in this function)\\n   13 |     int first = INT_MIN, second = INT_MIN;\\n      |                 ^~~~~~~\\n/tmp/agnostics_c_iix0un6i/program.c:3:1: note: 'INT_MIN' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\\n    2 | #include <stdlib.h>\\n  +++ |+#include <limits.h>\\n    3 | \\n/tmp/agnostics_c_iix0un6i/program.c:13:17: note: each undeclared identifier is reported only once for each function it appears in\\n   13 |     int first = INT_MIN, second = INT_MIN;\\n      |                 ^~~~~~~\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_iix0un6i/program.c: In function 'main':\n/tmp/agnostics_c_iix0un6i/program.c:13:17: error: 'INT_MIN' undeclared (first use in this function)\n   13 |     int first = INT_MIN, second = INT_MIN;\n      |                 ^~~~~~~\n/tmp/agnostics_c_iix0un6i/program.c:3:1: note: 'INT_MIN' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\n    2 | #include <stdlib.h>\n  +++ |+#include <limits.h>\n    3 | \n/tmp/agnostics_c_iix0un6i/program.c:13:17: note: each undeclared identifier is reported only once for each function it appears in\n   13 |     int first = INT_MIN, second = INT_MIN;\n      |                 ^~~~~~~\n"}
{"question_id": "abc365_a", "solution": "#include <stdio.h>\n\nint main() {\n    int Y;\n    scanf(\"%d\", &Y);\n\n    int days;\n    if (Y % 400 == 0) {\n        days = 366;\n    } else if (Y % 100 == 0) {\n        days = 365;\n    } else if (Y % 4 == 0) {\n        days = 366;\n    } else {\n        days = 365;\n    }\n\n    printf(\"%d\\n\", days);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc365_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    // Calculate prefix XORs\n    int *prefix_xor = (int *)malloc(n * sizeof(int));\n    prefix_xor[0] = arr[0];\n    for (int i = 1; i < n; i++) {\n        prefix_xor[i] = prefix_xor[i - 1] ^ arr[i];\n    }\n\n    // Use a hash map to count occurrences of prefix XORs\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int result = 0;\n\n    for (int i = 0; i < n; i++) {\n        // For each prefix XOR, add its count to the result\n        result += GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(prefix_xor[i]))) + 1;\n\n        // Update the count of the current prefix XOR\n        g_hash_table_insert(count, GINT_TO_POINTER(prefix_xor[i]), GINT_TO_POINTER(GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(prefix_xor[i]))) + 1));\n    }\n\n    // Output the result\n    printf(\"%d\\n\", result);\n\n    // Free allocated memory\n    free(arr);\n    free(prefix_xor);\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_285_bnqn/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_285_bnqn/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc365_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    GHashTable *map = g_hash_table_new(g_str_hash, g_str_equal);\n    int win = 0;\n\n    for (int i = 0; i < n; i++) {\n        char aoki = s[i];\n        char takahashi = 'A';\n\n        if (aoki == 'R') {\n            takahashi = 'P';\n        } else if (aoki == 'P') {\n            takahashi = 'S';\n        } else if (aoki == 'S') {\n            takahashi = 'R';\n        }\n\n        if (g_hash_table_lookup(map, &takahashi) == NULL) {\n            g_hash_table_insert(map, &takahashi, GINT_TO_POINTER(1));\n            win++;\n        }\n    }\n\n    printf(\"%d\\n\", win);\n\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_gyoe3g48/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_gyoe3g48/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc365_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    long long m;\n    scanf(\"%d %lld\", &n, &m);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    long long total_cost = 0;\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n        total_cost += a[i];\n    }\n\n    if (total_cost <= m) {\n        printf(\"infinite\n\");\n    } else {\n        qsort(a, n, sizeof(int), compare);\n        long long sum = 0;\n        int x = 0;\n\n        for (int i = 0; i < n; i++) {\n            int min_val = a[i];\n            if (sum + min_val <= m) {\n                sum += min_val;\n                x = min_val;\n            } else {\n                break;\n            }\n        }\n\n        printf(\"%d\n\", x);\n    }\n\n    free(a);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_saq5v1be/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_saq5v1be/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc366_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n// Function to compare two pairs based on A_i and B_i\nint compare(const void *a, const void *b) {\n    int *pair1 = (int *)a;\n    int *pair2 = (int *)b;\n    if (pair1[0] != pair2[0]) {\n        return pair2[0] - pair1[0]; // Compare A_i in descending order\n    } else {\n        return pair2[1] - pair1[1]; // Compare B_i in descending order if A_i are equal\n    }\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    // Read coefficients and store them in an array of pairs\n    int **coeffs = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        coeffs[i] = (int *)malloc(2 * sizeof(int));\n        scanf(\"%d %d\", &coeffs[i][0], &coeffs[i][1]);\n    }\n\n    // Sort the coefficients array using the custom comparator\n    qsort(coeffs, N, sizeof(int *), compare);\n\n    // Initialize the result with the first function's value\n    int result = coeffs[0][0] * 1 + coeffs[0][1];\n\n    // Apply the remaining functions to the result\n    for (int i = 1; i < K; i++) {\n        result = coeffs[i][0] * result + coeffs[i][1];\n    }\n\n    // Print the result\n    printf(\"%d\\n\", result);\n\n    // Free allocated memory\n    for (int i = 0; i < N; i++) {\n        free(coeffs[i]);\n    }\n    free(coeffs);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_yzscrtb3/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_yzscrtb3/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc366_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Read input strings\n    GArray *strings = g_array_new(FALSE, FALSE, sizeof(char*));\n    for (int i = 0; i < n; i++) {\n        char *str = malloc(101 * sizeof(char));\n        scanf(\"%s\", str);\n        g_array_append_val(strings, str);\n    }\n\n    // Find the maximum length of the strings\n    int max_len = 0;\n    for (int i = 0; i < n; i++) {\n        char *str = g_array_index(strings, char*, i);\n        if (strlen(str) > max_len) {\n            max_len = strlen(str);\n        }\n    }\n\n    // Construct the vertical strings\n    for (int j = 0; j < max_len; j++) {\n        char *result = malloc((n + 1) * sizeof(char));\n        result[n] = '\\0';\n\n        for (int i = 0; i < n; i++) {\n            char *str = g_array_index(strings, char*, i);\n            if (j < strlen(str)) {\n                result[i] = str[j];\n            } else {\n                result[i] = '*';\n            }\n        }\n\n        // Ensure the result does not end with '*'\n        if (result[n - 1] == '*') {\n            result[n - 1] = '\\0';\n        }\n\n        printf(\"%s\\n\", result);\n        free(result);\n    }\n\n    // Free allocated memory\n    for (int i = 0; i < n; i++) {\n        free(g_array_index(strings, char*, i));\n    }\n    g_array_free(strings, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ni3qahtz/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ni3qahtz/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc366_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200000\n#define MAXD 1000000\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint compare(const void *a, const void *b) {\n    return ((Point*)a)->x - ((Point*)b)->x;\n}\n\nint main() {\n    int n, d;\n    scanf(\"%d %d\", &n, &d);\n\n    Point points[MAXN];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    qsort(points, n, sizeof(Point), compare);\n\n    int result = 0;\n    GHashTable *y_counts = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        int x = points[i].x;\n        int y = points[i].y;\n\n        // Remove points that are out of the range\n        GList *node = g_hash_table_lookup(y_counts, GINT_TO_POINTER(x - d));\n        if (node) {\n            int count = GPOINTER_TO_INT(node->data);\n            if (count == 1) {\n                g_hash_table_remove(y_counts, GINT_TO_POINTER(x - d));\n            } else {\n                g_hash_table_replace(y_counts, GINT_TO_POINTER(x - d), GINT_TO_POINTER(count - 1));\n            }\n        }\n\n        // Add current point\n        node = g_hash_table_lookup(y_counts, GINT_TO_POINTER(x + d));\n        if (node) {\n            int count = GPOINTER_TO_INT(node->data);\n            g_hash_table_replace(y_counts, GINT_TO_POINTER(x + d), GINT_TO_POINTER(count + 1));\n        } else {\n            g_hash_table_insert(y_counts, GINT_TO_POINTER(x + d), GINT_TO_POINTER(1));\n        }\n\n        // Count valid points within the range\n        result += g_hash_table_size(y_counts);\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(y_counts);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_16btredj/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_16btredj/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc366_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Create a 3D array using GArray for dynamic sizing\n    GArray *array = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n * n * n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(array, value);\n    }\n\n    // Create a prefix sum 3D array\n    GArray *prefix_sum = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n * n * n; i++) {\n        int value = g_array_index(array, int, i);\n        if (i > 0) {\n            value += g_array_index(prefix_sum, int, i - 1);\n        }\n        g_array_append_val(prefix_sum, value);\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n\n    for (int i = 0; i < q; i++) {\n        int lx, rx, ly, ry, lz, rz;\n        scanf(\"%d %d %d %d %d %d\", &lx, &rx, &ly, &ry, &lz, &rz);\n\n        int result = 0;\n        int index = (lx - 1) * n * n + (ly - 1) * n + lz - 1;\n        int end_index = (rx - 1) * n * n + (ry - 1) * n + rz - 1;\n\n        if (index >= 0 && end_index < n * n * n) {\n            result = g_array_index(prefix_sum, int, end_index);\n            if (index > 0) {\n                result -= g_array_index(prefix_sum, int, index - 1);\n            }\n        }\n\n        printf(\"%d\\n\", result);\n    }\n\n    // Clean up\n    g_array_free(array, TRUE);\n    g_array_free(prefix_sum, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_r485mbzk/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_r485mbzk/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc366_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, T, A;\n    scanf(\"%d %d %d\", &N, &T, &A);\n\n    // Calculate the difference in votes\n    int diff = abs(T - A);\n\n    // Check if the difference is more than half of the total votes\n    if (diff > N / 2) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ids9um1b/program.c: In function 'main':\\n/tmp/agnostics_c_ids9um1b/program.c:13:16: warning: missing terminating \\\" character\\n   13 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_ids9um1b/program.c:13:16: error: missing terminating \\\" character\\n   13 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_ids9um1b/program.c:14:1: warning: missing terminating \\\" character\\n   14 | \\\");\\n      | ^\\n/tmp/agnostics_c_ids9um1b/program.c:14:1: error: missing terminating \\\" character\\n   14 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_ids9um1b/program.c:15:5: error: expected expression before '}' token\\n   15 |     } else {\\n      |     ^\\n/tmp/agnostics_c_ids9um1b/program.c:13:16: error: expected ';' before '}' token\\n   13 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   14 | \\\");\\n   15 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_ids9um1b/program.c:16:16: warning: missing terminating \\\" character\\n   16 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_ids9um1b/program.c:16:16: error: missing terminating \\\" character\\n   16 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_ids9um1b/program.c:17:1: warning: missing terminating \\\" character\\n   17 | \\\");\\n      | ^\\n/tmp/agnostics_c_ids9um1b/program.c:17:1: error: missing terminating \\\" character\\n   17 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_ids9um1b/program.c:18:5: error: expected expression before '}' token\\n   18 |     }\\n      |     ^\\n/tmp/agnostics_c_ids9um1b/program.c:16:16: error: expected ';' before '}' token\\n   16 |         printf(\\\"No\\n      |                ^\\n      |                ;\\n   17 | \\\");\\n   18 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ids9um1b/program.c: In function 'main':\n/tmp/agnostics_c_ids9um1b/program.c:13:16: warning: missing terminating \" character\n   13 |         printf(\"Yes\n      |                ^\n/tmp/agnostics_c_ids9um1b/program.c:13:16: error: missing terminating \" character\n   13 |         printf(\"Yes\n      |                ^~~~\n/tmp/agnostics_c_ids9um1b/program.c:14:1: warning: missing terminating \" character\n   14 | \");\n      | ^\n/tmp/agnostics_c_ids9um1b/program.c:14:1: error: missing terminating \" character\n   14 | \");\n      | ^~~\n/tmp/agnostics_c_ids9um1b/program.c:15:5: error: expected expression before '}' token\n   15 |     } else {\n      |     ^\n/tmp/agnostics_c_ids9um1b/program.c:13:16: error: expected ';' before '}' token\n   13 |         printf(\"Yes\n      |                ^\n      |                ;\n   14 | \");\n   15 |     } else {\n      |     ~           \n/tmp/agnostics_c_ids9um1b/program.c:16:16: warning: missing terminating \" character\n   16 |         printf(\"No\n      |                ^\n/tmp/agnostics_c_ids9um1b/program.c:16:16: error: missing terminating \" character\n   16 |         printf(\"No\n      |                ^~~\n/tmp/agnostics_c_ids9um1b/program.c:17:1: warning: missing terminating \" character\n   17 | \");\n      | ^\n/tmp/agnostics_c_ids9um1b/program.c:17:1: error: missing terminating \" character\n   17 | \");\n      | ^~~\n/tmp/agnostics_c_ids9um1b/program.c:18:5: error: expected expression before '}' token\n   18 |     }\n      |     ^\n/tmp/agnostics_c_ids9um1b/program.c:16:16: error: expected ';' before '}' token\n   16 |         printf(\"No\n      |                ^\n      |                ;\n   17 | \");\n   18 |     }\n      |     ~           \n"}
{"question_id": "abc366_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int Q;\n    scanf(\"%d\", &Q);\n\n    GHashTable *bag = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < Q; i++) {\n        int query_type, x;\n        scanf(\"%d\", &query_type);\n\n        if (query_type == 1) {\n            scanf(\"%d\", &x);\n            g_hash_table_insert(bag, GINT_TO_POINTER(x), GINT_TO_POINTER(1));\n        } else if (query_type == 2) {\n            scanf(\"%d\", &x);\n            g_hash_table_remove(bag, GINT_TO_POINTER(x));\n        } else if (query_type == 3) {\n            printf(\"%zu\n\", g_hash_table_size(bag));\n        }\n    }\n\n    g_hash_table_destroy(bag);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4kbmzh4v/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_4kbmzh4v/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc366_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 60\n#define MAXM (MAXN * (MAXN - 1) / 2)\n\nGArray *adj[MAXN];\nint color[MAXN];  // 0: uncolored, 1: color 1, -1: color -1\n\nbool is_bipartite(int v, int c) {\n    color[v] = c;\n    for (int i = 0; i < adj[v]->len; i++) {\n        int u = g_array_index(adj[v], int, i);\n        if (color[u] == c) return false;\n        if (color[u] == 0 && !is_bipartite(u, -c)) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n        color[i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        g_array_append_val(adj[u], v);\n        g_array_append_val(adj[v], u);\n    }\n\n    if (!is_bipartite(0, 1)) {\n        printf(\"No\n\");\n        for (int i = 0; i < n; i++) {\n            g_array_free(adj[i], TRUE);\n        }\n        return 0;\n    }\n\n    printf(\"Yes\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", color[i] == 1 ? 1 : 2);\n    }\n    printf(\"\\n\");\n\n    for (int i = 0; i < n; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_5vmus3nt/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_5vmus3nt/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc367_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int *x = (int *)malloc(n * sizeof(int));\n    int *a = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &x[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // Find the cycle lengths\n    int *cycle = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        cycle[i] = 1;\n        int next = x[i] - 1;\n        while (next != i) {\n            cycle[i]++;\n            next = x[next] - 1;\n        }\n    }\n\n    // Determine the effective number of operations\n    for (int i = 0; i < n; i++) {\n        k %= cycle[i];\n    }\n\n    // Apply the operations\n    for (int i = 0; i < n; i++) {\n        int start = i;\n        int len = cycle[i];\n        int temp[len];\n\n        for (int j = 0; j < len; j++) {\n            temp[j] = a[start];\n            start = x[start] - 1;\n        }\n\n        start = i;\n        for (int j = 0; j < len; j++) {\n            a[start] = temp[(j + k) % len];\n            start = x[start] - 1;\n        }\n    }\n\n    // Output the result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Free memory\n    free(x);\n    free(a);\n    free(cycle);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_s8ge47pp/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_s8ge47pp/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc367_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    for (int q_id = 0; q_id < q; q_id++) {\n        int l, r, L, R;\n        scanf(\"%d %d %d %d\", &l, &r, &L, &R);\n\n        // Create frequency maps for the subsequences\n        GHashTable *freq_a = g_hash_table_new(g_direct_hash, g_direct_equal);\n        GHashTable *freq_b = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n        for (int i = l - 1; i < r; i++) {\n            int key = a[i];\n            int *count = (int *)g_hash_table_lookup(freq_a, GINT_TO_POINTER(key));\n            if (count == NULL) {\n                count = (int *)malloc(sizeof(int));\n                *count = 0;\n                g_hash_table_insert(freq_a, GINT_TO_POINTER(key), count);\n            }\n            (*count)++;\n        }\n\n        for (int i = L - 1; i < R; i++) {\n            int key = b[i];\n            int *count = (int *)g_hash_table_lookup(freq_b, GINT_TO_POINTER(key));\n            if (count == NULL) {\n                count = (int *)malloc(sizeof(int));\n                *count = 0;\n                g_hash_table_insert(freq_b, GINT_TO_POINTER(key), count);\n            }\n            (*count)++;\n        }\n\n        // Compare the frequency maps\n        bool possible = true;\n        GList *keys = g_hash_table_get_keys(freq_a);\n        for (GList *node = keys; node != NULL; node = node->next) {\n            int key = GPOINTER_TO_INT(node->data);\n            int *count_a = (int *)g_hash_table_lookup(freq_a, GINT_TO_POINTER(key));\n            int *count_b = (int *)g_hash_table_lookup(freq_b, GINT_TO_POINTER(key));\n            if (count_b == NULL || *count_a != *count_b) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (possible) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n\n        // Clean up\n        g_hash_table_destroy(freq_a);\n        g_hash_table_destroy(freq_b);\n        g_list_free(keys);\n    }\n\n    free(a);\n    free(b);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_01ayoegq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_01ayoegq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc367_a", "solution": "#include <stdio.h>\n\nint main() {\n    int A, B, C;\n    scanf(\"%d %d %d\", &A, &B, &C);\n\n    if ((C > B && B > A) || (A > C && C > B)) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_wxf06m23/program.c: In function 'main':\\n/tmp/agnostics_c_wxf06m23/program.c:8:16: warning: missing terminating \\\" character\\n    8 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_wxf06m23/program.c:8:16: error: missing terminating \\\" character\\n    8 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_wxf06m23/program.c:9:1: warning: missing terminating \\\" character\\n    9 | \\\");\\n      | ^\\n/tmp/agnostics_c_wxf06m23/program.c:9:1: error: missing terminating \\\" character\\n    9 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_wxf06m23/program.c:10:5: error: expected expression before '}' token\\n   10 |     } else {\\n      |     ^\\n/tmp/agnostics_c_wxf06m23/program.c:8:16: error: expected ';' before '}' token\\n    8 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n    9 | \\\");\\n   10 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_wxf06m23/program.c:11:16: warning: missing terminating \\\" character\\n   11 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_wxf06m23/program.c:11:16: error: missing terminating \\\" character\\n   11 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_wxf06m23/program.c:12:1: warning: missing terminating \\\" character\\n   12 | \\\");\\n      | ^\\n/tmp/agnostics_c_wxf06m23/program.c:12:1: error: missing terminating \\\" character\\n   12 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_wxf06m23/program.c:13:5: error: expected expression before '}' token\\n   13 |     }\\n      |     ^\\n/tmp/agnostics_c_wxf06m23/program.c:11:16: error: expected ';' before '}' token\\n   11 |         printf(\\\"No\\n      |                ^\\n      |                ;\\n   12 | \\\");\\n   13 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_wxf06m23/program.c: In function 'main':\n/tmp/agnostics_c_wxf06m23/program.c:8:16: warning: missing terminating \" character\n    8 |         printf(\"Yes\n      |                ^\n/tmp/agnostics_c_wxf06m23/program.c:8:16: error: missing terminating \" character\n    8 |         printf(\"Yes\n      |                ^~~~\n/tmp/agnostics_c_wxf06m23/program.c:9:1: warning: missing terminating \" character\n    9 | \");\n      | ^\n/tmp/agnostics_c_wxf06m23/program.c:9:1: error: missing terminating \" character\n    9 | \");\n      | ^~~\n/tmp/agnostics_c_wxf06m23/program.c:10:5: error: expected expression before '}' token\n   10 |     } else {\n      |     ^\n/tmp/agnostics_c_wxf06m23/program.c:8:16: error: expected ';' before '}' token\n    8 |         printf(\"Yes\n      |                ^\n      |                ;\n    9 | \");\n   10 |     } else {\n      |     ~           \n/tmp/agnostics_c_wxf06m23/program.c:11:16: warning: missing terminating \" character\n   11 |         printf(\"No\n      |                ^\n/tmp/agnostics_c_wxf06m23/program.c:11:16: error: missing terminating \" character\n   11 |         printf(\"No\n      |                ^~~\n/tmp/agnostics_c_wxf06m23/program.c:12:1: warning: missing terminating \" character\n   12 | \");\n      | ^\n/tmp/agnostics_c_wxf06m23/program.c:12:1: error: missing terminating \" character\n   12 | \");\n      | ^~~\n/tmp/agnostics_c_wxf06m23/program.c:13:5: error: expected expression before '}' token\n   13 |     }\n      |     ^\n/tmp/agnostics_c_wxf06m23/program.c:11:16: error: expected ';' before '}' token\n   11 |         printf(\"No\n      |                ^\n      |                ;\n   12 | \");\n   13 |     }\n      |     ~           \n"}
{"question_id": "abc367_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    GArray *a = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        g_array_append_val(a, x);\n    }\n\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(long long));\n    g_array_append_val(dp, 0);\n\n    for (int i = 0; i < n; i++) {\n        GArray *new_dp = g_array_new(FALSE, FALSE, sizeof(long long));\n        g_array_append_val(new_dp, 0);\n\n        for (int j = 0; j < dp->len; j++) {\n            long long prev = g_array_index(dp, long long, j);\n            long long current = prev ^ g_array_index(a, int, i);\n\n            g_array_append_val(new_dp, (prev + current) % MOD);\n        }\n\n        for (int j = 0; j < new_dp->len; j++) {\n            long long value = g_array_index(new_dp, long long, j);\n            if ((j + 1) % m == 0) {\n                value = (value * value) % MOD;\n            }\n            g_array_append_val(dp, value);\n        }\n\n        g_array_free(new_dp, TRUE);\n    }\n\n    long long result = 0;\n    for (int i = 0; i < dp->len; i++) {\n        result = (result + g_array_index(dp, long long, i)) % MOD;\n    }\n\n    printf(\"%lld\\n\", result);\n\n    g_array_free(dp, TRUE);\n    g_array_free(a, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_xudr5rlm/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_xudr5rlm/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc367_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    // Read input\n    char input[100];\n    scanf(\"%s\", input);\n\n    // Convert input to a double\n    double X = atof(input);\n\n    // Check if the number is an integer\n    if (X == (int)X) {\n        printf(\"%d\n\", (int)X);\n    } else {\n        // Convert the number to a string\n        char formatted[100];\n        sprintf(formatted, \"%.3f\", X);\n\n        // Remove trailing zeros and the unnecessary decimal point\n        char *end = formatted + strlen(formatted) - 1;\n        while (*end == '0' || *end == '.') {\n            *end = '\\0';\n            end--;\n        }\n\n        // Print the formatted number\n        printf(\"%s\n\", formatted);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_hjouglg0/program.c: In function 'main':\\n/tmp/agnostics_c_hjouglg0/program.c:15:16: warning: missing terminating \\\" character\\n   15 |         printf(\\\"%d\\n      |                ^\\n/tmp/agnostics_c_hjouglg0/program.c:15:16: error: missing terminating \\\" character\\n   15 |         printf(\\\"%d\\n      |                ^~~\\n/tmp/agnostics_c_hjouglg0/program.c:16:1: warning: missing terminating \\\" character\\n   16 | \\\", (int)X);\\n      | ^\\n/tmp/agnostics_c_hjouglg0/program.c:16:1: error: missing terminating \\\" character\\n   16 | \\\", (int)X);\\n      | ^~~~~~~~~~~\\n/tmp/agnostics_c_hjouglg0/program.c:17:5: error: expected expression before '}' token\\n   17 |     } else {\\n      |     ^\\n/tmp/agnostics_c_hjouglg0/program.c:15:16: error: expected ';' before '}' token\\n   15 |         printf(\\\"%d\\n      |                ^\\n      |                ;\\n   16 | \\\", (int)X);\\n   17 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_hjouglg0/program.c:30:16: warning: missing terminating \\\" character\\n   30 |         printf(\\\"%s\\n      |                ^\\n/tmp/agnostics_c_hjouglg0/program.c:30:16: error: missing terminating \\\" character\\n   30 |         printf(\\\"%s\\n      |                ^~~\\n/tmp/agnostics_c_hjouglg0/program.c:31:1: warning: missing terminating \\\" character\\n   31 | \\\", formatted);\\n      | ^\\n/tmp/agnostics_c_hjouglg0/program.c:31:1: error: missing terminating \\\" character\\n   31 | \\\", formatted);\\n      | ^~~~~~~~~~~~~~\\n/tmp/agnostics_c_hjouglg0/program.c:32:5: error: expected expression before '}' token\\n   32 |     }\\n      |     ^\\n/tmp/agnostics_c_hjouglg0/program.c:30:16: error: expected ';' before '}' token\\n   30 |         printf(\\\"%s\\n      |                ^\\n      |                ;\\n   31 | \\\", formatted);\\n   32 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_hjouglg0/program.c: In function 'main':\n/tmp/agnostics_c_hjouglg0/program.c:15:16: warning: missing terminating \" character\n   15 |         printf(\"%d\n      |                ^\n/tmp/agnostics_c_hjouglg0/program.c:15:16: error: missing terminating \" character\n   15 |         printf(\"%d\n      |                ^~~\n/tmp/agnostics_c_hjouglg0/program.c:16:1: warning: missing terminating \" character\n   16 | \", (int)X);\n      | ^\n/tmp/agnostics_c_hjouglg0/program.c:16:1: error: missing terminating \" character\n   16 | \", (int)X);\n      | ^~~~~~~~~~~\n/tmp/agnostics_c_hjouglg0/program.c:17:5: error: expected expression before '}' token\n   17 |     } else {\n      |     ^\n/tmp/agnostics_c_hjouglg0/program.c:15:16: error: expected ';' before '}' token\n   15 |         printf(\"%d\n      |                ^\n      |                ;\n   16 | \", (int)X);\n   17 |     } else {\n      |     ~           \n/tmp/agnostics_c_hjouglg0/program.c:30:16: warning: missing terminating \" character\n   30 |         printf(\"%s\n      |                ^\n/tmp/agnostics_c_hjouglg0/program.c:30:16: error: missing terminating \" character\n   30 |         printf(\"%s\n      |                ^~~\n/tmp/agnostics_c_hjouglg0/program.c:31:1: warning: missing terminating \" character\n   31 | \", formatted);\n      | ^\n/tmp/agnostics_c_hjouglg0/program.c:31:1: error: missing terminating \" character\n   31 | \", formatted);\n      | ^~~~~~~~~~~~~~\n/tmp/agnostics_c_hjouglg0/program.c:32:5: error: expected expression before '}' token\n   32 |     }\n      |     ^\n/tmp/agnostics_c_hjouglg0/program.c:30:16: error: expected ';' before '}' token\n   30 |         printf(\"%s\n      |                ^\n      |                ;\n   31 | \", formatted);\n   32 |     }\n      |     ~           \n"}
{"question_id": "abc367_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    g_hash_table_insert(map, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n\n    long long sum = 0;\n    long long count = 0;\n\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        sum += a;\n        int remainder = sum % m;\n\n        gpointer value = g_hash_table_lookup(map, GINT_TO_POINTER(remainder));\n        if (value != NULL) {\n            count += GPOINTER_TO_INT(value);\n        }\n\n        g_hash_table_insert(map, GINT_TO_POINTER(remainder), GINT_TO_POINTER(GPOINTER_TO_INT(value) + 1));\n    }\n\n    printf(\"%lld\n\", count);\n\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ngp2txik/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ngp2txik/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc367_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 8\n#define MAX_R 5\n#define MAX_K 10\n\ntypedef struct {\n    int *sequence;\n    int length;\n} Sequence;\n\nGHashTable *printed_sequences;\n\nvoid dfs(int n, int k, int *r, int *current_sequence, int current_sum, int index) {\n    if (index == n) {\n        if (current_sum % k == 0) {\n            int *new_sequence = (int *)g_malloc(n * sizeof(int));\n            memcpy(new_sequence, current_sequence, n * sizeof(int));\n            g_hash_table_insert(printed_sequences, new_sequence, NULL);\n        }\n        return;\n    }\n\n    for (int i = 1; i <= r[index]; i++) {\n        current_sequence[index] = i;\n        dfs(n, k, r, current_sequence, current_sum + i, index + 1);\n    }\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int r[MAX_N];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &r[i]);\n    }\n\n    printed_sequences = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int *current_sequence = (int *)g_malloc(n * sizeof(int));\n    dfs(n, k, r, current_sequence, 0, 0);\n\n    GList *keys = g_hash_table_get_keys(printed_sequences);\n    int count = g_list_length(keys);\n\n    printf(\"%d\\n\", count);\n\n    GList *node = keys;\n    while (node != NULL) {\n        int *sequence = (int *)node->data;\n        for (int i = 0; i < n; i++) {\n            printf(\"%d \", sequence[i]);\n        }\n        printf(\"\\n\");\n        node = node->next;\n    }\n\n    g_list_free(keys);\n    g_hash_table_destroy(printed_sequences);\n    g_free(current_sequence);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_y6n5ey59/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_y6n5ey59/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc368_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 100000\n\nGArray *A, *B;\nGArray *prefix_max, *suffix_max;\n\nvoid preprocess(int n) {\n    prefix_max = g_array_new(FALSE, FALSE, sizeof(long long));\n    suffix_max = g_array_new(FALSE, FALSE, sizeof(long long));\n\n    long long v = 0;\n    for (int i = 0; i < n; i++) {\n        v = v + A->data[i] * B->data[i];\n        g_array_append_val(prefix_max, v);\n    }\n\n    v = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        v = v + A->data[i] * B->data[i];\n        g_array_append_val(suffix_max, v);\n    }\n}\n\nlong long query(int l, int r) {\n    long long result = 0;\n    if (l == 0) {\n        result = prefix_max->data[r];\n    } else if (r == A->len - 1) {\n        result = suffix_max->data[A->len - 1 - l];\n    } else {\n        result = prefix_max->data[r] - prefix_max->data[l - 1];\n    }\n    return result;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d\", &n);\n\n    A = g_array_new(FALSE, FALSE, sizeof(int));\n    B = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        g_array_append_val(A, x);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        g_array_append_val(B, x);\n    }\n\n    scanf(\"%d\", &q);\n\n    preprocess(n);\n\n    for (int i = 0; i < q; i++) {\n        int type, l, r;\n        scanf(\"%d %d %d\", &type, &l, &r);\n        l--;\n        r--;\n\n        if (type == 1) {\n            g_array_index(A, int, l) = r;\n        } else if (type == 2) {\n            g_array_index(B, int, l) = r;\n        } else if (type == 3) {\n            long long result = query(l, r);\n            printf(\"%lld\\n\", result);\n        }\n    }\n\n    g_array_free(A, TRUE);\n    g_array_free(B, TRUE);\n    g_array_free(prefix_max, TRUE);\n    g_array_free(suffix_max, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_e6mh7jkq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_e6mh7jkq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc368_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    GQueue *queue = g_queue_new();\n\n    // Read the initial stack of cards and add them to the queue\n    for (int i = 0; i < n; i++) {\n        int card;\n        scanf(\"%d\", &card);\n        g_queue_push_tail(queue, GINT_TO_POINTER(card));\n    }\n\n    // Move the bottom K cards to the top\n    for (int i = 0; i < k; i++) {\n        int card = GPOINTER_TO_INT(g_queue_pop_tail(queue));\n        g_queue_push_head(queue, GINT_TO_POINTER(card));\n    }\n\n    // Print the cards in the new order\n    for (int i = 0; i < n; i++) {\n        int card = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        printf(\"%d \", card);\n        g_queue_push_tail(queue, GINT_TO_POINTER(card));  // Reinsert the card to maintain the queue\n    }\n\n    printf(\"\\n\");\n\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_gnk6zx8j/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_gnk6zx8j/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc368_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    int operations = 0;\n\n    while (g_array_index(arr, int, 0) > 0 && g_array_index(arr, int, 1) > 0) {\n        // Sort in descending order\n        g_array_sort(arr, (GCompareFunc)g_int_compare);\n\n        // Decrease the first two elements by 1\n        int first = g_array_index(arr, int, 0);\n        int second = g_array_index(arr, int, 1);\n        g_array_index(arr, int, 0) = first - 1;\n        g_array_index(arr, int, 1) = second - 1;\n\n        operations++;\n    }\n\n    printf(\"%d\n\", operations);\n\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_rxyumkz3/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_rxyumkz3/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc368_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n\n        int odd_divisors = 0;\n        for (int j = 2; j <= a; j++) {\n            if (a % j == 0 && (j & 1) == 1) {\n                odd_divisors++;\n            }\n        }\n\n        if (odd_divisors % 2 == 1) {\n            g_hash_table_insert(count, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n        } else {\n            g_hash_table_insert(count, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n        }\n    }\n\n    int total_odd = 0;\n    for (gpointer key, value; g_hash_table_iter_init(&iter, count); g_hash_table_iter_next(&iter, &key, &value)) {\n        total_odd += GPOINTER_TO_INT(value);\n    }\n\n    if (total_odd % 2 == 1) {\n        printf(\"Anna\n\");\n    } else {\n        printf(\"Bruno\n\");\n    }\n\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_352xrxzh/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_352xrxzh/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc368_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize variables\n    GArray *enemies = g_array_new(FALSE, FALSE, sizeof(int));\n    int T = 0;\n\n    // Read enemy healths\n    for (int i = 0; i < n; i++) {\n        int health;\n        scanf(\"%d\", &health);\n        g_array_append_val(enemies, health);\n    }\n\n    // Process until all enemies have health 0 or less\n    while (g_array_length(enemies) > 0) {\n        // Attack the frontmost enemy\n        int *frontmost = &g_array_index(enemies, int, 0);\n        if (*frontmost > 0) {\n            if (T % 3 == 0) {\n                *frontmost -= 3;\n            } else {\n                *frontmost -= 1;\n            }\n            T++;\n        }\n\n        // If the frontmost enemy's health is 0 or less, remove it\n        if (*frontmost <= 0) {\n            g_array_remove_range(enemies, 0, 1);\n        }\n    }\n\n    // Output the number of actions performed\n    printf(\"%d\\n\", T);\n\n    // Clean up\n    g_array_free(enemies, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_j2luulxu/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_j2luulxu/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc368_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\nGArray *adj[MAXN];\nGHashTable *parent;\nGHashTable *depth;\n\nvoid add_edge(int u, int v) {\n    g_array_append_val(adj[u], v);\n    g_array_append_val(adj[v], u);\n}\n\nvoid dfs(int u, int p, int d) {\n    parent = g_hash_table_new(g_direct_hash, g_direct_equal);\n    g_hash_table_insert(parent, GINT_TO_POINTER(u), GINT_TO_POINTER(p));\n    depth = g_hash_table_new(g_direct_hash, g_direct_equal);\n    g_hash_table_insert(depth, GINT_TO_POINTER(u), GINT_TO_POINTER(d));\n\n    for (int i = 0; i < g_array_get_length(adj[u]); i++) {\n        int v = g_array_index(adj[u], int, i);\n        if (v != p) {\n            dfs(v, u, d + 1);\n        }\n    }\n\n    g_hash_table_destroy(parent);\n    g_hash_table_destroy(depth);\n}\n\nint lca(int u, int v) {\n    int d1 = g_hash_table_lookup(depth, GINT_TO_POINTER(u));\n    int d2 = g_hash_table_lookup(depth, GINT_TO_POINTER(v));\n\n    if (d1 > d2) {\n        u = g_hash_table_lookup(parent, GINT_TO_POINTER(u));\n    } else if (d1 < d2) {\n        v = g_hash_table_lookup(parent, GINT_TO_POINTER(v));\n    }\n\n    while (u != v) {\n        u = g_hash_table_lookup(parent, GINT_TO_POINTER(u));\n        v = g_hash_table_lookup(parent, GINT_TO_POINTER(v));\n    }\n\n    return u;\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    for (int i = 0; i < n; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a - 1, b - 1);\n    }\n\n    int *vertices = (int *)malloc(k * sizeof(int));\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d\", &vertices[i]);\n        vertices[i]--;\n    }\n\n    int lca_result = vertices[0];\n    for (int i = 1; i < k; i++) {\n        lca_result = lca(lca_result, vertices[i]);\n    }\n\n    int count = 0;\n    dfs(lca_result, -1, 0);\n    for (int i = 0; i < k; i++) {\n        count += g_hash_table_lookup(depth, GINT_TO_POINTER(vertices[i])) + 1;\n    }\n\n    printf(\"%d\\n\", count);\n\n    for (int i = 0; i < n; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    free(vertices);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_374giaal/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_374giaal/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc368_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Define a structure to hold train details\ntypedef struct {\n    int A, B, S, T;\n} Train;\n\n// Comparison function for qsort to sort trains by arrival time\nint compare(const void *a, const void *b) {\n    Train *t1 = (Train *)a;\n    Train *t2 = (Train *)b;\n    return t1->T - t2->T;\n}\n\nint main() {\n    int N, M, X1;\n    scanf(\"%d %d %d\", &N, &M, &X1);\n\n    Train *trains = (Train *)malloc(M * sizeof(Train));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d %d\", &trains[i].A, &trains[i].B, &trains[i].S, &trains[i].T);\n    }\n\n    // Sort trains by their arrival time\n    qsort(trains, M, sizeof(Train), compare);\n\n    // Initialize the delays array with X1\n    int *delays = (int *)malloc(M * sizeof(int));\n    memset(delays, X1, M * sizeof(int));\n\n    // Calculate the minimum delays required for each train\n    for (int i = 1; i < M; i++) {\n        for (int j = 0; j < i; j++) {\n            if (trains[j].B == trains[i].A && trains[i].S <= trains[j].T) {\n                delays[i] = delays[j] + (trains[j].T - trains[i].S + 1);\n            }\n        }\n    }\n\n    // Print the delays for trains 2 to M\n    for (int i = 1; i < M; i++) {\n        printf(\"%d \", delays[i]);\n    }\n    printf(\"\\n\");\n\n    // Free allocated memory\n    free(trains);\n    free(delays);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_rfx2lwzk/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_rfx2lwzk/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc369_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    qsort(A, n, sizeof(int), compare);\n\n    long long max_points = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            max_points += A[i];\n        } else {\n            max_points += 2 * A[i];\n        }\n    }\n\n    printf(\"%lld\\n\", max_points);\n\n    free(A);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_660i6l3f/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_660i6l3f/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc369_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    return ((Edge *)a)->w - ((Edge *)b)->w;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Edge edges[n - 1];\n    for (int i = 0; i < n - 1; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n        edges[i].u--;\n        edges[i].v--;\n    }\n\n    qsort(edges, n - 1, sizeof(Edge), compare);\n\n    GHashTable *graph[n];\n    for (int i = 0; i < n; i++) {\n        graph[i] = g_hash_table_new(g_direct_hash, g_direct_equal);\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        g_hash_table_insert(graph[edges[i].u], GINT_TO_POINTER(edges[i].v), GINT_TO_POINTER(edges[i].w));\n        g_hash_table_insert(graph[edges[i].v], GINT_TO_POINTER(edges[i].u), GINT_TO_POINTER(edges[i].w));\n    }\n\n    for (int k = 1; k <= n; k++) {\n        long long total = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int dist = 0;\n                GQueue *queue = g_queue_new();\n                GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n                g_queue_push_tail(queue, GINT_TO_POINTER(i));\n                g_hash_table_insert(visited, GINT_TO_POINTER(i), NULL);\n\n                while (!g_queue_is_empty(queue)) {\n                    int curr = GPOINTER_TO_INT(g_queue_pop_head(queue));\n                    if (curr == j) {\n                        break;\n                    }\n                    GHashTable *adj = graph[curr];\n                    GHashTableIter iter;\n                    gpointer key, value;\n                    g_hash_table_iter_init(&iter, adj);\n                    while (g_hash_table_iter_next(&iter, &key, &value)) {\n                        int neighbor = GPOINTER_TO_INT(key);\n                        int weight = GPOINTER_TO_INT(value);\n                        if (!g_hash_table_contains(visited, GINT_TO_POINTER(neighbor))) {\n                            dist += weight;\n                            g_queue_push_tail(queue, GINT_TO_POINTER(neighbor));\n                            g_hash_table_insert(visited, GINT_TO_POINTER(neighbor), NULL);\n                        }\n                    }\n                }\n\n                g_queue_free(queue);\n                g_hash_table_destroy(visited);\n\n                total += dist;\n            }\n        }\n\n        printf(\"%lld\n\", total);\n    }\n\n    for (int i = 0; i < n; i++) {\n        g_hash_table_destroy(graph[i]);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_3zpqwjkz/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_3zpqwjkz/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc369_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Initialize variables\n    long long count = 0;\n\n    // Iterate over all possible subarrays\n    for (int i = 0; i < n; i++) {\n        // Use a hash map to store the differences and their counts\n        GHashTable *diff_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n        for (int j = i + 1; j < n; j++) {\n            int diff = A[j] - A[j - 1];\n            gpointer value = g_hash_table_lookup(diff_count, GINT_TO_POINTER(diff));\n            if (value != NULL) {\n                count += GPOINTER_TO_INT(value);\n            }\n            g_hash_table_insert(diff_count, GINT_TO_POINTER(diff), GINT_TO_POINTER(GPOINTER_TO_INT(value) + 1));\n        }\n        g_hash_table_destroy(diff_count);\n    }\n\n    // Output result\n    printf(\"%lld\n\", count);\n\n    // Free memory\n    free(A);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4uzr6k5k/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_4uzr6k5k/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc369_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int A, B;\n    scanf(\"%d %d\", &A, &B);\n\n    int count = 0;\n\n    // Check for x = (2*A + B) / 2\n    if ((2*A + B) % 2 == 0) {\n        int x = (2*A + B) / 2;\n        if (x >= 1 && x <= 100) {\n            count++;\n        }\n    }\n\n    // Check for x = (A + 2*B) / 2\n    if ((A + 2*B) % 2 == 0) {\n        int x = (A + 2*B) / 2;\n        if (x >= 1 && x <= 100) {\n            count++;\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_cnmjie47/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_cnmjie47/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc369_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *positions = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int left_hand = 0, right_hand = 0;\n    int fatigue = 0;\n\n    for (int i = 0; i < n; i++) {\n        int key;\n        char hand;\n        scanf(\"%d %c\", &key, &hand);\n\n        if (hand == 'L') {\n            if (left_hand != 0) {\n                fatigue += abs(key - left_hand);\n            }\n            left_hand = key;\n        } else {\n            if (right_hand != 0) {\n                fatigue += abs(key - right_hand);\n            }\n            right_hand = key;\n        }\n    }\n\n    printf(\"%d\n\", fatigue);\n\n    g_hash_table_destroy(positions);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_cnkgosdr/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_cnkgosdr/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc369_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 400\n#define MAX_M 200000\n#define MAX_Q 3000\n#define MAX_K 5\n\ntypedef struct {\n    int u, v, t;\n} Bridge;\n\ntypedef struct {\n    int island, time;\n} State;\n\nint compare(const void *a, const void *b) {\n    return ((State *)a)->time - ((State *)b)->time;\n}\n\nint min_time_to_travel(int n, int m, Bridge *bridges, int q, int *k, int **queries) {\n    // Build the graph using adjacency list\n    GArray *adj[MAX_N] = {NULL};\n    for (int i = 1; i <= n; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n    for (int i = 0; i < m; i++) {\n        g_array_append_val(adj[bridges[i].u], bridges[i].v);\n        g_array_append_val(adj[bridges[i].v], bridges[i].u);\n    }\n\n    // Initialize DP table\n    int dp[n + 1][1 << m];\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j < 1 << m; j++) {\n            dp[i][j] = INT_MAX;\n        }\n    }\n    dp[1][0] = 0;\n\n    // Perform Dijkstra's algorithm with memoization\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER((State){1, 0}));\n\n    while (!g_queue_is_empty(queue)) {\n        State current = *(State *)g_queue_pop_head(queue);\n\n        for (int i = 0; i < adj[current.island].len; i++) {\n            int next_island = g_array_index(adj[current.island], int, i);\n\n            for (int j = 0; j < m; j++) {\n                if (bridges[j].u == current.island && bridges[j].v == next_island ||\n                    bridges[j].u == next_island && bridges[j].v == current.island) {\n                    int next_state = (1 << j) | current.time;\n\n                    if (dp[next_island][next_state] > dp[current.island][current.time] + bridges[j].t) {\n                        dp[next_island][next_state] = dp[current.island][current.time] + bridges[j].t;\n                        g_queue_push_tail(queue, GINT_TO_POINTER((State){next_island, dp[next_island][next_state]}));\n                    }\n                }\n            }\n        }\n    }\n\n    // Find the minimum time for each query\n    int result[q];\n    for (int i = 0; i < q; i++) {\n        int min_time = INT_MAX;\n\n        for (int j = 0; j < k[i]; j++) {\n            int bridge_index = queries[i][j] - 1;\n\n            for (int state = 0; state < 1 << m; state++) {\n                if (state & (1 << bridge_index)) {\n                    min_time = fmin(min_time, dp[n][state]);\n                }\n            }\n        }\n\n        result[i] = min_time;\n    }\n\n    // Free memory\n    for (int i = 1; i <= n; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n    g_queue_free(queue);\n\n    return result;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    Bridge bridges[m];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &bridges[i].u, &bridges[i].v, &bridges[i].t);\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n\n    int k[q];\n    int queries[q][MAX_K];\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d\", &k[i]);\n        for (int j = 0; j < k[i]; j++) {\n            scanf(\"%d\", &queries[i][j]);\n        }\n    }\n\n    int *result = min_time_to_travel(n, m, bridges, q, k, queries);\n\n    for (int i = 0; i < q; i++) {\n        printf(\"%d\\n\", result[i]);\n    }\n\n    free(result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_hqckfjbm/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_hqckfjbm/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc370_a", "solution": "#include <stdio.h>\n\nint main() {\n    int L, R;\n    scanf(\"%d %d\", &L, &R);\n\n    if (L == 1 && R == 0) {\n        printf(\"Yes\n\");\n    } else if (L == 0 && R == 1) {\n        printf(\"No\n\");\n    } else {\n        printf(\"Invalid\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tvjmf3xb/program.c: In function 'main':\\n/tmp/agnostics_c_tvjmf3xb/program.c:8:16: warning: missing terminating \\\" character\\n    8 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_tvjmf3xb/program.c:8:16: error: missing terminating \\\" character\\n    8 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_tvjmf3xb/program.c:9:1: warning: missing terminating \\\" character\\n    9 | \\\");\\n      | ^\\n/tmp/agnostics_c_tvjmf3xb/program.c:9:1: error: missing terminating \\\" character\\n    9 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_tvjmf3xb/program.c:10:5: error: expected expression before '}' token\\n   10 |     } else if (L == 0 && R == 1) {\\n      |     ^\\n/tmp/agnostics_c_tvjmf3xb/program.c:8:16: error: expected ';' before '}' token\\n    8 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n    9 | \\\");\\n   10 |     } else if (L == 0 && R == 1) {\\n      |     ~           \\n/tmp/agnostics_c_tvjmf3xb/program.c:11:16: warning: missing terminating \\\" character\\n   11 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_tvjmf3xb/program.c:11:16: error: missing terminating \\\" character\\n   11 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_tvjmf3xb/program.c:12:1: warning: missing terminating \\\" character\\n   12 | \\\");\\n      | ^\\n/tmp/agnostics_c_tvjmf3xb/program.c:12:1: error: missing terminating \\\" character\\n   12 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_tvjmf3xb/program.c:13:5: error: expected expression before '}' token\\n   13 |     } else {\\n      |     ^\\n/tmp/agnostics_c_tvjmf3xb/program.c:11:16: error: expected ';' before '}' token\\n   11 |         printf(\\\"No\\n      |                ^\\n      |                ;\\n   12 | \\\");\\n   13 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_tvjmf3xb/program.c:14:16: warning: missing terminating \\\" character\\n   14 |         printf(\\\"Invalid\\n      |                ^\\n/tmp/agnostics", "raw_stderr": "", "result": "fail"}
{"question_id": "abc370_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nGHashTable *factorization(int n) {\n    GHashTable *fact = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 2; i * i <= n; i++) {\n        int count = 0;\n        while (n % i == 0) {\n            n /= i;\n            count++;\n        }\n        if (count > 0) {\n            g_hash_table_insert(fact, GINT_TO_POINTER(i), GINT_TO_POINTER(count));\n        }\n    }\n    if (n > 1) {\n        g_hash_table_insert(fact, GINT_TO_POINTER(n), GINT_TO_POINTER(1));\n    }\n    return fact;\n}\n\nint dp[100001][100001];\n\nint count_sequences(int product, int length, int M, GHashTable *factorization) {\n    if (length == M) {\n        return product % 3 == 0 ? 1 : 0;\n    }\n    if (dp[product][length] != -1) {\n        return dp[product][length];\n    }\n    int count = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, factorization);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int prime = GPOINTER_TO_INT(key);\n        int exp = GPOINTER_TO_INT(value);\n        for (int i = 0; i <= exp; i++) {\n            count = (count + count_sequences(product * pow(prime, i), length + 1, M, factorization)) % MOD;\n        }\n    }\n    dp[product][length] = count;\n    return count;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    memset(dp, -1, sizeof(dp));\n    int result = 0;\n    for (int i = 1; i <= N; i++) {\n        GHashTable *fact = factorization(i);\n        result = (result + count_sequences(i, 1, M, fact)) % MOD;\n        g_hash_table_destroy(fact);\n    }\n    printf(\"%d\n\", result);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_7pxobvt9/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_7pxobvt9/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc370_c", "solution": null, "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:other\", \"stdout\": \"\", \"stderr\": \"Invalid JSON input: Unterminated string starting at: line 1 column 58275 (char 58274)\"}\n", "raw_stderr": "", "result": "fail:other", "stdout": "", "stderr": "Invalid JSON input: Unterminated string starting at: line 1 column 58275 (char 58274)"}
{"question_id": "abc370_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <glib.h>\n\n#define MAX_H 400000\n#define MAX_W 400000\n\nint main() {\n    int H, W, Q;\n    scanf(\"%d %d %d\", &H, &W, &Q);\n\n    GHashTable *walls = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            g_hash_table_insert(walls, GINT_TO_POINTER(i * W + j), GINT_TO_POINTER(1));\n        }\n    }\n\n    for (int q = 0; q < Q; q++) {\n        int R, C;\n        scanf(\"%d %d\", &R, &C);\n\n        int pos = (R - 1) * W + (C - 1);\n        if (g_hash_table_lookup(walls, GINT_TO_POINTER(pos))) {\n            g_hash_table_remove(walls, GINT_TO_POINTER(pos));\n        } else {\n            for (int i = R - 1; i >= 0; i--) {\n                int up_pos = (i - 1) * W + (C - 1);\n                if (g_hash_table_lookup(walls, GINT_TO_POINTER(up_pos))) {\n                    g_hash_table_remove(walls, GINT_TO_POINTER(up_pos));\n                    break;\n                }\n            }\n\n            for (int i = R - 1; i < H; i++) {\n                int down_pos = i * W + (C - 1);\n                if (g_hash_table_lookup(walls, GINT_TO_POINTER(down_pos))) {\n                    g_hash_table_remove(walls, GINT_TO_POINTER(down_pos));\n                    break;\n                }\n            }\n\n            for (int j = C - 1; j >= 0; j--) {\n                int left_pos = (R - 1) * W + (j - 1);\n                if (g_hash_table_lookup(walls, GINT_TO_POINTER(left_pos))) {\n                    g_hash_table_remove(walls, GINT_TO_POINTER(left_pos));\n                    break;\n                }\n            }\n\n            for (int j = C - 1; j < W; j++) {\n                int right_pos = (R - 1) * W + j;\n                if (g_hash_table_lookup(walls, GINT_TO_POINTER(right_pos))) {\n                    g_hash_table_remove(walls, GINT_TO_POINTER(right_pos));\n                    break;\n                }\n            }\n        }\n    }\n\n    printf(\"%zu\\n\", g_hash_table_size(walls));\n\n    g_hash_table_destroy(walls);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_mm4tswk5/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_mm4tswk5/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc370_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nGHashTable *memo;\n\n// Function to calculate the number of ways to divide the sequence such that no subsequence sums to K\nlong long countWays(int *arr, int n, int k, long long currentSum) {\n    // Base case: if we have processed all elements\n    if (n == 0) {\n        return (currentSum != k);\n    }\n\n    // Check if the result is already computed\n    gpointer result = g_hash_table_lookup(memo, GINT_TO_POINTER((n << 32) | (currentSum & 0xFFFFFFFFLL) | (k & 0xFFFFFFFFLL)));\n    if (result != NULL) {\n        return GPOINTER_TO_LONG(result);\n    }\n\n    // Option 1: Continue the current subsequence\n    long long continueCurrent = countWays(arr, n - 1, k, currentSum + arr[n - 1]);\n\n    // Option 2: Start a new subsequence\n    long long startNewSubsequence = countWays(arr, n - 1, k, arr[n - 1]);\n\n    // Total ways = ways to continue current + ways to start new\n    long long totalWays = (continueCurrent + startNewSubsequence) % MOD;\n\n    // Store the result in the memo table\n    g_hash_table_insert(memo, GINT_TO_POINTER((n << 32) | (currentSum & 0xFFFFFFFFLL) | (k & 0xFFFFFFFFLL)), GINT_TO_POINTER(totalWays));\n\n    return totalWays;\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    memo = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    long long result = countWays(arr, n, k, 0);\n\n    printf(\"%lld\\n\", result);\n\n    free(arr);\n    g_hash_table_destroy(memo);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_57kza4_b/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_57kza4_b/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc370_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Create a hash table to store transformation results\n    GHashTable *transformation = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read the transformation matrix\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= i; j++) {\n            int value;\n            scanf(\"%d\", &value);\n            g_hash_table_insert(transformation, GINT_TO_POINTER(i * 100 + j), GINT_TO_POINTER(value));\n        }\n    }\n\n    // Initialize the queue with the first element\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(1));\n\n    // Process the queue to find the final element\n    while (!g_queue_is_empty(queue)) {\n        int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        for (int i = 1; i <= N; i++) {\n            int key = current * 100 + i;\n            if (g_hash_table_contains(transformation, GINT_TO_POINTER(key))) {\n                int next = GPOINTER_TO_INT(g_hash_table_lookup(transformation, GINT_TO_POINTER(key)));\n                g_queue_push_tail(queue, GINT_TO_POINTER(next));\n            }\n        }\n    }\n\n    // Output the final element\n    printf(\"%d\n\", GPOINTER_TO_INT(g_queue_pop_head(queue)));\n\n    // Clean up\n    g_hash_table_destroy(transformation);\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_rg_4mdkz/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_rg_4mdkz/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc370_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    qsort(a, n, sizeof(int), compare);\n\n    int prefix_sum[n + 1];\n    prefix_sum[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1];\n    }\n\n    int min_weight = INT_MAX;\n    int never_cut = 0;\n\n    for (int i = 0; i < n; i++) {\n        int current_weight = prefix_sum[n] - prefix_sum[i];\n        int cut_lines = n - i;\n\n        if (current_weight < min_weight) {\n            min_weight = current_weight;\n            never_cut = cut_lines;\n        } else if (current_weight == min_weight) {\n            never_cut = fmin(never_cut, cut_lines);\n        }\n    }\n\n    printf(\"%d %d\n\", min_weight, never_cut);\n\n    free(a);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_mqf96qag/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_mqf96qag/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc371_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Initialize a hash table to store the earliest-born male child for each family\n    GHashTable *earliest_male = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < m; i++) {\n        int family, gender;\n        scanf(\"%d %d\", &family, &gender);\n\n        // Check if the baby is male\n        if (gender == 1) {\n            // Check if this is the earliest-born male in the family\n            gpointer existing_earliest = g_hash_table_lookup(earliest_male, GINT_TO_POINTER(family));\n            if (existing_earliest == NULL || GPOINTER_TO_INT(existing_earliest) > i) {\n                // Update the hash table with the current baby\n                g_hash_table_insert(earliest_male, GINT_TO_POINTER(family), GINT_TO_POINTER(i));\n            }\n        }\n\n        // Determine if the name given is Taro\n        if (g_hash_table_lookup(earliest_male, GINT_TO_POINTER(family)) == GINT_TO_POINTER(i)) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    // Clean up\n    g_hash_table_destroy(earliest_male);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_p2h_h_ri/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_p2h_h_ri/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc371_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d\", &n);\n\n    int *x = (int *)malloc(n * sizeof(int));\n    int *p = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &x[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n\n    scanf(\"%d\", &q);\n\n    GArray *prefix_sum = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_append_val(prefix_sum, 0);\n\n    for (int i = 0; i < n; i++) {\n        g_array_append_val(prefix_sum, g_array_index(prefix_sum, int, i) + p[i]);\n    }\n\n    qsort(x, n, sizeof(int), compare);\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n\n        int idx_l = g_array_bsearch(prefix_sum, GINT_TO_POINTER(l), 0, prefix_sum->len, compare);\n        int idx_r = g_array_bsearch(prefix_sum, GINT_TO_POINTER(r), 0, prefix_sum->len, compare);\n\n        if (idx_l == -1) idx_l = 0;\n        if (idx_r == -1) idx_r = prefix_sum->len - 1;\n\n        int result = g_array_index(prefix_sum, int, idx_r) - g_array_index(prefix_sum, int, idx_l);\n        printf(\"%d\n\", result);\n    }\n\n    g_array_free(prefix_sum, TRUE);\n    free(x);\n    free(p);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_rj2c9nbd/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_rj2c9nbd/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc371_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *P = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        g_array_append_val(P, p);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(\"%d\", &a);\n        g_array_append_val(A, a);\n    }\n\n    int *visited = (int *)calloc(n, sizeof(int));\n    int *cycle = (int *)malloc(n * sizeof(int));\n    int cycle_size = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            int start = i;\n            do {\n                cycle[cycle_size++] = A->data[i];\n                visited[i] = 1;\n                i = P->data[i] - 1;\n            } while (i != start);\n        }\n    }\n\n    qsort(cycle, cycle_size, sizeof(int), compare);\n\n    int *result = (int *)malloc(n * sizeof(int));\n    int result_index = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (visited[i]) {\n            result[result_index++] = cycle[i % cycle_size];\n        } else {\n            result[result_index++] = A->data[i];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", result[i]);\n    }\n    printf(\"\\n\");\n\n    free(visited);\n    free(cycle);\n    free(result);\n    g_array_free(P, TRUE);\n    g_array_free(A, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_qw2ynkdp/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_qw2ynkdp/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc371_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n    int *positions = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &positions[i]);\n    }\n\n    int q;\n    scanf(\"%d\", &q);\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < n; i++) {\n        g_hash_table_insert(map, GINT_TO_POINTER(positions[i]), GINT_TO_POINTER(i));\n    }\n\n    long long total_moves = 0;\n    for (int i = 0; i < q; i++) {\n        int t, g;\n        scanf(\"%d %d\", &t, &g);\n        int *pos = (int *)g_hash_table_lookup(map, GINT_TO_POINTER(g));\n        if (pos != NULL) {\n            total_moves += abs(*pos - t);\n        }\n    }\n\n    // Output result\n    printf(\"%lld\n\", total_moves);\n\n    // Clean up\n    free(positions);\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_kfzd3r2u/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_kfzd3r2u/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc371_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 8\n#define INF 1e9\n\nint N, M_G, M_H;\nint edges_G[MAXN][MAXN] = {0};\nint edges_H[MAXN][MAXN] = {0};\nint costs[MAXN][MAXN] = {0};\n\nvoid read_input() {\n    scanf(\"%d\", &N);\n    scanf(\"%d\", &M_G);\n    for (int i = 0; i < M_G; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        edges_G[u - 1][v - 1] = 1;\n        edges_G[v - 1][u - 1] = 1;\n    }\n    scanf(\"%d\", &M_H);\n    for (int i = 0; i < M_H; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        edges_H[a - 1][b - 1] = 1;\n        edges_H[b - 1][a - 1] = 1;\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            scanf(\"%d\", &costs[i][j]);\n            costs[j][i] = costs[i][j];\n        }\n    }\n}\n\nint min_cost_to_isomorphic() {\n    int dp[MAXN][1 << N] = {0};\n\n    for (int i = 0; i < 1 << N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[j][i] = INF;\n        }\n    }\n\n    dp[0][0] = 0;\n\n    for (int i = 1; i < 1 << N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i & (1 << j)) {\n                int prev = i ^ (1 << j);\n                for (int k = 0; k < N; k++) {\n                    if (prev & (1 << k)) {\n                        dp[j][i] = fmin(dp[j][i], dp[k][prev] + costs[j][k]);\n                    }\n                }\n            }\n        }\n    }\n\n    int min_cost = INF;\n    for (int i = 0; i < N; i++) {\n        min_cost = fmin(min_cost, dp[i][(1 << N) - 1]);\n    }\n\n    return min_cost;\n}\n\nint main() {\n    read_input();\n    printf(\"%d\n\", min_cost_to_isomorphic());\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_voyz4l_9/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_voyz4l_9/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc371_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int *prefix = (int *)calloc(n, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int key = arr[i];\n        gpointer value = g_hash_table_lookup(count, GINT_TO_POINTER(key));\n        if (value == NULL) {\n            g_hash_table_insert(count, GINT_TO_POINTER(key), GINT_TO_POINTER(1));\n            prefix[i] = prefix[i - 1] + 1;\n        } else {\n            int prev_count = GPOINTER_TO_INT(value);\n            g_hash_table_insert(count, GINT_TO_POINTER(key), GINT_TO_POINTER(prev_count + 1));\n            prefix[i] = prefix[i - 1];\n        }\n    }\n\n    long long result = 0;\n    for (int i = 0; i < n; i++) {\n        result += prefix[i];\n    }\n\n    printf(\"%lld\\n\", result);\n\n    free(arr);\n    free(prefix);\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_pmtwmw8l/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_pmtwmw8l/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc371_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char relationships[4];\n    scanf(\"%s\", relationships);\n\n    // Initialize age relationships\n    bool A_older_than_B = (relationships[0] == \">\");\n    bool A_older_than_C = (relationships[1] == \">\");\n    bool B_older_than_C = (relationships[2] == \">\");\n\n    // Determine the middle brother\n    char middle_brother;\n    if (A_older_than_B && A_older_than_C) {\n        if (B_older_than_C) {\n            middle_brother = 'B';\n        } else {\n            middle_brother = 'C';\n        }\n    } else if (A_older_than_B && !A_older_than_C) {\n        middle_brother = 'A';\n    } else if (!A_older_than_B && A_older_than_C) {\n        middle_brother = 'A';\n    } else {\n        middle_brother = 'B';\n    }\n\n    // Output the result\n    printf(\"%c\n\", middle_brother);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_o86k6vix/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_o86k6vix/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc372_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n// Function to compare two integers for sorting\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    // Initialize a hash table to store adjacency lists\n    GHashTable *graph = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < Q; i++) {\n        int type;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n\n            // Add edge u -> v\n            GArray *list_u = g_hash_table_lookup(graph, GINT_TO_POINTER(u));\n            if (!list_u) {\n                list_u = g_array_new(FALSE, FALSE, sizeof(int));\n                g_hash_table_insert(graph, GINT_TO_POINTER(u), list_u);\n            }\n            g_array_append_val(list_u, v);\n\n            // Add edge v -> u\n            GArray *list_v = g_hash_table_lookup(graph, GINT_TO_POINTER(v));\n            if (!list_v) {\n                list_v = g_array_new(FALSE, FALSE, sizeof(int));\n                g_hash_table_insert(graph, GINT_TO_POINTER(v), list_v);\n            }\n            g_array_append_val(list_v, u);\n        } else if (type == 2) {\n            int v, k;\n            scanf(\"%d %d\", &v, &k);\n\n            // Get the list of connected vertices\n            GArray *list = g_hash_table_lookup(graph, GINT_TO_POINTER(v));\n            if (!list || list->len < k) {\n                printf(\"-1\n\");\n                continue;\n            }\n\n            // Sort the list in descending order\n            qsort(list->data, list->len, sizeof(int), compare);\n\n            // Print the k-th largest element\n            printf(\"%d\n\", g_array_index(list, int, k-1));\n        }\n    }\n\n    // Free the allocated memory\n    g_hash_table_destroy(graph);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8vvf_vqs/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_8vvf_vqs/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc372_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    char *s = (char *)malloc(n + 1);\n    scanf(\"%s\", s);\n\n    GHashTable *abc_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initialize the count of 'ABC' in the initial string\n    int count = 0;\n    for (int i = 0; i <= n - 3; i++) {\n        if (s[i] == 'A' && s[i + 1] == 'B' && s[i + 2] == 'C') {\n            count++;\n        }\n    }\n    g_hash_table_insert(abc_count, GINT_TO_POINTER(0), GINT_TO_POINTER(count));\n\n    for (int i = 0; i < q; i++) {\n        int x;\n        char c;\n        scanf(\"%d %c\", &x, &c);\n\n        // Update the string and count 'ABC'\n        if (s[x - 1] != c) {\n            char old_char = s[x - 1];\n            s[x - 1] = c;\n\n            // Update the count based on the change\n            if (x >= 2 && x <= n - 2) {\n                int prev_count = GPOINTER_TO_INT(g_hash_table_lookup(abc_count, GINT_TO_POINTER(i - 1)));\n                int new_count = prev_count;\n\n                // Check if the previous 'ABC' is still valid\n                if (old_char == 'A' && s[x - 2] == 'B' && s[x - 1] == 'C') {\n                    new_count--;\n                }\n\n                // Check if the new 'ABC' is valid\n                if (s[x - 2] == 'A' && s[x - 1] == 'B' && c == 'C') {\n                    new_count++;\n                }\n\n                g_hash_table_insert(abc_count, GINT_TO_POINTER(i), GINT_TO_POINTER(new_count));\n            } else {\n                g_hash_table_insert(abc_count, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n            }\n        }\n\n        // Print the count of 'ABC' after the update\n        int final_count = GPOINTER_TO_INT(g_hash_table_lookup(abc_count, GINT_TO_POINTER(i)));\n        printf(\"%d\\n\", final_count);\n    }\n\n    // Free allocated memory\n    free(s);\n    g_hash_table_destroy(abc_count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_fv9e342y/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_fv9e342y/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc372_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *heights = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n\n    GArray *result = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n        while (result->len > 0 && heights[i] > g_array_index(result, int, result->len - 1)) {\n            count++;\n            g_array_remove_index(result, result->len - 1);\n        }\n        count++;\n        g_array_append_val(result, count);\n    }\n\n    for (int i = 0; i < result->len; i++) {\n        printf(\"%d\", g_array_index(result, int, i));\n        if (i < result->len - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    g_array_free(result, TRUE);\n    free(heights);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_d2uhjorr/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_d2uhjorr/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc372_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define LL long long\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N;\n        scanf(\"%d\", &N);\n\n        GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n        LL total = 0;\n\n        for (int i = 0; i < N; i++) {\n            int A, B, C;\n            scanf(\"%d %d %d\", &A, &B, &C);\n\n            // Calculate the maximum possible value of x that satisfies the inequality\n            LL max_x = (C - 1) / A;\n\n            // Calculate the number of valid y values for each x\n            for (LL x = 1; x <= max_x; x++) {\n                LL y = (C - A * x) / B;\n                if (A * x + B * y < C) {\n                    total += y;\n                }\n            }\n        }\n\n        printf(\"%lld\\n\", total);\n\n        g_hash_table_destroy(map);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0kh92wbe/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0kh92wbe/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc372_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    GArray *adj = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i <= N; i++) {\n        g_array_append_val(adj, 0);\n    }\n\n    for (int i = 0; i < M; i++) {\n        int X, Y;\n        scanf(\"%d %d\", &X, &Y);\n        g_array_append_val(adj, Y);\n    }\n\n    int dp[K + 1][N + 1];\n    memset(dp, 0, sizeof(dp));\n\n    dp[0][1] = 1;\n\n    for (int i = 1; i <= K; i++) {\n        for (int v = 1; v <= N; v++) {\n            int next = g_array_index(adj, int, v);\n            dp[i][v] = (dp[i][v] + dp[i - 1][next]) % MOD;\n        }\n    }\n\n    int result = 0;\n    for (int v = 1; v <= N; v++) {\n        result = (result + dp[K][v]) % MOD;\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_array_free(adj, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_dgy7ub2o/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_dgy7ub2o/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc372_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input string\n    char input[101];  // 100 characters + 1 for the null terminator\n    scanf(\"%s\", input);\n\n    // Create a dynamic array to store the result\n    GArray *result = g_array_new(FALSE, FALSE, sizeof(char));\n\n    // Iterate through the input string\n    for (int i = 0; input[i] != '\\0'; i++) {\n        // If the character is not '.', append it to the result array\n        if (input[i] != \".\") {\n            g_array_append_val(result, input[i]);\n        }\n    }\n\n    // Convert the GArray to a null-terminated string\n    char *output = (char *)g_array_free(result, FALSE);\n\n    // Print the result\n    printf(\"%s\\n\", output);\n\n    // Free the dynamically allocated string\n    free(output);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_xuzuew2d/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_xuzuew2d/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc373_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Initialize a hash table to count the number of valid strings\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initialize the count for each index to 0\n    for (int i = 1; i <= 12; i++) {\n        g_hash_table_insert(count, GINT_TO_POINTER(i), GINT_TO_POINTER(0));\n    }\n\n    // Read the 12 strings from standard input\n    for (int i = 0; i < 12; i++) {\n        char str[101]; // Buffer to store the string\n        scanf(\"%s\", str);\n\n        // Get the length of the string\n        int len = strlen(str);\n\n        // Check if the length matches the index (1-based)\n        if (len == i + 1) {\n            // Increment the count for this length\n            int *current_count = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(i + 1)));\n            *current_count += 1;\n        }\n    }\n\n    // Initialize the result to 0\n    int result = 0;\n\n    // Sum up the counts for all valid lengths\n    for (int i = 1; i <= 12; i++) {\n        int *count_value = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(i)));\n        result += *count_value;\n    }\n\n    // Print the result\n    printf(\"%d\\n\", result);\n\n    // Clean up the hash table\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_uc461gpd/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_uc461gpd/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc373_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[1000];\n    scanf(\"%s\", S);\n\n    int n = strlen(S);\n    int total_distance = 0;\n\n    // Initialize the starting position of the finger at the key for A (coordinate 1)\n    int current_position = 1;\n\n    // Iterate through the permutation string\n    for (int i = 0; i < n; i++) {\n        // Calculate the coordinate of the current key\n        int current_key = S[i] - 'A' + 1;\n\n        // Calculate the distance from the current position to the current key\n        int distance = abs(current_key - current_position);\n\n        // Accumulate the total distance\n        total_distance += distance;\n\n        // Update the current position to the current key\n        current_position = current_key;\n    }\n\n    // Output the total distance\n    printf(\"%d\n\", total_distance);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__fy7dezl/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__fy7dezl/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc373_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, W;\n    scanf(\"%d %d\", &N, &W);\n\n    GArray *items = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < N; i++) {\n        int w, v;\n        scanf(\"%d %d\", &w, &v);\n        g_array_append_val(items, w);\n        g_array_append_val(items, v);\n    }\n\n    int dp[N + 1][W + 1];\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 1; i <= N; i++) {\n        int w = g_array_index(items, int, (i - 1) * 2);\n        int v = g_array_index(items, int, (i - 1) * 2 + 1);\n        for (int j = 0; j <= W; j++) {\n            dp[i][j] = dp[i - 1][j];\n            for (int k = 1; k * w <= j; k++) {\n                dp[i][j] = fmax(dp[i][j], dp[i - 1][j - k * w] + k * v - k * k);\n            }\n        }\n    }\n\n    printf(\"%d\\n\", dp[N][W]);\n\n    g_array_free(items, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jsb2cw61/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jsb2cw61/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc373_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 300\n#define MAX_COORD 5000\n\n// Structure to store points\ntypedef struct {\n    int x, y;\n} Point;\n\n// Comparison function for qsort\nint compare(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    int slope1 = p1->y * MAX_COORD + p1->x;\n    int slope2 = p2->y * MAX_COORD + p2->x;\n    return slope1 - slope2;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    Point P[MAXN], Q[MAXN];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &P[i].x, &P[i].y);\n    }\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &Q[i].x, &Q[i].y);\n    }\n\n    // Sort points based on their slopes with respect to the origin\n    qsort(P, N, sizeof(Point), compare);\n    qsort(Q, N, sizeof(Point), compare);\n\n    // Construct the permutation R\n    int R[MAXN];\n    for (int i = 0; i < N; i++) {\n        R[i] = i + 1;\n    }\n\n    // Output the permutation\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", R[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_9_wikh1j/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_9_wikh1j/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc373_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    int *B = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n\n    int maxA = A[0];\n    int maxB = B[0];\n\n    for (int i = 1; i < n; i++) {\n        if (A[i] > maxA) {\n            maxA = A[i];\n        }\n        if (B[i] > maxB) {\n            maxB = B[i];\n        }\n    }\n\n    printf(\"%d\n\", maxA + maxB);\n\n    free(A);\n    free(B);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_6ccvhpy3/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_6ccvhpy3/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc373_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %lld\", &N, &M, &K);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Sort the votes in descending order\n    qsort(A, N, sizeof(int), compare);\n\n    // Calculate the total votes already counted\n    long long total_votes = 0;\n    for (int i = 0; i < N; i++) {\n        total_votes += A[i];\n    }\n\n    // Calculate the remaining votes\n    long long remaining_votes = K - total_votes;\n\n    // Calculate the minimum additional votes needed for each candidate\n    int *C = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        if (A[i] >= remaining_votes / (M + 1)) {\n            C[i] = -1;\n        } else {\n            C[i] = remaining_votes / (M + 1) - A[i];\n        }\n    }\n\n    // Print the result\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", C[i]);\n    }\n    printf(\"\\n\");\n\n    // Free allocated memory\n    free(A);\n    free(C);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_zwji1mlx/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_zwji1mlx/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc181_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\n// Function to update the Fenwick Tree\nvoid update(GArray *tree, int index, int value) {\n    while (index < tree->len) {\n        g_array_index(tree, int, index) += value;\n        index += index & -index;\n    }\n}\n\n// Function to get the prefix sum from the Fenwick Tree\nint prefix_sum(GArray *tree, int index) {\n    int sum = 0;\n    while (index > 0) {\n        sum += g_array_index(tree, int, index);\n        index -= index & -index;\n    }\n    return sum;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d\", &N);\n    int P[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n    scanf(\"%d\", &M);\n    int A[M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Initialize Fenwick Tree\n    GArray *tree = g_array_sized_new(FALSE, FALSE, sizeof(int), N + 1);\n    g_array_set_size(tree, N + 1);\n    memset(g_array_data(tree), 0, (N + 1) * sizeof(int));\n\n    // Calculate initial inversion number\n    int inversions = 0;\n    for (int i = 0; i < N; i++) {\n        inversions += i - prefix_sum(tree, P[i] - 1);\n        update(tree, P[i], 1);\n    }\n\n    // Process each operation\n    for (int i = 0; i < M; i++) {\n        int a = A[i];\n        int b = P[a - 1];\n        if (a == 1 || b == 1) {\n            printf(\"%d\\n\", inversions);\n            continue;\n        }\n\n        int pos1 = prefix_sum(tree, b - 1);\n        int pos2 = prefix_sum(tree, a - 2);\n        inversions -= pos1 - pos2;\n        update(tree, b, -1);\n        update(tree, a, 1);\n        inversions += pos1 - pos2;\n\n        printf(\"%d\\n\", inversions);\n    }\n\n    // Free resources\n    g_array_free(tree, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__c_j0e39/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__c_j0e39/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc181_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define N 500\n\nvoid backtrack(int row, int col, char grid[N][N], int *P, int *Q, int N, GHashTable **row_used, GHashTable **col_used, bool *result) {\n    if (row == N) {\n        *result = true;\n        return;\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (!g_hash_table_contains(row_used[row], GINT_TO_POINTER(i)) && !g_hash_table_contains(col_used[col], GINT_TO_POINTER(i))) {\n            grid[row][col] = '0' + i;\n            g_hash_table_insert(row_used[row], GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n            g_hash_table_insert(col_used[col], GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n\n            int next_row = row + (col == N - 1 ? 1 : 0);\n            int next_col = (col + 1) % N;\n\n            backtrack(next_row, next_col, grid, P, Q, N, row_used, col_used, result);\n\n            if (*result) {\n                return;\n            }\n\n            g_hash_table_remove(row_used[row], GINT_TO_POINTER(i));\n            g_hash_table_remove(col_used[col], GINT_TO_POINTER(i));\n        }\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int P[N], Q[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &P[i]);\n    }\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &Q[i]);\n    }\n\n    char grid[N][N];\n    GHashTable *row_used[N];\n    GHashTable *col_used[N];\n\n    for (int i = 0; i < N; i++) {\n        row_used[i] = g_hash_table_new(g_direct_hash, g_direct_equal);\n        col_used[i] = g_hash_table_new(g_direct_hash, g_direct_equal);\n    }\n\n    bool result = false;\n    backtrack(0, 0, grid, P, Q, N, row_used, col_used, &result);\n\n    if (result) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                printf(\"%c\", grid[i][j]);\n            }\n            printf(\"\\n\");\n        }\n    } else {\n        printf(\"No solution found\\n\");\n    }\n\n    for (int i = 0; i < N; i++) {\n        g_hash_table_destroy(row_used[i]);\n        g_hash_table_destroy(col_used[i]);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_x67ss1rf/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_x67ss1rf/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc181_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    for (int i = 0; i < t; i++) {\n        char s[500001];\n        char x[500001];\n        char y[500001];\n        scanf(\"%s %s %s\", s, x, y);\n\n        int len_x = strlen(x);\n        int len_y = strlen(y);\n\n        GHashTable *count_x = g_hash_table_new(g_str_hash, g_str_equal);\n        GHashTable *count_y = g_hash_table_new(g_str_hash, g_str_equal);\n\n        // Count frequency of characters in f(S, T, X)\n        for (int j = 0; j < len_x; j++) {\n            char *c = (char *)malloc(2 * sizeof(char));\n            c[0] = s[j];\n            c[1] = '\\0';\n            int *count = (int *)g_hash_table_lookup(count_x, c);\n            if (count == NULL) {\n                count = (int *)malloc(sizeof(int));\n                *count = 0;\n                g_hash_table_insert(count_x, c, count);\n            }\n            if (x[j] == '0') {\n                (*count)++;\n            } else {\n                (*count)++;\n            }\n        }\n\n        // Count frequency of characters in f(S, T, Y)\n        for (int j = 0; j < len_y; j++) {\n            char *c = (char *)malloc(2 * sizeof(char));\n            c[0] = s[j];\n            c[1] = '\\0';\n            int *count = (int *)g_hash_table_lookup(count_y, c);\n            if (count == NULL) {\n                count = (int *)malloc(sizeof(int));\n                *count = 0;\n                g_hash_table_insert(count_y, c, count);\n            }\n            if (y[j] == '0') {\n                (*count)++;\n            } else {\n                (*count)++;\n            }\n        }\n\n        // Compare the frequency of characters\n        bool is_equal = true;\n        GList *keys = g_hash_table_get_keys(count_x);\n        GList *node = keys;\n        while (node != NULL) {\n            char *key = (char *)node->data;\n            int *count_x_val = (int *)g_hash_table_lookup(count_x, key);\n            int *count_y_val = (int *)g_hash_table_lookup(count_y, key);\n            if (count_x_val == NULL || count_y_val == NULL || *count_x_val != *count_y_val) {\n                is_equal = false;\n                break;\n            }\n            node = g_list_next(node);\n        }\n\n        // Free memory\n        g_hash_table_destroy(count_x);\n        g_hash_table_destroy(count_y);\n        g_list_free(keys);\n\n        // Print result\n        if (is_equal) {\n            printf(\"Yes\\n\");\n        } else {\n            printf(\"No\\n\");\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_3i4wvihf/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_3i4wvihf/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc181_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint count_inversions(int *arr, int n) {\n    int inversions = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inversions++;\n            }\n        }\n    }\n    return inversions;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N;\n        scanf(\"%d\", &N);\n\n        int *P = (int *)malloc(N * sizeof(int));\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &P[i]);\n        }\n\n        int result = count_inversions(P, N);\n        printf(\"%d\n\", result);\n\n        free(P);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_87gjpsi6/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_87gjpsi6/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc182_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GArray *a = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *b = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(a, value);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int value;\n        scanf(\"%d\", &value);\n        g_array_append_val(b, value);\n    }\n\n    int operations = 0;\n\n    for (int i = 0; i < n; i++) {\n        int diff = abs(g_array_index(a, int, i) - g_array_index(b, int, i));\n        int min_operations = diff < m - diff ? diff : m - diff;\n        operations += min_operations;\n    }\n\n    printf(\"%d\n\", operations);\n\n    g_array_free(a, TRUE);\n    g_array_free(b, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_9m27utq4/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_9m27utq4/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc182_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M, C, K;\n    scanf(\"%d %d %d %d\", &N, &M, &C, &K);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GHashTable *min_values = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < N; i++) {\n        int remainder = (A[i] % M + M) % M;\n        if (!g_hash_table_contains(min_values, GINT_TO_POINTER(remainder))) {\n            g_hash_table_insert(min_values, GINT_TO_POINTER(remainder), GINT_TO_POINTER(remainder));\n        } else {\n            int current_min = GPOINTER_TO_INT(g_hash_table_lookup(min_values, GINT_TO_POINTER(remainder)));\n            if (remainder < current_min) {\n                g_hash_table_insert(min_values, GINT_TO_POINTER(remainder), GINT_TO_POINTER(remainder));\n            }\n        }\n    }\n\n    long long sum = 0;\n    for (int k = 0; k < K; k++) {\n        int remainder = (C * k % M + M) % M;\n        if (g_hash_table_contains(min_values, GINT_TO_POINTER(remainder))) {\n            sum += GPOINTER_TO_INT(g_hash_table_lookup(min_values, GINT_TO_POINTER(remainder)));\n        }\n    }\n\n    printf(\"%lld\n\", sum);\n\n    g_hash_table_destroy(min_values);\n    free(A);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__b6x6wf4/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__b6x6wf4/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc182_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int p;\n    int v;\n} Operation;\n\nint compare(const void *a, const void *b) {\n    return ((Operation *)a)->p - ((Operation *)b)->p;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    Operation ops[q];\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d\", &ops[i].p, &ops[i].v);\n    }\n\n    qsort(ops, q, sizeof(Operation), compare);\n\n    GHashTable *dp = g_hash_table_new(g_int_hash, g_int_equal);\n    g_hash_table_insert(dp, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n\n    for (int i = 0; i < q; i++) {\n        int p = ops[i].p;\n        int v = ops[i].v;\n\n        GHashTable *new_dp = g_hash_table_new(g_int_hash, g_int_equal);\n\n        int sum = 0;\n        GHashTableIter iter;\n        gpointer key, value;\n        g_hash_table_iter_init(&iter, dp);\n        while (g_hash_table_iter_next(&iter, &key, &value)) {\n            int key_val = GPOINTER_TO_INT(key);\n            int val = GPOINTER_TO_INT(value);\n\n            if (key_val + p > n) {\n                sum = (sum + val) % MOD;\n            } else {\n                int next_val = (val * 2) % MOD;\n                g_hash_table_insert(new_dp, GINT_TO_POINTER(key_val + p), GINT_TO_POINTER(next_val));\n            }\n        }\n\n        g_hash_table_destroy(dp);\n        dp = new_dp;\n    }\n\n    int result = 0;\n    g_hash_table_iter_init(&iter, dp);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        result = (result + GPOINTER_TO_INT(value)) % MOD;\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_dk06nw75/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_dk06nw75/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc182_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    long long n, m;\n    scanf(\"%lld %lld\", &n, &m);\n\n    // Initialize DP table\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(long long));\n    g_array_append_val(dp, 1);\n\n    // Precompute factorials and their modular inverses\n    GArray *fact = g_array_new(FALSE, FALSE, sizeof(long long));\n    GArray *inv_fact = g_array_new(FALSE, FALSE, sizeof(long long));\n    g_array_append_val(fact, 1);\n    g_array_append_val(inv_fact, 1);\n\n    for (long long i = 1; i <= n; i++) {\n        g_array_append_val(fact, (g_array_index(fact, long long, i - 1) * i) % MOD);\n        g_array_append_val(inv_fact, pow_mod(g_array_index(fact, long long, i), MOD - 2, MOD));\n    }\n\n    // Process each element in the sequence\n    for (long long i = 1; i <= m; i++) {\n        GArray *new_dp = g_array_new(FALSE, FALSE, sizeof(long long));\n        g_array_append_val(new_dp, 1);\n\n        for (long long j = 1; j <= n; j++) {\n            long long score = 0;\n            for (long long k = 1; k <= i; k++) {\n                if (i % k == 0) {\n                    score += (g_array_index(dp, long long, j - 1) * pow_mod(k, j, MOD)) % MOD;\n                    score %= MOD;\n                }\n            }\n            g_array_append_val(new_dp, score);\n        }\n\n        g_array_free(dp, TRUE);\n        dp = new_dp;\n    }\n\n    // Output the result\n    printf(\"%lld\\n\", g_array_index(dp, long long, n - 1));\n\n    // Clean up\n    g_array_free(dp, TRUE);\n    g_array_free(fact, TRUE);\n    g_array_free(inv_fact, TRUE);\n\n    return 0;\n}\n\n// Helper function to compute (base^exp) % mod using modular exponentiation\nlong long pow_mod(long long base, long long exp, long long mod) {\n    long long result = 1;\n    base = base % mod;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_05sa_rgv/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_05sa_rgv/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc183_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 250001\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N, K;\n        scanf(\"%d %d\", &N, &K);\n\n        int A[MAXN], B[MAXN];\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &A[i]);\n        }\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &B[i]);\n        }\n\n        GHashTable *freq_A = g_hash_table_new(g_direct_hash, g_direct_equal);\n        GHashTable *freq_B = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n        for (int i = 0; i < N; i++) {\n            int count_A = GPOINTER_TO_INT(g_hash_table_lookup(freq_A, GINT_TO_POINTER(A[i]))) + 1;\n            int count_B = GPOINTER_TO_INT(g_hash_table_lookup(freq_B, GINT_TO_POINTER(B[i]))) + 1;\n            g_hash_table_insert(freq_A, GINT_TO_POINTER(A[i]), GINT_TO_POINTER(count_A));\n            g_hash_table_insert(freq_B, GINT_TO_POINTER(B[i]), GINT_TO_POINTER(count_B));\n        }\n\n        bool possible = true;\n\n        for (int i = 1; i <= N; i++) {\n            int count_A = GPOINTER_TO_INT(g_hash_table_lookup(freq_A, GINT_TO_POINTER(i)));\n            int count_B = GPOINTER_TO_INT(g_hash_table_lookup(freq_B, GINT_TO_POINTER(i)));\n\n            if (count_A < count_B) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (possible) {\n            int window_size = K + 1;\n            int extra_elements = 0;\n\n            for (int i = 0; i < N; i++) {\n                int count_A = GPOINTER_TO_INT(g_hash_table_lookup(freq_A, GINT_TO_POINTER(A[i])));\n                int count_B = GPOINTER_TO_INT(g_hash_table_lookup(freq_B, GINT_TO_POINTER(B[i])));\n\n                if (count_A > count_B) {\n                    extra_elements += count_A - count_B;\n                }\n\n                if (i >= window_size) {\n                    int count_A_out = GPOINTER_TO_INT(g_hash_table_lookup(freq_A, GINT_TO_POINTER(A[i - window_size])));\n                    if (count_A_out > 0) {\n                        extra_elements -= count_A_out;\n                    }\n                }\n\n                if (extra_elements > window_size) {\n                    possible = false;\n                    break;\n                }\n            }\n        }\n\n        if (possible) {\n            printf(\"Yes\\n\");\n        } else {\n            printf(\"No\\n\");\n        }\n\n        g_hash_table_destroy(freq_A);\n        g_hash_table_destroy(freq_B);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_f9ru4w3h/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_f9ru4w3h/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc183_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int l, r, x;\n} Condition;\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    Condition *conditions = (Condition *)malloc(m * sizeof(Condition));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &conditions[i].l, &conditions[i].r, &conditions[i].x);\n    }\n\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_append_val(dp, 1);\n\n    for (int i = 1; i <= n; i++) {\n        int *new_dp = (int *)malloc(n * sizeof(int));\n        memset(new_dp, 0, n * sizeof(int));\n\n        for (int j = 0; j < m; j++) {\n            Condition c = conditions[j];\n            if (i >= c.l && i <= c.r) {\n                if (i != c.x) {\n                    for (int k = 0; k < n; k++) {\n                        if (k != c.x - 1) {\n                            new_dp[k] = (new_dp[k] + dp[k]) % MOD;\n                        }\n                    }\n                }\n            } else {\n                for (int k = 0; k < n; k++) {\n                    new_dp[k] = (new_dp[k] + dp[k]) % MOD;\n                }\n            }\n        }\n\n        g_array_free(dp, TRUE);\n        dp = g_array_new(FALSE, FALSE, sizeof(int));\n        for (int j = 0; j < n; j++) {\n            g_array_append_val(dp, new_dp[j]);\n        }\n        free(new_dp);\n    }\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        result = (result + dp->data[i]) % MOD;\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_array_free(dp, TRUE);\n    free(conditions);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_7d8bwn7l/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_7d8bwn7l/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc183_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    // Initialize the sequence with the first sequence\n    int *sequence = (int *)malloc(n * k * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < k; j++) {\n            sequence[i * k + j] = i + 1;\n        }\n    }\n\n    // Generate the lexicographically third sequence\n    for (int i = 0; i < n * k - 2; i++) {\n        int min_index = i;\n        for (int j = i + 1; j < n * k; j++) {\n            if (sequence[j] < sequence[min_index]) {\n                min_index = j;\n            }\n        }\n        if (min_index != i) {\n            int temp = sequence[min_index];\n            sequence[min_index] = sequence[i];\n            sequence[i] = temp;\n        }\n    }\n\n    // Print the sequence\n    for (int i = 0; i < n * k; i++) {\n        printf(\"%d\", sequence[i]);\n        if (i != n * k - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    // Free the allocated memory\n    free(sequence);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_cje_r1dl/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_cje_r1dl/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc183_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 250000\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GQueue *queue = g_queue_new();\n    int leaves[MAXN];\n    int leaf_count = 0;\n\n    // Read input and add leaves to the queue\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        if (a == 1) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(b));\n            leaves[leaf_count++] = b;\n        } else if (b == 1) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(a));\n            leaves[leaf_count++] = a;\n        }\n    }\n\n    // Process operations to maximize score\n    for (int i = 0; i < n / 2; i++) {\n        int leaf1 = g_queue_pop_head(queue);\n        int leaf2 = g_queue_pop_tail(queue);\n        printf(\"%d %d\n\", leaf1, leaf2);\n    }\n\n    // Free memory\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_dhq004rc/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_dhq004rc/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc374_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to check if a given maximum number of people can be achieved\nbool canAchieveMax(int *departments, int n, int maxPeople) {\n    int groupA = 0, groupB = 0;\n    for (int i = 0; i < n; i++) {\n        if (groupA <= groupB) {\n            groupA += departments[i];\n        } else {\n            groupB += departments[i];\n        }\n        if (groupA > maxPeople || groupB > maxPeople) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *departments = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &departments[i]);\n    }\n\n    // Sort departments in descending order\n    g_array_sort(g_array_new(FALSE, FALSE, sizeof(int)), departments, n, (GCompareFunc)compare);\n\n    int low = 1, high = 0;\n    for (int i = 0; i < n; i++) {\n        high += departments[i];\n    }\n\n    int result = high;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (canAchieveMax(departments, n, mid)) {\n            result = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    printf(\"%d\n\", result);\n\n    free(departments);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_286lkmx6/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_286lkmx6/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc374_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, K, X;\n    scanf(\"%d %d %d\", &N, &K, &X);\n\n    int *T = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &T[i]);\n    }\n\n    qsort(T, N, sizeof(int), compare);\n\n    int *next_shipment = (int *)malloc((N + 1) * sizeof(int));\n    memset(next_shipment, 0, (N + 1) * sizeof(int));\n\n    int dissatisfaction = 0;\n    int current_shipment = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (i > 0 && T[i] == T[i - 1]) {\n            current_shipment++;\n        } else {\n            current_shipment = 1;\n        }\n\n        if (current_shipment > K) {\n            int next = T[i] + X;\n            for (int j = i - 1; j >= 0 && T[j] >= next; j--) {\n                dissatisfaction += T[j] - next;\n                next += X;\n            }\n            i = j;\n        } else {\n            next_shipment[i + 1] = T[i] + X;\n        }\n    }\n\n    printf(\"%d\\n\", dissatisfaction);\n\n    free(T);\n    free(next_shipment);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_c35i7kor/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_c35i7kor/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc374_b", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[101], T[101];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int len1 = strlen(S);\n    int len2 = strlen(T);\n    int min_len = (len1 < len2) ? len1 : len2;\n\n    for (int i = 0; i < min_len; i++) {\n        if (S[i] != T[i]) {\n            printf(\"%d\n\", i + 1);\n            return 0;\n        }\n    }\n\n    if (len1 != len2) {\n        printf(\"%d\n\", min_len + 1);\n    } else {\n        printf(\"0\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__o3ea8xk/program.c: In function 'main':\\n/tmp/agnostics_c__o3ea8xk/program.c:15:20: warning: missing terminating \\\" character\\n   15 |             printf(\\\"%d\\n      |                    ^\\n/tmp/agnostics_c__o3ea8xk/program.c:15:20: error: missing terminating \\\" character\\n   15 |             printf(\\\"%d\\n      |                    ^~~\\n/tmp/agnostics_c__o3ea8xk/program.c:16:1: warning: missing terminating \\\" character\\n   16 | \\\", i + 1);\\n      | ^\\n/tmp/agnostics_c__o3ea8xk/program.c:16:1: error: missing terminating \\\" character\\n   16 | \\\", i + 1);\\n      | ^~~~~~~~~~\\n/tmp/agnostics_c__o3ea8xk/program.c:17:13: error: expected expression before 'return'\\n   17 |             return 0;\\n      |             ^~~~~~\\n/tmp/agnostics_c__o3ea8xk/program.c:17:22: error: expected ';' before '}' token\\n   17 |             return 0;\\n      |                      ^\\n      |                      ;\\n   18 |         }\\n      |         ~             \\n/tmp/agnostics_c__o3ea8xk/program.c:22:16: warning: missing terminating \\\" character\\n   22 |         printf(\\\"%d\\n      |                ^\\n/tmp/agnostics_c__o3ea8xk/program.c:22:16: error: missing terminating \\\" character\\n   22 |         printf(\\\"%d\\n      |                ^~~\\n/tmp/agnostics_c__o3ea8xk/program.c:23:1: warning: missing terminating \\\" character\\n   23 | \\\", min_len + 1);\\n      | ^\\n/tmp/agnostics_c__o3ea8xk/program.c:23:1: error: missing terminating \\\" character\\n   23 | \\\", min_len + 1);\\n      | ^~~~~~~~~~~~~~~~\\n/tmp/agnostics_c__o3ea8xk/program.c:24:5: error: expected expression before '}' token\\n   24 |     } else {\\n      |     ^\\n/tmp/agnostics_c__o3ea8xk/program.c:22:16: error: expected ';' before '}' token\\n   22 |         printf(\\\"%d\\n      |                ^\\n      |                ;\\n   23 | \\\", min_len + 1);\\n   24 |     } else {\\n      |     ~           \\n/tmp/agnostics_c__o3ea8xk/program.c:25:16: warning: missing terminating \\\" character\\n   ", "raw_stderr": "", "result": "fail"}
{"question_id": "abc374_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <glib.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point p1, p2;\n} Line;\n\n// Calculate Euclidean distance between two points\ndouble distance(Point p1, Point p2) {\n    return sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n}\n\n// Function to compare two lines based on their starting points\nint compare_lines(const void *a, const void *b) {\n    Line *l1 = (Line *)a;\n    Line *l2 = (Line *)b;\n    return (l1->p1.x != l2->p1.x) ? l1->p1.x - l2->p1.x : l1->p1.y - l2->p1.y;\n}\n\n// Calculate the minimum time to print all line segments\ndouble min_time(int n, int S, int T, Line lines[]) {\n    qsort(lines, n, sizeof(Line), compare_lines);\n\n    double total_time = 0.0;\n    Point current = {0, 0};\n\n    for (int i = 0; i < n; i++) {\n        Line *line = &lines[i];\n        double dist = distance(current, line->p1);\n        total_time += dist / S;\n        current = line->p1;\n\n        dist = distance(current, line->p2);\n        total_time += dist / T;\n        current = line->p2;\n    }\n\n    return total_time;\n}\n\nint main() {\n    int n, S, T;\n    scanf(\"%d %d %d\", &n, &S, &T);\n\n    Line lines[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d\", &lines[i].p1.x, &lines[i].p1.y, &lines[i].p2.x, &lines[i].p2.y);\n    }\n\n    double result = min_time(n, S, T, lines);\n    printf(\"%.15f\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ao2brjan/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ao2brjan/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc374_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_NAME_LEN 2\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *names = g_hash_table_new(g_str_hash, g_str_equal);\n    GArray *ng_list = g_array_new(FALSE, FALSE, sizeof(char*));\n\n    for (int i = 0; i < n; i++) {\n        char name[MAX_NAME_LEN + 1];\n        scanf(\"%s\", name);\n        g_hash_table_insert(names, name, GINT_TO_POINTER(1));\n    }\n\n    for (int i = 0; i < n; i++) {\n        char name[MAX_NAME_LEN + 1];\n        scanf(\"%s\", name);\n\n        bool found = false;\n        for (gpointer key = g_hash_table_get_first_key(names); key != NULL; key = g_hash_table_get_next_key(names, key)) {\n            char *ng_name = (char*)key;\n            if (strstr(ng_name, name) != NULL) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            char *new_ng_name = (char*)malloc(MAX_NAME_LEN * (n + 1));\n            strcpy(new_ng_name, name);\n\n            for (int j = 0; j < n; j++) {\n                char ng_name[MAX_NAME_LEN + 1];\n                scanf(\"%s\", ng_name);\n                strcat(new_ng_name, ng_name);\n            }\n\n            g_array_append_val(ng_list, new_ng_name);\n        }\n    }\n\n    printf(\"%d\\n\", ng_list->len);\n\n    for (int i = 0; i < ng_list->len; i++) {\n        char *ng_name = g_array_index(ng_list, char*, i);\n        free(ng_name);\n    }\n\n    g_hash_table_destroy(names);\n    g_array_free(ng_list, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_wucx_ykd/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_wucx_ykd/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc374_a", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    // Read input string S\n    char S[31];  // Ensure enough space for the string and the null terminator\n    scanf(\"%s\", S);\n\n    // Check if the string ends with 'san'\n    int len = strlen(S);\n    if (len >= 3 && strcmp(S + len - 3, \"san\") == 0) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2nkinkpu/program.c: In function 'main':\\n/tmp/agnostics_c_2nkinkpu/program.c:12:16: warning: missing terminating \\\" character\\n   12 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_2nkinkpu/program.c:12:16: error: missing terminating \\\" character\\n   12 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_2nkinkpu/program.c:13:1: warning: missing terminating \\\" character\\n   13 | \\\");\\n      | ^\\n/tmp/agnostics_c_2nkinkpu/program.c:13:1: error: missing terminating \\\" character\\n   13 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_2nkinkpu/program.c:14:5: error: expected expression before '}' token\\n   14 |     } else {\\n      |     ^\\n/tmp/agnostics_c_2nkinkpu/program.c:12:16: error: expected ';' before '}' token\\n   12 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   13 | \\\");\\n   14 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_2nkinkpu/program.c:15:16: warning: missing terminating \\\" character\\n   15 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_2nkinkpu/program.c:15:16: error: missing terminating \\\" character\\n   15 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_2nkinkpu/program.c:16:1: warning: missing terminating \\\" character\\n   16 | \\\");\\n      | ^\\n/tmp/agnostics_c_2nkinkpu/program.c:16:1: error: missing terminating \\\" character\\n   16 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_2nkinkpu/program.c:17:5: error: expected expression before '}' token\\n   17 |     }\\n      |     ^\\n/tmp/agnostics_c_2nkinkpu/program.c:15:16: error: expected ';' before '}' token\\n   15 |         printf(\\\"No\\n      |                ^\\n      |                ;\\n   16 | \\\");\\n   17 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2nkinkpu/program.c: In function 'main':\n/tmp/agnostics_c_2nkinkpu/program.c:12:16: warning: missing terminating \" character\n   12 |         printf(\"Yes\n      |                ^\n/tmp/agnostics_c_2nkinkpu/program.c:12:16: error: missing terminating \" character\n   12 |         printf(\"Yes\n      |                ^~~~\n/tmp/agnostics_c_2nkinkpu/program.c:13:1: warning: missing terminating \" character\n   13 | \");\n      | ^\n/tmp/agnostics_c_2nkinkpu/program.c:13:1: error: missing terminating \" character\n   13 | \");\n      | ^~~\n/tmp/agnostics_c_2nkinkpu/program.c:14:5: error: expected expression before '}' token\n   14 |     } else {\n      |     ^\n/tmp/agnostics_c_2nkinkpu/program.c:12:16: error: expected ';' before '}' token\n   12 |         printf(\"Yes\n      |                ^\n      |                ;\n   13 | \");\n   14 |     } else {\n      |     ~           \n/tmp/agnostics_c_2nkinkpu/program.c:15:16: warning: missing terminating \" character\n   15 |         printf(\"No\n      |                ^\n/tmp/agnostics_c_2nkinkpu/program.c:15:16: error: missing terminating \" character\n   15 |         printf(\"No\n      |                ^~~\n/tmp/agnostics_c_2nkinkpu/program.c:16:1: warning: missing terminating \" character\n   16 | \");\n      | ^\n/tmp/agnostics_c_2nkinkpu/program.c:16:1: error: missing terminating \" character\n   16 | \");\n      | ^~~\n/tmp/agnostics_c_2nkinkpu/program.c:17:5: error: expected expression before '}' token\n   17 |     }\n      |     ^\n/tmp/agnostics_c_2nkinkpu/program.c:15:16: error: expected ';' before '}' token\n   15 |         printf(\"No\n      |                ^\n      |                ;\n   16 | \");\n   17 |     }\n      |     ~           \n"}
{"question_id": "abc374_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_PROCESSES 100\n#define MAX_VALUE 10000000\n\ntypedef struct {\n    int A, P, B, Q;\n} Process;\n\n// Function to check if a given production capacity can be achieved within the budget\nbool canAchieveCapacity(Process processes[], int n, int budget, int capacity) {\n    int totalCost = 0;\n    for (int i = 0; i < n; i++) {\n        int S_units = (capacity + processes[i].A - 1) / processes[i].A; // Ceiling division\n        int T_units = (capacity + processes[i].B - 1) / processes[i].B; // Ceiling division\n        int cost = S_units * processes[i].P + T_units * processes[i].Q;\n        if (cost > budget) {\n            return false;\n        }\n        totalCost += cost;\n    }\n    return totalCost <= budget;\n}\n\nint main() {\n    int n, budget;\n    scanf(\"%d %d\", &n, &budget);\n\n    Process processes[MAX_PROCESSES];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d\", &processes[i].A, &processes[i].P, &processes[i].B, &processes[i].Q);\n    }\n\n    int low = 0, high = MAX_VALUE;\n    int result = 0;\n\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (canAchieveCapacity(processes, n, budget, mid)) {\n            result = mid;\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_k3qey54m/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_k3qey54m/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc375_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int A[n], B[n];\n    int team_strength[4] = {0};\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n        team_strength[A[i]] += B[i];\n    }\n\n    int total_strength = team_strength[1] + team_strength[2] + team_strength[3];\n    if (total_strength % 3 != 0) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int target_strength = total_strength / 3;\n\n    int switches = 0;\n    GHashTable *excess = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *deficit = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        if (team_strength[A[i]] > target_strength) {\n            g_hash_table_insert(excess, GINT_TO_POINTER(A[i]), GINT_TO_POINTER(team_strength[A[i]] - target_strength));\n        } else if (team_strength[A[i]] < target_strength) {\n            g_hash_table_insert(deficit, GINT_TO_POINTER(A[i]), GINT_TO_POINTER(target_strength - team_strength[A[i]]));\n        }\n    }\n\n    int *excess_vals = g_hash_table_get_values(excess);\n    int *deficit_vals = g_hash_table_get_values(deficit);\n\n    int excess_count = g_hash_table_size(excess);\n    int deficit_count = g_hash_table_size(deficit);\n\n    if (excess_count != deficit_count) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    for (int i = 0; i < excess_count; i++) {\n        int need = GPOINTER_TO_INT(deficit_vals[i]);\n        int have = GPOINTER_TO_INT(excess_vals[i]);\n\n        if (need > have) {\n            switches += have;\n        } else {\n            switches += need;\n        }\n    }\n\n    printf(\"%d\\n\", switches);\n\n    g_hash_table_destroy(excess);\n    g_hash_table_destroy(deficit);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_idnx26iq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_idnx26iq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc375_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    double total_cost = 0.0;\n    double x_prev = 0.0, y_prev = 0.0;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n\n        double distance = sqrt((x - x_prev) * (x - x_prev) + (y - y_prev) * (y - y_prev));\n        total_cost += distance;\n\n        x_prev = x;\n        y_prev = y;\n    }\n\n    // Add the cost of returning to the origin\n    total_cost += sqrt(x_prev * x_prev + y_prev * y_prev);\n\n    printf(\"%.10f\\n\", total_cost);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"27668169958335.63809169231721161667\", \"got\": \"27668169958335.5234375000\", \"stderr\": \"Test case 0 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "27668169958335.63809169231721161667", "got": "27668169958335.5234375000", "stderr": "Test case 0 produced wrong output\n"}
{"question_id": "abc375_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define N 3000\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char grid[N][N];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for (int i = 0; i < n / 2; i++) {\n        for (int x = i; x <= n - 1 - i; x++) {\n            int y = n - 1 - x;\n            char temp = grid[x][y];\n            grid[x][y] = grid[i][x];\n            grid[i][x] = temp;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i]);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_81hjf5nw/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_81hjf5nw/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc375_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[200001];\n    scanf(\"%s\", s);\n\n    int count = 0;\n    for (int i = 0; i < n - 2; i++) {\n        if (s[i] == '#' && s[i + 1] == '.' && s[i + 2] == '#') {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc375_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[200001];\n    scanf(\"%s\", S);\n    int n = strlen(S);\n\n    GHashTable *count = g_hash_table_new(g_str_hash, g_str_equal);\n    long long result = 0;\n\n    for (int j = 1; j < n - 1; j++) {\n        char ch = S[j];\n\n        // Count pairs (i, k) such that S[i] == S[k] and i < j < k\n        char key[3];\n        key[0] = S[0];\n        key[1] = ch;\n        key[2] = S[n - 1];\n        gpointer value = g_hash_table_lookup(count, key);\n        if (value) {\n            result += GPOINTER_TO_INT(value);\n        }\n\n        // Update the hash table with the current character positions\n        for (int i = 0; i < j; i++) {\n            char key[2];\n            key[0] = S[i];\n            key[1] = S[j];\n            value = g_hash_table_lookup(count, key);\n            if (value) {\n                g_hash_table_insert(count, key, GINT_TO_POINTER(GPOINTER_TO_INT(value) + 1));\n            } else {\n                g_hash_table_insert(count, key, GINT_TO_POINTER(1));\n            }\n        }\n    }\n\n    g_hash_table_destroy(count);\n\n    printf(\"%lld\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_0sj8mwmg/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_0sj8mwmg/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc375_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define INF 1000000000\n\ntypedef struct {\n    int to;\n    int weight;\n} Edge;\n\nvoid dijkstra(int n, GArray *graph[], int start, int *dist) {\n    memset(dist, INF, sizeof(int) * n);\n    dist[start] = 0;\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(start));\n\n    while (!g_queue_is_empty(queue)) {\n        int u = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n        for (int i = 0; i < graph[u]->len; i++) {\n            Edge edge = g_array_index(graph[u], Edge, i);\n            int v = edge.to;\n            int weight = edge.weight;\n\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                g_queue_push_tail(queue, GINT_TO_POINTER(v));\n            }\n        }\n    }\n\n    g_queue_free(queue);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GArray **graph = g_new(GArray *, n);\n    for (int i = 0; i < n; i++) {\n        graph[i] = g_array_new(FALSE, FALSE, sizeof(Edge));\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        a--; b--;\n        g_array_append_val(graph[a], (Edge){b, c});\n        g_array_append_val(graph[b], (Edge){a, c});\n    }\n\n    int *dist_all = g_new(int, n);\n    dijkstra(n, graph, 0, dist_all);\n\n    for (int i = 0; i < m; i++) {\n        int *dist_removed = g_new(int, n);\n        dijkstra(n, graph, 0, dist_removed);\n\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        a--; b--;\n\n        for (int j = 0; j < graph[a]->len; j++) {\n            Edge edge = g_array_index(graph[a], Edge, j);\n            if (edge.to == b) {\n                g_array_remove_index(graph[a], j);\n                break;\n            }\n        }\n\n        for (int j = 0; j < graph[b]->len; j++) {\n            Edge edge = g_array_index(graph[b], Edge, j);\n            if (edge.to == a) {\n                g_array_remove_index(graph[b], j);\n                break;\n            }\n        }\n\n        if (dist_all[n - 1] != dist_removed[n - 1]) {\n            printf(\"Yes\\n\");\n        } else {\n            printf(\"No\\n\");\n        }\n\n        for (int j = 0; j < graph[a]->len; j++) {\n            Edge edge = g_array_index(graph[a], Edge, j);\n            if (edge.to == b) {\n                g_array_append_val(graph[a], (Edge){b, c});\n                break;\n            }\n        }\n\n        for (int j = 0; j < graph[b]->len; j++) {\n            Edge edge = g_array_index(graph[b], Edge, j);\n            if (edge.to == a) {\n                g_array_append_val(graph[b], (Edge){a, c});\n                break;\n            }\n        }\n\n        g_free(dist_removed);\n    }\n\n    for (int i = 0; i < n; i++) {\n        g_array_free(graph[i], TRUE);\n    }\n    g_free(graph);\n    g_free(dist_all);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2fog7ybb/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2fog7ybb/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc375_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define INF 1000000000\n\n// Function to compare two integers for qsort\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, M, Q;\n    scanf(\"%d %d %d\", &N, &M, &Q);\n\n    // Adjacency list for the graph\n    GArray *adj[N + 1];\n    for (int i = 1; i <= N; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Array to store the cost of each edge\n    int cost[M + 1];\n\n    // Array to store the state of each edge (closed or open)\n    bool closed[M + 1];\n    memset(closed, false, sizeof(closed));\n\n    // Read the edges and their costs\n    for (int i = 1; i <= M; i++) {\n        int A, B, C;\n        scanf(\"%d %d %d\", &A, &B, &C);\n        g_array_append_val(adj[A], B);\n        g_array_append_val(adj[B], A);\n        cost[i] = C;\n    }\n\n    // Process each query\n    for (int q = 0; q < Q; q++) {\n        int type;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            int i;\n            scanf(\"%d\", &i);\n            closed[i] = true;\n        } else if (type == 2) {\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n\n            // Create a new adjacency list excluding the closed roads\n            GArray *adj_new[N + 1];\n            for (int i = 1; i <= N; i++) {\n                adj_new[i] = g_array_new(FALSE, FALSE, sizeof(int));\n            }\n\n            for (int i = 1; i <= M; i++) {\n                if (!closed[i]) {\n                    int A = i == 1 ? 1 : 2;\n                    int B = i == 1 ? 2 : 1;\n                    g_array_append_val(adj_new[A], B);\n                    g_array_append_val(adj_new[B], A);\n                }\n            }\n\n            // Use Dijkstra's algorithm to find the shortest path\n            int dist[N + 1];\n            for (int i = 1; i <= N; i++) {\n                dist[i] = INF;\n            }\n            dist[x] = 0;\n\n            GPriorityQueue *pq = g_priority_queue_new((GCompareFunc)compare);\n            g_priority_queue_push(pq, GINT_TO_POINTER(x), 0);\n\n            while (!g_priority_queue_is_empty(pq)) {\n                int u = GPOINTER_TO_INT(g_priority_queue_pop_head(pq));\n\n                for (int i = 0; i < adj_new[u]->len; i++) {\n                    int v = g_array_index(adj_new[u], int, i);\n                    if (dist[u] + cost[i] < dist[v]) {\n                        dist[v] = dist[u] + cost[i];\n                        g_priority_queue_push(pq, GINT_TO_POINTER(v), dist[v]);\n                    }\n                }\n            }\n\n            g_priority_queue_unref(pq);\n\n            // Free the new adjacency list\n            for (int i = 1; i <= N; i++) {\n                g_array_free(adj_new[i], TRUE);\n            }\n\n            if (dist[y] == INF) {\n                printf(\"-1\\n\");\n            } else {\n                printf(\"%d\\n\", dist[y]);\n            }\n        }\n    }\n\n    // Free the adjacency list\n    for (int i = 1; i <= N; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_yuiih0s9/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_yuiih0s9/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc376_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    // Initialize current positions of left and right hands\n    int left_hand = 1;\n    int right_hand = 2;\n\n    // Initialize total operations counter\n    int total_operations = 0;\n\n    // Process each instruction\n    for (int i = 0; i < q; i++) {\n        char hand;\n        int target;\n        scanf(\"%c %d\", &hand, &target);\n\n        if (hand == 'L') {\n            // Move left hand to target part\n            int steps = abs(target - left_hand);\n            if (right_hand != target) {\n                total_operations += steps;\n                left_hand = target;\n            }\n        } else if (hand == 'R') {\n            // Move right hand to target part\n            int steps = abs(target - right_hand);\n            if (left_hand != target) {\n                total_operations += steps;\n                right_hand = target;\n            }\n        }\n    }\n\n    // Output the total number of operations\n    printf(\"%d\\n\", total_operations);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_3t6dmgpc/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_3t6dmgpc/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc376_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n\n        GArray *edges = g_hash_table_lookup(adj_list, GINT_TO_POINTER(a));\n        if (edges == NULL) {\n            edges = g_array_new(FALSE, FALSE, sizeof(int));\n            g_hash_table_insert(adj_list, GINT_TO_POINTER(a), edges);\n        }\n        g_array_append_val(edges, b);\n    }\n\n    int *dist = malloc((n + 1) * sizeof(int));\n    for (int i = 0; i <= n; i++) {\n        dist[i] = INT_MAX;\n    }\n\n    dist[1] = 0;\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(1));\n\n    bool found_cycle = false;\n    int min_edges = INT_MAX;\n\n    while (!g_queue_is_empty(queue)) {\n        int u = GPOINTER_TO_INT(g_queue_pop_head(queue));\n\n        GArray *edges = g_hash_table_lookup(adj_list, GINT_TO_POINTER(u));\n        if (edges != NULL) {\n            for (gsize i = 0; i < edges->len; i++) {\n                int v = g_array_index(edges, int, i);\n\n                if (dist[u] + 1 < dist[v]) {\n                    dist[v] = dist[u] + 1;\n                    g_queue_push_tail(queue, GINT_TO_POINTER(v));\n                }\n\n                if (v == 1) {\n                    found_cycle = true;\n                    min_edges = dist[u] + 1;\n                }\n            }\n        }\n    }\n\n    if (found_cycle) {\n        printf(\"%d\n\", min_edges);\n    } else {\n        printf(\"-1\n\");\n    }\n\n    g_hash_table_destroy(adj_list);\n    g_queue_free(queue);\n    free(dist);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__vzkcz5b/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__vzkcz5b/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc376_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int *parent;\n    int *prob;\n    GArray *children;\n} Node;\n\ntypedef struct {\n    GHashTable *dp;\n} Solution;\n\nvoid init_node(Node *node, int *parent, int *prob, int n) {\n    node->parent = parent;\n    node->prob = prob;\n    node->children = g_array_new(FALSE, FALSE, sizeof(int));\n}\n\nvoid add_child(Node *node, int child) {\n    g_array_append_val(node->children, child);\n}\n\nvoid free_node(Node *node) {\n    g_array_free(node->children, TRUE);\n}\n\nvoid init_solution(Solution *sol) {\n    sol->dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n}\n\nvoid free_solution(Solution *sol) {\n    g_hash_table_destroy(sol->dp);\n}\n\nint dfs(Node *node, Solution *sol, int *sum_prob) {\n    int node_id = g_array_index(node->children, int, 0);\n    int parent_id = node->parent[node_id];\n\n    if (g_hash_table_contains(sol->dp, GINT_TO_POINTER(parent_id))) {\n        return GPOINTER_TO_INT(g_hash_table_lookup(sol->dp, GINT_TO_POINTER(parent_id)));\n    }\n\n    int expected = 0;\n    int total_prob = 0;\n\n    for (int i = 0; i < node->children->len; i++) {\n        int child_id = g_array_index(node->children, int, i);\n        int child_prob = node->prob[child_id];\n\n        total_prob += child_prob;\n        expected += dfs(node, sol, sum_prob) + child_prob;\n    }\n\n    expected = (expected * sum_prob[node_id]) / total_prob;\n    g_hash_table_insert(sol->dp, GINT_TO_POINTER(parent_id), GINT_TO_POINTER(expected));\n\n    return expected;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N;\n        scanf(\"%d\", &N);\n\n        int *parent = (int *)malloc(N * sizeof(int));\n        int *prob = (int *)malloc(N * sizeof(int));\n\n        for (int i = 1; i < N; i++) {\n            scanf(\"%d\", &parent[i]);\n        }\n\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &prob[i]);\n        }\n\n        Node *nodes = (Node *)malloc(N * sizeof(Node));\n\n        for (int i = 0; i < N; i++) {\n            init_node(&nodes[i], parent, prob, N);\n        }\n\n        for (int i = 1; i < N; i++) {\n            add_child(&nodes[parent[i]], i);\n        }\n\n        int sum_prob[N];\n        sum_prob[0] = 0;\n\n        for (int i = 1; i < N; i++) {\n            sum_prob[i] = sum_prob[parent[i]] + prob[i];\n        }\n\n        Solution sol;\n        init_solution(&sol);\n\n        int expected = dfs(&nodes[0], &sol, sum_prob);\n\n        printf(\"%d\\n\", expected);\n\n        for (int i = 0; i < N; i++) {\n            free_node(&nodes[i]);\n        }\n\n        free(parent);\n        free(prob);\n        free(nodes);\n        free_solution(&sol);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_79qi9631/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_79qi9631/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc376_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, C;\n    scanf(\"%d %d\", &N, &C);\n\n    int *times = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &times[i]);\n    }\n\n    int last_received = -1; // Initialize to -1 to ensure the first press always counts\n    int candy_count = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (times[i] - last_received >= C) {\n            candy_count++;\n            last_received = times[i];\n        }\n    }\n\n    printf(\"%d\n\", candy_count);\n\n    free(times);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__3m8ei8h/program.c: In function 'main':\\n/tmp/agnostics_c__3m8ei8h/program.c:23:12: warning: missing terminating \\\" character\\n   23 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c__3m8ei8h/program.c:23:12: error: missing terminating \\\" character\\n   23 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c__3m8ei8h/program.c:24:1: warning: missing terminating \\\" character\\n   24 | \\\", candy_count);\\n      | ^\\n/tmp/agnostics_c__3m8ei8h/program.c:24:1: error: missing terminating \\\" character\\n   24 | \\\", candy_count);\\n      | ^~~~~~~~~~~~~~~~\\n/tmp/agnostics_c__3m8ei8h/program.c:26:16: error: expected ')' before ';' token\\n   26 |     free(times);\\n      |                ^\\n      |                )\\n/tmp/agnostics_c__3m8ei8h/program.c:23:11: note: to match this '('\\n   23 |     printf(\\\"%d\\n      |           ^\\n/tmp/agnostics_c__3m8ei8h/program.c:26:5: error: invalid use of void expression\\n   26 |     free(times);\\n      |     ^~~~~~~~~~~\\n/tmp/agnostics_c__3m8ei8h/program.c:27:14: error: expected ';' before '}' token\\n   27 |     return 0;\\n      |              ^\\n      |              ;\\n   28 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__3m8ei8h/program.c: In function 'main':\n/tmp/agnostics_c__3m8ei8h/program.c:23:12: warning: missing terminating \" character\n   23 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c__3m8ei8h/program.c:23:12: error: missing terminating \" character\n   23 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c__3m8ei8h/program.c:24:1: warning: missing terminating \" character\n   24 | \", candy_count);\n      | ^\n/tmp/agnostics_c__3m8ei8h/program.c:24:1: error: missing terminating \" character\n   24 | \", candy_count);\n      | ^~~~~~~~~~~~~~~~\n/tmp/agnostics_c__3m8ei8h/program.c:26:16: error: expected ')' before ';' token\n   26 |     free(times);\n      |                ^\n      |                )\n/tmp/agnostics_c__3m8ei8h/program.c:23:11: note: to match this '('\n   23 |     printf(\"%d\n      |           ^\n/tmp/agnostics_c__3m8ei8h/program.c:26:5: error: invalid use of void expression\n   26 |     free(times);\n      |     ^~~~~~~~~~~\n/tmp/agnostics_c__3m8ei8h/program.c:27:14: error: expected ';' before '}' token\n   27 |     return 0;\n      |              ^\n      |              ;\n   28 | }\n      | ~             \n"}
{"question_id": "abc376_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    // Initialize current positions of left and right hands\n    int left_hand = 1;\n    int right_hand = 2;\n\n    // Initialize total number of operations\n    int total_operations = 0;\n\n    // Process each instruction\n    for (int i = 0; i < q; i++) {\n        char hand;\n        int target;\n        scanf(\" %c %d\", &hand, &target);\n\n        // Calculate the number of operations to move the left hand\n        if (hand == 'L') {\n            if (target == left_hand) continue;\n            int operations = abs(target - left_hand);\n            if (target > left_hand) {\n                if (right_hand == target - 1) {\n                    operations -= 1;\n                }\n            } else {\n                if (right_hand == target + 1) {\n                    operations -= 1;\n                }\n            }\n            total_operations += operations;\n            left_hand = target;\n        }\n\n        // Calculate the number of operations to move the right hand\n        if (hand == 'R') {\n            if (target == right_hand) continue;\n            int operations = abs(target - right_hand);\n            if (target > right_hand) {\n                if (left_hand == target - 1) {\n                    operations -= 1;\n                }\n            } else {\n                if (left_hand == target + 1) {\n                    operations -= 1;\n                }\n            }\n            total_operations += operations;\n            right_hand = target;\n        }\n    }\n\n    // Output the total number of operations\n    printf(\"%d\\n\", total_operations);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_nl_6h27t/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_nl_6h27t/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc376_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    int *B = (int *)malloc((n - 1) * sizeof(int));\n    for (int i = 0; i < n - 1; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n\n    qsort(A, n, sizeof(int), compare);\n    qsort(B, n - 1, sizeof(int), compare);\n\n    int min_size = 0;\n    for (int i = 0; i < n - 1; i++) {\n        min_size = fmax(min_size, A[i] + B[i]);\n    }\n\n    int left = min_size, right = INT_MAX;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        int placed = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (mid >= A[i] + B[i]) {\n                placed++;\n            }\n        }\n        if (placed == n - 1) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    if (left >= min_size) {\n        printf(\"%d\\n\", left);\n    } else {\n        printf(\"-1\\n\");\n    }\n\n    free(A);\n    free(B);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__5wkd08e/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__5wkd08e/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc376_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MAX_N 200000\n#define MAX_T 200000\n\ntypedef struct {\n    int A[MAX_N];\n    int B[MAX_N];\n} Sequence;\n\nint compare(const void *a, const void *b) {\n    return (*(int*)b - *(int*)a);\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N, K;\n        scanf(\"%d %d\", &N, &K);\n\n        Sequence seq;\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &seq.A[i]);\n        }\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &seq.B[i]);\n        }\n\n        qsort(seq.A, N, sizeof(int), compare);\n        qsort(seq.B, N, sizeof(int), compare);\n\n        int min_value = INT_MAX;\n        for (int i = 0; i <= N - K; i++) {\n            int max_A = seq.A[i];\n            int sum_B = 0;\n            for (int j = 0; j < K; j++) {\n                sum_B += seq.B[i + j];\n            }\n            min_value = fmin(min_value, max_A * sum_B);\n        }\n\n        printf(\"%d\\n\", min_value);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_avap07s9/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_avap07s9/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc377_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashSet *capturable = g_hash_set_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n\n        for (int x = -2; x <= 2; x++) {\n            for (int y = -2; y <= 2; y++) {\n                if (abs(x) + abs(y) == 3) {\n                    int new_x = a + x;\n                    int new_y = b + y;\n\n                    if (new_x >= 1 && new_x <= N && new_y >= 1 && new_y <= N) {\n                        g_hash_set_add(capturable, GINT_TO_POINTER(new_x * 1000000 + new_y));\n                    }\n                }\n            }\n        }\n    }\n\n    long long empty_squares = (long long)N * N - g_hash_set_size(capturable);\n\n    printf(\"%lld\\n\", empty_squares);\n\n    g_hash_set_destroy(capturable);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ax4pj37d/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ax4pj37d/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc377_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char grid[8][9];  // 8 rows, 9 columns for null terminator\n    for (int i = 0; i < 8; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    // Initialize variables\n    int count = 0;\n    GHashTable *rows = g_hash_table_new(g_str_hash, g_str_equal);\n    GHashTable *cols = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Mark occupied rows and columns\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (grid[i][j] == '#') {\n                char row_key[2] = { (char)(i + '0'), 0 };  // Convert row index to string\n                char col_key[2] = { (char)(j + '0'), 0 };  // Convert column index to string\n                g_hash_table_insert(rows, row_key, GINT_TO_POINTER(1));\n                g_hash_table_insert(cols, col_key, GINT_TO_POINTER(1));\n            }\n        }\n    }\n\n    // Count empty squares not in occupied rows or columns\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (grid[i][j] == '.' &&\n                !g_hash_table_lookup(rows, GINT_TO_POINTER(i)) &&\n                !g_hash_table_lookup(cols, GINT_TO_POINTER(j))) {\n                count++;\n            }\n        }\n    }\n\n    // Output result\n    printf(\"%d\n\", count);\n\n    // Clean up\n    g_hash_table_destroy(rows);\n    g_hash_table_destroy(cols);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_nrejjd2q/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_nrejjd2q/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc377_a", "solution": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[4];\n    scanf(\"%s\", S);\n\n    int countA = 0, countB = 0, countC = 0;\n\n    // Count occurrences of each character\n    for (int i = 0; i < 3; i++) {\n        if (S[i] == 'A') countA++;\n        else if (S[i] == 'B') countB++;\n        else if (S[i] == 'C') countC++;\n    }\n\n    // Check if counts match ABC\n    if (countA == 1 && countB == 1 && countC == 1) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ktu21fnr/program.c: In function 'main':\\n/tmp/agnostics_c_ktu21fnr/program.c:19:16: warning: missing terminating \\\" character\\n   19 |         printf(\\\"Yes\\n      |                ^\\n/tmp/agnostics_c_ktu21fnr/program.c:19:16: error: missing terminating \\\" character\\n   19 |         printf(\\\"Yes\\n      |                ^~~~\\n/tmp/agnostics_c_ktu21fnr/program.c:20:1: warning: missing terminating \\\" character\\n   20 | \\\");\\n      | ^\\n/tmp/agnostics_c_ktu21fnr/program.c:20:1: error: missing terminating \\\" character\\n   20 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_ktu21fnr/program.c:21:5: error: expected expression before '}' token\\n   21 |     } else {\\n      |     ^\\n/tmp/agnostics_c_ktu21fnr/program.c:19:16: error: expected ';' before '}' token\\n   19 |         printf(\\\"Yes\\n      |                ^\\n      |                ;\\n   20 | \\\");\\n   21 |     } else {\\n      |     ~           \\n/tmp/agnostics_c_ktu21fnr/program.c:22:16: warning: missing terminating \\\" character\\n   22 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_ktu21fnr/program.c:22:16: error: missing terminating \\\" character\\n   22 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_ktu21fnr/program.c:23:1: warning: missing terminating \\\" character\\n   23 | \\\");\\n      | ^\\n/tmp/agnostics_c_ktu21fnr/program.c:23:1: error: missing terminating \\\" character\\n   23 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_ktu21fnr/program.c:24:5: error: expected expression before '}' token\\n   24 |     }\\n      |     ^\\n/tmp/agnostics_c_ktu21fnr/program.c:22:16: error: expected ';' before '}' token\\n   22 |         printf(\\\"No\\n      |                ^\\n      |                ;\\n   23 | \\\");\\n   24 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ktu21fnr/program.c: In function 'main':\n/tmp/agnostics_c_ktu21fnr/program.c:19:16: warning: missing terminating \" character\n   19 |         printf(\"Yes\n      |                ^\n/tmp/agnostics_c_ktu21fnr/program.c:19:16: error: missing terminating \" character\n   19 |         printf(\"Yes\n      |                ^~~~\n/tmp/agnostics_c_ktu21fnr/program.c:20:1: warning: missing terminating \" character\n   20 | \");\n      | ^\n/tmp/agnostics_c_ktu21fnr/program.c:20:1: error: missing terminating \" character\n   20 | \");\n      | ^~~\n/tmp/agnostics_c_ktu21fnr/program.c:21:5: error: expected expression before '}' token\n   21 |     } else {\n      |     ^\n/tmp/agnostics_c_ktu21fnr/program.c:19:16: error: expected ';' before '}' token\n   19 |         printf(\"Yes\n      |                ^\n      |                ;\n   20 | \");\n   21 |     } else {\n      |     ~           \n/tmp/agnostics_c_ktu21fnr/program.c:22:16: warning: missing terminating \" character\n   22 |         printf(\"No\n      |                ^\n/tmp/agnostics_c_ktu21fnr/program.c:22:16: error: missing terminating \" character\n   22 |         printf(\"No\n      |                ^~~\n/tmp/agnostics_c_ktu21fnr/program.c:23:1: warning: missing terminating \" character\n   23 | \");\n      | ^\n/tmp/agnostics_c_ktu21fnr/program.c:23:1: error: missing terminating \" character\n   23 | \");\n      | ^~~\n/tmp/agnostics_c_ktu21fnr/program.c:24:5: error: expected expression before '}' token\n   24 |     }\n      |     ^\n/tmp/agnostics_c_ktu21fnr/program.c:22:16: error: expected ';' before '}' token\n   22 |         printf(\"No\n      |                ^\n      |                ;\n   23 | \");\n   24 |     }\n      |     ~           \n"}
{"question_id": "abc377_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *prefix_costs = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int k = 1; k <= n; k++) {\n        char s[100001];\n        scanf(\"%s\", s);\n\n        int len = strlen(s);\n        int min_cost = len;\n\n        for (int i = 0; i < len; i++) {\n            char prefix[100001];\n            strncpy(prefix, s, i + 1);\n            prefix[i + 1] = '\\0';\n\n            gpointer cost_ptr = g_hash_table_lookup(prefix_costs, prefix);\n            int cost = (cost_ptr) ? GPOINTER_TO_INT(cost_ptr) : 0;\n\n            min_cost = fmin(min_cost, cost + (len - i - 1));\n        }\n\n        printf(\"%d\n\", min_cost);\n\n        g_hash_table_insert(prefix_costs, strdup(s), GINT_TO_POINTER(min_cost));\n    }\n\n    g_hash_table_destroy(prefix_costs);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_do9okatf/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_do9okatf/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc377_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAXN 1000000000\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Sets to keep track of occupied rows, columns, and diagonals\n    bool rows[MAXN] = {false};\n    bool cols[MAXN] = {false};\n    bool diags1[MAXN * 2] = {false};\n    bool diags2[MAXN * 2] = {false};\n\n    // Mark occupied rows, columns, and diagonals\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        rows[a - 1] = true;\n        cols[b - 1] = true;\n        diags1[a + b - 2] = true;\n        diags2[a - b + N - 2] = true;\n    }\n\n    // Count valid squares\n    int count = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (!rows[i - 1] && !cols[j - 1] && !diags1[i + j - 2] && !diags2[i - j + N - 2]) {\n                count++;\n            }\n        }\n    }\n\n    // Print the result\n    printf(\"%d\n\", count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_vtcdt3_s/program.c: In function 'main':\\n/tmp/agnostics_c_vtcdt3_s/program.c:38:12: warning: missing terminating \\\" character\\n   38 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_vtcdt3_s/program.c:38:12: error: missing terminating \\\" character\\n   38 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_vtcdt3_s/program.c:39:1: warning: missing terminating \\\" character\\n   39 | \\\", count);\\n      | ^\\n/tmp/agnostics_c_vtcdt3_s/program.c:39:1: error: missing terminating \\\" character\\n   39 | \\\", count);\\n      | ^~~~~~~~~~\\n/tmp/agnostics_c_vtcdt3_s/program.c:41:5: error: expected expression before 'return'\\n   41 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_vtcdt3_s/program.c:41:14: error: expected ';' before '}' token\\n   41 |     return 0;\\n      |              ^\\n      |              ;\\n   42 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_vtcdt3_s/program.c: In function 'main':\n/tmp/agnostics_c_vtcdt3_s/program.c:38:12: warning: missing terminating \" character\n   38 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c_vtcdt3_s/program.c:38:12: error: missing terminating \" character\n   38 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c_vtcdt3_s/program.c:39:1: warning: missing terminating \" character\n   39 | \", count);\n      | ^\n/tmp/agnostics_c_vtcdt3_s/program.c:39:1: error: missing terminating \" character\n   39 | \", count);\n      | ^~~~~~~~~~\n/tmp/agnostics_c_vtcdt3_s/program.c:41:5: error: expected expression before 'return'\n   41 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_vtcdt3_s/program.c:41:14: error: expected ';' before '}' token\n   41 |     return 0;\n      |              ^\n      |              ;\n   42 | }\n      | ~             \n"}
{"question_id": "abc377_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    int p[MAXN];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int cycle_length = 0;\n    int current = 0;\n\n    // Find the cycle length\n    while (!g_hash_table_contains(visited, GINT_TO_POINTER(current))) {\n        g_hash_table_insert(visited, GINT_TO_POINTER(current), GINT_TO_POINTER(1));\n        current = p[current] - 1;\n        cycle_length++;\n    }\n\n    // If the cycle length is 1, the permutation does not change\n    if (cycle_length == 1) {\n        for (int i = 0; i < n; i++) {\n            printf(\"%d \", p[i] + 1);\n        }\n    } else {\n        // Find the starting point of the cycle\n        int start = 0;\n        while (start != current) {\n            start++;\n        }\n\n        // Find the position of the current element in the cycle\n        int pos = 0;\n        current = start;\n        while (current != start || pos == 0) {\n            current = p[current] - 1;\n            pos++;\n        }\n\n        // Apply the operation K times\n        for (int i = 0; i < n; i++) {\n            int new_pos = (pos + (k % cycle_length)) % cycle_length;\n            int new_start = start;\n            for (int j = 0; j < new_pos; j++) {\n                new_start = p[new_start] - 1;\n            }\n            printf(\"%d \", new_start + 1);\n        }\n    }\n\n    printf(\"\\n\");\n\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2mnmra1w/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2mnmra1w/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc377_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GArray *L = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *R = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        g_array_append_val(L, l);\n        g_array_append_val(R, r);\n    }\n\n    int count = 0;\n\n    for (int l = 1; l <= M; l++) {\n        for (int r = l; r <= M; r++) {\n            bool valid = true;\n            for (int i = 0; i < N; i++) {\n                if (l >= g_array_index(L, int, i) && r <= g_array_index(R, int, i)) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) {\n                count++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    g_array_free(L, TRUE);\n    g_array_free(R, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2vszeccn/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2vszeccn/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc378_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    long long result = 0;\n    for (int i = 0; i < n; i++) {\n        long long sum = 0;\n        for (int j = i; j < n; j++) {\n            sum += a[j];\n            result += (sum % m);\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n\n    free(a);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_vfxi1ubb/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_vfxi1ubb/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc378_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_H 10\n#define MAX_W 10\n#define MAX_K 11\n\ntypedef struct {\n    int h, w, k;\n    char grid[MAX_H][MAX_W];\n} Problem;\n\ntypedef struct {\n    int x, y;\n} Point;\n\nGHashTable *visited;\n\nbool is_valid(Problem *problem, Point p) {\n    return p.x >= 0 && p.x < problem->h && p.y >= 0 && p.y < problem->w && problem->grid[p.x][p.y] == '.' && !g_hash_table_contains(visited, GINT_TO_POINTER(p.x * MAX_W + p.y));\n}\n\nvoid dfs(Problem *problem, Point current, int steps) {\n    if (steps == problem->k) {\n        g_hash_table_insert(visited, GINT_TO_POINTER(current.x * MAX_W + current.y), GINT_TO_POINTER(1));\n        return;\n    }\n    Point directions[4] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    for (int i = 0; i < 4; i++) {\n        Point next = {current.x + directions[i].x, current.y + directions[i].y};\n        if (is_valid(problem, next)) {\n            dfs(problem, next, steps + 1);\n        }\n    }\n}\n\nint count_paths(Problem *problem) {\n    visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int count = 0;\n    for (int i = 0; i < problem->h; i++) {\n        for (int j = 0; j < problem->w; j++) {\n            if (problem->grid[i][j] == '.' && !g_hash_table_contains(visited, GINT_TO_POINTER(i * MAX_W + j))) {\n                dfs(problem, (Point){i, j}, 0);\n                if (g_hash_table_contains(visited, GINT_TO_POINTER(i * MAX_W + j))) {\n                    count++;\n                }\n                g_hash_table_remove(visited, GINT_TO_POINTER(i * MAX_W + j));\n            }\n        }\n    }\n    g_hash_table_destroy(visited);\n    return count;\n}\n\nint main() {\n    Problem problem;\n    scanf(\"%d %d %d\", &problem.h, &problem.w, &problem.k);\n    for (int i = 0; i < problem.h; i++) {\n        scanf(\"%s\", problem.grid[i]);\n    }\n    int result = count_paths(&problem);\n    printf(\"%d\\n\", result);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4iu2l9jr/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_4iu2l9jr/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc378_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Read the collection schedule for each type of garbage\n    GHashTable *schedule = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < N; i++) {\n        int q, r;\n        scanf(\"%d %d\", &q, &r);\n        g_hash_table_insert(schedule, GINT_TO_POINTER(i + 1), GINT_TO_POINTER(q * (r / q + 1) + (r % q != 0 ? 1 : 0)));\n    }\n\n    int Q;\n    scanf(\"%d\", &Q);\n\n    // Process each query\n    for (int j = 0; j < Q; j++) {\n        int t, d;\n        scanf(\"%d %d\", &t, &d);\n\n        // Get the next collection day for the given type of garbage\n        int next_collection_day = GPOINTER_TO_INT(g_hash_table_lookup(schedule, GINT_TO_POINTER(t)));\n\n        // If the garbage is already collected on day d, the next collection day is the same\n        if (d % next_collection_day == 0) {\n            printf(\"%d\n\", d);\n        } else {\n            // Otherwise, find the next collection day after day d\n            int days_passed = d % next_collection_day;\n            int days_until_next_collection = next_collection_day - days_passed;\n            printf(\"%d\n\", d + days_until_next_collection);\n        }\n    }\n\n    // Clean up\n    g_hash_table_destroy(schedule);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_a3qoo0_y/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_a3qoo0_y/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc378_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n// Function to add an edge to the graph\nvoid add_edge(GHashTable *adj_list, int u, int v) {\n    g_hash_table_add(adj_list, GINT_TO_POINTER(u), g_array_append_val(g_array_new(FALSE, FALSE, sizeof(int)), v));\n    g_hash_table_add(adj_list, GINT_TO_POINTER(v), g_array_append_val(g_array_new(FALSE, FALSE, sizeof(int)), u));\n}\n\n// Function to check if adding an edge (u, v) forms a valid cycle with degree 3\nbool is_valid_cycle(GHashTable *adj_list, int u, int v) {\n    GArray *adj_u = g_hash_table_lookup(adj_list, GINT_TO_POINTER(u));\n    GArray *adj_v = g_hash_table_lookup(adj_list, GINT_TO_POINTER(v));\n    int degree_u = adj_u ? adj_u->len : 0;\n    int degree_v = adj_v ? adj_v->len : 0;\n    return degree_u == 2 && degree_v == 2;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Read edges and build the graph\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(adj_list, u, v);\n    }\n\n    int count = 0;\n\n    // Try adding an edge between every pair of non-adjacent vertices\n    for (int u = 1; u <= n; u++) {\n        for (int v = u + 1; v <= n; v++) {\n            if (!g_hash_table_contains(adj_list, GINT_TO_POINTER(u)) || !g_hash_table_contains(adj_list, GINT_TO_POINTER(v))) {\n                continue;\n            }\n            if (is_valid_cycle(adj_list, u, v)) {\n                count++;\n            }\n        }\n    }\n\n    // Output the result\n    printf(\"%d\n\", count);\n\n    // Clean up\n    g_hash_table_destroy(adj_list);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_echubvoz/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_echubvoz/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc378_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 1000000007\n\ntypedef struct {\n    int a;\n    int b;\n    int len;\n} State;\n\ntypedef struct {\n    State key;\n    int value;\n} MemoEntry;\n\nGHashTable *memo;\n\nint hash_func(const void *key) {\n    const State *state = (const State *)key;\n    return (state->a * 1000000001 + state->b * 1000000001 + state->len) % 1000000007;\n}\n\nint equal_func(const void *a, const void *b) {\n    const State *state1 = (const State *)a;\n    const State *state2 = (const State *)b;\n    return state1->a == state2->a && state1->b == state2->b && state1->len == state2->len;\n}\n\nint dp(int a, int b, int len) {\n    State key = {a, b, len};\n    gpointer result = g_hash_table_lookup(memo, &key);\n    if (result != NULL) {\n        return GPOINTER_TO_INT(result);\n    }\n\n    if (a == 0 && b == 0) {\n        return 1;\n    }\n\n    int count = 0;\n\n    if (a > 0) {\n        for (int i = 1; i <= len; i++) {\n            count = (count + dp(a - 1, b, i - 1)) % MOD;\n        }\n    }\n\n    if (b > 0) {\n        for (int i = 1; i <= len; i++) {\n            count = (count + dp(a, b - 1, i - 1)) % MOD;\n        }\n    }\n\n    g_hash_table_insert(memo, &key, GINT_TO_POINTER(count));\n    return count;\n}\n\nint main() {\n    int a, b, m;\n    scanf(\"%d %d %d\", &a, &b, &m);\n\n    memo = g_hash_table_new(hash_func, equal_func);\n\n    int result = dp(a, b, a + b - 1);\n\n    g_hash_table_destroy(memo);\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_gfyoggus/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_gfyoggus/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc378_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int a[4];\n    for (int i = 0; i < 4; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < 4; i++) {\n        int *val = (int *)g_hash_table_lookup(count, GINT_TO_POINTER(a[i]));\n        if (val == NULL) {\n            g_hash_table_insert(count, GINT_TO_POINTER(a[i]), GINT_TO_POINTER(1));\n        } else {\n            *val += 1;\n        }\n    }\n\n    int result = 0;\n    for (gpointer key, value; g_hash_table_iter_init(&iter, count); g_hash_table_iter_next(&iter, &key, &value)) {\n        int occurrences = GPOINTER_TO_INT(value);\n        result += occurrences / 2;\n    }\n\n    printf(\"%d\n\", result);\n\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_zj3i74ii/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_zj3i74ii/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc378_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize the hash table to store the most recent index of each element\n    GHashTable *last_index = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Initialize the array to store the result\n    int *b = (int *)malloc(n * sizeof(int));\n\n    // Iterate through the sequence A\n    for (int i = 0; i < n; i++) {\n        int a_i;\n        scanf(\"%d\", &a_i);\n\n        // Check if the element has appeared before\n        gpointer index = g_hash_table_lookup(last_index, GINT_TO_POINTER(a_i));\n        if (index != NULL) {\n            // Store the most recent index in the result array\n            b[i] = GPOINTER_TO_INT(index);\n        } else {\n            // If the element has not appeared before, store -1\n            b[i] = -1;\n        }\n\n        // Update the most recent index of the current element\n        g_hash_table_insert(last_index, GINT_TO_POINTER(a_i), GINT_TO_POINTER(i));\n    }\n\n    // Print the result\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", b[i]);\n    }\n    printf(\"\\n\");\n\n    // Free the memory\n    free(b);\n    g_hash_table_destroy(last_index);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_xjl7ugj7/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_xjl7ugj7/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc379_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    char s[101];\n    scanf(\"%s\", s);\n\n    int count = 0;\n    int healthy = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'O') {\n            healthy++;\n            if (healthy == k) {\n                count++;\n                healthy = 0;\n            }\n        } else {\n            healthy = 0;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tr13xorv/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_tr13xorv/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc379_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[200001];\n    scanf(\"%s\", s);\n\n    GHashTable *prefix_sum = g_hash_table_new(g_str_hash, g_str_equal);\n    g_hash_table_insert(prefix_sum, \"0\", GINT_TO_POINTER(0));\n\n    long long result = 0;\n    long long current_sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        int digit = s[i] - '0';\n        current_sum = (current_sum * 10 + digit) % 1000000007;\n        result = (result + current_sum) % 1000000007;\n\n        char key[20];\n        sprintf(key, \"%lld\", current_sum);\n        gpointer value = g_hash_table_lookup(prefix_sum, key);\n        if (value) {\n            int count = GPOINTER_TO_INT(value);\n            result = (result + count * (i + 1)) % 1000000007;\n        }\n\n        g_hash_table_insert(prefix_sum, key, GINT_TO_POINTER(1 + GPOINTER_TO_INT(value)));\n    }\n\n    printf(\"%lld\\n\", result);\n\n    g_hash_table_destroy(prefix_sum);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_iaa8waq9/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_iaa8waq9/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc379_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < m; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        int *count = (int *)g_hash_table_lookup(map, GINT_TO_POINTER(x));\n        if (count == NULL) {\n            count = (int *)malloc(sizeof(int));\n            *count = 0;\n            g_hash_table_insert(map, GINT_TO_POINTER(x), count);\n        }\n        (*count)++;\n    }\n\n    int total_stones = 0;\n    int max_stones = 0;\n\n    for (GList *node = g_hash_table_get_keys(map); node != NULL; node = node->next) {\n        int *count = (int *)g_hash_table_lookup(map, node->data);\n        total_stones += *count;\n        max_stones = MAX(max_stones, *count);\n    }\n\n    if (total_stones != n) {\n        printf(\"-1\n\");\n        g_hash_table_destroy(map);\n        return 0;\n    }\n\n    int operations = 0;\n\n    for (GList *node = g_hash_table_get_keys(map); node != NULL; node = node->next) {\n        int *count = (int *)g_hash_table_lookup(map, node->data);\n        operations += abs(*count - 1);\n    }\n\n    printf(\"%d\n\", operations);\n\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_2kgotwu6/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_2kgotwu6/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc379_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_QUERIES 200000\n\nint main() {\n    // Read input\n    int Q;\n    scanf(\"%d\", &Q);\n\n    // Prepare data structures\n    GQueue *queue = g_queue_new();  // To keep track of plant growth\n    GHashTable *height_count = g_hash_table_new(g_direct_hash, g_direct_equal);  // To count plants by height\n    GArray *harvested_count = g_array_new(FALSE, FALSE, sizeof(int));  // To store results of type 3 queries\n\n    // Process each query\n    for (int i = 0; i < Q; i++) {\n        int query_type;\n        scanf(\"%d\", &query_type);\n\n        if (query_type == 1) {\n            // Plant a new plant of height 0\n            g_queue_push_tail(queue, GINT_TO_POINTER(0));\n            g_hash_table_insert(height_count, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n        } else if (query_type == 2) {\n            // Wait for T days\n            int T;\n            scanf(\"%d\", &T);\n            int n = g_queue_get_length(queue);\n            for (int j = 0; j < n; j++) {\n                int *height = g_queue_pop_head(queue);\n                *height += T;\n                g_queue_push_tail(queue, height);\n                g_hash_table_insert(height_count, GINT_TO_POINTER(*height), GINT_TO_POINTER(g_hash_table_lookup(height_count, GINT_TO_POINTER(*height)) + 1));\n            }\n        } else if (query_type == 3) {\n            // Harvest plants with height at least H\n            int H;\n            scanf(\"%d\", &H);\n            int count = 0;\n            while (g_queue_get_length(queue) > 0) {\n                int *height = g_queue_peek_head(queue);\n                if (*height < H) {\n                    break;\n                }\n                g_queue_pop_head(queue);\n                count++;\n                g_hash_table_insert(height_count, GINT_TO_POINTER(*height), GINT_TO_POINTER(g_hash_table_lookup(height_count, GINT_TO_POINTER(*height)) - 1));\n                if (g_hash_table_lookup(height_count, GINT_TO_POINTER(*height)) == 0) {\n                    g_hash_table_remove(height_count, GINT_TO_POINTER(*height));\n                }\n            }\n            g_array_append_val(harvested_count, count);\n        }\n    }\n\n    // Output results of type 3 queries\n    for (int i = 0; i < harvested_count->len; i++) {\n        printf(\"%d\n\", g_array_index(harvested_count, int, i));\n    }\n\n    // Clean up\n    g_queue_free(queue);\n    g_hash_table_destroy(height_count);\n    g_array_free(harvested_count, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_sb3jlvmb/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_sb3jlvmb/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc379_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int n;\n    int m;\n    int **grid;\n    GArray *adj[200];\n} Grid;\n\nvoid init_grid(Grid *g, int H, int W) {\n    g->n = H;\n    g->m = W;\n    g->grid = (int **)malloc(H * sizeof(int *));\n    for (int i = 0; i < H; i++) {\n        g->grid[i] = (int *)malloc(W * sizeof(int));\n    }\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            g->grid[i][j] = 0;\n        }\n    }\n    for (int i = 0; i < 200; i++) {\n        g->adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n}\n\nvoid free_grid(Grid *g) {\n    for (int i = 0; i < g->n; i++) {\n        free(g->grid[i]);\n    }\n    free(g->grid);\n    for (int i = 0; i < 200; i++) {\n        g_array_free(g->adj[i], TRUE);\n    }\n}\n\nvoid build_adjacency_list(Grid *g) {\n    for (int i = 0; i < g->n; i++) {\n        for (int j = 0; j < g->m; j++) {\n            if (i > 0 && g->grid[i - 1][j] == 0) {\n                g_array_append_val(g->adj[g->m * i + j], g->m * (i - 1) + j);\n            }\n            if (i < g->n - 1 && g->grid[i + 1][j] == 0) {\n                g_array_append_val(g->adj[g->m * i + j], g->m * (i + 1) + j);\n            }\n            if (j > 0 && g->grid[i][j - 1] == 0) {\n                g_array_append_val(g->adj[g->m * i + j], g->m * i + (j - 1));\n            }\n            if (j < g->m - 1 && g->grid[i][j + 1] == 0) {\n                g_array_append_val(g->adj[g->m * i + j], g->m * i + (j + 1));\n            }\n        }\n    }\n}\n\nint dfs(Grid *g, int node, int prev, int *visited) {\n    if (visited[node]) {\n        return 0;\n    }\n    visited[node] = 1;\n    int count = 1;\n    GArray *neighbors = g->adj[node];\n    for (int i = 0; i < neighbors->len; i++) {\n        int neighbor = g_array_index(neighbors, int, i);\n        if (g->grid[neighbor / g->m][neighbor % g->m] != 0 && g->grid[neighbor / g->m][neighbor % g->m] != prev) {\n            count = (count + dfs(g, neighbor, g->grid[neighbor / g->m][neighbor % g->m], visited)) % MOD;\n        }\n    }\n    return count;\n}\n\nint count_valid_grids(Grid *g) {\n    int total_count = 1;\n    for (int i = 0; i < g->n; i++) {\n        for (int j = 0; j < g->m; j++) {\n            if (g->grid[i][j] == 0) {\n                int *visited = (int *)calloc(g->n * g->m, sizeof(int));\n                total_count = (total_count * dfs(g, g->m * i + j, 0, visited)) % MOD;\n                free(visited);\n            }\n        }\n    }\n    return total_count;\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    Grid g;\n    init_grid(&g, H, W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            char ch;\n            scanf(\"%c\", &ch);\n            if (ch == '1') {\n                g.grid[i][j] = 1;\n            } else if (ch == '2') {\n                g.grid[i][j] = 2;\n            } else if (ch == '3') {\n                g.grid[i][j] = 3;\n            } else {\n                g.grid[i][j] = 0;\n            }\n        }\n    }\n    build_adjacency_list(&g);\n    int result = count_valid_grids(&g);\n    printf(\"%d\n\", result);\n    free_grid(&g);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_uazhb2re/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_uazhb2re/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc379_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    int *heights = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n\n    GHashTable *left_max = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *right_max = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int current_max = 0;\n    for (int i = 0; i < n; i++) {\n        current_max = MAX(current_max, heights[i]);\n        g_hash_table_insert(left_max, GINT_TO_POINTER(i), GINT_TO_POINTER(current_max));\n    }\n\n    current_max = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        current_max = MAX(current_max, heights[i]);\n        g_hash_table_insert(right_max, GINT_TO_POINTER(i), GINT_TO_POINTER(current_max));\n    }\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n\n        int left_max_height = GPOINTER_TO_INT(g_hash_table_lookup(left_max, GINT_TO_POINTER(r - 1)));\n        int right_max_height = GPOINTER_TO_INT(g_hash_table_lookup(right_max, GINT_TO_POINTER(l + 1)));\n\n        int visible_count = 0;\n        for (int j = r + 1; j < n; j++) {\n            if (heights[j] > left_max_height && heights[j] > right_max_height) {\n                visible_count++;\n            }\n        }\n\n        printf(\"%d\\n\", visible_count);\n    }\n\n    free(heights);\n    g_hash_table_destroy(left_max);\n    g_hash_table_destroy(right_max);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_yntqt1ma/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_yntqt1ma/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc379_a", "solution": "#include <stdio.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    // Extract digits\n    int hundreds = N / 100;\n    int tens = (N / 10) % 10;\n    int ones = N % 10;\n\n    // Form new integers\n    int new1 = tens * 100 + ones * 10 + hundreds;\n    int new2 = ones * 100 + hundreds * 10 + tens;\n\n    // Print the new integers\n    printf(\"%d %d\n\", new1, new2);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_hsnzg4l2/program.c: In function 'main':\\n/tmp/agnostics_c_hsnzg4l2/program.c:17:12: warning: missing terminating \\\" character\\n   17 |     printf(\\\"%d %d\\n      |            ^\\n/tmp/agnostics_c_hsnzg4l2/program.c:17:12: error: missing terminating \\\" character\\n   17 |     printf(\\\"%d %d\\n      |            ^~~~~~\\n/tmp/agnostics_c_hsnzg4l2/program.c:18:1: warning: missing terminating \\\" character\\n   18 | \\\", new1, new2);\\n      | ^\\n/tmp/agnostics_c_hsnzg4l2/program.c:18:1: error: missing terminating \\\" character\\n   18 | \\\", new1, new2);\\n      | ^~~~~~~~~~~~~~~\\n/tmp/agnostics_c_hsnzg4l2/program.c:20:5: error: expected expression before 'return'\\n   20 |     return 0;\\n      |     ^~~~~~\\n/tmp/agnostics_c_hsnzg4l2/program.c:20:14: error: expected ';' before '}' token\\n   20 |     return 0;\\n      |              ^\\n      |              ;\\n   21 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_hsnzg4l2/program.c: In function 'main':\n/tmp/agnostics_c_hsnzg4l2/program.c:17:12: warning: missing terminating \" character\n   17 |     printf(\"%d %d\n      |            ^\n/tmp/agnostics_c_hsnzg4l2/program.c:17:12: error: missing terminating \" character\n   17 |     printf(\"%d %d\n      |            ^~~~~~\n/tmp/agnostics_c_hsnzg4l2/program.c:18:1: warning: missing terminating \" character\n   18 | \", new1, new2);\n      | ^\n/tmp/agnostics_c_hsnzg4l2/program.c:18:1: error: missing terminating \" character\n   18 | \", new1, new2);\n      | ^~~~~~~~~~~~~~~\n/tmp/agnostics_c_hsnzg4l2/program.c:20:5: error: expected expression before 'return'\n   20 |     return 0;\n      |     ^~~~~~\n/tmp/agnostics_c_hsnzg4l2/program.c:20:14: error: expected ';' before '}' token\n   20 |     return 0;\n      |              ^\n      |              ;\n   21 | }\n      | ~             \n"}
{"question_id": "abc380_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 500005\n#define MAX_Q 200005\n\ntypedef struct {\n    int parent;\n    int size;\n} UnionFind;\n\nUnionFind uf[MAX_N];\n\nvoid init_uf(int n) {\n    for (int i = 1; i <= n; i++) {\n        uf[i].parent = i;\n        uf[i].size = 1;\n    }\n}\n\nint find(int u) {\n    if (uf[u].parent != u) {\n        uf[u].parent = find(uf[u].parent);\n    }\n    return uf[u].parent;\n}\n\nvoid union_sets(int u, int v) {\n    int pu = find(u);\n    int pv = find(v);\n    if (pu != pv) {\n        if (uf[pu].size < uf[pv].size) {\n            uf[pu].parent = pv;\n            uf[pv].size += uf[pu].size;\n        } else {\n            uf[pv].parent = pu;\n            uf[pu].size += uf[pv].size;\n        }\n    }\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    init_uf(n);\n\n    for (int i = 0; i < q; i++) {\n        int type, x, c;\n        scanf(\"%d\", &type);\n        if (type == 1) {\n            scanf(\"%d %d\", &x, &c);\n            for (int j = x; j <= n; j++) {\n                if (find(j) != find(j - 1)) {\n                    union_sets(j, j - 1);\n                }\n            }\n            for (int j = x; j >= 1; j--) {\n                if (find(j) != find(j + 1)) {\n                    union_sets(j, j + 1);\n                }\n            }\n        } else if (type == 2) {\n            scanf(\"%d\", &c);\n            int count = 0;\n            for (int j = 1; j <= n; j++) {\n                if (find(j) == j && uf[j].size == 1) {\n                    count++;\n                }\n            }\n            printf(\"%d\\n\", count);\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_3olfqzta/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_3olfqzta/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc380_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_CARDS 12\n\n// Function to compare integers for qsort\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\n// Function to determine the winner\nvoid determine_winner(int N, int M, int L, int A[N], int B[M], int C[L]) {\n    // Sort the cards in descending order\n    qsort(A, N, sizeof(int), compare);\n    qsort(B, M, sizeof(int), compare);\n    qsort(C, L, sizeof(int), compare);\n\n    // Initialize the game state\n    GArray *table = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *takahashi_hand = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *aoki_hand = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Transfer Takahashi's cards to his hand\n    for (int i = 0; i < N; i++) {\n        g_array_append_val(takahashi_hand, A[i]);\n    }\n\n    // Transfer Aoki's cards to his hand\n    for (int i = 0; i < M; i++) {\n        g_array_append_val(aoki_hand, B[i]);\n    }\n\n    // Transfer table cards to the table\n    for (int i = 0; i < L; i++) {\n        g_array_append_val(table, C[i]);\n    }\n\n    // Game loop\n    while (g_array_get_length(takahashi_hand) > 0 || g_array_get_length(aoki_hand) > 0) {\n        if (g_array_get_length(takahashi_hand) > 0) {\n            // Takahashi's turn\n            int card = g_array_index(takahashi_hand, int, 0);\n            g_array_remove_index(takahashi_hand, 0);\n            g_array_append_val(table, card);\n\n            // Check for cards Takahashi can take\n            int i = 0;\n            while (i < g_array_get_length(table)) {\n                if (g_array_index(table, int, i) < card) {\n                    int taken_card = g_array_index(table, int, i);\n                    g_array_remove_index(table, i);\n                    g_array_append_val(takahashi_hand, taken_card);\n                } else {\n                    i++;\n                }\n            }\n        } else {\n            // Aoki's turn\n            int card = g_array_index(aoki_hand, int, 0);\n            g_array_remove_index(aoki_hand, 0);\n            g_array_append_val(table, card);\n\n            // Check for cards Aoki can take\n            int i = 0;\n            while (i < g_array_get_length(table)) {\n                if (g_array_index(table, int, i) < card) {\n                    int taken_card = g_array_index(table, int, i);\n                    g_array_remove_index(table, i);\n                    g_array_append_val(aoki_hand, taken_card);\n                } else {\n                    i++;\n                }\n            }\n        }\n    }\n\n    // Determine the winner\n    if (g_array_get_length(takahashi_hand) > 0) {\n        printf(\"Takahashi\\n\");\n    } else {\n        printf(\"Aoki\\n\");\n    }\n\n    // Clean up\n    g_array_free(table, TRUE);\n    g_array_free(takahashi_hand, TRUE);\n    g_array_free(aoki_hand, TRUE);\n}\n\nint main() {\n    // Read input\n    int N, M, L;\n    scanf(\"%d %d %d\", &N, &M, &L);\n    int A[N], B[M], C[L];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n    for (int i = 0; i < L; i++) {\n        scanf(\"%d\", &C[i]);\n    }\n\n    // Determine the winner\n    determine_winner(N, M, L, A, B, C);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ota0oxic/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ota0oxic/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc380_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    GArray *ones = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '1') {\n            g_array_append_val(ones, i);\n        }\n    }\n\n    int l_k = g_array_index(ones, int, k - 1);\n    int r_k = g_array_index(ones, int, k);\n    int l_k_minus_1 = g_array_index(ones, int, k - 2);\n\n    char result[n + 1];\n    int index = 0;\n\n    for (int i = 0; i <= r_k_minus_1; i++) {\n        result[index++] = s[i];\n    }\n\n    for (int i = l_k; i <= r_k; i++) {\n        result[index++] = '1';\n    }\n\n    for (int i = r_k + 1; i < n; i++) {\n        result[index++] = s[i];\n    }\n\n    result[index] = '\\0';\n\n    printf(\"%s\\n\", result);\n\n    g_array_free(ones, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_tdou7d77/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_tdou7d77/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc380_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[200005];\n    int Q;\n    scanf(\"%s\", S);\n    scanf(\"%d\", &Q);\n\n    int len = strlen(S);\n    char T[len + 1];\n\n    // Create the transformed string T\n    for (int i = 0; i < len; i++) {\n        if (islower(S[i])) {\n            T[i] = toupper(S[i]);\n        } else {\n            T[i] = tolower(S[i]);\n        }\n    }\n    T[len] = '\\0';\n\n    // Answer the queries\n    for (int i = 0; i < Q; i++) {\n        long long K;\n        scanf(\"%lld\", &K);\n\n        // Determine the character at position K\n        if (K <= len) {\n            printf(\"%c \", S[K - 1]);\n        } else {\n            K -= len;\n            if (K <= len) {\n                printf(\"%c \", T[K - 1]);\n            } else {\n                K -= len;\n                printf(\"%c \", S[K - 1]);\n            }\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_yawujxk7/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_yawujxk7/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc380_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n;\n    scanf(\"%d\", &n);\n\n    // Initialize counters for digits 1, 2, and 3\n    int count_1 = 0, count_2 = 0, count_3 = 0;\n\n    // Convert the number to a string to iterate through each digit\n    char str[7]; // 6 digits + 1 for null terminator\n    sprintf(str, \"%d\", n);\n\n    // Iterate through each digit and update the corresponding counter\n    for (int i = 0; i < 6; i++) {\n        if (str[i] == '1') {\n            count_1++;\n        } else if (str[i] == '2') {\n            count_2++;\n        } else if (str[i] == '3') {\n            count_3++;\n        }\n    }\n\n    // Check if the counters match the required frequencies\n    if (count_1 == 1 && count_2 == 2 && count_3 == 3) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_av6kn0wq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_av6kn0wq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc380_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int num;\n        scanf(\"%d\", &num);\n        g_array_append_val(arr, num);\n    }\n\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i <= n; i++) {\n        g_array_append_val(dp, 0);\n    }\n\n    for (int i = 1; i <= k; i++) {\n        for (int j = n - 1; j >= 0; j--) {\n            int sum = 0;\n            for (int l = 0; l < n - j; l++) {\n                sum = (sum + g_array_index(dp, int, l) + (g_array_index(arr, int, j + l) > g_array_index(arr, int, j + l + 1))) % MOD;\n            }\n            g_array_index(dp, int, j) = sum;\n        }\n    }\n\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        result = (result + g_array_index(dp, int, i)) % MOD;\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_array_free(arr, TRUE);\n    g_array_free(dp, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ndnqnniw/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ndnqnniw/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc380_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S[1001];\n    scanf(\"%s\", S);\n\n    // Length of the string S\n    int len = strlen(S);\n\n    // Initialize GArray to store the sequence A\n    GArray *A = g_array_new(FALSE, FALSE, sizeof(int));\n\n    // Initialize variables to count the number of '-' characters\n    int count = 0;\n\n    // Iterate through the string S\n    for (int i = 0; i < len; i++) {\n        if (S[i] == '-') {\n            // Increment the count of '-' characters\n            count++;\n        } else if (S[i] == '|') {\n            // If we encounter a '|', append the count to the sequence A\n            g_array_append_val(A, count);\n            // Reset the count to 0\n            count = 0;\n        }\n    }\n\n    // Print the sequence A\n    for (int i = 0; i < A->len; i++) {\n        printf(\"%d \", g_array_index(A, int, i));\n    }\n    printf(\"\\n\");\n\n    // Clean up\n    g_array_free(A, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_05ztdaf8/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_05ztdaf8/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc381_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    if (n % 2 == 0) {\n        printf(\"No\n\");\n        return 0;\n    }\n\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    int mid = (n + 1) / 2;\n\n    for (int i = 0; i < mid - 1; i++) {\n        if (s[i] != '1') {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    if (s[mid - 1] != '/') {\n        printf(\"No\n\");\n        return 0;\n    }\n\n    for (int i = mid; i < n; i++) {\n        if (s[i] != '2') {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_nb5lly6m/program.c: In function 'main':\\n/tmp/agnostics_c_nb5lly6m/program.c:11:16: warning: missing terminating \\\" character\\n   11 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_nb5lly6m/program.c:11:16: error: missing terminating \\\" character\\n   11 |         printf(\\\"No\\n      |                ^~~\\n/tmp/agnostics_c_nb5lly6m/program.c:12:1: warning: missing terminating \\\" character\\n   12 | \\\");\\n      | ^\\n/tmp/agnostics_c_nb5lly6m/program.c:12:1: error: missing terminating \\\" character\\n   12 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_nb5lly6m/program.c:13:9: error: expected expression before 'return'\\n   13 |         return 0;\\n      |         ^~~~~~\\n/tmp/agnostics_c_nb5lly6m/program.c:13:18: error: expected ';' before '}' token\\n   13 |         return 0;\\n      |                  ^\\n      |                  ;\\n   14 |     }\\n      |     ~             \\n/tmp/agnostics_c_nb5lly6m/program.c:23:20: warning: missing terminating \\\" character\\n   23 |             printf(\\\"No\\n      |                    ^\\n/tmp/agnostics_c_nb5lly6m/program.c:23:20: error: missing terminating \\\" character\\n   23 |             printf(\\\"No\\n      |                    ^~~\\n/tmp/agnostics_c_nb5lly6m/program.c:24:1: warning: missing terminating \\\" character\\n   24 | \\\");\\n      | ^\\n/tmp/agnostics_c_nb5lly6m/program.c:24:1: error: missing terminating \\\" character\\n   24 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_nb5lly6m/program.c:25:13: error: expected expression before 'return'\\n   25 |             return 0;\\n      |             ^~~~~~\\n/tmp/agnostics_c_nb5lly6m/program.c:25:22: error: expected ';' before '}' token\\n   25 |             return 0;\\n      |                      ^\\n      |                      ;\\n   26 |         }\\n      |         ~             \\n/tmp/agnostics_c_nb5lly6m/program.c:30:16: warning: missing terminating \\\" character\\n   30 |         printf(\\\"No\\n      |                ^\\n/tmp/agnostics_c_nb5lly6m", "raw_stderr": "", "result": "fail"}
{"question_id": "abc381_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n// Function to check if a character is 1, 2, or /\nbool is_valid_char(char c) {\n    return c == '1' || c == '2' || c == '/';\n}\n\n// Function to find the maximum length of a subsequence that is an 11/22 string\nint max_1122_subseq_len(const char *s, int start, int end) {\n    int n = end - start + 1;\n    if (n % 2 == 0) return 0; // Length must be odd\n\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(int));\n    g_array_set_size(dp, n);\n    memset(dp->data, 0, n * sizeof(int));\n\n    for (int i = start; i <= end; i++) {\n        if (!is_valid_char(s[i])) continue;\n\n        int len = i - start + 1;\n        if (len == 1 && s[i] == '1') {\n            dp->data[i - start] = 1;\n        } else if (len == 2 && s[i] == '2') {\n            dp->data[i - start] = 2;\n        } else if (len > 2 && s[i] == '2' && dp->data[len - 3] > 0) {\n            dp->data[i - start] = dp->data[len - 3] + 1;\n        }\n    }\n\n    int max_len = 0;\n    for (int i = 0; i < n; i++) {\n        if (dp->data[i] > max_len) {\n            max_len = dp->data[i];\n        }\n    }\n\n    g_array_free(dp, TRUE);\n    return max_len;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        l--; // Adjust to 0-based index\n        r--;\n\n        int result = max_1122_subseq_len(s, l, r);\n        printf(\"%d\n\", result);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_n66nifw8/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_n66nifw8/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc381_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char s[101];\n    scanf(\"%s\", s);\n\n    int n = strlen(s);\n    if (n % 2 != 0) {\n        printf(\"No\n\");\n        return 0;\n    }\n\n    GHashTable *count = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; i < n; i++) {\n        char *c = &s[i];\n        int *value = (int *)g_hash_table_lookup(count, c);\n        if (value) {\n            (*value)++;\n        } else {\n            g_hash_table_insert(count, c, GINT_TO_POINTER(1));\n        }\n    }\n\n    int odd_count = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, count);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        int val = GPOINTER_TO_INT(value);\n        if (val % 2 != 0) {\n            odd_count++;\n        }\n    }\n\n    if (odd_count != 0) {\n        printf(\"No\n\");\n    } else {\n        printf(\"Yes\n\");\n    }\n\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_3lfk95wp/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_3lfk95wp/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc381_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    int max_length = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '/') {\n            int j = i + 1;\n            while (j < n && s[j] == '2') {\n                j++;\n            }\n            if (j - i > max_length) {\n                max_length = j - i;\n            }\n            i = j - 1;\n        }\n    }\n\n    printf(\"%d\n\", max_length);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jycq8ow7/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jycq8ow7/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc381_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    int max_length = 0;\n    for (int i = 0; i < n; i++) {\n        GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n        int length = 0;\n\n        for (int j = i; j < n; j++) {\n            int key = arr[j];\n            int *val = (int *)g_hash_table_lookup(count, GINT_TO_POINTER(key));\n\n            if (val == NULL) {\n                g_hash_table_insert(count, GINT_TO_POINTER(key), GINT_TO_POINTER(1));\n                length += 2;\n            } else {\n                if (*val == 1) {\n                    length += 2;\n                    g_hash_table_insert(count, GINT_TO_POINTER(key), GINT_TO_POINTER(2));\n                } else {\n                    break;\n                }\n            }\n\n            if (length % 2 == 0) {\n                max_length = (length > max_length) ? length : max_length;\n            }\n        }\n\n        g_hash_table_destroy(count);\n    }\n\n    printf(\"%d\\n\", max_length);\n\n    free(arr);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_hsveo5m0/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_hsveo5m0/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc382_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nvoid generate_sequences(int N, int M, int *sequence, int index) {\n    if (index == N) {\n        for (int i = 0; i < N; i++) {\n            printf(\"%d\", sequence[i]);\n            if (i < N - 1) {\n                printf(\" \");\n            }\n        }\n        printf(\"\\n\");\n        return;\n    }\n\n    if (index == 0) {\n        for (int i = 1; i <= M; i++) {\n            sequence[index] = i;\n            generate_sequences(N, M, sequence, index + 1);\n        }\n    } else {\n        for (int i = sequence[index - 1] + 10; i <= M; i++) {\n            sequence[index] = i;\n            generate_sequences(N, M, sequence, index + 1);\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    int *sequence = (int *)malloc(N * sizeof(int));\n    int count = 0;\n\n    generate_sequences(N, M, sequence, 0);\n\n    free(sequence);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4z53kwj1/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_4z53kwj1/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc382_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n    char S[1000];\n    scanf(\"%s\", S);\n\n    // Count the initial number of cookies\n    int cookies = 0;\n    for (int i = 0; i < N; i++) {\n        if (S[i] == '@') {\n            cookies++;\n        }\n    }\n\n    // Calculate the number of empty boxes after D days\n    int empty_boxes = cookies - D;\n    if (empty_boxes < 0) {\n        empty_boxes = 0;\n    }\n\n    // Output the result\n    printf(\"%d\n\", empty_boxes);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_xdlgj8li/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_xdlgj8li/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc382_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n    char S[N + 1];\n    scanf(\"%s\", S);\n\n    GQueue *queue = g_queue_new();\n    int *days = (int *)malloc(N * sizeof(int));\n    memset(days, 0, N * sizeof(int));\n\n    for (int i = N - 1; i >= 0; i--) {\n        if (S[i] == '@') {\n            g_queue_push_head(queue, GINT_TO_POINTER(i));\n            days[i] = D;\n        }\n    }\n\n    for (int i = 0; i < D; i++) {\n        if (!g_queue_is_empty(queue)) {\n            int index = GPOINTER_TO_INT(g_queue_pop_head(queue));\n            if (index > 0) {\n                g_queue_push_head(queue, GINT_TO_POINTER(index - 1));\n                days[index - 1] = days[index] - 1;\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (days[i] > 0) {\n            printf(\"@\");\n        } else {\n            printf(\".\");\n        }\n    }\n    printf(\"\\n\");\n\n    g_queue_free(queue);\n    free(days);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_uans00vu/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_uans00vu/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc382_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 1000000007\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    GHashTable *bars = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < N; i++) {\n        int R, C, L;\n        scanf(\"%d %d %d\", &R, &C, &L);\n\n        int cycle = H - R + 1;\n        int final_R = (R + (MOD * (1000000000 - 1) / 2) * cycle) % H;\n\n        g_hash_table_insert(bars, GINT_TO_POINTER(i + 1), GINT_TO_POINTER(final_R));\n    }\n\n    for (int i = 1; i <= N; i++) {\n        int final_R = GPOINTER_TO_INT(g_hash_table_lookup(bars, GINT_TO_POINTER(i)));\n        printf(\"%d\n\", final_R);\n    }\n\n    g_hash_table_destroy(bars);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_5yfsgyhr/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_5yfsgyhr/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc382_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        long long K, S_x, S_y, T_x, T_y;\n        scanf(\"%lld %lld %lld %lld %lld\", &K, &S_x, &S_y, &T_x, &T_y);\n\n        // Calculate the tile coordinates for the starting and target points\n        int start_i = (S_x + 0.5) / K;\n        int start_j = (S_y + 0.5) / K;\n        int start_k = (S_x + 0.5) - start_i * K;\n\n        int target_i = (T_x + 0.5) / K;\n        int target_j = (T_y + 0.5) / K;\n        int target_k = (T_x + 0.5) - target_i * K;\n\n        // Calculate the minimum number of moves required\n        int moves = 0;\n\n        if (start_i % 2 == target_i % 2) {\n            moves += abs(start_j - target_j);\n        } else {\n            moves += abs(start_i - target_i);\n        }\n\n        if (start_j % 2 == target_j % 2) {\n            moves += abs(start_k - target_k);\n        } else {\n            moves += abs(start_k - target_k);\n        }\n\n        // Output the result\n        printf(\"%d\\n\", moves);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_n01emqxv/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_n01emqxv/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc382_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Read gourmet levels\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Read sushi deliciousness\n    int *B = (int *)malloc(m * sizeof(int));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n\n    // Initialize a GQueue to keep track of people\n    GQueue *queue = g_queue_new();\n    for (int i = 0; i < n; i++) {\n        g_queue_push_tail(queue, GINT_TO_POINTER(i + 1));\n    }\n\n    // Process each sushi\n    for (int i = 0; i < m; i++) {\n        int sushi = B[i];\n        int eaten = -1;\n\n        // Check people in order\n        while (!g_queue_is_empty(queue)) {\n            int person = GPOINTER_TO_INT(g_queue_pop_head(queue));\n            if (sushi >= A[person - 1]) {\n                eaten = person;\n                break;\n            }\n        }\n\n        // Print the result for this sushi\n        printf(\"%d\\n\", eaten);\n\n        // If someone ate the sushi, add them back to the end of the queue\n        if (eaten != -1) {\n            g_queue_push_tail(queue, GINT_TO_POINTER(eaten));\n        }\n    }\n\n    // Clean up\n    free(A);\n    free(B);\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_xtwz456m/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_xtwz456m/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc383_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 1000\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int H, W, D;\n    scanf(\"%d %d %d\", &H, &W, &D);\n\n    char grid[MAX][MAX];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    GQueue *queue = g_queue_new();\n    int directions[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    // Initialize visited array\n    bool visited[MAX][MAX];\n    memset(visited, false, sizeof(visited));\n\n    // Enqueue all humidifier positions\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'H') {\n                g_queue_push_tail(queue, GINT_TO_POINTER(i * W + j));\n                visited[i][j] = true;\n            }\n        }\n    }\n\n    // Perform BFS to mark all reachable cells\n    while (!g_queue_is_empty(queue)) {\n        int pos = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        int row = pos / W;\n        int col = pos % W;\n\n        for (int k = 0; k < 4; k++) {\n            int new_row = row + directions[k][0];\n            int new_col = col + directions[k][1];\n\n            if (new_row >= 0 && new_row < H && new_col >= 0 && new_col < W && !visited[new_row][new_col] && grid[new_row][new_col] != '#') {\n                visited[new_row][new_col] = true;\n                g_queue_push_tail(queue, GINT_TO_POINTER(new_row * W + new_col));\n            }\n        }\n    }\n\n    // Count the number of humidified floor cells\n    int humidified_count = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.' && visited[i][j]) {\n                humidified_count++;\n            }\n        }\n    }\n\n    printf(\"%d\n\", humidified_count);\n\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_imzfpb9h/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_imzfpb9h/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc383_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    GArray *events = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        int T, V;\n        scanf(\"%d %d\", &T, &V);\n        g_array_append_val(events, T);\n        g_array_append_val(events, V);\n    }\n\n    int time = 0;\n    int water = 0;\n\n    for (int i = 0; i < events->len; i += 2) {\n        int T = g_array_index(events, int, i);\n        int V = g_array_index(events, int, i + 1);\n\n        while (time < T) {\n            water = water - 1;\n            time = time + 1;\n        }\n\n        water = water + V;\n        time = T;\n    }\n\n    printf(\"%d\\n\", water);\n\n    g_array_free(events, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_mn2drvlv/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_mn2drvlv/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc383_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAXN 200005\n#define MAXM 200005\n#define INF 1e9\n\ntypedef struct {\n    int to, weight;\n} Edge;\n\ntypedef struct {\n    int vertex, dist;\n} Node;\n\nint n, m, k;\nEdge edges[MAXM];\nint A[MAXN], B[MAXN];\nGArray *adj[MAXN];\n\nvoid dijkstra(int start, int *dist) {\n    memset(dist, 0x3f, sizeof(int) * n);\n    dist[start] = 0;\n    GPriorityQueue *pq = g_priority_queue_new((GCompareFunc)g_int_compare);\n    g_priority_queue_push(pq, GINT_TO_POINTER(start), GINT_TO_POINTER(0));\n\n    while (!g_priority_queue_is_empty(pq)) {\n        int u = GPOINTER_TO_INT(g_priority_queue_pop_head(pq));\n        for (int i = 0; i < g_array_get_length(adj[u]); i++) {\n            Edge e = g_array_index(adj[u], Edge, i);\n            int v = e.to;\n            int weight = e.weight;\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                g_priority_queue_push(pq, GINT_TO_POINTER(v), GINT_TO_POINTER(dist[v]));\n            }\n        }\n    }\n\n    g_priority_queue_free(pq);\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        u--;\n        v--;\n        edges[i] = (Edge){v, w};\n        adj[u] = g_array_append_val(adj[u], edges[i]);\n        adj[v] = g_array_append_val(adj[v], edges[i]);\n    }\n\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d\", &A[i]);\n        A[i]--;\n    }\n\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d\", &B[i]);\n        B[i]--;\n    }\n\n    int *dist = (int *)malloc(n * sizeof(int));\n\n    int result = 0;\n\n    for (int i = 0; i < k; i++) {\n        dijkstra(A[i], dist);\n        int min_dist = INF;\n        for (int j = 0; j < k; j++) {\n            if (A[i] != B[j]) {\n                min_dist = g_min(min_dist, dist[B[j]]);\n            }\n        }\n        result += min_dist;\n    }\n\n    printf(\"%d\\n\", result);\n\n    free(dist);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_mrlsneyy/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_mrlsneyy/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc383_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 10\n\nint manhattan_distance(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint max_humidified_cells(char grid[MAX][MAX], int H, int W, int D) {\n    int max_humidified = 0;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.') {\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        if (grid[k][l] == '.') {\n                            int humidified = 0;\n\n                            for (int m = 0; m < H; m++) {\n                                for (int n = 0; n < W; n++) {\n                                    if (grid[m][n] == '.' && manhattan_distance(i, j, m, n) <= D && manhattan_distance(k, l, m, n) <= D) {\n                                        humidified++;\n                                    }\n                                }\n                            }\n\n                            if (humidified > max_humidified) {\n                                max_humidified = humidified;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return max_humidified;\n}\n\nint main() {\n    int H, W, D;\n    scanf(\"%d %d %d\", &H, &W, &D);\n\n    char grid[MAX][MAX];\n\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int result = max_humidified_cells(grid, H, W, D);\n\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_bfeslx87/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_bfeslx87/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc383_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    long long N;\n    scanf(\"%lld\", &N);\n\n    // Initialize a hash table to store prime numbers up to sqrt(N)\n    GHashTable *primes = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Function to check if a number is prime\n    bool is_prime(long long num) {\n        if (num <= 1) return false;\n        if (num <= 3) return true;\n        if (num % 2 == 0 || num % 3 == 0) return false;\n        for (long long i = 5; i * i <= num; i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n\n    // Populate the hash table with prime numbers up to sqrt(N)\n    for (long long i = 2; i * i <= N; i++) {\n        if (is_prime(i)) {\n            g_hash_table_insert(primes, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n        }\n    }\n\n    // Function to count numbers with exactly 9 divisors\n    long long count = 0;\n    GList *list = g_hash_table_get_keys(primes);\n\n    for (GList *node = list; node != NULL; node = node->next) {\n        long long p = GPOINTER_TO_INT(node->data);\n        if (p * p * p * p * p * p * p * p * p <= N) {\n            count++;\n        }\n        if (p * p * p * p * p * p * p * p * p * p * p <= N) {\n            count++;\n        }\n    }\n\n    g_list_free(list);\n\n    // Output the result\n    printf(\"%lld\\n\", count);\n\n    // Clean up\n    g_hash_table_destroy(primes);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_qj3u_o6f/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_qj3u_o6f/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc384_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, R;\n    scanf(\"%d %d\", &N, &R);\n\n    for (int i = 0; i < N; i++) {\n        int D, A;\n        scanf(\"%d %d\", &D, &A);\n\n        if ((D == 1 && R >= 1600 && R <= 2799) || (D == 2 && R >= 1200 && R <= 2399)) {\n            R += A;\n        }\n    }\n\n    printf(\"%d\\n\", R);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc384_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int n, s;\n    scanf(\"%d %d\", &n, &s);\n\n    // Read the sequence\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // Initialize variables\n    GHashTable *prefix_sum_map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    long long sum = 0;\n    g_hash_table_insert(prefix_sum_map, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n\n    // Iterate through the sequence\n    for (int i = 0; i < n; i++) {\n        sum += a[i];\n        long long target = (sum - s + n) % n;\n\n        // Check if the target exists in the hash map\n        if (g_hash_table_contains(prefix_sum_map, GINT_TO_POINTER(target))) {\n            printf(\"Yes\\n\");\n            free(a);\n            g_hash_table_destroy(prefix_sum_map);\n            return 0;\n        }\n\n        // Insert the current sum into the hash map\n        g_hash_table_insert(prefix_sum_map, GINT_TO_POINTER(sum % n), GINT_TO_POINTER(1));\n    }\n\n    // If no valid subsequence is found\n    printf(\"No\\n\");\n\n    // Clean up\n    free(a);\n    g_hash_table_destroy(prefix_sum_map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_r7a3vc7z/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_r7a3vc7z/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc384_g", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    int k;\n    scanf(\"%d\", &k);\n\n    int *x = (int *)malloc(k * sizeof(int));\n    int *y = (int *)malloc(k * sizeof(int));\n\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d %d\", &x[i], &y[i]);\n    }\n\n    int *prefix_sum = (int *)malloc((n + 1) * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        prefix_sum[i + 1] = prefix_sum[i] + abs(a[i] - b[i]);\n    }\n\n    for (int i = 0; i < k; i++) {\n        int result = prefix_sum[x[i]] - prefix_sum[y[i] - 1];\n        printf(\"%d\n\", result);\n    }\n\n    free(a);\n    free(b);\n    free(x);\n    free(y);\n    free(prefix_sum);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_9f4vfb1w/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_9f4vfb1w/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc384_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char c1, c2;\n    scanf(\" %c %c\", &c1, &c2);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] != c1) {\n            s[i] = c2;\n        }\n    }\n\n    printf(\"%s\\n\", s);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_bs9aut3q/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_bs9aut3q/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc384_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX 500\n#define INF 1e12\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    int value;\n    Point point;\n} Node;\n\nint compare(const void *a, const void *b) {\n    return ((Node*)a)->value - ((Node*)b)->value;\n}\n\nint main() {\n    int H, W, X, P, Q;\n    scanf(\"%d %d %d\", &H, &W, &X);\n    scanf(\"%d %d\", &P, &Q);\n\n    int grid[H][W];\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    Point directions[] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER(P * W + Q));\n\n    int max_strength = grid[P - 1][Q - 1];\n    while (!g_queue_is_empty(queue)) {\n        int current = GPOINTER_TO_INT(g_queue_pop_head(queue));\n        int x = current / W + 1;\n        int y = current % W + 1;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + directions[i].x;\n            int ny = y + directions[i].y;\n\n            if (nx >= 1 && nx <= H && ny >= 1 && ny <= W) {\n                int neighbor_strength = grid[nx - 1][ny - 1];\n                if (neighbor_strength < (grid[x - 1][y - 1] / X)) {\n                    max_strength += neighbor_strength;\n                    grid[nx - 1][ny - 1] = 0;\n                    g_queue_push_tail(queue, GINT_TO_POINTER(nx * W + ny));\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_strength);\n\n    g_queue_free(queue);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_orf_z304/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_orf_z304/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc384_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint f(int x) {\n    while (x % 2 == 0) {\n        x /= 2;\n    }\n    return x;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n    int *arr = (int *)malloc(n * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n        int fx = f(arr[i]);\n        g_hash_table_insert(map, GINT_TO_POINTER(fx), GINT_TO_POINTER(GPOINTER_TO_INT(g_hash_table_lookup(map, GINT_TO_POINTER(fx))) + 1));\n    }\n\n    long long sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int fx = f(arr[i] + arr[j]);\n            sum += GPOINTER_TO_INT(g_hash_table_lookup(map, GINT_TO_POINTER(fx)));\n        }\n    }\n\n    printf(\"%lld\\n\", sum);\n\n    g_hash_table_destroy(map);\n    free(arr);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_hiswkhll/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_hiswkhll/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc384_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define NUM_PROBLEMS 5\n#define MAX_NAME_LENGTH 6\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int score;\n} Participant;\n\nint compare(const void *a, const void *b) {\n    Participant *pa = (Participant *)a;\n    Participant *pb = (Participant *)b;\n    if (pa->score != pb->score) {\n        return pb->score - pa->score;\n    } else {\n        return strcmp(pa->name, pb->name);\n    }\n}\n\nvoid generateParticipants(int scores[], Participant participants[], int index, char currentName[], int currentScore) {\n    if (index == NUM_PROBLEMS) {\n        strcpy(participants[index - 1].name, currentName);\n        participants[index - 1].score = currentScore;\n        return;\n    }\n    generateParticipants(scores, participants, index + 1, currentName, currentScore);\n    currentName[index] = 'A' + index;\n    currentName[index + 1] = '\\0';\n    generateParticipants(scores, participants, index + 1, currentName, currentScore + scores[index]);\n}\n\nint main() {\n    int scores[NUM_PROBLEMS];\n    for (int i = 0; i < NUM_PROBLEMS; i++) {\n        scanf(\"%d\", &scores[i]);\n    }\n\n    Participant participants[31];\n    char currentName[NUM_PROBLEMS + 1];\n    currentName[0] = '\\0';\n    generateParticipants(scores, participants, 0, currentName, 0);\n\n    qsort(participants, 31, sizeof(Participant), compare);\n\n    for (int i = 0; i < 31; i++) {\n        printf(\"%s\\n\", participants[i].name);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8mwuwh6o/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_8mwuwh6o/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc385_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    int x;\n    int h;\n} Building;\n\nint compare(const void *a, const void *b) {\n    return ((Building *)a)->x - ((Building *)b)->x;\n}\n\nbool is_visible(Building *buildings, int n, double height) {\n    for (int i = 0; i < n; i++) {\n        double x = buildings[i].x;\n        double h = buildings[i].h;\n        if (h <= height) continue;\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            double x2 = buildings[j].x;\n            double h2 = buildings[j].h;\n            if (h2 <= height) continue;\n            double slope = (h - h2) / (x - x2);\n            if (slope * (x - x2) + h2 > height) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Building *buildings = (Building *)malloc(n * sizeof(Building));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &buildings[i].x, &buildings[i].h);\n    }\n\n    qsort(buildings, n, sizeof(Building), compare);\n\n    double low = 0, high = 1e9;\n    while (high - low > EPS) {\n        double mid = (low + high) / 2;\n        if (is_visible(buildings, n, mid)) {\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n\n    if (low == 0) {\n        printf(\"-1\n\");\n    } else {\n        printf(\"%.15f\n\", low);\n    }\n\n    free(buildings);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_9k2sdst1/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_9k2sdst1/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc385_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int A, B, C;\n    scanf(\"%d %d %d\", &A, &B, &C);\n\n    int totalSum = A + B + C;\n\n    // Check if the total sum is even\n    if (totalSum % 2 != 0) {\n        printf(\"No\\n\");\n        return 0;\n    }\n\n    int halfSum = totalSum / 2;\n\n    // Check if any of the numbers is half of the total sum\n    if (A == halfSum || B == halfSum || C == halfSum) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_mefyl9p4/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_mefyl9p4/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc385_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *heights = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n\n    int max_count = 1;\n\n    for (int i = 0; i < n; i++) {\n        int count = 1;\n        for (int j = i + 1; j < n; j++) {\n            if (heights[i] == heights[j]) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        max_count = (count > max_count) ? count : max_count;\n    }\n\n    printf(\"%d\n\", max_count);\n\n    free(heights);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ktrssyia/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ktrssyia/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc385_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, m, sx, sy;\n    scanf(\"%d %d %d %d\", &n, &m, &sx, &sy);\n\n    GHashTable *houses = g_hash_table_new(g_direct_hash, g_direct_equal);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        g_hash_table_insert(houses, GINT_TO_POINTER(x), GINT_TO_POINTER(y));\n    }\n\n    int cx = sx, cy = sy;\n    GHashSet *visited = g_hash_set_new(g_direct_hash, g_direct_equal);\n    g_hash_set_add(visited, GINT_TO_POINTER(cx));\n    g_hash_set_add(visited, GINT_TO_POINTER(cy));\n\n    for (int i = 0; i < m; i++) {\n        char direction;\n        int distance;\n        scanf(\" %c %d\", &direction, &distance);\n\n        for (int j = 0; j < distance; j++) {\n            if (direction == 'U') {\n                cy += 1;\n            } else if (direction == 'D') {\n                cy -= 1;\n            } else if (direction == 'L') {\n                cx -= 1;\n            } else if (direction == 'R') {\n                cx += 1;\n            }\n\n            if (g_hash_table_contains(houses, GINT_TO_POINTER(cx)) && g_hash_table_contains(houses, GINT_TO_POINTER(cy))) {\n                if (!g_hash_set_contains(visited, GINT_TO_POINTER(cx))) {\n                    g_hash_set_add(visited, GINT_TO_POINTER(cx));\n                }\n                if (!g_hash_set_contains(visited, GINT_TO_POINTER(cy))) {\n                    g_hash_set_add(visited, GINT_TO_POINTER(cy));\n                }\n            }\n        }\n    }\n\n    int distinct_houses = g_hash_set_size(visited);\n    printf(\"%d %d %d\\n\", cx, cy, distinct_houses);\n\n    g_hash_table_destroy(houses);\n    g_hash_set_destroy(visited);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_sox814l3/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_sox814l3/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc385_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int N;\n    scanf(\"%d\", &N);\n\n    // Create adjacency list for the tree\n    GArray *adj[N + 1];\n    for (int i = 1; i <= N; i++) {\n        adj[i] = g_array_new(FALSE, FALSE, sizeof(int));\n    }\n\n    // Read edges and build the adjacency list\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        g_array_append_val(adj[u], v);\n        g_array_append_val(adj[v], u);\n    }\n\n    // Function to perform DFS and count vertices\n    int dfs(int node, int parent, int *x, int *y) {\n        int count = 1;\n        int child_count = 0;\n        int leaves = 0;\n\n        for (guint i = 0; i < adj[node]->len; i++) {\n            int neighbor = g_array_index(adj[node], int, i);\n            if (neighbor != parent) {\n                int child_leaves = dfs(neighbor, node, x, y);\n                child_count++;\n                leaves += child_leaves;\n            }\n        }\n\n        if (child_count > *x) {\n            *x = child_count;\n        }\n\n        if (leaves > *y) {\n            *y = leaves;\n        }\n\n        return count;\n    }\n\n    // Initialize variables to store x and y\n    int x = 0, y = 0;\n\n    // Perform DFS to find x and y\n    dfs(1, 0, &x, &y);\n\n    // Calculate the minimum number of vertices to delete\n    int min_deletes = N - (x + 1 + y);\n\n    // Output the result\n    printf(\"%d\n\", min_deletes);\n\n    // Clean up\n    for (int i = 1; i <= N; i++) {\n        g_array_free(adj[i], TRUE);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_zb6ggrep/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_zb6ggrep/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc385_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <glib.h>\n\n#define MAX_H 100\n#define MAX_W 100\n\nint main() {\n    int H, W, X, Y;\n    scanf(\"%d %d %d %d\", &H, &W, &X, &Y);\n\n    char grid[MAX_H][MAX_W];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    char T[10001];\n    scanf(\"%s\", T);\n\n    GHashTable *visited_houses = g_hash_table_new(g_str_hash, g_str_equal);\n\n    for (int i = 0; T[i] != '\\0'; i++) {\n        int new_X = X, new_Y = Y;\n        if (T[i] == 'U') new_X--;\n        else if (T[i] == 'D') new_X++;\n        else if (T[i] == 'L') new_Y--;\n        else if (T[i] == 'R') new_Y++;\n\n        if (new_X >= 0 && new_X < H && new_Y >= 0 && new_Y < W && grid[new_X][new_Y] != '#') {\n            X = new_X;\n            Y = new_Y;\n            if (grid[X][Y] == '@') {\n                char house[2] = {grid[X][Y], '\\0'};\n                if (!g_hash_table_contains(visited_houses, house)) {\n                    g_hash_table_insert(visited_houses, house, GINT_TO_POINTER(1));\n                }\n            }\n        }\n    }\n\n    printf(\"%d %d %zu\\n\", X, Y, g_hash_table_size(visited_houses));\n\n    g_hash_table_destroy(visited_houses);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_ymnhsz4u/program.c:5:10: fatal error: glib.h: No such file or directory\\n    5 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_ymnhsz4u/program.c:5:10: fatal error: glib.h: No such file or directory\n    5 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc386_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n\n    // Read the array A\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(guint64));\n    for (int i = 0; i < n; i++) {\n        guint64 value;\n        scanf(\"%llu\", &value);\n        g_array_append_val(arr, value);\n    }\n\n    // Sort the array to facilitate finding the maximum XOR\n    qsort(arr->data, arr->len, sizeof(guint64), (int (*)(const void *, const void *))guint64_compare);\n\n    // Initialize a hash table to keep track of the maximum XOR values\n    GHashTable *max_xor = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Iterate through the sorted array and calculate the maximum XOR for each possible subset of size K\n    for (int i = 0; i <= n - k; i++) {\n        guint64 current_xor = 0;\n        for (int j = i; j < i + k; j++) {\n            current_xor ^= g_array_index(arr, guint64, j);\n        }\n        g_hash_table_insert(max_xor, GINT_TO_POINTER(i), GINT_TO_POINTER(current_xor));\n    }\n\n    // Find the maximum value in the hash table\n    guint64 max_value = 0;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, max_xor);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        if (GPOINTER_TO_INT(value) > max_value) {\n            max_value = GPOINTER_TO_INT(value);\n        }\n    }\n\n    // Output the result\n    printf(\"%llu\\n\", max_value);\n\n    // Clean up\n    g_array_free(arr, TRUE);\n    g_hash_table_destroy(max_xor);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_q7ksqgwq/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_q7ksqgwq/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc386_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    int A, B, C, D;\n    scanf(\"%d %d %d %d\", &A, &B, &C, &D);\n\n    // Create a hash table to count occurrences of each card\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Function to update the count of a card\n    auto update_count = [](GHashTable *hash, int card) {\n        gpointer value = g_hash_table_lookup(hash, GINT_TO_POINTER(card));\n        int count = (value != NULL) ? GPOINTER_TO_INT(value) : 0;\n        g_hash_table_insert(hash, GINT_TO_POINTER(card), GINT_TO_POINTER(count + 1));\n    };\n\n    // Update counts for all four cards\n    update_count(count, A);\n    update_count(count, B);\n    update_count(count, C);\n    update_count(count, D);\n\n    // Get the counts of each card\n    int a_count = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(A)));\n    int b_count = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(B)));\n    int c_count = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(C)));\n    int d_count = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(D)));\n\n    // Check if adding one card can form a Full House\n    if ((a_count == 2 && (b_count == 3 || c_count == 3 || d_count == 3)) ||\n        (a_count == 3 && (b_count == 2 || c_count == 2 || d_count == 2))) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8n7a8qtl/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_8n7a8qtl/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc386_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    GHashTable *rows = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *cols = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < M; i++) {\n        int X, Y;\n        char C;\n        scanf(\"%d %d %c\", &X, &Y, &C);\n\n        if (C == 'B') {\n            g_hash_table_insert(rows, GINT_TO_POINTER(X), GINT_TO_POINTER(1));\n            g_hash_table_insert(cols, GINT_TO_POINTER(Y), GINT_TO_POINTER(1));\n        }\n    }\n\n    bool isPossible = true;\n\n    for (int i = 1; i <= N; i++) {\n        if (g_hash_table_lookup(rows, GINT_TO_POINTER(i)) == NULL) {\n            if (i % 2 == 1) {\n                g_hash_table_insert(rows, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n            } else {\n                isPossible = false;\n                break;\n            }\n        }\n\n        if (g_hash_table_lookup(cols, GINT_TO_POINTER(i)) == NULL) {\n            if (i % 2 == 1) {\n                g_hash_table_insert(cols, GINT_TO_POINTER(i), GINT_TO_POINTER(1));\n            } else {\n                isPossible = false;\n                break;\n            }\n        }\n    }\n\n    if (isPossible) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    g_hash_table_destroy(rows);\n    g_hash_table_destroy(cols);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_h115nd94/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_h115nd94/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc386_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int K;\n    scanf(\"%d\", &K);\n\n    char S[500001], T[500001];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int lenS = strlen(S);\n    int lenT = strlen(T);\n\n    int diff = 0;\n\n    if (lenS == lenT) {\n        // If lengths are equal, check for character replacements\n        for (int i = 0; i < lenS; i++) {\n            if (S[i] != T[i]) {\n                diff++;\n            }\n        }\n    } else if (lenS == lenT + 1) {\n        // If S is one character longer, check for deletions\n        int i = 0, j = 0;\n        while (i < lenS && j < lenT) {\n            if (S[i] == T[j]) {\n                i++;\n                j++;\n            } else {\n                i++;\n                diff++;\n            }\n        }\n    } else if (lenS == lenT - 1) {\n        // If S is one character shorter, check for insertions\n        int i = 0, j = 0;\n        while (i < lenS && j < lenT) {\n            if (S[i] == T[j]) {\n                i++;\n                j++;\n            } else {\n                j++;\n                diff++;\n            }\n        }\n    } else {\n        // If lengths differ by more than 1, conversion is not possible\n        diff = 2;\n    }\n\n    if (diff <= 1) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_7xej82jo/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_7xej82jo/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc386_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S[1001];\n    scanf(\"%s\", S);\n\n    // Initialize result\n    int result = 0;\n\n    // Iterate through each character in the string\n    int n = strlen(S);\n    for (int i = 0; i < n; i++) {\n        // Increment result by 1 for each character press\n        result++;\n\n        // If the current character is '0', we need to press '00' instead of '0'\n        if (S[i] == '0') {\n            result++;\n        }\n    }\n\n    // Output result\n    printf(\"%d\\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_a19auqtr/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_a19auqtr/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc386_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint min(int a, int b, int c) {\n    return min(min(a, b), c);\n}\n\nint levenshtein_distance(char *s, char *t) {\n    int m = strlen(s);\n    int n = strlen(t);\n    int *d = (int *)g_malloc((m + 1) * (n + 1) * sizeof(int));\n\n    for (int i = 0; i <= m; i++) {\n        d[i * (n + 1)] = i;\n    }\n\n    for (int j = 0; j <= n; j++) {\n        d[j] = j;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                d[i * (n + 1) + j] = d[(i - 1) * (n + 1) + j - 1];\n            } else {\n                d[i * (n + 1) + j] = min(\n                    d[(i - 1) * (n + 1) + j],\n                    d[i * (n + 1) + j - 1],\n                    d[(i - 1) * (n + 1) + j - 1]\n                ) + 1;\n            }\n        }\n    }\n\n    int result = d[m * (n + 1) + n];\n    g_free(d);\n    return result;\n}\n\nint main() {\n    int k;\n    scanf(\"%d\", &k);\n\n    char s[500001], t[500001];\n    scanf(\"%s\", s);\n    scanf(\"%s\", t);\n\n    int distance = levenshtein_distance(s, t);\n\n    if (distance <= k) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_f4qqndtp/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_f4qqndtp/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc184_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nGHashTable *dp;\n\nint dfs(Point *points, int n, int index, int prev) {\n    if (index == n) return 1;\n    if (g_hash_table_contains(dp, GINT_TO_POINTER(index * 300 + prev))) return GPOINTER_TO_INT(g_hash_table_lookup(dp, GINT_TO_POINTER(index * 300 + prev)));\n\n    int res = 0;\n    if (prev == -1 || (points[index].x > points[prev].x && points[index].y > points[prev].y) || (points[index].x < points[prev].x && points[index].y < points[prev].y)) {\n        res = (res + dfs(points, n, index + 1, index)) % MOD;\n    }\n    res = (res + dfs(points, n, index + 1, prev)) % MOD;\n\n    g_hash_table_insert(dp, GINT_TO_POINTER(index * 300 + prev), GINT_TO_POINTER(res));\n    return res;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Point *points = (Point *)malloc(n * sizeof(Point));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int result = dfs(points, n, 0, -1);\n\n    printf(\"%d\n\", result);\n\n    free(points);\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_cej1mshj/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_cej1mshj/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc184_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GHashTable *hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 1; i <= n; i++) {\n        int gap = i;\n        g_hash_table_insert(hash, GINT_TO_POINTER(gap), GINT_TO_POINTER(1));\n    }\n\n    int max_folds = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int gap = i;\n        int count = GPOINTER_TO_INT(g_hash_table_lookup(hash, GINT_TO_POINTER(gap)));\n        if (count > max_folds) {\n            max_folds = count;\n        }\n    }\n\n    printf(\"%d\n\", max_folds);\n\n    g_hash_table_destroy(hash);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_veicrwes/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_veicrwes/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc184_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GHashTable *states = g_hash_table_new(g_str_hash, g_str_equal);\n    GArray *sequences = g_array_new(FALSE, FALSE, sizeof(char*));\n\n    for (int i = 0; i < n; i++) {\n        char *seq = malloc((m + 1) * sizeof(char));\n        scanf(\"%s\", seq);\n        g_array_append_val(sequences, seq);\n    }\n\n    long long result = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            char *seq1 = g_array_index(sequences, char*, i);\n            char *seq2 = g_array_index(sequences, char*, j);\n\n            int x = 0;\n            bool changed = true;\n\n            while (changed) {\n                changed = false;\n\n                for (int k = 0; k < m; k++) {\n                    int sum = 0;\n                    for (int l = 0; l <= k; l++) {\n                        sum += seq1[l] - '0';\n                    }\n                    sum %= 2;\n\n                    if (sum != seq2[k] - '0') {\n                        seq1[k] = '0' + sum;\n                        changed = true;\n                    }\n                }\n\n                x++;\n            }\n\n            result = (result + x) % MOD;\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n\n    for (int i = 0; i < n; i++) {\n        free(g_array_index(sequences, char*, i));\n    }\n\n    g_array_free(sequences, TRUE);\n    g_hash_table_destroy(states);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_3enwe582/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_3enwe582/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc185_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int N, X;\n    scanf(\"%d %d\", &N, &X);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    qsort(A, N, sizeof(int), compare);\n\n    for (int i = 0; i < N - 2; i++) {\n        int j = i + 1, k = N - 1;\n        while (j < k) {\n            int sum = A[i] + A[j] + A[k];\n            if (sum == X) {\n                printf(\"%d %d %d\n\", i + 1, j + 1, k + 1);\n                free(A);\n                return 0;\n            } else if (sum < X) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n\n    printf(\"-1\n\");\n    free(A);\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_uethdy0t/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_uethdy0t/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc185_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    GHashTable *hash;\n} State;\n\nvoid init_state(State *state) {\n    state->hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n}\n\nvoid free_state(State *state) {\n    g_hash_table_destroy(state->hash);\n}\n\nvoid update_state(State *state, int key, int value) {\n    gpointer existing_value = g_hash_table_lookup(state->hash, GINT_TO_POINTER(key));\n    if (existing_value) {\n        int sum = GPOINTER_TO_INT(existing_value) + value;\n        g_hash_table_insert(state->hash, GINT_TO_POINTER(key), GINT_TO_POINTER(sum % MOD));\n    } else {\n        g_hash_table_insert(state->hash, GINT_TO_POINTER(key), GINT_TO_POINTER(value % MOD));\n    }\n}\n\nint get_state(State *state, int key) {\n    gpointer value = g_hash_table_lookup(state->hash, GINT_TO_POINTER(key));\n    return value ? GPOINTER_TO_INT(value) : 0;\n}\n\nvoid solve(int *A, int N) {\n    for (int m = 1; m <= N; m++) {\n        State state;\n        init_state(&state);\n\n        for (int i = 0; i < (1 << m); i++) {\n            if (i == 0) {\n                update_state(&state, 0, 0);\n                continue;\n            }\n\n            int sum = 0;\n            for (int j = 0; j < m; j++) {\n                if (i & (1 << j)) {\n                    sum += A[j];\n                }\n            }\n\n            update_state(&state, sum, get_state(&state, sum) + 1);\n        }\n\n        int result = 0;\n        for (int i = 0; i < (1 << m); i++) {\n            int sum = 0;\n            for (int j = 0; j < m; j++) {\n                if (i & (1 << j)) {\n                    sum += A[j];\n                }\n            }\n\n            int count = get_state(&state, sum);\n            for (int j = 0; j < m; j++) {\n                if (i & (1 << j)) {\n                    int gcd = 0;\n                    for (int k = 0; k < m; k++) {\n                        if (i & (1 << k) && k != j) {\n                            gcd = gcd ? gcd : A[j];\n                            gcd = gcd > A[k] ? gcd : A[k];\n                            while (gcd) {\n                                int temp = gcd;\n                                gcd = A[k] % gcd;\n                                A[k] = temp;\n                            }\n                        }\n                    }\n                    result = (result + count * gcd) % MOD;\n                }\n            }\n        }\n\n        printf(\"%d\\n\", result);\n\n        free_state(&state);\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    solve(A, N);\n\n    free(A);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_qxz5eua5/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_qxz5eua5/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc185_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    for (int t = 0; t < T; t++) {\n        int N;\n        scanf(\"%d\", &N);\n\n        GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n        for (int i = 0; i < N; i++) {\n            int value;\n            scanf(\"%d\", &value);\n            g_array_append_val(arr, value);\n        }\n\n        int balance = 0;\n        int possible = 1;\n\n        for (int i = 1; i < N; i++) {\n            balance += arr->data[i] - arr->data[i - 1];\n            if (balance < 0) {\n                possible = 0;\n                break;\n            }\n        }\n\n        if (possible) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n\n        g_array_free(arr, TRUE);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_w7r0vwk8/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_w7r0vwk8/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc185_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Initialize DP table\n    GHashTable *dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Base case: if only one vertex, no operations needed\n    g_hash_table_insert(dp, GINT_TO_POINTER(1), GINT_TO_POINTER(0));\n\n    // Iterate over each vertex count from 2 to N*M + 1\n    for (int i = 2; i <= N * M + 1; i++) {\n        int sum = 0;\n\n        // Iterate over each possible previous vertex count\n        for (int j = 1; j < i; j++) {\n            int key = i - j;\n            gpointer value = g_hash_table_lookup(dp, GINT_TO_POINTER(key));\n            if (value != NULL) {\n                sum = (sum + GPOINTER_TO_INT(value)) % MOD;\n            }\n        }\n\n        // Calculate the expected number of operations for the current vertex count\n        int expected = (sum * (i - 1)) % MOD;\n        g_hash_table_insert(dp, GINT_TO_POINTER(i), GINT_TO_POINTER(expected));\n    }\n\n    // Get the expected number of operations for N*M + 1 vertices\n    gpointer result = g_hash_table_lookup(dp, GINT_TO_POINTER(N * M + 1));\n    printf(\"%d\n\", GPOINTER_TO_INT(result));\n\n    // Clean up\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_37z0fd9o/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_37z0fd9o/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc186_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <glib.h>\n\nbool is_valid_fixed_count(int N, int K) {\n    // Check if K is a valid fixed count for an N x N matrix\n    // A matrix can have at most N^2 fixed elements\n    // A matrix can have at least 0 fixed elements\n    return K >= 0 && K <= N * N;\n}\n\nbool can_have_fixed_count(int N, int K) {\n    // Check if it's possible to have exactly K fixed elements in an N x N matrix\n    // If K is 0, it's always possible\n    if (K == 0) {\n        return true;\n    }\n    // If K is N^2, it's always possible\n    if (K == N * N) {\n        return true;\n    }\n    // For other values of K, check if it's possible\n    // A matrix can have exactly K fixed elements if and only if K is even\n    return K % 2 == 0;\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    for (int i = 0; i < Q; i++) {\n        int K;\n        scanf(\"%d\", &K);\n\n        if (is_valid_fixed_count(N, K) && can_have_fixed_count(N, K)) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_xr2yoyk3/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_xr2yoyk3/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc186_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nGHashTable *dp;\n\nint countPolishSequences(int *A, int N, int pos) {\n    if (pos == N) return 1;\n    if (g_hash_table_contains(dp, GINT_TO_POINTER(pos))) return GPOINTER_TO_INT(g_hash_table_lookup(dp, GINT_TO_POINTER(pos)));\n\n    int count = 0;\n    for (int i = 0; i <= A[pos]; i++) {\n        count = (count + countPolishSequences(A, N, pos + i + 1)) % MOD;\n    }\n\n    g_hash_table_insert(dp, GINT_TO_POINTER(pos), GINT_TO_POINTER(count));\n    return count;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int result = countPolishSequences(A, N, 0);\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(dp);\n    free(A);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_o9yc0yci/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_o9yc0yci/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc186_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nGHashTable *memo;\n\nint dp(int i, int prev, int *A, int *used) {\n    if (i == 0) return 1;\n    gpointer key = GINT_TO_POINTER(i * 1000000 + prev * 1000 + used[0] * 100 + used[1] * 10 + used[2]);\n    if (g_hash_table_contains(memo, key)) return GPOINTER_TO_INT(g_hash_table_lookup(memo, key));\n\n    int res = 0;\n    for (int j = 1; j <= i; j++) {\n        if (A[i-1] < j && !used[j]) {\n            used[j] = 1;\n            res = (res + dp(i-1, j, A, used)) % MOD;\n            used[j] = 0;\n        }\n    }\n\n    g_hash_table_insert(memo, key, GINT_TO_POINTER(res));\n    return res;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int A[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    int used[3] = {0, 0, 0};\n    memo = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int result = dp(N, 0, A, used);\n\n    printf(\"%d\n\", result);\n\n    g_hash_table_destroy(memo);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c__un_r96j/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c__un_r96j/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc186_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    int X[M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    // Initialize DP table\n    int dp[N + 1][M + 1];\n    memset(dp, 0, sizeof(dp));\n\n    // Base case: There is one way to form an empty sequence\n    dp[0][0] = 1;\n\n    // Fill DP table\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= M; j++) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % MOD;\n            if (X[j - 1] == 1) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD;\n            }\n        }\n    }\n\n    // Calculate the number of valid sequences\n    int result = 0;\n    for (int i = 1; i <= N; i++) {\n        result = (result + dp[i][M]) % MOD;\n    }\n\n    // Subtract the invalid sequences (those that can be formed as a subsequence of X)\n    int invalid = 0;\n    for (int i = 1; i <= M; i++) {\n        invalid = (invalid + dp[N][i]) % MOD;\n    }\n\n    result = (result - invalid + MOD) % MOD;\n\n    // Print the result\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_h_m2k36p/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_h_m2k36p/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc186_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int N, M;\n        scanf(\"%d %d\", &N, &M);\n\n        GArray *boxes = g_array_new(FALSE, FALSE, sizeof(int));\n        for (int i = 0; i < N; i++) {\n            int V, P;\n            scanf(\"%d %d\", &V, &P);\n            g_array_append_val(boxes, P);\n        }\n\n        g_array_sort(boxes, (GCompareFunc)g_int_compare);\n\n        int total_cost = 0;\n        for (int i = 0; i < M; i++) {\n            total_cost += g_array_index(boxes, int, i);\n        }\n\n        printf(\"%d\\n\", total_cost);\n\n        g_array_free(boxes, TRUE);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_7qrp67_e/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_7qrp67_e/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc187_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    int B[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n\n    GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Generate all possible sequences B'\n    int q = 0;\n    for (int i = 0; i < N; i++) {\n        if (B[i] == -1) {\n            q++;\n        }\n    }\n\n    int *order = (int *)malloc(q * sizeof(int));\n    int *values = (int *)malloc(q * sizeof(int));\n\n    int index = 0;\n    for (int i = 0; i < N; i++) {\n        if (B[i] == -1) {\n            order[index] = i;\n            values[index] = 1;\n            index++;\n        }\n    }\n\n    for (int i = 1; i <= M; i++) {\n        for (int j = 0; j < q; j++) {\n            values[j] = i;\n        }\n\n        int connected_components = 0;\n        GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n        for (int j = 0; j < N; j++) {\n            if (B[j] != -1) {\n                int val = B[j];\n                if (!g_hash_table_contains(visited, GINT_TO_POINTER(val))) {\n                    connected_components++;\n                    GQueue *queue = g_queue_new();\n                    g_queue_push_tail(queue, GINT_TO_POINTER(val));\n                    while (!g_queue_is_empty(queue)) {\n                        int node = GPOINTER_TO_INT(g_queue_pop_head(queue));\n                        if (!g_hash_table_contains(visited, GINT_TO_POINTER(node))) {\n                            g_hash_table_insert(visited, GINT_TO_POINTER(node), GINT_TO_POINTER(1));\n                            for (int k = 0; k < N; k++) {\n                                if (B[k] != -1 && B[k] > node) {\n                                    g_queue_push_tail(queue, GINT_TO_POINTER(B[k]));\n                                }\n                            }\n                        }\n                    }\n                    g_queue_free(queue);\n                }\n            }\n        }\n\n        g_hash_table_insert(count, GINT_TO_POINTER(connected_components), GINT_TO_POINTER(GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(connected_components))) + 1));\n\n        g_hash_table_destroy(visited);\n    }\n\n    long long sum = 0;\n    GList *keys = g_hash_table_get_keys(count);\n    GList *node;\n    for (node = keys; node != NULL; node = node->next) {\n        int key = GPOINTER_TO_INT(node->data);\n        int value = GPOINTER_TO_INT(g_hash_table_lookup(count, GINT_TO_POINTER(key)));\n        sum = (sum + (long long)key * value) % MOD;\n    }\n\n    printf(\"%lld\n\", sum);\n\n    g_hash_table_destroy(count);\n    free(order);\n    free(values);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8foiopca/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_8foiopca/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc188_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 200000\n#define MAX_M 200000\n\ntypedef struct {\n    int a;\n    int b;\n    int c;\n} Testimony;\n\nGHashTable *hash;\nGArray *testimonies;\n\nbool is_valid(int n, int *confused) {\n    for (int i = 0; i < n; i++) {\n        int a = g_array_index(testimonies, Testimony, i).a - 1;\n        int b = g_array_index(testimonies, Testimony, i).b - 1;\n        int c = g_array_index(testimonies, Testimony, i).c;\n        int status_a = (confused[a] == 1) ? (rand() % 2) : (c == 0 ? 1 : 0);\n        int status_b = (confused[b] == 1) ? (rand() % 2) : (c == 0 ? 1 : 0);\n        if (status_a == status_b) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid backtrack(int n, int *confused, int pos) {\n    if (pos == n) {\n        if (is_valid(n, confused)) {\n            for (int i = 0; i < n; i++) {\n                printf(\"%d\", confused[i]);\n            }\n            printf(\"\\n\");\n            exit(0);\n        }\n        return;\n    }\n    confused[pos] = 0;\n    backtrack(n, confused, pos + 1);\n    confused[pos] = 1;\n    backtrack(n, confused, pos + 1);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    hash = g_hash_table_new(g_direct_hash, g_direct_equal);\n    testimonials = g_array_new(FALSE, FALSE, sizeof(Testimony));\n\n    for (int i = 0; i < m; i++) {\n        Testimony t;\n        scanf(\"%d %d %d\", &t.a, &t.b, &t.c);\n        g_array_append_val(testimonies, t);\n    }\n\n    int *confused = (int *)malloc(n * sizeof(int));\n    memset(confused, 0, n * sizeof(int));\n\n    backtrack(n, confused, 0);\n\n    printf(\"-1\\n\");\n\n    g_hash_table_destroy(hash);\n    g_array_free(testimonies, TRUE);\n    free(confused);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_jpje_0b3/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_jpje_0b3/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc188_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int N, K;\n        scanf(\"%d %d\", &N, &K);\n\n        // Check if N is even and if K is such that the points can be symmetrically colored\n        if (N % 2 == 0 && (K == 1 || K == N - 1)) {\n            printf(\"Yes\n\");\n        } else {\n            printf(\"No\n\");\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_miconqt0/program.c: In function 'main':\\n/tmp/agnostics_c_miconqt0/program.c:15:20: warning: missing terminating \\\" character\\n   15 |             printf(\\\"Yes\\n      |                    ^\\n/tmp/agnostics_c_miconqt0/program.c:15:20: error: missing terminating \\\" character\\n   15 |             printf(\\\"Yes\\n      |                    ^~~~\\n/tmp/agnostics_c_miconqt0/program.c:16:1: warning: missing terminating \\\" character\\n   16 | \\\");\\n      | ^\\n/tmp/agnostics_c_miconqt0/program.c:16:1: error: missing terminating \\\" character\\n   16 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_miconqt0/program.c:17:9: error: expected expression before '}' token\\n   17 |         } else {\\n      |         ^\\n/tmp/agnostics_c_miconqt0/program.c:15:20: error: expected ';' before '}' token\\n   15 |             printf(\\\"Yes\\n      |                    ^\\n      |                    ;\\n   16 | \\\");\\n   17 |         } else {\\n      |         ~           \\n/tmp/agnostics_c_miconqt0/program.c:18:20: warning: missing terminating \\\" character\\n   18 |             printf(\\\"No\\n      |                    ^\\n/tmp/agnostics_c_miconqt0/program.c:18:20: error: missing terminating \\\" character\\n   18 |             printf(\\\"No\\n      |                    ^~~\\n/tmp/agnostics_c_miconqt0/program.c:19:1: warning: missing terminating \\\" character\\n   19 | \\\");\\n      | ^\\n/tmp/agnostics_c_miconqt0/program.c:19:1: error: missing terminating \\\" character\\n   19 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_miconqt0/program.c:20:9: error: expected expression before '}' token\\n   20 |         }\\n      |         ^\\n/tmp/agnostics_c_miconqt0/program.c:18:20: error: expected ';' before '}' token\\n   18 |             printf(\\\"No\\n      |                    ^\\n      |                    ;\\n   19 | \\\");\\n   20 |         }\\n      |         ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_miconqt0/program.c: In function 'main':\n/tmp/agnostics_c_miconqt0/program.c:15:20: warning: missing terminating \" character\n   15 |             printf(\"Yes\n      |                    ^\n/tmp/agnostics_c_miconqt0/program.c:15:20: error: missing terminating \" character\n   15 |             printf(\"Yes\n      |                    ^~~~\n/tmp/agnostics_c_miconqt0/program.c:16:1: warning: missing terminating \" character\n   16 | \");\n      | ^\n/tmp/agnostics_c_miconqt0/program.c:16:1: error: missing terminating \" character\n   16 | \");\n      | ^~~\n/tmp/agnostics_c_miconqt0/program.c:17:9: error: expected expression before '}' token\n   17 |         } else {\n      |         ^\n/tmp/agnostics_c_miconqt0/program.c:15:20: error: expected ';' before '}' token\n   15 |             printf(\"Yes\n      |                    ^\n      |                    ;\n   16 | \");\n   17 |         } else {\n      |         ~           \n/tmp/agnostics_c_miconqt0/program.c:18:20: warning: missing terminating \" character\n   18 |             printf(\"No\n      |                    ^\n/tmp/agnostics_c_miconqt0/program.c:18:20: error: missing terminating \" character\n   18 |             printf(\"No\n      |                    ^~~\n/tmp/agnostics_c_miconqt0/program.c:19:1: warning: missing terminating \" character\n   19 | \");\n      | ^\n/tmp/agnostics_c_miconqt0/program.c:19:1: error: missing terminating \" character\n   19 | \");\n      | ^~~\n/tmp/agnostics_c_miconqt0/program.c:20:9: error: expected expression before '}' token\n   20 |         }\n      |         ^\n/tmp/agnostics_c_miconqt0/program.c:18:20: error: expected ';' before '}' token\n   18 |             printf(\"No\n      |                    ^\n      |                    ;\n   19 | \");\n   20 |         }\n      |         ~           \n"}
{"question_id": "arc188_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    GArray *seq;\n    GArray *rev;\n} Sequence;\n\nbool is_valid_sequence(Sequence *seq, int *A, int *B, int N) {\n    GArray *sorted_seq = g_array_copy(seq->seq);\n    g_array_sort(sorted_seq, (GCompareFunc)g_int_compare);\n    GArray *sorted_rev = g_array_copy(seq->rev);\n    g_array_sort(sorted_rev, (GCompareFunc)g_int_compare);\n\n    int a = 1, b = 1;\n    for (int i = 0; i < N; i++) {\n        if (g_array_index(sorted_seq, int, i) == A[i]) {\n            a++;\n        }\n        if (B[i] != -1 && g_array_index(sorted_rev, int, i) == B[i]) {\n            b++;\n        }\n    }\n\n    return a == N + 1 && b == N + 1;\n}\n\nint count_valid_pairs(int *A, int *B, int N) {\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                int seq[3] = {i + 1, j + 1, k + 1};\n                int rev_seq[3] = {k + 1, j + 1, i + 1};\n\n                Sequence seq_a, seq_b;\n                seq_a.seq = g_array_new(FALSE, FALSE, sizeof(int));\n                seq_a.rev = g_array_new(FALSE, FALSE, sizeof(int));\n                seq_b.seq = g_array_new(FALSE, FALSE, sizeof(int));\n                seq_b.rev = g_array_new(FALSE, FALSE, sizeof(int));\n\n                for (int m = 0; m < 3; m++) {\n                    g_array_append_val(seq_a.seq, seq[m]);\n                    g_array_append_val(seq_a.rev, rev_seq[m]);\n                }\n\n                if (is_valid_sequence(&seq_a, A, B, N)) {\n                    count++;\n                }\n\n                g_array_free(seq_a.seq, TRUE);\n                g_array_free(seq_a.rev, TRUE);\n                g_array_free(seq_b.seq, TRUE);\n                g_array_free(seq_b.rev, TRUE);\n            }\n        }\n    }\n\n    return count % MOD;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int A[N], B[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &B[i]);\n    }\n\n    int result = count_valid_pairs(A, B, N);\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_6agjdlew/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_6agjdlew/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc188_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    char S[N + 1];\n    scanf(\"%s\", S);\n\n    GHashTable *dp[N + 1][N + 1];\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            dp[i][j] = g_hash_table_new(g_str_hash, g_str_equal);\n        }\n    }\n\n    // Initialize base cases\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            g_hash_table_insert(dp[i][j], \"0\", GINT_TO_POINTER(1));\n        }\n    }\n\n    // Fill DP table\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= N; j++) {\n            for (int k = 0; k <= N; k++) {\n                char *key = g_strdup_printf(\"%d,%d\", j, k);\n                int value = GPOINTER_TO_INT(g_hash_table_lookup(dp[i][j], key));\n                if (value == 0) continue;\n\n                if (S[i] != '?' && S[i] == S[i + 1]) {\n                    char *new_key = g_strdup_printf(\"%d,%d\", j + 2, k);\n                    g_hash_table_insert(dp[i + 2][k], new_key, GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(dp[i + 2][k], new_key)) + value) % MOD));\n                }\n\n                if (S[i] != '?' && S[i] == 'A' && S[i + 1] == 'B' && S[i + 2] == 'C') {\n                    char *new_key = g_strdup_printf(\"%d,%d\", j, k + 3);\n                    g_hash_table_insert(dp[i + 3][k + 3], new_key, GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(dp[i + 3][k + 3], new_key)) + value) % MOD));\n                }\n\n                if (S[i] == '?') {\n                    for (char c = 'A'; c <= 'C'; c++) {\n                        if (S[i + 1] != '?' && S[i + 1] == c) {\n                            char *new_key = g_strdup_printf(\"%d,%d\", j + 2, k);\n                            g_hash_table_insert(dp[i + 2][k], new_key, GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(dp[i + 2][k], new_key)) + value) % MOD));\n                        }\n\n                        if (S[i + 1] == '?' && S[i + 2] == '?' && (c == 'A' || c == 'B' || c == 'C')) {\n                            char *new_key = g_strdup_printf(\"%d,%d\", j, k + 3);\n                            g_hash_table_insert(dp[i + 3][k + 3], new_key, GINT_TO_POINTER((GPOINTER_TO_INT(g_hash_table_lookup(dp[i + 3][k + 3], new_key)) + value) % MOD));\n                        }\n                    }\n                }\n\n                g_free(key);\n            }\n        }\n    }\n\n    // Count the number of ways to replace '?' to get at least K good substrings\n    int result = 0;\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            char *key = g_strdup_printf(\"%d,%d\", i, j);\n            int value = GPOINTER_TO_INT(g_hash_table_lookup(dp[N][j], key));\n            if (value >= K) {\n                result = (result + value) % MOD;\n            }\n            g_free(key);\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    // Clean up\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            g_hash_table_destroy(dp[i][j]);\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_22ur2s2r/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_22ur2s2r/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc189_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *A = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    GArray *dp = g_array_new(FALSE, FALSE, sizeof(long long));\n    g_array_append_val(dp, 1);\n\n    for (int i = 1; i < n; i++) {\n        long long prev = g_array_index(dp, long long, i - 1);\n        if (A[i] != A[i - 1]) {\n            g_array_append_val(dp, prev * 2 % MOD);\n        } else {\n            g_array_append_val(dp, prev);\n        }\n    }\n\n    long long result = g_array_index(dp, long long, n - 1);\n\n    printf(\"%lld\\n\", result);\n\n    free(A);\n    g_array_free(dp, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_txmn1ker/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_txmn1ker/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc189_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n, x;\n    scanf(\"%d %d\", &n, &x);\n\n    GArray *red = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *blue = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *P = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *Q = g_array_new(FALSE, FALSE, sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        g_array_append_val(red, a);\n        g_array_append_val(blue, b);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int p, q;\n        scanf(\"%d %d\", &p, &q);\n        g_array_append_val(P, p - 1);\n        g_array_append_val(Q, q - 1);\n    }\n\n    int operations = 0;\n    for (int i = 0; i < n; i++) {\n        if (i == x - 1) continue;\n\n        int r = g_array_index(red, int, i);\n        int b = g_array_index(blue, int, i);\n\n        if (r > 0) {\n            int p = g_array_index(P, int, i);\n            if (g_array_index(blue, int, p) > 0) {\n                operations++;\n            } else {\n                printf(\"-1\n\");\n                g_array_free(red, TRUE);\n                g_array_free(blue, TRUE);\n                g_array_free(P, TRUE);\n                g_array_free(Q, TRUE);\n                return 0;\n            }\n        }\n\n        if (b > 0) {\n            int q = g_array_index(Q, int, i);\n            if (g_array_index(red, int, q) > 0) {\n                operations++;\n            } else {\n                printf(\"-1\n\");\n                g_array_free(red, TRUE);\n                g_array_free(blue, TRUE);\n                g_array_free(P, TRUE);\n                g_array_free(Q, TRUE);\n                return 0;\n            }\n        }\n    }\n\n    printf(\"%d\n\", operations);\n\n    g_array_free(red, TRUE);\n    g_array_free(blue, TRUE);\n    g_array_free(P, TRUE);\n    g_array_free(Q, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_8obux2wg/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_8obux2wg/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc189_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *sizes = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &sizes[i]);\n    }\n\n    GArray *left_max = g_array_new(FALSE, FALSE, sizeof(int));\n    GArray *right_max = g_array_new(FALSE, FALSE, sizeof(int));\n\n    int current_max = 0;\n    for (int i = 0; i < n; i++) {\n        if (sizes[i] > current_max) {\n            current_max = sizes[i];\n        }\n        g_array_append_val(left_max, current_max);\n    }\n\n    current_max = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (sizes[i] > current_max) {\n            current_max = sizes[i];\n        }\n        g_array_prepend_val(right_max, current_max);\n    }\n\n    for (int i = 0; i < n; i++) {\n        int result = sizes[i];\n        if (i > 0) {\n            result += g_array_index(left_max, int, i - 1);\n        }\n        if (i < n - 1) {\n            result += g_array_index(right_max, int, n - i - 2);\n        }\n        printf(\"%d \", result);\n    }\n\n    free(sizes);\n    g_array_free(left_max, TRUE);\n    g_array_free(right_max, TRUE);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_fbqc9hrl/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_fbqc9hrl/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "arc189_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *coords = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &coords[i]);\n    }\n\n    qsort(coords, n, sizeof(int), compare);\n\n    int min_sum = 0;\n    for (int i = 0; i < n; i++) {\n        min_sum += coords[i];\n    }\n\n    printf(\"%d\n\", min_sum);\n\n    free(coords);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_pjuzw1ak/program.c:3:10: fatal error: glib.h: No such file or directory\\n    3 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_pjuzw1ak/program.c:3:10: fatal error: glib.h: No such file or directory\n    3 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
