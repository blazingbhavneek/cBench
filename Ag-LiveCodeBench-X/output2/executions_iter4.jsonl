{"question_id": "abc301_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    int takahashi_wins = 0;\n    int aoki_wins = 0;\n    int takahashi_last_game = -1;\n    int aoki_last_game = -1;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'T') {\n            takahashi_wins++;\n            takahashi_last_game = i;\n        } else if (s[i] == 'A') {\n            aoki_wins++;\n            aoki_last_game = i;\n        }\n    }\n\n    if (takahashi_wins > aoki_wins) {\n        printf(\"T\\n\");\n    } else if (aoki_wins > takahashi_wins) {\n        printf(\"A\\n\");\n    } else {\n        if (takahashi_last_game < aoki_last_game) {\n            printf(\"T\\n\");\n        } else {\n            printf(\"A\\n\");\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "abc302_a", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long long A, B;\n    scanf(\"%lld %lld\", &A, &B);\n\n    // Calculate the minimum number of attacks needed\n    long long attacks = (A + B - 1) / B;\n\n    // Print the result\n    printf(\"%lld\\n\", attacks);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"success\", \"stderr\": \"\"}\n", "raw_stderr": "", "result": "success", "stderr": ""}
{"question_id": "1873_D", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n        char s[n + 1];\n        scanf(\"%s\", s);\n\n        int blackCount = 0;\n\n        // Count the number of black cells\n        for (int i = 0; i < n; i++) {\n            if (s[i] == 'B') {\n                blackCount++;\n            }\n        }\n\n        // The minimum number of operations needed is the number of black cells divided by k\n        // If there are remaining black cells after dividing by k, we need an additional operation\n        int operations = (blackCount + k - 1) / k;\n\n        printf(\"%d\\n\", operations);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"2\\n2\", \"got\": \"1\\n1\", \"stderr\": \"Test case 0 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "2\n2", "got": "1\n1", "stderr": "Test case 0 produced wrong output\n"}
{"question_id": "1873_B", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *a = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n\n        long long current_product = 1;\n        for (int i = 0; i < n; i++) {\n            current_product *= a[i];\n        }\n\n        long long max_product = current_product;\n        for (int i = 0; i < n; i++) {\n            long long increase = current_product / a[i] * (a[i] + 1);\n            if (increase > max_product) {\n                max_product = increase;\n            }\n        }\n\n        printf(\"%lld\\n\", max_product);\n\n        free(a);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": -8, \"stdout\": \"192000\\n\", \"stderr\": \"Test case 3 failed with exit code -8:\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": -8, "stdout": "192000\n", "stderr": "Test case 3 failed with exit code -8:\n"}
{"question_id": "1883_C", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <ctype.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        int count[5] = {0};\n        for (int i = 0; i < n; i++) {\n            int a;\n            scanf(\"%d\", &a);\n\n            if (a % 2 == 0) count[2]++;\n            if (a % 3 == 0) count[3]++;\n            if (a % 5 == 0) count[5]++;\n        }\n\n        int operations = 0;\n        if (k == 2 && count[2] == 0) operations++;\n        if (k == 3 && count[3] == 0) operations++;\n        if (k == 5 && count[5] == 0) operations++;\n\n        printf(\"%d\n\", operations);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_u9fag9v8/program.c: In function 'main':\\n/tmp/agnostics_c_u9fag9v8/program.c:32:16: warning: missing terminating \\\" character\\n   32 |         printf(\\\"%d\\n      |                ^\\n/tmp/agnostics_c_u9fag9v8/program.c:32:16: error: missing terminating \\\" character\\n   32 |         printf(\\\"%d\\n      |                ^~~\\n/tmp/agnostics_c_u9fag9v8/program.c:33:1: warning: missing terminating \\\" character\\n   33 | \\\", operations);\\n      | ^\\n/tmp/agnostics_c_u9fag9v8/program.c:33:1: error: missing terminating \\\" character\\n   33 | \\\", operations);\\n      | ^~~~~~~~~~~~~~~\\n/tmp/agnostics_c_u9fag9v8/program.c:34:5: error: expected expression before '}' token\\n   34 |     }\\n      |     ^\\n/tmp/agnostics_c_u9fag9v8/program.c:32:16: error: expected ';' before '}' token\\n   32 |         printf(\\\"%d\\n      |                ^\\n      |                ;\\n   33 | \\\", operations);\\n   34 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_u9fag9v8/program.c: In function 'main':\n/tmp/agnostics_c_u9fag9v8/program.c:32:16: warning: missing terminating \" character\n   32 |         printf(\"%d\n      |                ^\n/tmp/agnostics_c_u9fag9v8/program.c:32:16: error: missing terminating \" character\n   32 |         printf(\"%d\n      |                ^~~\n/tmp/agnostics_c_u9fag9v8/program.c:33:1: warning: missing terminating \" character\n   33 | \", operations);\n      | ^\n/tmp/agnostics_c_u9fag9v8/program.c:33:1: error: missing terminating \" character\n   33 | \", operations);\n      | ^~~~~~~~~~~~~~~\n/tmp/agnostics_c_u9fag9v8/program.c:34:5: error: expected expression before '}' token\n   34 |     }\n      |     ^\n/tmp/agnostics_c_u9fag9v8/program.c:32:16: error: expected ';' before '}' token\n   32 |         printf(\"%d\n      |                ^\n      |                ;\n   33 | \", operations);\n   34 |     }\n      |     ~           \n"}
{"question_id": "1883_B", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100001\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        char s[MAXN];\n        scanf(\"%s\", s);\n\n        // Count the frequency of each character\n        int char_count[26] = {0};\n        for (int i = 0; i < n; i++) {\n            char_count[s[i] - 'a']++;\n        }\n\n        int odd_count = 0;\n        // Count how many characters have an odd frequency\n        for (int i = 0; i < 26; i++) {\n            if (char_count[i] % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        // Check if it's possible to form a palindrome\n        if (odd_count <= 1 && k >= n - odd_count) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"YES\\nYES\\nNO\\nYES\\nYES\", \"got\": \"NO\\nNO\\nNO\\nNO\\nNO\", \"stderr\": \"Test case 0 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "YES\nYES\nNO\nYES\nYES", "got": "NO\nNO\nNO\nNO\nNO", "stderr": "Test case 0 produced wrong output\n"}
{"question_id": "1873_A", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    for (int test = 0; test < t; test++) {\n        char str[4];\n        scanf(\"%s\", str);\n\n        // Find the positions of 'a', 'b', and 'c'\n        int pos_a = -1, pos_b = -1, pos_c = -1;\n        for (int i = 0; i < 3; i++) {\n            if (str[i] == 'a') pos_a = i;\n            else if (str[i] == 'b') pos_b = i;\n            else if (str[i] == 'c') pos_c = i;\n        }\n\n        // Check if the string is already sorted or can be sorted with one swap\n        if ((pos_a == 0 && pos_b == 1 && pos_c == 2) ||\n            (pos_a == 0 && pos_b == 2 && pos_c == 1) ||\n            (pos_a == 1 && pos_b == 0 && pos_c == 2) ||\n            (pos_a == 1 && pos_b == 2 && pos_c == 0) ||\n            (pos_a == 2 && pos_b == 0 && pos_c == 1) ||\n            (pos_a == 2 && pos_b == 1 && pos_c == 0)) {\n            printf(\"YES\n\");\n        } else {\n            printf(\"NO\n\");\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_se7aawvq/program.c: In function 'main':\\n/tmp/agnostics_c_se7aawvq/program.c:28:20: warning: missing terminating \\\" character\\n   28 |             printf(\\\"YES\\n      |                    ^\\n/tmp/agnostics_c_se7aawvq/program.c:28:20: error: missing terminating \\\" character\\n   28 |             printf(\\\"YES\\n      |                    ^~~~\\n/tmp/agnostics_c_se7aawvq/program.c:29:1: warning: missing terminating \\\" character\\n   29 | \\\");\\n      | ^\\n/tmp/agnostics_c_se7aawvq/program.c:29:1: error: missing terminating \\\" character\\n   29 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_se7aawvq/program.c:30:9: error: expected expression before '}' token\\n   30 |         } else {\\n      |         ^\\n/tmp/agnostics_c_se7aawvq/program.c:28:20: error: expected ';' before '}' token\\n   28 |             printf(\\\"YES\\n      |                    ^\\n      |                    ;\\n   29 | \\\");\\n   30 |         } else {\\n      |         ~           \\n/tmp/agnostics_c_se7aawvq/program.c:31:20: warning: missing terminating \\\" character\\n   31 |             printf(\\\"NO\\n      |                    ^\\n/tmp/agnostics_c_se7aawvq/program.c:31:20: error: missing terminating \\\" character\\n   31 |             printf(\\\"NO\\n      |                    ^~~\\n/tmp/agnostics_c_se7aawvq/program.c:32:1: warning: missing terminating \\\" character\\n   32 | \\\");\\n      | ^\\n/tmp/agnostics_c_se7aawvq/program.c:32:1: error: missing terminating \\\" character\\n   32 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_se7aawvq/program.c:33:9: error: expected expression before '}' token\\n   33 |         }\\n      |         ^\\n/tmp/agnostics_c_se7aawvq/program.c:31:20: error: expected ';' before '}' token\\n   31 |             printf(\\\"NO\\n      |                    ^\\n      |                    ;\\n   32 | \\\");\\n   33 |         }\\n      |         ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_se7aawvq/program.c: In function 'main':\n/tmp/agnostics_c_se7aawvq/program.c:28:20: warning: missing terminating \" character\n   28 |             printf(\"YES\n      |                    ^\n/tmp/agnostics_c_se7aawvq/program.c:28:20: error: missing terminating \" character\n   28 |             printf(\"YES\n      |                    ^~~~\n/tmp/agnostics_c_se7aawvq/program.c:29:1: warning: missing terminating \" character\n   29 | \");\n      | ^\n/tmp/agnostics_c_se7aawvq/program.c:29:1: error: missing terminating \" character\n   29 | \");\n      | ^~~\n/tmp/agnostics_c_se7aawvq/program.c:30:9: error: expected expression before '}' token\n   30 |         } else {\n      |         ^\n/tmp/agnostics_c_se7aawvq/program.c:28:20: error: expected ';' before '}' token\n   28 |             printf(\"YES\n      |                    ^\n      |                    ;\n   29 | \");\n   30 |         } else {\n      |         ~           \n/tmp/agnostics_c_se7aawvq/program.c:31:20: warning: missing terminating \" character\n   31 |             printf(\"NO\n      |                    ^\n/tmp/agnostics_c_se7aawvq/program.c:31:20: error: missing terminating \" character\n   31 |             printf(\"NO\n      |                    ^~~\n/tmp/agnostics_c_se7aawvq/program.c:32:1: warning: missing terminating \" character\n   32 | \");\n      | ^\n/tmp/agnostics_c_se7aawvq/program.c:32:1: error: missing terminating \" character\n   32 | \");\n      | ^~~\n/tmp/agnostics_c_se7aawvq/program.c:33:9: error: expected expression before '}' token\n   33 |         }\n      |         ^\n/tmp/agnostics_c_se7aawvq/program.c:31:20: error: expected ';' before '}' token\n   31 |             printf(\"NO\n      |                    ^\n      |                    ;\n   32 | \");\n   33 |         }\n      |         ~           \n"}
{"question_id": "1899_D", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        long long count[1000001] = {0};\n        long long result = 0;\n\n        for (int i = 0; i < n; i++) {\n            int a;\n            scanf(\"%d\", &a);\n\n            int note = 1 << a;\n            result += count[note];\n            count[note]++;\n        }\n\n        printf(\"%lld\n\", result);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_1q9lrqg5/program.c: In function 'main':\\n/tmp/agnostics_c_1q9lrqg5/program.c:25:16: warning: missing terminating \\\" character\\n   25 |         printf(\\\"%lld\\n      |                ^\\n/tmp/agnostics_c_1q9lrqg5/program.c:25:16: error: missing terminating \\\" character\\n   25 |         printf(\\\"%lld\\n      |                ^~~~~\\n/tmp/agnostics_c_1q9lrqg5/program.c:26:1: warning: missing terminating \\\" character\\n   26 | \\\", result);\\n      | ^\\n/tmp/agnostics_c_1q9lrqg5/program.c:26:1: error: missing terminating \\\" character\\n   26 | \\\", result);\\n      | ^~~~~~~~~~~\\n/tmp/agnostics_c_1q9lrqg5/program.c:27:5: error: expected expression before '}' token\\n   27 |     }\\n      |     ^\\n/tmp/agnostics_c_1q9lrqg5/program.c:25:16: error: expected ';' before '}' token\\n   25 |         printf(\\\"%lld\\n      |                ^\\n      |                ;\\n   26 | \\\", result);\\n   27 |     }\\n      |     ~           \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_1q9lrqg5/program.c: In function 'main':\n/tmp/agnostics_c_1q9lrqg5/program.c:25:16: warning: missing terminating \" character\n   25 |         printf(\"%lld\n      |                ^\n/tmp/agnostics_c_1q9lrqg5/program.c:25:16: error: missing terminating \" character\n   25 |         printf(\"%lld\n      |                ^~~~~\n/tmp/agnostics_c_1q9lrqg5/program.c:26:1: warning: missing terminating \" character\n   26 | \", result);\n      | ^\n/tmp/agnostics_c_1q9lrqg5/program.c:26:1: error: missing terminating \" character\n   26 | \", result);\n      | ^~~~~~~~~~~\n/tmp/agnostics_c_1q9lrqg5/program.c:27:5: error: expected expression before '}' token\n   27 |     }\n      |     ^\n/tmp/agnostics_c_1q9lrqg5/program.c:25:16: error: expected ';' before '}' token\n   25 |         printf(\"%lld\n      |                ^\n      |                ;\n   26 | \", result);\n   27 |     }\n      |     ~           \n"}
{"question_id": "1899_A", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        // If n is divisible by 3, Vanya wins immediately\n        if (n % 3 == 0) {\n            printf(\"First\\n\");\n        } else {\n            // If n is not divisible by 3, the winner depends on the remainder\n            if (n % 3 == 1) {\n                // If n % 3 == 1, Vanya can add 1 to make it divisible by 3 and win\n                printf(\"First\\n\");\n            } else {\n                // If n % 3 == 2, Vanya can add 1 to make it divisible by 3 and win\n                printf(\"First\\n\");\n            }\n        }\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"Second\", \"got\": \"First\", \"stderr\": \"Test case 2 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "Second", "got": "First", "stderr": "Test case 2 produced wrong output\n"}
{"question_id": "1899_B", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *boxes = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &boxes[i]);\n        }\n\n        qsort(boxes, n, sizeof(int), compare);\n\n        long long *prefix_sums = (long long *)malloc((n + 1) * sizeof(long long));\n        prefix_sums[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            prefix_sums[i] = prefix_sums[i - 1] + boxes[i - 1];\n        }\n\n        long long max_diff = 0;\n        for (int k = 1; k <= n; k++) {\n            long long current_diff = abs(prefix_sums[n] - 2 * prefix_sums[k]);\n            if (current_diff > max_diff) {\n                max_diff = current_diff;\n            }\n        }\n\n        printf(\"%lld\\n\", max_diff);\n\n        free(boxes);\n        free(prefix_sums);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_852gfp_z/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_852gfp_z/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc301_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S[1000];\n    long long N;\n    scanf(\"%s %lld\", S, &N);\n\n    // Process using appropriate data structure\n    GHashTable *map = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    // Your algorithm here\n    int len = strlen(S);\n    for (int i = 0; i < 1 << len; i++) {\n        char temp[len + 1];\n        strcpy(temp, S);\n        for (int j = 0; j < len; j++) {\n            if (temp[j] == '?') {\n                temp[j] = '0' + (i >> j) % 2;\n            }\n        }\n        long long value = strtoll(temp, NULL, 2);\n        if (value <= N) {\n            g_hash_table_insert(map, GINT_TO_POINTER(value), GINT_TO_POINTER(1));\n        }\n    }\n\n    // Output result\n    long long result = -1;\n    GHashTableIter iter;\n    gpointer key, value;\n    g_hash_table_iter_init(&iter, map);\n    while (g_hash_table_iter_next(&iter, &key, &value)) {\n        if (GPOINTER_TO_INT(key) <= N && GPOINTER_TO_INT(key) > result) {\n            result = GPOINTER_TO_INT(key);\n        }\n    }\n    printf(\"%lld\n\", result);\n\n    // Clean up\n    g_hash_table_destroy(map);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_uu4gyp3x/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_uu4gyp3x/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "1899_C", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <stdbool.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *a = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n\n        int maxSum = INT_MIN;\n        int currentSum = 0;\n        bool lastWasOdd = false;\n\n        for (int i = 0; i < n; i++) {\n            bool isOdd = (a[i] % 2 != 0);\n\n            if (i == 0 || (isOdd && !lastWasOdd) || (!isOdd && lastWasOdd)) {\n                currentSum += a[i];\n                lastWasOdd = isOdd;\n            } else {\n                currentSum = a[i];\n                lastWasOdd = isOdd;\n            }\n\n            if (currentSum > maxSum) {\n                maxSum = currentSum;\n            }\n        }\n\n        if (maxSum == INT_MIN) {\n            // If maxSum is still INT_MIN, it means the array only contains negative numbers\n            // Find the maximum negative number\n            maxSum = INT_MIN;\n            for (int i = 0; i < n; i++) {\n                if (a[i] > maxSum) {\n                    maxSum = a[i];\n                }\n            }\n        }\n\n        printf(\"%d\\n\", maxSum);\n\n        free(a);\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:wrong-output\", \"expected\": \"-1\", \"got\": \"-2\", \"stderr\": \"Test case 7 produced wrong output\\n\"}\n", "raw_stderr": "", "result": "fail:wrong-output", "expected": "-1", "got": "-2", "stderr": "Test case 7 produced wrong output\n"}
{"question_id": "abc301_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char S[200001], T[200001];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int n = strlen(S);\n    int countS[26] = {0};\n    int countT[26] = {0};\n\n    // Count characters in S and T\n    for (int i = 0; i < n; i++) {\n        if (S[i] != '@') {\n            countS[S[i] - 'a']++;\n        }\n        if (T[i] != '@') {\n            countT[T[i] - 'a']++;\n        }\n    }\n\n    // Compare counts of non-'@' characters\n    for (int i = 0; i < 26; i++) {\n        if (countS[i] != countT[i]) {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    // Check if the two rows of cards coincide after replacing '@' symbols\n    for (int i = 0; i < n; i++) {\n        if (S[i] == '@' && T[i] == '@') {\n            continue;\n        }\n        if (S[i] == '@' || T[i] == '@') {\n            printf(\"No\n\");\n            return 0;\n        }\n        if (S[i] != T[i]) {\n            printf(\"No\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\n\");\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_1uog7av8/program.c: In function 'main':\\n/tmp/agnostics_c_1uog7av8/program.c:27:20: warning: missing terminating \\\" character\\n   27 |             printf(\\\"No\\n      |                    ^\\n/tmp/agnostics_c_1uog7av8/program.c:27:20: error: missing terminating \\\" character\\n   27 |             printf(\\\"No\\n      |                    ^~~\\n/tmp/agnostics_c_1uog7av8/program.c:28:1: warning: missing terminating \\\" character\\n   28 | \\\");\\n      | ^\\n/tmp/agnostics_c_1uog7av8/program.c:28:1: error: missing terminating \\\" character\\n   28 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_1uog7av8/program.c:29:13: error: expected expression before 'return'\\n   29 |             return 0;\\n      |             ^~~~~~\\n/tmp/agnostics_c_1uog7av8/program.c:29:22: error: expected ';' before '}' token\\n   29 |             return 0;\\n      |                      ^\\n      |                      ;\\n   30 |         }\\n      |         ~             \\n/tmp/agnostics_c_1uog7av8/program.c:39:20: warning: missing terminating \\\" character\\n   39 |             printf(\\\"No\\n      |                    ^\\n/tmp/agnostics_c_1uog7av8/program.c:39:20: error: missing terminating \\\" character\\n   39 |             printf(\\\"No\\n      |                    ^~~\\n/tmp/agnostics_c_1uog7av8/program.c:40:1: warning: missing terminating \\\" character\\n   40 | \\\");\\n      | ^\\n/tmp/agnostics_c_1uog7av8/program.c:40:1: error: missing terminating \\\" character\\n   40 | \\\");\\n      | ^~~\\n/tmp/agnostics_c_1uog7av8/program.c:41:13: error: expected expression before 'return'\\n   41 |             return 0;\\n      |             ^~~~~~\\n/tmp/agnostics_c_1uog7av8/program.c:41:22: error: expected ';' before '}' token\\n   41 |             return 0;\\n      |                      ^\\n      |                      ;\\n   42 |         }\\n      |         ~             \\n/tmp/agnostics_c_1uog7av8/program.c:44:20: warning: missing terminating \\\" character\\n   44 |             printf(\\\"No\\n  ", "raw_stderr": "", "result": "fail"}
{"question_id": "abc301_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <ctype.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    while (true) {\n        bool changed = false;\n        for (int i = 0; i < n - 1; i++) {\n            int a = arr[i];\n            int b = arr[i + 1];\n            if (abs(a - b) != 1) {\n                changed = true;\n                int diff = abs(b - a);\n                int new_size = n + diff;\n                int *new_arr = (int *)realloc(arr, new_size * sizeof(int));\n                if (new_arr == NULL) {\n                    fprintf(stderr, \"Memory allocation failed\");\n                    free(arr);\n                    return 1;\n                }\n                arr = new_arr;\n                n = new_size;\n\n                if (a < b) {\n                    for (int j = diff; j > 0; j--) {\n                        arr[i + 1 + j] = a + j;\n                    }\n                } else {\n                    for (int j = diff; j > 0; j--) {\n                        arr[i + 1 + j] = a - j;\n                    }\n                }\n            }\n        }\n        if (!changed) {\n            break;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    free(arr);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Test case 2 failed with exit code 1:\\nMemory allocation failed\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Test case 2 failed with exit code 1:\nMemory allocation failed"}
{"question_id": "abc302_d", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// No need for glib.h as we are not using any GLib data structures\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m, d;\n    scanf(\"%d %d %d\", &n, &m, &d);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(m * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    qsort(a, n, sizeof(int), compare);\n    qsort(b, m, sizeof(int), compare);\n\n    int max_sum = -1;\n    int i = 0, j = m - 1;\n\n    while (i < n && j >= 0) {\n        if (a[i] + b[j] > max_sum && b[j] - a[i] <= d) {\n            max_sum = a[i] + b[j];\n        }\n\n        if (b[j] - a[i] > d) {\n            j--;\n        } else {\n            i++;\n        }\n    }\n\n    printf(\"%d\n\", max_sum);\n\n    free(a);\n    free(b);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_vcdyfc84/program.c: In function 'main':\\n/tmp/agnostics_c_vcdyfc84/program.c:44:12: warning: missing terminating \\\" character\\n   44 |     printf(\\\"%d\\n      |            ^\\n/tmp/agnostics_c_vcdyfc84/program.c:44:12: error: missing terminating \\\" character\\n   44 |     printf(\\\"%d\\n      |            ^~~\\n/tmp/agnostics_c_vcdyfc84/program.c:45:1: warning: missing terminating \\\" character\\n   45 | \\\", max_sum);\\n      | ^\\n/tmp/agnostics_c_vcdyfc84/program.c:45:1: error: missing terminating \\\" character\\n   45 | \\\", max_sum);\\n      | ^~~~~~~~~~~~\\n/tmp/agnostics_c_vcdyfc84/program.c:47:12: error: expected ')' before ';' token\\n   47 |     free(a);\\n      |            ^\\n      |            )\\n/tmp/agnostics_c_vcdyfc84/program.c:44:11: note: to match this '('\\n   44 |     printf(\\\"%d\\n      |           ^\\n/tmp/agnostics_c_vcdyfc84/program.c:47:5: error: invalid use of void expression\\n   47 |     free(a);\\n      |     ^~~~~~~\\n/tmp/agnostics_c_vcdyfc84/program.c:50:14: error: expected ';' before '}' token\\n   50 |     return 0;\\n      |              ^\\n      |              ;\\n   51 | }\\n      | ~             \\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_vcdyfc84/program.c: In function 'main':\n/tmp/agnostics_c_vcdyfc84/program.c:44:12: warning: missing terminating \" character\n   44 |     printf(\"%d\n      |            ^\n/tmp/agnostics_c_vcdyfc84/program.c:44:12: error: missing terminating \" character\n   44 |     printf(\"%d\n      |            ^~~\n/tmp/agnostics_c_vcdyfc84/program.c:45:1: warning: missing terminating \" character\n   45 | \", max_sum);\n      | ^\n/tmp/agnostics_c_vcdyfc84/program.c:45:1: error: missing terminating \" character\n   45 | \", max_sum);\n      | ^~~~~~~~~~~~\n/tmp/agnostics_c_vcdyfc84/program.c:47:12: error: expected ')' before ';' token\n   47 |     free(a);\n      |            ^\n      |            )\n/tmp/agnostics_c_vcdyfc84/program.c:44:11: note: to match this '('\n   44 |     printf(\"%d\n      |           ^\n/tmp/agnostics_c_vcdyfc84/program.c:47:5: error: invalid use of void expression\n   47 |     free(a);\n      |     ^~~~~~~\n/tmp/agnostics_c_vcdyfc84/program.c:50:14: error: expected ';' before '}' token\n   50 |     return 0;\n      |              ^\n      |              ;\n   51 | }\n      | ~             \n"}
{"question_id": "abc301_f", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    char s[300001];\n    scanf(\"%s\", s);\n\n    int n = strlen(s);\n    GHashTable *dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n    g_hash_table_insert(dp, GINT_TO_POINTER(0), GINT_TO_POINTER(1));\n\n    for (int i = 0; i < n; i++) {\n        int c = s[i] - 'A';\n        GHashTable *new_dp = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n        if (s[i] == '?') {\n            for (int a = 0; a < 26; a++) {\n                for (int b = 0; b < 26; b++) {\n                    for (int d = 0; d < 26; d++) {\n                        int key = (a << 10) | (b << 5) | d;\n                        int value = GPOINTER_TO_INT(g_hash_table_lookup(dp, GINT_TO_POINTER(key)));\n                        if (value != 0) {\n                            g_hash_table_insert(new_dp, GINT_TO_POINTER(key), GINT_TO_POINTER((value + value) % MOD));\n                        }\n                    }\n                }\n            }\n        } else {\n            int a = (s[i] - 'A') % 26;\n            for (int b = 0; b < 26; b++) {\n                for (int d = 0; d < 26; d++) {\n                    int key = (a << 10) | (b << 5) | d;\n                    int value = GPOINTER_TO_INT(g_hash_table_lookup(dp, GINT_TO_POINTER(key)));\n                    if (value != 0) {\n                        g_hash_table_insert(new_dp, GINT_TO_POINTER(key), GINT_TO_POINTER((value + value) % MOD));\n                    }\n                }\n            }\n        }\n\n        g_hash_table_destroy(dp);\n        dp = new_dp;\n    }\n\n    int result = 0;\n    for (int a = 0; a < 26; a++) {\n        for (int b = 0; b < 26; b++) {\n            for (int d = 0; d < 26; d++) {\n                int key = (a << 10) | (b << 5) | d;\n                int value = GPOINTER_TO_INT(g_hash_table_lookup(dp, GINT_TO_POINTER(key)));\n                if (value != 0) {\n                    result = (result + value) % MOD;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    g_hash_table_destroy(dp);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_q8997_ma/program.c:4:10: fatal error: glib.h: No such file or directory\\n    4 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_q8997_ma/program.c:4:10: fatal error: glib.h: No such file or directory\n    4 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc301_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <glib.h>\n\n#define MAX_H 300\n#define MAX_W 300\n\ntypedef struct {\n    int x, y;\n    int moves;\n    int candy_count;\n} State;\n\nint main() {\n    int H, W, T;\n    scanf(\"%d %d %d\", &H, &W, &T);\n\n    char grid[MAX_H][MAX_W + 1];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int start_x, start_y;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                start_x = i;\n                start_y = j;\n            }\n        }\n    }\n\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, g_new(State, 1));\n    g_queue_peek_tail(queue)->x = start_x;\n    g_queue_peek_tail(queue)->y = start_y;\n    g_queue_peek_tail(queue)->moves = 0;\n    g_queue_peek_tail(queue)->candy_count = 0;\n\n    GHashTable *visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    int max_candy = -1;\n\n    while (g_queue_get_length(queue) > 0 && T > 0) {\n        State *current = g_queue_pop_head(queue);\n\n        if (current->x == start_x && current->y == start_y && current->moves == T) {\n            max_candy = current->candy_count;\n        }\n\n        int dx[] = {-1, 1, 0, 0};\n        int dy[] = {0, 0, -1, 1};\n\n        for (int k = 0; k < 4; k++) {\n            int nx = current->x + dx[k];\n            int ny = current->y + dy[k];\n            int nm = current->moves + 1;\n            int nc = current->candy_count;\n\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W) {\n                if (grid[nx][ny] == 'o') {\n                    nc++;\n                }\n\n                if (grid[nx][ny] != '#') {\n                    GHashTable *new_visited = g_hash_table_new(g_direct_hash, g_direct_equal);\n                    GHashTable *new_visited_key = g_hash_table_new(g_direct_hash, g_direct_equal);\n                    g_hash_table_insert(new_visited_key, GINT_TO_POINTER(nx), GINT_TO_POINTER(ny));\n                    g_hash_table_insert(new_visited_key, GINT_TO_POINTER(nm), GINT_TO_POINTER(nc));\n                    if (!g_hash_table_lookup_extended(visited, new_visited_key, NULL, NULL)) {\n                        g_hash_table_insert(visited, new_visited_key, GINT_TO_POINTER(1));\n                        State *new_state = g_new(State, 1);\n                        new_state->x = nx;\n                        new_state->y = ny;\n                        new_state->moves = nm;\n                        new_state->candy_count = nc;\n                        g_queue_push_tail(queue, new_state);\n                    }\n                    g_hash_table_destroy(new_visited);\n                    g_hash_table_destroy(new_visited_key);\n                }\n            }\n        }\n\n        g_free(current);\n        T--;\n    }\n\n    printf(\"%d\\n\", max_candy);\n\n    g_queue_free(queue);\n    g_hash_table_destroy(visited);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_nzsn1zck/program.c:5:10: fatal error: glib.h: No such file or directory\\n    5 | #include <glib.h>\\n      |          ^~~~~~~~\\ncompilation terminated.\\n\"}\n", "raw_stderr": "", "result": "fail:error", "exit_code": 1, "stdout": "", "stderr": "Compilation failed:\n/tmp/agnostics_c_nzsn1zck/program.c:5:10: fatal error: glib.h: No such file or directory\n    5 | #include <glib.h>\n      |          ^~~~~~~~\ncompilation terminated.\n"}
{"question_id": "abc302_b", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define H 100\n#define W 100\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    char grid[H][W + 1];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    bool found = false;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 's') {\n                int dx[] = {0, 0, 1, -1, 1, -1, 1, -1};\n                int dy[] = {1, -1, 0, 0, 1, 1, -1, -1};\n\n                for (int k = 0; k < 8; k++) {\n                    int x = i, y = j;\n                    char letters[5] = {grid[x][y], 0};\n\n                    for (int l = 1; l < 5; l++) {\n                        x += dx[k];\n                        y += dy[k];\n\n                        if (x >= 0 && x < H && y >= 0 && y < W) {\n                            letters[l] = grid[x][y];\n                        } else {\n                            break;\n                        }\n                    }\n\n                    if (letters[0] == 's' && letters[1] == 'n' && letters[2] == 'u' && letters[3] == 'k' && letters[4] == 'e') {\n                        printf(\"%d %d\n\", i + 1, j + 1);\n                        printf(\"%d %d\n\", i + 1, j + 2);\n                        printf(\"%d %d\n\", i + 1, j + 3);\n                        printf(\"%d %d\n\", i + 1, j + 4);\n                        printf(\"%d %d\n\", i + 1, j + 5);\n                        found = true;\n                        break;\n                    }\n                }\n\n                if (found) {\n                    break;\n                }\n            }\n        }\n\n        if (found) {\n            break;\n        }\n    }\n\n    if (!found) {\n        printf(\"No solution found.\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_r6mh1jk4/program.c: In function 'main':\\n/tmp/agnostics_c_r6mh1jk4/program.c:6:11: error: expected identifier or '(' before numeric constant\\n    6 | #define H 100\\n      |           ^~~\\n/tmp/agnostics_c_r6mh1jk4/program.c:10:9: note: in expansion of macro 'H'\\n   10 |     int H, W;\\n      |         ^\\n/tmp/agnostics_c_r6mh1jk4/program.c:11:20: error: lvalue required as unary '&' operand\\n   11 |     scanf(\\\"%d %d\\\", &H, &W);\\n      |                    ^\\n/tmp/agnostics_c_r6mh1jk4/program.c:11:24: error: lvalue required as unary '&' operand\\n   11 |     scanf(\\\"%d %d\\\", &H, &W);\\n      |                        ^\\n/tmp/agnostics_c_r6mh1jk4/program.c:42:32: warning: missing terminating \\\" character\\n   42 |                         printf(\\\"%d %d\\n      |                                ^\\n/tmp/agnostics_c_r6mh1jk4/program.c:42:32: error: missing terminating \\\" character\\n   42 |                         printf(\\\"%d %d\\n      |                                ^~~~~~\\n/tmp/agnostics_c_r6mh1jk4/program.c:43:1: warning: missing terminating \\\" character\\n   43 | \\\", i + 1, j + 1);\\n      | ^\\n/tmp/agnostics_c_r6mh1jk4/program.c:43:1: error: missing terminating \\\" character\\n   43 | \\\", i + 1, j + 1);\\n      | ^~~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_r6mh1jk4/program.c:44:32: warning: missing terminating \\\" character\\n   44 |                         printf(\\\"%d %d\\n      |                                ^\\n/tmp/agnostics_c_r6mh1jk4/program.c:44:32: error: missing terminating \\\" character\\n   44 |                         printf(\\\"%d %d\\n      |                                ^~~~~~\\n/tmp/agnostics_c_r6mh1jk4/program.c:45:1: warning: missing terminating \\\" character\\n   45 | \\\", i + 1, j + 2);\\n      | ^\\n/tmp/agnostics_c_r6mh1jk4/program.c:45:1: error: missing terminating \\\" character\\n   45 | \\\", i + 1, j + 2);\\n      | ^~~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_r6mh1jk4/program.c:46:32: warning: missing terminating \\\" character\\n ", "raw_stderr": "", "result": "fail"}
{"question_id": "abc302_c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 8\n#define MAX_M 5\n\n// Function to check if two strings can be transformed into each other by changing exactly one character\nbool can_transform(const char *s1, const char *s2, int m) {\n    int diff = 0;\n    for (int i = 0; i < m; i++) {\n        if (s1[i] != s2[i]) {\n            diff++;\n            if (diff > 1) {\n                return false;\n            }\n        }\n    }\n    return diff == 1;\n}\n\n// Function to check if the graph is connected\nbool is_connected(const char *strings[], int n) {\n    // Create a graph using an adjacency list\n    GHashTable *graph = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Add nodes to the graph\n    for (int i = 0; i < n; i++) {\n        g_hash_table_insert(graph, (gpointer)strings[i], NULL);\n    }\n\n    // Add edges to the graph\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (can_transform(strings[i], strings[j], MAX_M)) {\n                g_hash_table_insert(graph, (gpointer)strings[i], (gpointer)strings[j]);\n                g_hash_table_insert(graph, (gpointer)strings[j], (gpointer)strings[i]);\n            }\n        }\n    }\n\n    // Check if the graph is connected using a depth-first search\n    bool *visited = (bool *)calloc(n, sizeof(bool));\n\n    void dfs(const char *node, GHashTable *graph, bool *visited) {\n        visited[node - strings[0]] = true;\n        GList *edges = g_hash_table_lookup(graph, (gpointer)node);\n        if (edges) {\n            for (GList *it = edges; it != NULL; it = it->next) {\n                if (!visited[GPOINTER_TO_INT(it->data) - strings[0]]) {\n                    dfs((const char *)it->data, graph, visited);\n                }\n            }\n        }\n    }\n\n    // Start DFS from the first node\n    dfs(strings[0], graph, visited);\n\n    // Check if all nodes are visited\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            g_hash_table_destroy(graph);\n            free(visited);\n            return false;\n        }\n    }\n\n    g_hash_table_destroy(graph);\n    free(visited);\n    return true;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    // Read input strings and store them in an array\n    char strings[MAX_N][MAX_M + 1];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", strings[i]);\n    }\n\n    // Check if the graph is connected\n    if (is_connected(strings, n)) {\n        printf(\"Yes\n\");\n    } else {\n        printf(\"No\n\");\n    }\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_4k3p7ocp/program.c: In function 'is_connected':\\n/tmp/agnostics_c_4k3p7ocp/program.c:26:5: error: unknown type name 'GHashTable'\\n   26 |     GHashTable *graph = g_hash_table_new(g_str_hash, g_str_equal);\\n      |     ^~~~~~~~~~\\n/tmp/agnostics_c_4k3p7ocp/program.c:26:25: warning: implicit declaration of function 'g_hash_table_new' [-Wimplicit-function-declaration]\\n   26 |     GHashTable *graph = g_hash_table_new(g_str_hash, g_str_equal);\\n      |                         ^~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_4k3p7ocp/program.c:26:42: error: 'g_str_hash' undeclared (first use in this function)\\n   26 |     GHashTable *graph = g_hash_table_new(g_str_hash, g_str_equal);\\n      |                                          ^~~~~~~~~~\\n/tmp/agnostics_c_4k3p7ocp/program.c:26:42: note: each undeclared identifier is reported only once for each function it appears in\\n/tmp/agnostics_c_4k3p7ocp/program.c:26:54: error: 'g_str_equal' undeclared (first use in this function)\\n   26 |     GHashTable *graph = g_hash_table_new(g_str_hash, g_str_equal);\\n      |                                                      ^~~~~~~~~~~\\n/tmp/agnostics_c_4k3p7ocp/program.c:30:9: warning: implicit declaration of function 'g_hash_table_insert' [-Wimplicit-function-declaration]\\n   30 |         g_hash_table_insert(graph, (gpointer)strings[i], NULL);\\n      |         ^~~~~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_4k3p7ocp/program.c:30:37: error: 'gpointer' undeclared (first use in this function)\\n   30 |         g_hash_table_insert(graph, (gpointer)strings[i], NULL);\\n      |                                     ^~~~~~~~\\n/tmp/agnostics_c_4k3p7ocp/program.c:30:46: error: expected ')' before 'strings'\\n   30 |         g_hash_table_insert(graph, (gpointer)strings[i], NULL);\\n      |                            ~                 ^~~~~~~\\n      |                                              )\\n/tmp/agnostics_c_4k3p7ocp/program.c:37:54: error: expected ')' before ", "raw_stderr": "", "result": "fail"}
{"question_id": "abc302_e", "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <ctype.h>\n\n// No need to include glib.h, as the problem does not require it\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    // Initialize adjacency list and edge count hash tables\n    GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *edge_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        g_hash_table_insert(adj_list, GINT_TO_POINTER(i + 1), g_array_new(FALSE, FALSE, sizeof(int)));\n        g_hash_table_insert(edge_count, GINT_TO_POINTER(i + 1), GINT_TO_POINTER(0));\n    }\n\n    for (int i = 0; i < q; i++) {\n        int type, u, v;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            scanf(\"%d %d\", &u, &v);\n\n            GArray *u_adj = (GArray *)g_hash_table_lookup(adj_list, GINT_TO_POINTER(u));\n            GArray *v_adj = (GArray *)g_hash_table_lookup(adj_list, GINT_TO_POINTER(v));\n\n            g_array_append_val(u_adj, v);\n            g_array_append_val(v_adj, u);\n\n            int u_count = GPOINTER_TO_INT(g_hash_table_lookup(edge_count, GINT_TO_POINTER(u)));\n            int v_count = GPOINTER_TO_INT(g_hash_table_lookup(edge_count, GINT_TO_POINTER(v)));\n\n            g_hash_table_insert(edge_count, GINT_TO_POINTER(u), GINT_TO_POINTER(u_count + 1));\n            g_hash_table_insert(edge_count, GINT_TO_POINTER(v), GINT_TO_POINTER(v_count + 1));\n        } else if (type == 2) {\n            scanf(\"%d\", &u);\n\n            GArray *u_adj = (GArray *)g_hash_table_lookup(adj_list, GINT_TO_POINTER(u));\n\n            for (int j = 0; j < u_adj->len; j++) {\n                int v = g_array_index(u_adj, int, j);\n\n                GArray *v_adj = (GArray *)g_hash_table_lookup(adj_list, GINT_TO_POINTER(v));\n\n                g_array_remove_index(v_adj, g_array_find(v_adj, (GCompareFunc)g_int_equal, GINT_TO_POINTER(u)));\n\n                int v_count = GPOINTER_TO_INT(g_hash_table_lookup(edge_count, GINT_TO_POINTER(v)));\n\n                g_hash_table_insert(edge_count, GINT_TO_POINTER(v), GINT_TO_POINTER(v_count - 1));\n            }\n\n            g_array_free(u_adj, TRUE);\n            g_hash_table_insert(adj_list, GINT_TO_POINTER(u), g_array_new(FALSE, FALSE, sizeof(int)));\n\n            int u_count = GPOINTER_TO_INT(g_hash_table_lookup(edge_count, GINT_TO_POINTER(u)));\n\n            g_hash_table_insert(edge_count, GINT_TO_POINTER(u), GINT_TO_POINTER(u_count - u_adj->len));\n        }\n\n        int isolated_count = 0;\n\n        for (int j = 0; j < n; j++) {\n            int count = GPOINTER_TO_INT(g_hash_table_lookup(edge_count, GINT_TO_POINTER(j + 1)));\n\n            if (count == 0) {\n                isolated_count++;\n            }\n        }\n\n        printf(\"%d\\n\", isolated_count);\n    }\n\n    g_hash_table_destroy(adj_list);\n    g_hash_table_destroy(edge_count);\n\n    return 0;\n}", "raw_exit_code": 0, "raw_stdout": "{\"result\": \"fail:error\", \"exit_code\": 1, \"stdout\": \"\", \"stderr\": \"Compilation failed:\\n/tmp/agnostics_c_gw8xtefb/program.c: In function 'main':\\n/tmp/agnostics_c_gw8xtefb/program.c:16:5: error: unknown type name 'GHashTable'\\n   16 |     GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\\n      |     ^~~~~~~~~~\\n/tmp/agnostics_c_gw8xtefb/program.c:16:28: warning: implicit declaration of function 'g_hash_table_new' [-Wimplicit-function-declaration]\\n   16 |     GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\\n      |                            ^~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_gw8xtefb/program.c:16:45: error: 'g_direct_hash' undeclared (first use in this function)\\n   16 |     GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\\n      |                                             ^~~~~~~~~~~~~\\n/tmp/agnostics_c_gw8xtefb/program.c:16:45: note: each undeclared identifier is reported only once for each function it appears in\\n/tmp/agnostics_c_gw8xtefb/program.c:16:60: error: 'g_direct_equal' undeclared (first use in this function)\\n   16 |     GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\\n      |                                                            ^~~~~~~~~~~~~~\\n/tmp/agnostics_c_gw8xtefb/program.c:17:5: error: unknown type name 'GHashTable'\\n   17 |     GHashTable *edge_count = g_hash_table_new(g_direct_hash, g_direct_equal);\\n      |     ^~~~~~~~~~\\n/tmp/agnostics_c_gw8xtefb/program.c:20:9: warning: implicit declaration of function 'g_hash_table_insert' [-Wimplicit-function-declaration]\\n   20 |         g_hash_table_insert(adj_list, GINT_TO_POINTER(i + 1), g_array_new(FALSE, FALSE, sizeof(int)));\\n      |         ^~~~~~~~~~~~~~~~~~~\\n/tmp/agnostics_c_gw8xtefb/program.c:20:39: warning: implicit declaration of function 'GINT_TO_POINTER' [-Wimplicit-function-declaration]\\n   20 |         g_hash_table_insert(adj_list, GINT_TO_POINTER(i + 1), g_array_new(FALSE, FALSE, sizeof(int)));\\n      |                               ", "raw_stderr": "", "result": "fail"}
