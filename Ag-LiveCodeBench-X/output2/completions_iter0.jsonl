{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    for (int test = 0; test < t; test++) {\n        char str[4];\n        scanf(\"%s\", str);\n\n        int inversions = 0;\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = i + 1; j < 3; j++) {\n                if (str[i] > str[j]) {\n                    inversions++;\n                }\n            }\n        }\n\n        if (inversions <= 1) {\n            printf(\"YES\n\");\n        } else {\n            printf(\"NO\n\");\n        }\n    }\n\n    return 0;\n}", "reasoning": "The problem involves determining if we can sort a string of three characters ('a', 'b', 'c') by performing at most one swap. The solution involves checking the current order of characters and determining if a single swap can achieve the sorted order 'abc'. We can achieve this by counting the number of inversions in the string. If there is at most one inversion, then a single swap can sort the string. If there are more than one inversions, then sorting with a single swap is not possible.", "question_id": "1873_A"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *a = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n\n        int max_index = 0;\n        for (int i = 1; i < n; i++) {\n            if (a[i] > a[max_index]) {\n                max_index = i;\n            }\n        }\n\n        a[max_index]++;\n        long long product = 1;\n        for (int i = 0; i < n; i++) {\n            product *= a[i];\n        }\n\n        printf(\"%lld\\n\", product);\n\n        free(a);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to maximize the product of the digits in an array by adding 1 to exactly one of the digits. Here's a step-by-step approach to achieve this:", "question_id": "1873_B"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n        char s[n + 1];\n        scanf(\"%s\", s);\n\n        int operations = 0;\n        int blackCount = 0;\n\n        // Sliding window to count black cells in each segment of length k\n        for (int i = 0; i < n; i++) {\n            if (s[i] == 'B') {\n                blackCount++;\n            }\n\n            if (i >= k) {\n                if (s[i - k] == 'B') {\n                    blackCount--;\n                }\n            }\n\n            // If we have a segment of k cells with all black cells, we need one operation\n            if (i >= k - 1 && blackCount == k) {\n                operations++;\n                blackCount = 0; // Reset the count after performing an operation\n            }\n        }\n\n        printf(\"%d\n\", operations);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of operations required to convert all black cells ('B') to white cells ('W') in a given strip of paper. Each operation allows us to turn any k consecutive cells white. The key insight is that we can use a sliding window approach to count the number of black cells in each segment of length k and then determine the minimum number of operations needed to convert these segments to white.", "question_id": "1873_D"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        char s[100001];\n        scanf(\"%s\", s);\n\n        // Count the frequency of each character\n        GHashTable *char_count = g_hash_table_new(g_str_hash, g_str_equal);\n        for (int i = 0; i < n; i++) {\n            char *ch = g_strndup(&s[i], 1);\n            int count = GPOINTER_TO_INT(g_hash_table_lookup(char_count, ch)) + 1;\n            g_hash_table_insert(char_count, ch, GINT_TO_POINTER(count));\n        }\n\n        int odd_count = 0;\n        // Count how many characters have an odd frequency\n        for (gpointer key, value; g_hash_table_iter_init(&iter, char_count); g_hash_table_iter_next(&iter, &key, &value)) {\n            if (GPOINTER_TO_INT(value) % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        // Clean up the hash table\n        g_hash_table_destroy(char_count);\n\n        // Check if it's possible to form a palindrome\n        if (odd_count <= (k + 1) / 2) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if it's possible to remove exactly k characters from a given string s such that the remaining characters can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd count (for strings of odd length) and all characters have even counts (for strings of even length). Here's how we can approach the problem step-by-step:\n\n1. For each test case, we need to count the frequency of each character in the string.\n2. We then count how many characters have an odd frequency.\n3. If the number of characters with odd frequencies is more than (k + 1) / 2, it's not possible to remove exactly k characters to form a palindrome. Otherwise, it is possible.\n\nWe need to handle multiple test cases, so we will read the number of test cases first, and then process each test case accordingly.", "question_id": "1883_B"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        int count[5] = {0};\n        for (int i = 0; i < n; i++) {\n            int a;\n            scanf(\"%d\", &a);\n\n            if (a % 2 == 0) count[2]++;\n            if (a % 3 == 0) count[3]++;\n            if (a % 5 == 0) count[5]++;\n        }\n\n        int operations = 0;\n        if (count[2] == 0) operations++;\n        if (count[3] == 0) operations++;\n        if (count[5] == 0) operations++;\n\n        printf(\"%d\\n\", operations);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the minimum number of operations required to make the product of all numbers in the array divisible by a given number k. The key observation is that we only need to consider the prime factors of k (which are limited to 2, 3, and 5). For each prime factor, we need to ensure that the product of the array contains at least one factor of that prime. We can achieve this by counting the number of factors of each prime in the array and determining how many operations are needed to increase the count to at least one for each prime factor.", "question_id": "1883_C"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        // If n is divisible by 3, Vanya wins immediately\n        if (n % 3 == 0) {\n            printf(\"First\\n\");\n        } else {\n            // If n is not divisible by 3, we need to check the parity of n\n            // If n is odd, Vanya can always make it even for Vova's turn\n            // If n is even, Vova can always make it odd for Vanya's turn\n            if (n % 2 != 0) {\n                printf(\"First\\n\");\n            } else {\n                printf(\"Second\\n\");\n            }\n        }\n    }\n\n    return 0;\n}", "reasoning": "To determine the winner of the game, we need to analyze the game mechanics and find a pattern or strategy that can predict the outcome based on the initial value of n. The key observation is that if the number is divisible by 3, Vanya wins immediately. If not, the players will alternate turns, and we need to determine who can force a win given optimal play from both sides. The game can be analyzed using dynamic programming or by recognizing a pattern in the winning and losing positions.", "question_id": "1899_A"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *boxes = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &boxes[i]);\n        }\n\n        qsort(boxes, n, sizeof(int), compare);\n\n        long long total_weight = 0;\n        for (int i = 0; i < n; i++) {\n            total_weight += boxes[i];\n        }\n\n        long long max_diff = total_weight;\n        for (int i = 1; i < n; i++) {\n            long long current_diff = abs(total_weight - 2 * (long long)boxes[i] * i);\n            if (current_diff > max_diff) {\n                max_diff = current_diff;\n            }\n        }\n\n        printf(\"%lld\n\", max_diff);\n\n        free(boxes);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine the maximum absolute difference between the total weights of two trucks when loading boxes. The key insight is that the optimal way to maximize this difference is to use the smallest possible number of trucks (i.e., n trucks) and the largest possible number of trucks (i.e., 1 truck). This is because the difference between the total weight of one truck and the total weight of n trucks is simply the sum of all the box weights. By using these two extremes, we can find the maximum absolute difference.", "question_id": "1899_B"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int *a = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n        }\n\n        int maxSum = INT_MIN;\n        int currentSum = 0;\n        bool lastWasOdd = false;\n\n        for (int i = 0; i < n; i++) {\n            bool isOdd = (a[i] % 2 != 0);\n\n            if (i == 0 || isOdd != lastWasOdd) {\n                currentSum += a[i];\n                lastWasOdd = isOdd;\n            } else {\n                currentSum = a[i];\n                lastWasOdd = isOdd;\n            }\n\n            if (currentSum > maxSum) {\n                maxSum = currentSum;\n            }\n        }\n\n        printf(\"%d\n\", maxSum);\n\n        free(a);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum sum of a subarray with alternating parities. Here's a step-by-step approach to achieve this:", "question_id": "1899_C"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        GHashTable *count = g_hash_table_new(g_direct_hash, g_direct_equal);\n        long long result = 0;\n\n        for (int i = 0; i < n; i++) {\n            int a;\n            scanf(\"%d\", &a);\n\n            gpointer value = g_hash_table_lookup(count, GINT_TO_POINTER(a));\n            if (value) {\n                result += GPOINTER_TO_INT(value);\n            }\n\n            g_hash_table_insert(count, GINT_TO_POINTER(a), GINT_TO_POINTER(GPOINTER_TO_INT(value) + 1));\n        }\n\n        printf(\"%lld\n\", result);\n\n        g_hash_table_destroy(count);\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of pairs (i, j) such that b_i^b_j = b_j^b_i. Given that b_i = 2^(a_i), this condition simplifies to (2^(a_i))^b_j = (2^(a_j))^b_i, which further simplifies to 2^(a_i * b_j) = 2^(a_j * b_i). This implies that a_i * b_j = a_j * b_i. Since a_i and a_j are powers of 2, this condition holds if and only if a_i and a_j are the same. Therefore, we need to count the number of pairs (i, j) where a_i = a_j and i < j.", "question_id": "1899_D"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char s[n + 1];\n    scanf(\"%s\", s);\n\n    int takahashi_wins = 0;\n    int aoki_wins = 0;\n    int takahashi_last_game = -1;\n    int aoki_last_game = -1;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'T') {\n            takahashi_wins++;\n            takahashi_last_game = i;\n        } else if (s[i] == 'A') {\n            aoki_wins++;\n            aoki_last_game = i;\n        }\n    }\n\n    if (takahashi_wins > aoki_wins) {\n        printf(\"T\\n\");\n    } else if (aoki_wins > takahashi_wins) {\n        printf(\"A\\n\");\n    } else {\n        if (takahashi_last_game < aoki_last_game) {\n            printf(\"T\\n\");\n        } else {\n            printf(\"A\\n\");\n        }\n    }\n\n    return 0;\n}", "reasoning": "To determine the overall winner between Takahashi and Aoki, we need to count the number of games each of them won and then compare these counts. If they have the same number of wins, we need to determine who reached that number of wins first. We can achieve this by iterating through the string S and keeping track of the number of wins for Takahashi and Aoki. We also need to keep track of the last game each of them won to determine the overall winner in case of a tie.", "question_id": "abc301_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    GArray *arr = g_array_new(FALSE, FALSE, sizeof(int));\n    for (int i = 0; i < n; i++) {\n        int num;\n        scanf(\"%d\", &num);\n        g_array_append_val(arr, num);\n    }\n\n    while (true) {\n        bool changed = false;\n        for (int i = 0; i < arr->len - 1; i++) {\n            int a = g_array_index(arr, int, i);\n            int b = g_array_index(arr, int, i + 1);\n            if (abs(a - b) != 1) {\n                changed = true;\n                if (a < b) {\n                    for (int j = b - 1; j > a; j--) {\n                        g_array_insert_val(arr, i + 1, j);\n                    }\n                } else {\n                    for (int j = a - 1; j < b; j++) {\n                        g_array_insert_val(arr, i + 1, j);\n                    }\n                }\n            }\n        }\n        if (!changed) {\n            break;\n        }\n    }\n\n    for (int i = 0; i < arr->len; i++) {\n        printf(\"%d \", g_array_index(arr, int, i));\n    }\n    printf(\"\\n\");\n\n    g_array_free(arr, TRUE);\n\n    return 0;\n}", "reasoning": "The problem requires us to insert numbers between adjacent elements of a sequence until all adjacent elements have an absolute difference of 1. We can achieve this by iterating through the sequence and checking the absolute difference between each pair of adjacent elements. If the difference is not 1, we insert the necessary numbers between them and continue the process until no more insertions are needed. We use a loop to iterate through the sequence and a conditional statement to check the absolute difference. If the difference is not 1, we insert the necessary numbers using a loop and update the sequence. We continue this process until no more insertions are needed. Finally, we print the resulting sequence.", "question_id": "abc301_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    char S[200001], T[200001];\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n\n    int n = strlen(S);\n    GHashTable *countS = g_hash_table_new(g_str_hash, g_str_equal);\n    GHashTable *countT = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Count characters in S and T\n    for (int i = 0; i < n; i++) {\n        if (S[i] != '@') {\n            char *key = g_strdup(&S[i]);\n            int *value = (int *)g_hash_table_lookup(countS, key);\n            if (value) {\n                *value += 1;\n            } else {\n                g_hash_table_insert(countS, key, GINT_TO_POINTER(1));\n            }\n            g_free(key);\n        }\n        if (T[i] != '@') {\n            char *key = g_strdup(&T[i]);\n            int *value = (int *)g_hash_table_lookup(countT, key);\n            if (value) {\n                *value += 1;\n            } else {\n                g_hash_table_insert(countT, key, GINT_TO_POINTER(1));\n            }\n            g_free(key);\n        }\n    }\n\n    // Compare counts of non-'@' characters\n    GList *keys = g_hash_table_get_keys(countS);\n    GList *node = keys;\n    while (node) {\n        char *key = (char *)node->data;\n        int *valueS = (int *)g_hash_table_lookup(countS, key);\n        int *valueT = (int *)g_hash_table_lookup(countT, key);\n        if (valueS && valueT && *valueS != *valueT) {\n            printf(\"No\\n\");\n            g_hash_table_destroy(countS);\n            g_hash_table_destroy(countT);\n            g_list_free(keys);\n            return 0;\n        }\n        node = g_list_next(node);\n    }\n\n    printf(\"Yes\\n\");\n\n    // Clean up\n    g_hash_table_destroy(countS);\n    g_hash_table_destroy(countT);\n    g_list_free(keys);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if we can rearrange the cards in two rows such that they coincide. The key observation is that the positions of '@' characters can be freely replaced with any other character, so we need to ensure that the non-'@' characters in both rows match in frequency and order after replacing '@' characters with any valid character. Here's a step-by-step approach to solve the problem:", "question_id": "abc301_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint main() {\n    // Read input\n    char S[61];\n    long long N;\n    scanf(\"%s %lld\", S, &N);\n\n    // Length of the string S\n    int len = strlen(S);\n\n    // Array to store all possible values\n    GArray *values = g_array_new(FALSE, FALSE, sizeof(long long));\n\n    // Function to generate all possible values\n    void generate_values(char *s, int index, long long current) {\n        if (index == len) {\n            if (current <= N) {\n                g_array_append_val(values, current);\n            }\n            return;\n        }\n        if (s[index] == '?') {\n            generate_values(s, index + 1, current * 2);\n            generate_values(s, index + 1, current * 2 + 1);\n        } else {\n            generate_values(s, index + 1, current * 2 + (s[index] - '0')));\n        }\n    }\n\n    // Generate all possible values from the string S\n    generate_values(S, 0, 0);\n\n    // Sort the array in descending order\n    qsort(values->data, values->len, sizeof(long long), (int (*)(const void *, const void *))strcmp);\n\n    // Find the greatest value less than or equal to N\n    long long result = -1;\n    for (int i = 0; i < values->len; i++) {\n        if (g_array_index(values, long long, i) <= N) {\n            result = g_array_index(values, long long, i);\n        } else {\n            break;\n        }\n    }\n\n    // Output the result\n    printf(\"%lld\\n\", result);\n\n    // Clean up\n    g_array_free(values, TRUE);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to generate all possible binary values from the given string S by replacing each '?' with '0' or '1'. We then need to find the greatest value among these that is less than or equal to N. Here's a step-by-step approach to achieve this:", "question_id": "abc301_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_H 300\n#define MAX_W 300\n\ntypedef struct {\n    int x, y;\n    int candy_count;\n} State;\n\nint main() {\n    int H, W, T;\n    scanf(\"%d %d %d\", &H, &W, &T);\n\n    char grid[MAX_H][MAX_W + 1];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int start_x, start_y;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') {\n                start_x = i;\n                start_y = j;\n            }\n        }\n    }\n\n    GQueue *queue = g_queue_new();\n    g_queue_push_tail(queue, GINT_TO_POINTER((State){start_x, start_y, 0}));\n\n    bool visited[MAX_H][MAX_W][19];\n    memset(visited, false, sizeof(visited));\n\n    int max_candy = -1;\n\n    while (!g_queue_is_empty(queue) && T > 0) {\n        int size = g_queue_get_length(queue);\n        for (int i = 0; i < size; i++) {\n            State current = *(State*)g_queue_pop_head(queue);\n\n            if (current.x == start_x && current.y == start_y) {\n                max_candy = current.candy_count;\n            }\n\n            int dx[] = {-1, 1, 0, 0};\n            int dy[] = {0, 0, -1, 1};\n\n            for (int k = 0; k < 4; k++) {\n                int nx = current.x + dx[k];\n                int ny = current.y + dy[k];\n                int nc = current.candy_count;\n\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny][nc]) {\n                    if (grid[nx][ny] == 'o') {\n                        nc++;\n                    }\n\n                    if (grid[nx][ny] != '#') {\n                        visited[nx][ny][nc] = true;\n                        g_queue_push_tail(queue, GINT_TO_POINTER((State){nx, ny, nc}));\n                    }\n                }\n            }\n        }\n\n        T--;\n    }\n\n    printf(\"%d\\n\", max_candy);\n\n    g_queue_free(queue);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to determine if Takahashi can reach the goal square within T moves and, if so, find the maximum number of candy squares he can visit on the way. We can approach this using a breadth-first search (BFS) algorithm to explore all possible paths from the start square to the goal square within the given number of moves. During the BFS, we will keep track of the number of candy squares visited and update the maximum count accordingly.", "question_id": "abc301_e"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MOD 998244353\n\nint main() {\n    char s[300001];\n    scanf(\"%s\", s);\n\n    int n = strlen(s);\n    int dp[2][2][2][2];\n    memset(dp, 0, sizeof(dp));\n\n    dp[0][0][0][0] = 1;\n\n    for (int i = 0; i < n; i++) {\n        int c = s[i] - 'A';\n        if (s[i] == '?') {\n            for (int a = 0; a < 26; a++) {\n                for (int b = 0; b < 26; b++) {\n                    for (int d = 0; d < 26; d++) {\n                        dp[1][a][b][d] = (dp[1][a][b][d] + dp[0][a][b][d]) % MOD;\n                        dp[1][a][b][d] = (dp[1][a][b][d] + dp[1][a][b][d]) % MOD;\n                    }\n                }\n            }\n        } else {\n            int a = (s[i] - 'A') % 26;\n            for (int b = 0; b < 26; b++) {\n                for (int d = 0; d < 26; d++) {\n                    dp[1][a][b][d] = (dp[1][a][b][d] + dp[0][a][b][d]) % MOD;\n                }\n            }\n        }\n        for (int a = 0; a < 26; a++) {\n            for (int b = 0; b < 26; b++) {\n                for (int d = 0; d < 26; d++) {\n                    dp[0][a][b][d] = 0;\n                }\n            }\n        }\n    }\n\n    int result = 0;\n    for (int a = 0; a < 26; a++) {\n        for (int b = 0; b < 26; b++) {\n            for (int d = 0; d < 26; d++) {\n                result = (result + dp[1][a][b][d]) % MOD;\n            }\n        }\n    }\n\n    printf(\"%d\n\", result);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to count the number of strings that do not contain a DDoS-type string as a subsequence. A DDoS-type string is defined as a string of length 4 with specific character constraints. We can approach this problem using dynamic programming and bit manipulation to efficiently count the valid strings.", "question_id": "abc301_f"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    long long A, B;\n    scanf(\"%lld %lld\", &A, &B);\n\n    // Calculate the minimum number of attacks needed\n    long long attacks = (A + B - 1) / B;\n\n    // Print the result\n    printf(\"%lld\n\", attacks);\n\n    return 0;\n}", "reasoning": "To determine the minimum number of attacks needed to reduce the enemy's stamina to 0 or less, we can use integer division and handle the remainder. The key is to ensure that the stamina is reduced by exactly B in each attack, and if there is any remaining stamina after the division, we need an additional attack to cover that remainder.", "question_id": "abc302_a"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define H 100\n#define W 100\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    char grid[H][W + 1];\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    bool found = false;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 's') {\n                int dx[] = {0, 0, 1, -1, 1, -1, 1, -1};\n                int dy[] = {1, -1, 0, 0, 1, 1, -1, -1};\n\n                for (int k = 0; k < 8; k++) {\n                    int x = i, y = j;\n                    char letters[5] = {grid[x][y], 0};\n\n                    for (int l = 1; l < 5; l++) {\n                        x += dx[k];\n                        y += dy[k];\n\n                        if (x >= 0 && x < H && y >= 0 && y < W) {\n                            letters[l] = grid[x][y];\n                        } else {\n                            break;\n                        }\n                    }\n\n                    if (letters[0] == 's' && letters[1] == 'n' && letters[2] == 'u' && letters[3] == 'k' && letters[4] == 'e') {\n                        printf(\"%d %d\n\", i + 1, j + 1);\n                        printf(\"%d %d\n\", i + 1, j + 2);\n                        printf(\"%d %d\n\", i + 1, j + 3);\n                        printf(\"%d %d\n\", i + 1, j + 4);\n                        printf(\"%d %d\n\", i + 1, j + 5);\n                        found = true;\n                        break;\n                    }\n                }\n\n                if (found) {\n                    break;\n                }\n            }\n        }\n\n        if (found) {\n            break;\n        }\n    }\n\n    if (!found) {\n        printf(\"No solution found.\n\");\n    }\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find a set of five contiguous cells in a grid that form a line and contain the letters 's', 'n', 'u', 'k', and 'e' in that order. We will iterate through each cell in the grid and check if it can be the starting point of a valid sequence. If it can, we will check the next four cells to see if they form a valid sequence and if they are in a straight line. If they are, we will print the coordinates of these cells.", "question_id": "abc302_b"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#define MAX_N 8\n#define MAX_M 5\n\n// Function to check if two strings can be transformed into each other by changing exactly one character\nbool can_transform(const char *s1, const char *s2, int m) {\n    int diff = 0;\n    for (int i = 0; i < m; i++) {\n        if (s1[i] != s2[i]) {\n            diff++;\n            if (diff > 1) {\n                return false;\n            }\n        }\n    }\n    return diff == 1;\n}\n\n// Function to check if the graph is connected\nbool is_connected(GHashTable *graph, int n) {\n    GQueue *queue = g_queue_new();\n    GHashTable *visited = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Start from the first node\n    GList *node = g_list_first(graph);\n    g_queue_push_tail(queue, g_strdup(node->data));\n    g_hash_table_insert(visited, node->data, GINT_TO_POINTER(1));\n\n    while (!g_queue_is_empty(queue)) {\n        char *current = g_queue_pop_head(queue);\n\n        GList *adjacent = g_hash_table_lookup(graph, current);\n        if (adjacent) {\n            GList *it;\n            for (it = adjacent; it != NULL; it = it->next) {\n                char *neighbor = it->data;\n                if (!g_hash_table_contains(visited, neighbor)) {\n                    g_queue_push_tail(queue, g_strdup(neighbor));\n                    g_hash_table_insert(visited, neighbor, GINT_TO_POINTER(1));\n                }\n            }\n        }\n        g_free(current);\n    }\n\n    // Check if all nodes are visited\n    for (node = g_list_first(graph); node != NULL; node = node->next) {\n        if (!g_hash_table_contains(visited, node->data)) {\n            g_hash_table_destroy(visited);\n            g_queue_free(queue);\n            return false;\n        }\n    }\n\n    g_hash_table_destroy(visited);\n    g_queue_free(queue);\n    return true;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    GHashTable *graph = g_hash_table_new(g_str_hash, g_str_equal);\n\n    // Read input strings and build the graph\n    for (int i = 0; i < n; i++) {\n        char s[MAX_M + 1];\n        scanf(\"%s\", s);\n        g_hash_table_insert(graph, g_strdup(s), NULL);\n    }\n\n    // Add edges to the graph if the strings can be transformed into each other\n    for (int i = 0; i < n; i++) {\n        char *s1 = g_hash_table_get_keys(graph)[i];\n        for (int j = i + 1; j < n; j++) {\n            char *s2 = g_hash_table_get_keys(graph)[j];\n            if (can_transform(s1, s2, m)) {\n                g_hash_table_insert(graph, s1, g_list_append(g_hash_table_lookup(graph, s1), g_strdup(s2)));\n                g_hash_table_insert(graph, s2, g_list_append(g_hash_table_lookup(graph, s2), g_strdup(s1)));\n            }\n        }\n    }\n\n    // Check if the graph is connected\n    if (is_connected(graph, n)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    // Clean up\n    g_hash_table_destroy(graph);\n\n    return 0;\n}", "reasoning": "The problem requires determining if we can rearrange a given set of strings such that each string can be transformed into the next by changing exactly one character. This can be approached by checking if there exists a path between each pair of strings where each transition involves changing exactly one character. We can model this as a graph problem where each string is a node and there is an edge between two nodes if they can be transformed into each other by changing exactly one character. We then need to check if the graph is connected, meaning there is a path between any two nodes.", "question_id": "abc302_c"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n, m, d;\n    scanf(\"%d %d %d\", &n, &m, &d);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    int *b = (int *)malloc(m * sizeof(int));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    qsort(a, n, sizeof(int), compare);\n    qsort(b, m, sizeof(int), compare);\n\n    int max_sum = -1;\n    int i = 0, j = m - 1;\n\n    while (i < n && j >= 0) {\n        if (a[i] + b[j] > max_sum && b[j] - a[i] <= d) {\n            max_sum = a[i] + b[j];\n        }\n\n        if (b[j] - a[i] > d) {\n            j--;\n        } else {\n            i++;\n        }\n    }\n\n    printf(\"%d\n\", max_sum);\n\n    free(a);\n    free(b);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to find the maximum sum of values of two gifts (one for Aoki and one for Snuke) such that the difference in their values is at most D. Here's a step-by-step approach to achieve this:", "question_id": "abc302_d"}
{"solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    GHashTable *adj_list = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable *edge_count = g_hash_table_new(g_direct_hash, g_direct_equal);\n\n    for (int i = 0; i < n; i++) {\n        g_hash_table_insert(adj_list, GINT_TO_POINTER(i + 1), g_array_new(FALSE, FALSE, sizeof(int)));\n        g_hash_table_insert(edge_count, GINT_TO_POINTER(i + 1), GINT_TO_POINTER(0));\n    }\n\n    for (int i = 0; i < q; i++) {\n        int type, u, v;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            scanf(\"%d %d\", &u, &v);\n\n            GArray *u_adj = (GArray *)g_hash_table_lookup(adj_list, GINT_TO_POINTER(u));\n            GArray *v_adj = (GArray *)g_hash_table_lookup(adj_list, GINT_TO_POINTER(v));\n\n            g_array_append_val(u_adj, v);\n            g_array_append_val(v_adj, u);\n\n            int u_count = GPOINTER_TO_INT(g_hash_table_lookup(edge_count, GINT_TO_POINTER(u)));\n            int v_count = GPOINTER_TO_INT(g_hash_table_lookup(edge_count, GINT_TO_POINTER(v)));\n\n            g_hash_table_insert(edge_count, GINT_TO_POINTER(u), GINT_TO_POINTER(u_count + 1));\n            g_hash_table_insert(edge_count, GINT_TO_POINTER(v), GINT_TO_POINTER(v_count + 1));\n        } else if (type == 2) {\n            scanf(\"%d\", &u);\n\n            GArray *u_adj = (GArray *)g_hash_table_lookup(adj_list, GINT_TO_POINTER(u));\n\n            for (int j = 0; j < u_adj->len; j++) {\n                int v = g_array_index(u_adj, int, j);\n\n                GArray *v_adj = (GArray *)g_hash_table_lookup(adj_list, GINT_TO_POINTER(v));\n\n                g_array_remove_index(v_adj, g_array_find(v_adj, (GCompareFunc)g_int_equal, GINT_TO_POINTER(u)));\n\n                int v_count = GPOINTER_TO_INT(g_hash_table_lookup(edge_count, GINT_TO_POINTER(v)));\n\n                g_hash_table_insert(edge_count, GINT_TO_POINTER(v), GINT_TO_POINTER(v_count - 1));\n            }\n\n            g_array_free(u_adj, TRUE);\n            g_hash_table_insert(adj_list, GINT_TO_POINTER(u), g_array_new(FALSE, FALSE, sizeof(int)));\n\n            int u_count = GPOINTER_TO_INT(g_hash_table_lookup(edge_count, GINT_TO_POINTER(u)));\n\n            g_hash_table_insert(edge_count, GINT_TO_POINTER(u), GINT_TO_POINTER(u_count - u_adj->len));\n        }\n\n        int isolated_count = 0;\n\n        for (int j = 0; j < n; j++) {\n            int count = GPOINTER_TO_INT(g_hash_table_lookup(edge_count, GINT_TO_POINTER(j + 1)));\n\n            if (count == 0) {\n                isolated_count++;\n            }\n        }\n\n        printf(\"%d\\n\", isolated_count);\n    }\n\n    g_hash_table_destroy(adj_list);\n    g_hash_table_destroy(edge_count);\n\n    return 0;\n}", "reasoning": "To solve this problem, we need to keep track of the connectivity of vertices in an undirected graph. We can use a hash table to store the adjacency list of each vertex and another hash table to keep track of the number of edges connected to each vertex. When processing each query, we will update these data structures accordingly and then determine the number of vertices that are not connected to any other vertices by an edge.", "question_id": "abc302_e"}
